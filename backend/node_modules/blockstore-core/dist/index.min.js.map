{
  "version": 3,
  "sources": ["../src/index.ts", "../src/base.ts", "../../interface-store/src/errors.ts", "../../../node_modules/multiformats/src/bytes.ts", "../../../node_modules/multiformats/src/vendor/base-x.js", "../../../node_modules/multiformats/src/bases/base.ts", "../../../node_modules/multiformats/src/bases/base32.ts", "../../../node_modules/multiformats/src/bases/base36.ts", "../../../node_modules/multiformats/src/bases/base58.ts", "../../../node_modules/multiformats/src/vendor/varint.js", "../../../node_modules/multiformats/src/varint.ts", "../../../node_modules/multiformats/src/hashes/digest.ts", "../../../node_modules/multiformats/src/cid.ts", "../../../node_modules/multiformats/src/codecs/raw.ts", "../src/memory.ts", "../src/black-hole.ts", "../../../node_modules/multiformats/src/bases/base64.ts", "../../../node_modules/weald/node_modules/ms/dist/index.mjs", "../../../node_modules/weald/src/common.ts", "../../../node_modules/weald/src/browser.ts", "../../../node_modules/weald/src/index.ts", "../../../node_modules/@libp2p/logger/src/index.ts", "../../../node_modules/it-peekable/src/index.ts", "../../../node_modules/it-filter/src/index.ts", "../../../node_modules/p-defer/index.js", "../../../node_modules/race-signal/src/index.ts", "../../../node_modules/it-queueless-pushable/src/index.ts", "../../../node_modules/it-merge/src/index.ts", "../src/tiered.ts"],
  "sourcesContent": ["/**\n * @packageDocumentation\n *\n * Various Blockstore implementations are available.\n *\n * ## Implementations\n *\n * - Base: [`src/base`](./src/base.ts)\n * - Memory: [`src/memory`](./src/memory.ts)\n * - BlackHole: ['src/black-hole](./src/black-hole.ts)\n * - Tiered: ['src/tiered](./src/tiered.ts)\n *\n * @example BaseBlockstore\n *\n * Provides a complete implementation of the Blockstore interface.  You must implement `.get`, `.put`, etc.\n *\n * ```js\n * import { BaseBlockstore } from 'blockstore-core/base'\n *\n * class MyCustomBlockstore extends BaseBlockstore {\n *   put (key, val, options) {\n *     // store a block\n *   }\n *\n *   get (key, options) {\n *     // retrieve a block\n *   }\n *\n *   // ...etc\n * }\n * ```\n *\n * @example MemoryBlockstore\n *\n * A simple Blockstore that stores blocks in memory.\n *\n * ```js\n * import { MemoryBlockstore } from 'blockstore-core/memory'\n *\n * const store = new MemoryBlockstore()\n * ```\n *\n * @example BlackHoleBlockstore\n *\n * A Blockstore that does not store any blocks.\n *\n * ```js\n * import { BlackHoleBlockstore } from 'blockstore-core/black-hole'\n *\n * const store = new BlackHoleBlockstore()\n * ```\n *\n * @example TieredBlockstore\n *\n * A tiered blockstore wraps one or more blockstores and will query each in parallel to retrieve a block - the operation will succeed if any wrapped store has the block.\n *\n * Writes are invoked on all wrapped blockstores.\n *\n * ```js\n * import { TieredBlockstore } from 'blockstore-core/tiered'\n *\n * const store = new TieredBlockstore([\n *   store1,\n *   store2,\n *   // ...etc\n * ])\n * ```\n *\n * @example IdentityBlockstore\n *\n * An identity blockstore is one that deals exclusively in Identity CIDs - this is a special CID with the codec [0x00](https://github.com/multiformats/multicodec/blob/d06fc6194710e8909bac64273c43f16b56ca4c34/table.csv#L2) where the multihash digest is the data that makes up the block.\n *\n * ```TypeScript\n * import { IdentityBlockstore } from 'blockstore-core/identity'\n * import { CID } from 'multiformats/cid'\n *\n * const blockstore = new IdentityBlockstore()\n *\n * blockstore.has(CID.parse('QmFoo')) // false\n *\n * blockstore.has(CID.parse('bafkqac3imvwgy3zao5xxe3de')) // true\n * ```\n */\n\nexport { BaseBlockstore } from './base.js'\nexport { MemoryBlockstore } from './memory.js'\nexport { BlackHoleBlockstore } from './black-hole.js'\nexport { TieredBlockstore } from './tiered.js'\n", "import type { Blockstore, Pair } from 'interface-blockstore'\nimport type { AbortOptions, Await, AwaitIterable } from 'interface-store'\nimport type { CID } from 'multiformats/cid'\n\nexport class BaseBlockstore implements Blockstore {\n  has (key: CID, options?: AbortOptions): Await<boolean> {\n    return Promise.reject(new Error('.has is not implemented'))\n  }\n\n  put (key: CID, val: Uint8Array, options?: AbortOptions): Await<CID> {\n    return Promise.reject(new Error('.put is not implemented'))\n  }\n\n  async * putMany (source: AwaitIterable<Pair>, options?: AbortOptions): AwaitIterable<CID> {\n    for await (const { cid, block } of source) {\n      await this.put(cid, block, options)\n      yield cid\n    }\n  }\n\n  get (key: CID, options?: AbortOptions): Await<Uint8Array> {\n    return Promise.reject(new Error('.get is not implemented'))\n  }\n\n  async * getMany (source: AwaitIterable<CID>, options?: AbortOptions): AwaitIterable<Pair> {\n    for await (const key of source) {\n      yield {\n        cid: key,\n        block: await this.get(key, options)\n      }\n    }\n  }\n\n  delete (key: CID, options?: AbortOptions): Await<void> {\n    return Promise.reject(new Error('.delete is not implemented'))\n  }\n\n  async * deleteMany (source: AwaitIterable<CID>, options?: AbortOptions): AwaitIterable<CID> {\n    for await (const key of source) {\n      await this.delete(key, options)\n      yield key\n    }\n  }\n\n  /**\n   * Extending classes should override `query` or implement this method\n   */\n  async * getAll (options?: AbortOptions): AwaitIterable<Pair> { // eslint-disable-line require-yield\n    throw new Error('.getAll is not implemented')\n  }\n}\n", "export class OpenFailedError extends Error {\n  static name = 'OpenFailedError'\n  static code = 'ERR_OPEN_FAILED'\n  name = OpenFailedError.name\n  code = OpenFailedError.code\n\n  constructor (message = 'Open failed') {\n    super(message)\n  }\n}\n\nexport class CloseFailedError extends Error {\n  static name = 'CloseFailedError'\n  static code = 'ERR_CLOSE_FAILED'\n  name = CloseFailedError.name\n  code = CloseFailedError.code\n\n  constructor (message = 'Close failed') {\n    super(message)\n  }\n}\n\nexport class PutFailedError extends Error {\n  static name = 'PutFailedError'\n  static code = 'ERR_PUT_FAILED'\n  name = PutFailedError.name\n  code = PutFailedError.code\n\n  constructor (message = 'Put failed') {\n    super(message)\n  }\n}\n\nexport class GetFailedError extends Error {\n  static name = 'GetFailedError'\n  static code = 'ERR_GET_FAILED'\n  name = GetFailedError.name\n  code = GetFailedError.code\n\n  constructor (message = 'Get failed') {\n    super(message)\n  }\n}\n\nexport class DeleteFailedError extends Error {\n  static name = 'DeleteFailedError'\n  static code = 'ERR_DELETE_FAILED'\n  name = DeleteFailedError.name\n  code = DeleteFailedError.code\n\n  constructor (message = 'Delete failed') {\n    super(message)\n  }\n}\n\nexport class HasFailedError extends Error {\n  static name = 'HasFailedError'\n  static code = 'ERR_HAS_FAILED'\n  name = HasFailedError.name\n  code = HasFailedError.code\n\n  constructor (message = 'Has failed') {\n    super(message)\n  }\n}\n\nexport class NotFoundError extends Error {\n  static name = 'NotFoundError'\n  static code = 'ERR_NOT_FOUND'\n  name = NotFoundError.name\n  code = NotFoundError.code\n\n  constructor (message = 'Not Found') {\n    super(message)\n  }\n}\n\nexport class AbortError extends Error {\n  static name = 'AbortError'\n  static code = 'ERR_ABORTED'\n  name = AbortError.name\n  code = AbortError.code\n\n  constructor (message = 'Aborted') {\n    super(message)\n  }\n}\n", "export const empty = new Uint8Array(0)\n\nexport function toHex (d: Uint8Array): string {\n  return d.reduce((hex, byte) => hex + byte.toString(16).padStart(2, '0'), '')\n}\n\nexport function fromHex (hex: string): Uint8Array {\n  const hexes = hex.match(/../g)\n  return hexes != null ? new Uint8Array(hexes.map(b => parseInt(b, 16))) : empty\n}\n\nexport function equals (aa: Uint8Array, bb: Uint8Array): boolean {\n  if (aa === bb) { return true }\n  if (aa.byteLength !== bb.byteLength) {\n    return false\n  }\n\n  for (let ii = 0; ii < aa.byteLength; ii++) {\n    if (aa[ii] !== bb[ii]) {\n      return false\n    }\n  }\n\n  return true\n}\n\nexport function coerce (o: ArrayBufferView | ArrayBuffer | Uint8Array): Uint8Array {\n  if (o instanceof Uint8Array && o.constructor.name === 'Uint8Array') { return o }\n  if (o instanceof ArrayBuffer) { return new Uint8Array(o) }\n  if (ArrayBuffer.isView(o)) {\n    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength)\n  }\n  throw new Error('Unknown type, must be binary type')\n}\n\nexport function isBinary (o: unknown): o is ArrayBuffer | ArrayBufferView {\n  return o instanceof ArrayBuffer || ArrayBuffer.isView(o)\n}\n\nexport function fromString (str: string): Uint8Array {\n  return new TextEncoder().encode(str)\n}\n\nexport function toString (b: Uint8Array): string {\n  return new TextDecoder().decode(b)\n}\n", "/* eslint-disable */\n// base-x encoding / decoding\n// Copyright (c) 2018 base-x contributors\n// Copyright (c) 2014-2018 The Bitcoin Core developers (base58.cpp)\n// Distributed under the MIT software license, see the accompanying\n// file LICENSE or http://www.opensource.org/licenses/mit-license.php.\n/**\n * @param {string} ALPHABET\n * @param {any} name\n */\nfunction base (ALPHABET, name) {\n  if (ALPHABET.length >= 255) { throw new TypeError('Alphabet too long') }\n  var BASE_MAP = new Uint8Array(256);\n  for (var j = 0; j < BASE_MAP.length; j++) {\n    BASE_MAP[j] = 255;\n  }\n  for (var i = 0; i < ALPHABET.length; i++) {\n    var x = ALPHABET.charAt(i);\n    var xc = x.charCodeAt(0);\n    if (BASE_MAP[xc] !== 255) { throw new TypeError(x + ' is ambiguous') }\n    BASE_MAP[xc] = i;\n  }\n  var BASE = ALPHABET.length;\n  var LEADER = ALPHABET.charAt(0);\n  var FACTOR = Math.log(BASE) / Math.log(256); // log(BASE) / log(256), rounded up\n  var iFACTOR = Math.log(256) / Math.log(BASE); // log(256) / log(BASE), rounded up\n  /**\n   * @param {any[] | Iterable<number>} source\n   */\n  function encode (source) {\n    // @ts-ignore\n    if (source instanceof Uint8Array) ; else if (ArrayBuffer.isView(source)) {\n      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);\n    } else if (Array.isArray(source)) {\n      source = Uint8Array.from(source);\n    }\n    if (!(source instanceof Uint8Array)) { throw new TypeError('Expected Uint8Array') }\n    if (source.length === 0) { return '' }\n        // Skip & count leading zeroes.\n    var zeroes = 0;\n    var length = 0;\n    var pbegin = 0;\n    var pend = source.length;\n    while (pbegin !== pend && source[pbegin] === 0) {\n      pbegin++;\n      zeroes++;\n    }\n        // Allocate enough space in big-endian base58 representation.\n    var size = ((pend - pbegin) * iFACTOR + 1) >>> 0;\n    var b58 = new Uint8Array(size);\n        // Process the bytes.\n    while (pbegin !== pend) {\n      var carry = source[pbegin];\n            // Apply \"b58 = b58 * 256 + ch\".\n      var i = 0;\n      for (var it1 = size - 1; (carry !== 0 || i < length) && (it1 !== -1); it1--, i++) {\n        carry += (256 * b58[it1]) >>> 0;\n        b58[it1] = (carry % BASE) >>> 0;\n        carry = (carry / BASE) >>> 0;\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i;\n      pbegin++;\n    }\n        // Skip leading zeroes in base58 result.\n    var it2 = size - length;\n    while (it2 !== size && b58[it2] === 0) {\n      it2++;\n    }\n        // Translate the result into a string.\n    var str = LEADER.repeat(zeroes);\n    for (; it2 < size; ++it2) { str += ALPHABET.charAt(b58[it2]); }\n    return str\n  }\n  /**\n   * @param {string | string[]} source\n   */\n  function decodeUnsafe (source) {\n    if (typeof source !== 'string') { throw new TypeError('Expected String') }\n    if (source.length === 0) { return new Uint8Array() }\n    var psz = 0;\n        // Skip leading spaces.\n    if (source[psz] === ' ') { return }\n        // Skip and count leading '1's.\n    var zeroes = 0;\n    var length = 0;\n    while (source[psz] === LEADER) {\n      zeroes++;\n      psz++;\n    }\n        // Allocate enough space in big-endian base256 representation.\n    var size = (((source.length - psz) * FACTOR) + 1) >>> 0; // log(58) / log(256), rounded up.\n    var b256 = new Uint8Array(size);\n        // Process the characters.\n    while (source[psz]) {\n            // Decode character\n      var carry = BASE_MAP[source.charCodeAt(psz)];\n            // Invalid character\n      if (carry === 255) { return }\n      var i = 0;\n      for (var it3 = size - 1; (carry !== 0 || i < length) && (it3 !== -1); it3--, i++) {\n        carry += (BASE * b256[it3]) >>> 0;\n        b256[it3] = (carry % 256) >>> 0;\n        carry = (carry / 256) >>> 0;\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i;\n      psz++;\n    }\n        // Skip trailing spaces.\n    if (source[psz] === ' ') { return }\n        // Skip leading zeroes in b256.\n    var it4 = size - length;\n    while (it4 !== size && b256[it4] === 0) {\n      it4++;\n    }\n    var vch = new Uint8Array(zeroes + (size - it4));\n    var j = zeroes;\n    while (it4 !== size) {\n      vch[j++] = b256[it4++];\n    }\n    return vch\n  }\n  /**\n   * @param {string | string[]} string\n   */\n  function decode (string) {\n    var buffer = decodeUnsafe(string);\n    if (buffer) { return buffer }\n    throw new Error(`Non-${name} character`)\n  }\n  return {\n    encode: encode,\n    decodeUnsafe: decodeUnsafe,\n    decode: decode\n  }\n}\nvar src = base;\n\nvar _brrp__multiformats_scope_baseX = src;\n\nexport default _brrp__multiformats_scope_baseX;\n", "import { coerce } from '../bytes.js'\nimport basex from '../vendor/base-x.js'\nimport type { BaseCodec, BaseDecoder, BaseEncoder, CombobaseDecoder, Multibase, MultibaseCodec, MultibaseDecoder, MultibaseEncoder, UnibaseDecoder } from './interface.js'\n\ninterface EncodeFn { (bytes: Uint8Array): string }\ninterface DecodeFn { (text: string): Uint8Array }\n\n/**\n * Class represents both BaseEncoder and MultibaseEncoder meaning it\n * can be used to encode to multibase or base encode without multibase\n * prefix.\n */\nclass Encoder<Base extends string, Prefix extends string> implements MultibaseEncoder<Prefix>, BaseEncoder {\n  readonly name: Base\n  readonly prefix: Prefix\n  readonly baseEncode: EncodeFn\n\n  constructor (name: Base, prefix: Prefix, baseEncode: EncodeFn) {\n    this.name = name\n    this.prefix = prefix\n    this.baseEncode = baseEncode\n  }\n\n  encode (bytes: Uint8Array): Multibase<Prefix> {\n    if (bytes instanceof Uint8Array) {\n      return `${this.prefix}${this.baseEncode(bytes)}`\n    } else {\n      throw Error('Unknown type, must be binary type')\n    }\n  }\n}\n\n/**\n * Class represents both BaseDecoder and MultibaseDecoder so it could be used\n * to decode multibases (with matching prefix) or just base decode strings\n * with corresponding base encoding.\n */\nclass Decoder<Base extends string, Prefix extends string> implements MultibaseDecoder<Prefix>, UnibaseDecoder<Prefix>, BaseDecoder {\n  readonly name: Base\n  readonly prefix: Prefix\n  readonly baseDecode: DecodeFn\n  private readonly prefixCodePoint: number\n\n  constructor (name: Base, prefix: Prefix, baseDecode: DecodeFn) {\n    this.name = name\n    this.prefix = prefix\n    const prefixCodePoint = prefix.codePointAt(0)\n    /* c8 ignore next 3 */\n    if (prefixCodePoint === undefined) {\n      throw new Error('Invalid prefix character')\n    }\n    this.prefixCodePoint = prefixCodePoint\n    this.baseDecode = baseDecode\n  }\n\n  decode (text: string): Uint8Array {\n    if (typeof text === 'string') {\n      if (text.codePointAt(0) !== this.prefixCodePoint) {\n        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`)\n      }\n      return this.baseDecode(text.slice(this.prefix.length))\n    } else {\n      throw Error('Can only multibase decode strings')\n    }\n  }\n\n  or<OtherPrefix extends string> (decoder: UnibaseDecoder<OtherPrefix> | ComposedDecoder<OtherPrefix>): ComposedDecoder<Prefix | OtherPrefix> {\n    return or(this, decoder)\n  }\n}\n\ntype Decoders<Prefix extends string> = Record<Prefix, UnibaseDecoder<Prefix>>\n\nclass ComposedDecoder<Prefix extends string> implements MultibaseDecoder<Prefix>, CombobaseDecoder<Prefix> {\n  readonly decoders: Decoders<Prefix>\n\n  constructor (decoders: Decoders<Prefix>) {\n    this.decoders = decoders\n  }\n\n  or <OtherPrefix extends string> (decoder: UnibaseDecoder<OtherPrefix> | ComposedDecoder<OtherPrefix>): ComposedDecoder<Prefix | OtherPrefix> {\n    return or(this, decoder)\n  }\n\n  decode (input: string): Uint8Array {\n    const prefix = input[0] as Prefix\n    const decoder = this.decoders[prefix]\n    if (decoder != null) {\n      return decoder.decode(input)\n    } else {\n      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)\n    }\n  }\n}\n\nexport function or <L extends string, R extends string> (left: UnibaseDecoder<L> | CombobaseDecoder<L>, right: UnibaseDecoder<R> | CombobaseDecoder<R>): ComposedDecoder<L | R> {\n  return new ComposedDecoder({\n    ...(left.decoders ?? { [(left as UnibaseDecoder<L>).prefix]: left }),\n    ...(right.decoders ?? { [(right as UnibaseDecoder<R>).prefix]: right })\n  } as Decoders<L | R>)\n}\n\nexport class Codec<Base extends string, Prefix extends string> implements MultibaseCodec<Prefix>, MultibaseEncoder<Prefix>, MultibaseDecoder<Prefix>, BaseCodec, BaseEncoder, BaseDecoder {\n  readonly name: Base\n  readonly prefix: Prefix\n  readonly baseEncode: EncodeFn\n  readonly baseDecode: DecodeFn\n  readonly encoder: Encoder<Base, Prefix>\n  readonly decoder: Decoder<Base, Prefix>\n\n  constructor (name: Base, prefix: Prefix, baseEncode: EncodeFn, baseDecode: DecodeFn) {\n    this.name = name\n    this.prefix = prefix\n    this.baseEncode = baseEncode\n    this.baseDecode = baseDecode\n    this.encoder = new Encoder(name, prefix, baseEncode)\n    this.decoder = new Decoder(name, prefix, baseDecode)\n  }\n\n  encode (input: Uint8Array): string {\n    return this.encoder.encode(input)\n  }\n\n  decode (input: string): Uint8Array {\n    return this.decoder.decode(input)\n  }\n}\n\nexport function from <Base extends string, Prefix extends string> ({ name, prefix, encode, decode }: { name: Base, prefix: Prefix, encode: EncodeFn, decode: DecodeFn }): Codec<Base, Prefix> {\n  return new Codec(name, prefix, encode, decode)\n}\n\nexport function baseX <Base extends string, Prefix extends string> ({ name, prefix, alphabet }: { name: Base, prefix: Prefix, alphabet: string }): Codec<Base, Prefix> {\n  const { encode, decode } = basex(alphabet, name)\n  return from({\n    prefix,\n    name,\n    encode,\n    decode: (text: string): Uint8Array => coerce(decode(text))\n  })\n}\n\nfunction decode (string: string, alphabetIdx: Record<string, number>, bitsPerChar: number, name: string): Uint8Array {\n  // Count the padding bytes:\n  let end = string.length\n  while (string[end - 1] === '=') {\n    --end\n  }\n\n  // Allocate the output:\n  const out = new Uint8Array((end * bitsPerChar / 8) | 0)\n\n  // Parse the data:\n  let bits = 0 // Number of bits currently in the buffer\n  let buffer = 0 // Bits waiting to be written out, MSB first\n  let written = 0 // Next byte to write\n  for (let i = 0; i < end; ++i) {\n    // Read one character from the string:\n    const value = alphabetIdx[string[i]]\n    if (value === undefined) {\n      throw new SyntaxError(`Non-${name} character`)\n    }\n\n    // Append the bits to the buffer:\n    buffer = (buffer << bitsPerChar) | value\n    bits += bitsPerChar\n\n    // Write out some bits if the buffer has a byte's worth:\n    if (bits >= 8) {\n      bits -= 8\n      out[written++] = 0xff & (buffer >> bits)\n    }\n  }\n\n  // Verify that we have received just enough bits:\n  if (bits >= bitsPerChar || (0xff & (buffer << (8 - bits))) !== 0) {\n    throw new SyntaxError('Unexpected end of data')\n  }\n\n  return out\n}\n\nfunction encode (data: Uint8Array, alphabet: string, bitsPerChar: number): string {\n  const pad = alphabet[alphabet.length - 1] === '='\n  const mask = (1 << bitsPerChar) - 1\n  let out = ''\n\n  let bits = 0 // Number of bits currently in the buffer\n  let buffer = 0 // Bits waiting to be written out, MSB first\n  for (let i = 0; i < data.length; ++i) {\n    // Slurp data into the buffer:\n    buffer = (buffer << 8) | data[i]\n    bits += 8\n\n    // Write out as much as we can:\n    while (bits > bitsPerChar) {\n      bits -= bitsPerChar\n      out += alphabet[mask & (buffer >> bits)]\n    }\n  }\n\n  // Partial character:\n  if (bits !== 0) {\n    out += alphabet[mask & (buffer << (bitsPerChar - bits))]\n  }\n\n  // Add padding characters until we hit a byte boundary:\n  if (pad) {\n    while (((out.length * bitsPerChar) & 7) !== 0) {\n      out += '='\n    }\n  }\n\n  return out\n}\n\nfunction createAlphabetIdx (alphabet: string): Record<string, number> {\n  // Build the character lookup table:\n  const alphabetIdx: Record<string, number> = {}\n  for (let i = 0; i < alphabet.length; ++i) {\n    alphabetIdx[alphabet[i]] = i\n  }\n  return alphabetIdx\n}\n\n/**\n * RFC4648 Factory\n */\nexport function rfc4648 <Base extends string, Prefix extends string> ({ name, prefix, bitsPerChar, alphabet }: { name: Base, prefix: Prefix, bitsPerChar: number, alphabet: string }): Codec<Base, Prefix> {\n  const alphabetIdx = createAlphabetIdx(alphabet)\n  return from({\n    prefix,\n    name,\n    encode (input: Uint8Array): string {\n      return encode(input, alphabet, bitsPerChar)\n    },\n    decode (input: string): Uint8Array {\n      return decode(input, alphabetIdx, bitsPerChar, name)\n    }\n  })\n}\n", "import { rfc4648 } from './base.js'\n\nexport const base32 = rfc4648({\n  prefix: 'b',\n  name: 'base32',\n  alphabet: 'abcdefghijklmnopqrstuvwxyz234567',\n  bitsPerChar: 5\n})\n\nexport const base32upper = rfc4648({\n  prefix: 'B',\n  name: 'base32upper',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567',\n  bitsPerChar: 5\n})\n\nexport const base32pad = rfc4648({\n  prefix: 'c',\n  name: 'base32pad',\n  alphabet: 'abcdefghijklmnopqrstuvwxyz234567=',\n  bitsPerChar: 5\n})\n\nexport const base32padupper = rfc4648({\n  prefix: 'C',\n  name: 'base32padupper',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=',\n  bitsPerChar: 5\n})\n\nexport const base32hex = rfc4648({\n  prefix: 'v',\n  name: 'base32hex',\n  alphabet: '0123456789abcdefghijklmnopqrstuv',\n  bitsPerChar: 5\n})\n\nexport const base32hexupper = rfc4648({\n  prefix: 'V',\n  name: 'base32hexupper',\n  alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV',\n  bitsPerChar: 5\n})\n\nexport const base32hexpad = rfc4648({\n  prefix: 't',\n  name: 'base32hexpad',\n  alphabet: '0123456789abcdefghijklmnopqrstuv=',\n  bitsPerChar: 5\n})\n\nexport const base32hexpadupper = rfc4648({\n  prefix: 'T',\n  name: 'base32hexpadupper',\n  alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV=',\n  bitsPerChar: 5\n})\n\nexport const base32z = rfc4648({\n  prefix: 'h',\n  name: 'base32z',\n  alphabet: 'ybndrfg8ejkmcpqxot1uwisza345h769',\n  bitsPerChar: 5\n})\n", "import { baseX } from './base.js'\n\nexport const base36 = baseX({\n  prefix: 'k',\n  name: 'base36',\n  alphabet: '0123456789abcdefghijklmnopqrstuvwxyz'\n})\n\nexport const base36upper = baseX({\n  prefix: 'K',\n  name: 'base36upper',\n  alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n})\n", "import { baseX } from './base.js'\n\nexport const base58btc = baseX({\n  name: 'base58btc',\n  prefix: 'z',\n  alphabet: '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'\n})\n\nexport const base58flickr = baseX({\n  name: 'base58flickr',\n  prefix: 'Z',\n  alphabet: '123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ'\n})\n", "/* eslint-disable */\nvar encode_1 = encode;\n\nvar MSB = 0x80\n  , REST = 0x7F\n  , MSBALL = ~REST\n  , INT = Math.pow(2, 31);\n\n/**\n * @param {number} num\n * @param {number[]} out\n * @param {number} offset\n */\nfunction encode(num, out, offset) {\n  out = out || [];\n  offset = offset || 0;\n  var oldOffset = offset;\n\n  while(num >= INT) {\n    out[offset++] = (num & 0xFF) | MSB;\n    num /= 128;\n  }\n  while(num & MSBALL) {\n    out[offset++] = (num & 0xFF) | MSB;\n    num >>>= 7;\n  }\n  out[offset] = num | 0;\n  \n  // @ts-ignore\n  encode.bytes = offset - oldOffset + 1;\n  \n  return out\n}\n\nvar decode = read;\n\nvar MSB$1 = 0x80\n  , REST$1 = 0x7F;\n\n/**\n * @param {string | any[]} buf\n * @param {number} offset\n */\nfunction read(buf, offset) {\n  var res    = 0\n    , offset = offset || 0\n    , shift  = 0\n    , counter = offset\n    , b\n    , l = buf.length;\n\n  do {\n    if (counter >= l) {\n      // @ts-ignore\n      read.bytes = 0;\n      throw new RangeError('Could not decode varint')\n    }\n    b = buf[counter++];\n    res += shift < 28\n      ? (b & REST$1) << shift\n      : (b & REST$1) * Math.pow(2, shift);\n    shift += 7;\n  } while (b >= MSB$1)\n\n  // @ts-ignore\n  read.bytes = counter - offset;\n\n  return res\n}\n\nvar N1 = Math.pow(2,  7);\nvar N2 = Math.pow(2, 14);\nvar N3 = Math.pow(2, 21);\nvar N4 = Math.pow(2, 28);\nvar N5 = Math.pow(2, 35);\nvar N6 = Math.pow(2, 42);\nvar N7 = Math.pow(2, 49);\nvar N8 = Math.pow(2, 56);\nvar N9 = Math.pow(2, 63);\n\nvar length = function (/** @type {number} */ value) {\n  return (\n    value < N1 ? 1\n  : value < N2 ? 2\n  : value < N3 ? 3\n  : value < N4 ? 4\n  : value < N5 ? 5\n  : value < N6 ? 6\n  : value < N7 ? 7\n  : value < N8 ? 8\n  : value < N9 ? 9\n  :              10\n  )\n};\n\nvar varint = {\n    encode: encode_1\n  , decode: decode\n  , encodingLength: length\n};\n\nvar _brrp_varint = varint;\n\nexport default _brrp_varint;\n", "import varint from './vendor/varint.js'\n\nexport function decode (data: Uint8Array, offset = 0): [number, number] {\n  const code = varint.decode(data, offset)\n  return [code, varint.decode.bytes]\n}\n\nexport function encodeTo (int: number, target: Uint8Array, offset = 0): Uint8Array {\n  varint.encode(int, target, offset)\n  return target\n}\n\nexport function encodingLength (int: number): number {\n  return varint.encodingLength(int)\n}\n", "import { coerce, equals as equalBytes } from '../bytes.js'\nimport * as varint from '../varint.js'\nimport type { MultihashDigest } from './interface.js'\n\n/**\n * Creates a multihash digest.\n */\nexport function create <Code extends number> (code: Code, digest: Uint8Array): Digest<Code, number> {\n  const size = digest.byteLength\n  const sizeOffset = varint.encodingLength(code)\n  const digestOffset = sizeOffset + varint.encodingLength(size)\n\n  const bytes = new Uint8Array(digestOffset + size)\n  varint.encodeTo(code, bytes, 0)\n  varint.encodeTo(size, bytes, sizeOffset)\n  bytes.set(digest, digestOffset)\n\n  return new Digest(code, size, digest, bytes)\n}\n\n/**\n * Turns bytes representation of multihash digest into an instance.\n */\nexport function decode (multihash: Uint8Array): MultihashDigest {\n  const bytes = coerce(multihash)\n  const [code, sizeOffset] = varint.decode(bytes)\n  const [size, digestOffset] = varint.decode(bytes.subarray(sizeOffset))\n  const digest = bytes.subarray(sizeOffset + digestOffset)\n\n  if (digest.byteLength !== size) {\n    throw new Error('Incorrect length')\n  }\n\n  return new Digest(code, size, digest, bytes)\n}\n\nexport function equals (a: MultihashDigest, b: unknown): b is MultihashDigest {\n  if (a === b) {\n    return true\n  } else {\n    const data = b as { code?: unknown, size?: unknown, bytes?: unknown }\n\n    return (\n      a.code === data.code &&\n      a.size === data.size &&\n      data.bytes instanceof Uint8Array &&\n      equalBytes(a.bytes, data.bytes)\n    )\n  }\n}\n\n/**\n * Represents a multihash digest which carries information about the\n * hashing algorithm and an actual hash digest.\n */\nexport class Digest<Code extends number, Size extends number> implements MultihashDigest {\n  readonly code: Code\n  readonly size: Size\n  readonly digest: Uint8Array\n  readonly bytes: Uint8Array\n\n  /**\n   * Creates a multihash digest.\n   */\n  constructor (code: Code, size: Size, digest: Uint8Array, bytes: Uint8Array) {\n    this.code = code\n    this.size = size\n    this.digest = digest\n    this.bytes = bytes\n  }\n}\n\n/**\n * Used to check that the passed multihash has the passed code\n */\nexport function hasCode <T extends number> (digest: MultihashDigest, code: T): digest is MultihashDigest<T> {\n  return digest.code === code\n}\n", "import { base32 } from './bases/base32.js'\nimport { base36 } from './bases/base36.js'\nimport { base58btc } from './bases/base58.js'\nimport { coerce } from './bytes.js'\nimport * as Digest from './hashes/digest.js'\nimport * as varint from './varint.js'\nimport type * as API from './link/interface.js'\n\n// This way TS will also expose all the types from module\nexport * from './link/interface.js'\n\nexport function format <T extends API.Link<unknown, number, number, API.Version>, Prefix extends string> (link: T, base?: API.MultibaseEncoder<Prefix>): API.ToString<T, Prefix> {\n  const { bytes, version } = link\n  switch (version) {\n    case 0:\n      return toStringV0(\n        bytes,\n        baseCache(link),\n        base as API.MultibaseEncoder<'z'> ?? base58btc.encoder\n      )\n    default:\n      return toStringV1(\n        bytes,\n        baseCache(link),\n        (base ?? base32.encoder) as API.MultibaseEncoder<Prefix>\n      )\n  }\n}\n\nexport function toJSON <Link extends API.UnknownLink> (link: Link): API.LinkJSON<Link> {\n  return {\n    '/': format(link)\n  }\n}\n\nexport function fromJSON <Link extends API.UnknownLink> (json: API.LinkJSON<Link>): CID<unknown, number, number, API.Version> {\n  return CID.parse(json['/'])\n}\n\nconst cache = new WeakMap<API.UnknownLink, Map<string, string>>()\n\nfunction baseCache (cid: API.UnknownLink): Map<string, string> {\n  const baseCache = cache.get(cid)\n  if (baseCache == null) {\n    const baseCache = new Map()\n    cache.set(cid, baseCache)\n    return baseCache\n  }\n  return baseCache\n}\n\nexport class CID<Data = unknown, Format extends number = number, Alg extends number = number, Version extends API.Version = API.Version> implements API.Link<Data, Format, Alg, Version> {\n  readonly code: Format\n  readonly version: Version\n  readonly multihash: API.MultihashDigest<Alg>\n  readonly bytes: Uint8Array\n  readonly '/': Uint8Array\n\n  /**\n   * @param version - Version of the CID\n   * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv\n   * @param multihash - (Multi)hash of the of the content.\n   */\n  constructor (version: Version, code: Format, multihash: API.MultihashDigest<Alg>, bytes: Uint8Array) {\n    this.code = code\n    this.version = version\n    this.multihash = multihash\n    this.bytes = bytes\n\n    // flag to serializers that this is a CID and\n    // should be treated specially\n    this['/'] = bytes\n  }\n\n  /**\n   * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`\n   * please either use `CID.asCID(cid)` or switch to new signalling mechanism\n   *\n   * @deprecated\n   */\n  get asCID (): this {\n    return this\n  }\n\n  // ArrayBufferView\n  get byteOffset (): number {\n    return this.bytes.byteOffset\n  }\n\n  // ArrayBufferView\n  get byteLength (): number {\n    return this.bytes.byteLength\n  }\n\n  toV0 (): CID<Data, API.DAG_PB, API.SHA_256, 0> {\n    switch (this.version) {\n      case 0: {\n        return this as CID<Data, API.DAG_PB, API.SHA_256, 0>\n      }\n      case 1: {\n        const { code, multihash } = this\n\n        if (code !== DAG_PB_CODE) {\n          throw new Error('Cannot convert a non dag-pb CID to CIDv0')\n        }\n\n        // sha2-256\n        if (multihash.code !== SHA_256_CODE) {\n          throw new Error('Cannot convert non sha2-256 multihash CID to CIDv0')\n        }\n\n        return (\n          CID.createV0(\n            multihash as API.MultihashDigest<API.SHA_256>\n          )\n        )\n      }\n      default: {\n        throw Error(\n          `Can not convert CID version ${this.version} to version 0. This is a bug please report`\n        )\n      }\n    }\n  }\n\n  toV1 (): CID<Data, Format, Alg, 1> {\n    switch (this.version) {\n      case 0: {\n        const { code, digest } = this.multihash\n        const multihash = Digest.create(code, digest)\n        return (\n          CID.createV1(this.code, multihash)\n        )\n      }\n      case 1: {\n        return this as CID<Data, Format, Alg, 1>\n      }\n      default: {\n        throw Error(\n          `Can not convert CID version ${this.version} to version 1. This is a bug please report`\n        )\n      }\n    }\n  }\n\n  equals (other: unknown): other is CID<Data, Format, Alg, Version> {\n    return CID.equals(this, other)\n  }\n\n  static equals <Data, Format extends number, Alg extends number, Version extends API.Version>(self: API.Link<Data, Format, Alg, Version>, other: unknown): other is CID {\n    const unknown = other as { code?: unknown, version?: unknown, multihash?: unknown }\n    return (\n      unknown != null &&\n      self.code === unknown.code &&\n      self.version === unknown.version &&\n      Digest.equals(self.multihash, unknown.multihash)\n    )\n  }\n\n  toString (base?: API.MultibaseEncoder<string>): string {\n    return format(this, base)\n  }\n\n  toJSON (): API.LinkJSON<this> {\n    return { '/': format(this) }\n  }\n\n  link (): this {\n    return this\n  }\n\n  readonly [Symbol.toStringTag] = 'CID';\n\n  // Legacy\n\n  [Symbol.for('nodejs.util.inspect.custom')] (): string {\n    return `CID(${this.toString()})`\n  }\n\n  /**\n   * Takes any input `value` and returns a `CID` instance if it was\n   * a `CID` otherwise returns `null`. If `value` is instanceof `CID`\n   * it will return value back. If `value` is not instance of this CID\n   * class, but is compatible CID it will return new instance of this\n   * `CID` class. Otherwise returns null.\n   *\n   * This allows two different incompatible versions of CID library to\n   * co-exist and interop as long as binary interface is compatible.\n   */\n  static asCID <Data, Format extends number, Alg extends number, Version extends API.Version, U>(input: API.Link<Data, Format, Alg, Version> | U): CID<Data, Format, Alg, Version> | null {\n    if (input == null) {\n      return null\n    }\n\n    const value = input as any\n    if (value instanceof CID) {\n      // If value is instance of CID then we're all set.\n      return value\n    } else if ((value['/'] != null && value['/'] === value.bytes) || value.asCID === value) {\n      // If value isn't instance of this CID class but `this.asCID === this` or\n      // `value['/'] === value.bytes` is true it is CID instance coming from a\n      // different implementation (diff version or duplicate). In that case we\n      // rebase it to this `CID` implementation so caller is guaranteed to get\n      // instance with expected API.\n      const { version, code, multihash, bytes } = value\n      return new CID(\n        version,\n        code,\n        multihash as API.MultihashDigest<Alg>,\n        bytes ?? encodeCID(version, code, multihash.bytes)\n      )\n    } else if (value[cidSymbol] === true) {\n      // If value is a CID from older implementation that used to be tagged via\n      // symbol we still rebase it to the this `CID` implementation by\n      // delegating that to a constructor.\n      const { version, multihash, code } = value\n      const digest = Digest.decode(multihash) as API.MultihashDigest<Alg>\n      return CID.create(version, code, digest)\n    } else {\n      // Otherwise value is not a CID (or an incompatible version of it) in\n      // which case we return `null`.\n      return null\n    }\n  }\n\n  /**\n   * @param version - Version of the CID\n   * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv\n   * @param digest - (Multi)hash of the of the content.\n   */\n  static create <Data, Format extends number, Alg extends number, Version extends API.Version>(version: Version, code: Format, digest: API.MultihashDigest<Alg>): CID<Data, Format, Alg, Version> {\n    if (typeof code !== 'number') {\n      throw new Error('String codecs are no longer supported')\n    }\n\n    if (!(digest.bytes instanceof Uint8Array)) {\n      throw new Error('Invalid digest')\n    }\n\n    switch (version) {\n      case 0: {\n        if (code !== DAG_PB_CODE) {\n          throw new Error(\n            `Version 0 CID must use dag-pb (code: ${DAG_PB_CODE}) block encoding`\n          )\n        } else {\n          return new CID(version, code, digest, digest.bytes)\n        }\n      }\n      case 1: {\n        const bytes = encodeCID(version, code, digest.bytes)\n        return new CID(version, code, digest, bytes)\n      }\n      default: {\n        throw new Error('Invalid version')\n      }\n    }\n  }\n\n  /**\n   * Simplified version of `create` for CIDv0.\n   */\n  static createV0 <T = unknown>(digest: API.MultihashDigest<typeof SHA_256_CODE>): CID<T, typeof DAG_PB_CODE, typeof SHA_256_CODE, 0> {\n    return CID.create(0, DAG_PB_CODE, digest)\n  }\n\n  /**\n   * Simplified version of `create` for CIDv1.\n   *\n   * @param code - Content encoding format code.\n   * @param digest - Multihash of the content.\n   */\n  static createV1 <Data, Code extends number, Alg extends number>(code: Code, digest: API.MultihashDigest<Alg>): CID<Data, Code, Alg, 1> {\n    return CID.create(1, code, digest)\n  }\n\n  /**\n   * Decoded a CID from its binary representation. The byte array must contain\n   * only the CID with no additional bytes.\n   *\n   * An error will be thrown if the bytes provided do not contain a valid\n   * binary representation of a CID.\n   */\n  static decode <Data, Code extends number, Alg extends number, Version extends API.Version>(bytes: API.ByteView<API.Link<Data, Code, Alg, Version>>): CID<Data, Code, Alg, Version> {\n    const [cid, remainder] = CID.decodeFirst(bytes)\n    if (remainder.length !== 0) {\n      throw new Error('Incorrect length')\n    }\n    return cid\n  }\n\n  /**\n   * Decoded a CID from its binary representation at the beginning of a byte\n   * array.\n   *\n   * Returns an array with the first element containing the CID and the second\n   * element containing the remainder of the original byte array. The remainder\n   * will be a zero-length byte array if the provided bytes only contained a\n   * binary CID representation.\n   */\n  static decodeFirst <T, C extends number, A extends number, V extends API.Version>(bytes: API.ByteView<API.Link<T, C, A, V>>): [CID<T, C, A, V>, Uint8Array] {\n    const specs = CID.inspectBytes(bytes)\n    const prefixSize = specs.size - specs.multihashSize\n    const multihashBytes = coerce(\n      bytes.subarray(prefixSize, prefixSize + specs.multihashSize)\n    )\n    if (multihashBytes.byteLength !== specs.multihashSize) {\n      throw new Error('Incorrect length')\n    }\n    const digestBytes = multihashBytes.subarray(\n      specs.multihashSize - specs.digestSize\n    )\n    const digest = new Digest.Digest(\n      specs.multihashCode,\n      specs.digestSize,\n      digestBytes,\n      multihashBytes\n    )\n    const cid =\n      specs.version === 0\n        ? CID.createV0(digest as API.MultihashDigest<API.SHA_256>)\n        : CID.createV1(specs.codec, digest)\n    return [cid as CID<T, C, A, V>, bytes.subarray(specs.size)]\n  }\n\n  /**\n   * Inspect the initial bytes of a CID to determine its properties.\n   *\n   * Involves decoding up to 4 varints. Typically this will require only 4 to 6\n   * bytes but for larger multicodec code values and larger multihash digest\n   * lengths these varints can be quite large. It is recommended that at least\n   * 10 bytes be made available in the `initialBytes` argument for a complete\n   * inspection.\n   */\n  static inspectBytes <T, C extends number, A extends number, V extends API.Version>(initialBytes: API.ByteView<API.Link<T, C, A, V>>): { version: V, codec: C, multihashCode: A, digestSize: number, multihashSize: number, size: number } {\n    let offset = 0\n    const next = (): number => {\n      const [i, length] = varint.decode(initialBytes.subarray(offset))\n      offset += length\n      return i\n    }\n\n    let version = next() as V\n    let codec = DAG_PB_CODE as C\n    if (version as number === 18) {\n      // CIDv0\n      version = 0 as V\n      offset = 0\n    } else {\n      codec = next() as C\n    }\n\n    if (version !== 0 && version !== 1) {\n      throw new RangeError(`Invalid CID version ${version}`)\n    }\n\n    const prefixSize = offset\n    const multihashCode = next() as A // multihash code\n    const digestSize = next() // multihash length\n    const size = offset + digestSize\n    const multihashSize = size - prefixSize\n\n    return { version, codec, multihashCode, digestSize, multihashSize, size }\n  }\n\n  /**\n   * Takes cid in a string representation and creates an instance. If `base`\n   * decoder is not provided will use a default from the configuration. It will\n   * throw an error if encoding of the CID is not compatible with supplied (or\n   * a default decoder).\n   */\n  static parse <Prefix extends string, Data, Code extends number, Alg extends number, Version extends API.Version>(source: API.ToString<API.Link<Data, Code, Alg, Version>, Prefix>, base?: API.MultibaseDecoder<Prefix>): CID<Data, Code, Alg, Version> {\n    const [prefix, bytes] = parseCIDtoBytes(source, base)\n\n    const cid = CID.decode(bytes)\n\n    if (cid.version === 0 && source[0] !== 'Q') {\n      throw Error('Version 0 CID string must not include multibase prefix')\n    }\n\n    // Cache string representation to avoid computing it on `this.toString()`\n    baseCache(cid).set(prefix, source)\n\n    return cid\n  }\n}\n\nfunction parseCIDtoBytes <Prefix extends string, Data, Code extends number, Alg extends number, Version extends API.Version> (source: API.ToString<API.Link<Data, Code, Alg, Version>, Prefix>, base?: API.MultibaseDecoder<Prefix>): [Prefix, API.ByteView<API.Link<Data, Code, Alg, Version>>] {\n  switch (source[0]) {\n    // CIDv0 is parsed differently\n    case 'Q': {\n      const decoder = base ?? base58btc\n      return [\n        base58btc.prefix as Prefix,\n        decoder.decode(`${base58btc.prefix}${source}`)\n      ]\n    }\n    case base58btc.prefix: {\n      const decoder = base ?? base58btc\n      return [base58btc.prefix as Prefix, decoder.decode(source)]\n    }\n    case base32.prefix: {\n      const decoder = base ?? base32\n      return [base32.prefix as Prefix, decoder.decode(source)]\n    }\n    case base36.prefix: {\n      const decoder = base ?? base36\n      return [base36.prefix as Prefix, decoder.decode(source)]\n    }\n    default: {\n      if (base == null) {\n        throw Error(\n          'To parse non base32, base36 or base58btc encoded CID multibase decoder must be provided'\n        )\n      }\n      return [source[0] as Prefix, base.decode(source)]\n    }\n  }\n}\n\nfunction toStringV0 (bytes: Uint8Array, cache: Map<string, string>, base: API.MultibaseEncoder<'z'>): string {\n  const { prefix } = base\n  if (prefix !== base58btc.prefix) {\n    throw Error(`Cannot string encode V0 in ${base.name} encoding`)\n  }\n\n  const cid = cache.get(prefix)\n  if (cid == null) {\n    const cid = base.encode(bytes).slice(1)\n    cache.set(prefix, cid)\n    return cid\n  } else {\n    return cid\n  }\n}\n\nfunction toStringV1 <Prefix extends string> (bytes: Uint8Array, cache: Map<string, string>, base: API.MultibaseEncoder<Prefix>): string {\n  const { prefix } = base\n  const cid = cache.get(prefix)\n  if (cid == null) {\n    const cid = base.encode(bytes)\n    cache.set(prefix, cid)\n    return cid\n  } else {\n    return cid\n  }\n}\n\nconst DAG_PB_CODE = 0x70\nconst SHA_256_CODE = 0x12\n\nfunction encodeCID (version: API.Version, code: number, multihash: Uint8Array): Uint8Array {\n  const codeOffset = varint.encodingLength(version)\n  const hashOffset = codeOffset + varint.encodingLength(code)\n  const bytes = new Uint8Array(hashOffset + multihash.byteLength)\n  varint.encodeTo(version, bytes, 0)\n  varint.encodeTo(code, bytes, codeOffset)\n  bytes.set(multihash, hashOffset)\n  return bytes\n}\n\nconst cidSymbol = Symbol.for('@ipld/js-cid/CID')\n", "import { coerce } from '../bytes.js'\nimport type { ArrayBufferView, ByteView } from './interface.js'\n\nexport const name = 'raw'\nexport const code = 0x55\n\nexport function encode (node: Uint8Array): ByteView<Uint8Array> {\n  return coerce(node)\n}\n\nexport function decode (data: ByteView<Uint8Array> | ArrayBufferView<Uint8Array>): Uint8Array {\n  return coerce(data)\n}\n", "import { NotFoundError } from 'interface-store'\nimport { base32 } from 'multiformats/bases/base32'\nimport { CID } from 'multiformats/cid'\nimport * as raw from 'multiformats/codecs/raw'\nimport * as Digest from 'multiformats/hashes/digest'\nimport { BaseBlockstore } from './base.js'\nimport type { Pair } from 'interface-blockstore'\nimport type { AbortOptions, Await, AwaitIterable } from 'interface-store'\n\nexport class MemoryBlockstore extends BaseBlockstore {\n  private readonly data: Map<string, Uint8Array>\n\n  constructor () {\n    super()\n\n    this.data = new Map()\n  }\n\n  put (key: CID, val: Uint8Array, options?: AbortOptions): Await<CID> {\n    options?.signal?.throwIfAborted()\n    this.data.set(base32.encode(key.multihash.bytes), val)\n\n    return key\n  }\n\n  get (key: CID, options?: AbortOptions): Await<Uint8Array> {\n    options?.signal?.throwIfAborted()\n    const buf = this.data.get(base32.encode(key.multihash.bytes))\n\n    if (buf == null) {\n      throw new NotFoundError()\n    }\n\n    return buf\n  }\n\n  has (key: CID, options?: AbortOptions): Await<boolean> {\n    options?.signal?.throwIfAborted()\n    return this.data.has(base32.encode(key.multihash.bytes))\n  }\n\n  async delete (key: CID, options?: AbortOptions): Promise<void> {\n    options?.signal?.throwIfAborted()\n    this.data.delete(base32.encode(key.multihash.bytes))\n  }\n\n  async * getAll (options?: AbortOptions): AwaitIterable<Pair> {\n    options?.signal?.throwIfAborted()\n\n    for (const [key, value] of this.data.entries()) {\n      yield {\n        cid: CID.createV1(raw.code, Digest.decode(base32.decode(key))),\n        block: value\n      }\n      options?.signal?.throwIfAborted()\n    }\n  }\n}\n", "import { NotFoundError } from 'interface-store'\nimport { BaseBlockstore } from './base.js'\nimport type { Pair } from 'interface-blockstore'\nimport type { AbortOptions, Await, AwaitIterable } from 'interface-store'\nimport type { CID } from 'multiformats/cid'\n\nexport class BlackHoleBlockstore extends BaseBlockstore {\n  put (key: CID, value: Uint8Array, options?: AbortOptions): Await<CID> {\n    options?.signal?.throwIfAborted()\n    return key\n  }\n\n  get (key: CID, options?: AbortOptions): Await<Uint8Array> {\n    options?.signal?.throwIfAborted()\n    throw new NotFoundError()\n  }\n\n  has (key: CID, options?: AbortOptions): Await<boolean> {\n    options?.signal?.throwIfAborted()\n    return false\n  }\n\n  async delete (cid: CID, options?: AbortOptions): Promise<void> {\n    options?.signal?.throwIfAborted()\n  }\n\n  // eslint-disable-next-line require-yield\n  async * getAll (options?: AbortOptions): AwaitIterable<Pair> {\n    options?.signal?.throwIfAborted()\n  }\n}\n", "import { rfc4648 } from './base.js'\n\nexport const base64 = rfc4648({\n  prefix: 'm',\n  name: 'base64',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',\n  bitsPerChar: 6\n})\n\nexport const base64pad = rfc4648({\n  prefix: 'M',\n  name: 'base64pad',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=',\n  bitsPerChar: 6\n})\n\nexport const base64url = rfc4648({\n  prefix: 'u',\n  name: 'base64url',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_',\n  bitsPerChar: 6\n})\n\nexport const base64urlpad = rfc4648({\n  prefix: 'U',\n  name: 'base64urlpad',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=',\n  bitsPerChar: 6\n})\n", "// Helpers.\nconst s = 1000;\nconst m = s * 60;\nconst h = m * 60;\nconst d = h * 24;\nconst w = d * 7;\nconst y = d * 365.25;\nfunction ms(value, options) {\n    try {\n        if (typeof value === 'string' && value.length > 0) {\n            return parse(value);\n        }\n        else if (typeof value === 'number' && isFinite(value)) {\n            return options?.long ? fmtLong(value) : fmtShort(value);\n        }\n        throw new Error('Value is not a string or number.');\n    }\n    catch (error) {\n        const message = isError(error)\n            ? `${error.message}. value=${JSON.stringify(value)}`\n            : 'An unknown error has occured.';\n        throw new Error(message);\n    }\n}\n/**\n * Parse the given `str` and return milliseconds.\n */\nfunction parse(str) {\n    str = String(str);\n    if (str.length > 100) {\n        throw new Error('Value exceeds the maximum length of 100 characters.');\n    }\n    const match = /^(-?(?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);\n    if (!match) {\n        return NaN;\n    }\n    const n = parseFloat(match[1]);\n    const type = (match[2] || 'ms').toLowerCase();\n    switch (type) {\n        case 'years':\n        case 'year':\n        case 'yrs':\n        case 'yr':\n        case 'y':\n            return n * y;\n        case 'weeks':\n        case 'week':\n        case 'w':\n            return n * w;\n        case 'days':\n        case 'day':\n        case 'd':\n            return n * d;\n        case 'hours':\n        case 'hour':\n        case 'hrs':\n        case 'hr':\n        case 'h':\n            return n * h;\n        case 'minutes':\n        case 'minute':\n        case 'mins':\n        case 'min':\n        case 'm':\n            return n * m;\n        case 'seconds':\n        case 'second':\n        case 'secs':\n        case 'sec':\n        case 's':\n            return n * s;\n        case 'milliseconds':\n        case 'millisecond':\n        case 'msecs':\n        case 'msec':\n        case 'ms':\n            return n;\n        default:\n            // This should never occur.\n            throw new Error(`The unit ${type} was matched, but no matching case exists.`);\n    }\n}\nexport default ms;\n/**\n * Short format for `ms`.\n */\nfunction fmtShort(ms) {\n    const msAbs = Math.abs(ms);\n    if (msAbs >= d) {\n        return `${Math.round(ms / d)}d`;\n    }\n    if (msAbs >= h) {\n        return `${Math.round(ms / h)}h`;\n    }\n    if (msAbs >= m) {\n        return `${Math.round(ms / m)}m`;\n    }\n    if (msAbs >= s) {\n        return `${Math.round(ms / s)}s`;\n    }\n    return `${ms}ms`;\n}\n/**\n * Long format for `ms`.\n */\nfunction fmtLong(ms) {\n    const msAbs = Math.abs(ms);\n    if (msAbs >= d) {\n        return plural(ms, msAbs, d, 'day');\n    }\n    if (msAbs >= h) {\n        return plural(ms, msAbs, h, 'hour');\n    }\n    if (msAbs >= m) {\n        return plural(ms, msAbs, m, 'minute');\n    }\n    if (msAbs >= s) {\n        return plural(ms, msAbs, s, 'second');\n    }\n    return `${ms} ms`;\n}\n/**\n * Pluralization helper.\n */\nfunction plural(ms, msAbs, n, name) {\n    const isPlural = msAbs >= n * 1.5;\n    return `${Math.round(ms / n)} ${name}${isPlural ? 's' : ''}`;\n}\n/**\n * A type guard for errors.\n */\nfunction isError(error) {\n    return typeof error === 'object' && error !== null && 'message' in error;\n}\n", "/* eslint-disable no-console */\n/* eslint-disable @typescript-eslint/strict-boolean-expressions */\n\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n */\nimport humanize from 'ms'\nimport type { Debug, Debugger } from './index.js'\n\nexport default function setup (env: any): Debug {\n  createDebug.debug = createDebug\n  createDebug.default = createDebug\n  createDebug.coerce = coerce\n  createDebug.disable = disable\n  createDebug.enable = enable\n  createDebug.enabled = enabled\n  createDebug.humanize = humanize\n  createDebug.destroy = destroy\n\n  Object.keys(env).forEach(key => {\n    // @ts-expect-error cannot use string to index type\n    createDebug[key] = env[key]\n  })\n\n  /**\n   * The currently active debug mode names, and names to skip.\n   */\n\n  createDebug.names = [] as any[]\n  createDebug.skips = [] as any[]\n\n  /**\n   * Map of special \"%n\" handling functions, for the debug \"format\" argument.\n   *\n   * Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n   */\n  createDebug.formatters = {} satisfies Record<string, any>\n\n  /**\n   * Selects a color for a debug namespace\n   *\n   * @param {string} namespace - The namespace string for the debug instance to be colored\n   * @returns {number | string} An ANSI color code for the given namespace\n   */\n  function selectColor (namespace: string): number | string {\n    let hash = 0\n\n    for (let i = 0; i < namespace.length; i++) {\n      hash = ((hash << 5) - hash) + namespace.charCodeAt(i)\n      hash |= 0 // Convert to 32bit integer\n    }\n\n    // @ts-expect-error colors is not in the types\n    return createDebug.colors[Math.abs(hash) % createDebug.colors.length]\n  }\n  createDebug.selectColor = selectColor\n\n  /**\n   * Create a debugger with the given `namespace`.\n   *\n   * @param {string} namespace\n   * @returns {Function}\n   */\n  function createDebug (namespace: string): Debugger {\n    let prevTime: any\n    let enableOverride: any = null\n    let namespacesCache: any\n    let enabledCache: any\n\n    function debug (...args: any[]): void {\n      // Disabled?\n      // @ts-expect-error enabled is not in the types\n      if (!debug.enabled) {\n        return\n      }\n\n      const self: any = debug\n\n      // Set `diff` timestamp\n      const curr = Number(new Date())\n      const ms = curr - (prevTime || curr)\n      self.diff = ms\n      self.prev = prevTime\n      self.curr = curr\n      prevTime = curr\n\n      args[0] = createDebug.coerce(args[0])\n\n      if (typeof args[0] !== 'string') {\n        // Anything else let's inspect with %O\n        args.unshift('%O')\n      }\n\n      // Apply any `formatters` transformations\n      let index = 0\n      args[0] = args[0].replace(/%([a-zA-Z%])/g, (match: any, format: any): any => {\n        // If we encounter an escaped % then don't increase the array index\n        if (match === '%%') {\n          return '%'\n        }\n        index++\n        // @ts-expect-error formatters is not in the types\n        const formatter = createDebug.formatters[format]\n        if (typeof formatter === 'function') {\n          const val = args[index]\n          match = formatter.call(self, val)\n\n          // Now we need to remove `args[index]` since it's inlined in the `format`\n          args.splice(index, 1)\n          index--\n        }\n        return match\n      })\n\n      // Apply env-specific formatting (colors, etc.)\n      // @ts-expect-error formatArgs is not in the types\n      createDebug.formatArgs.call(self, args)\n\n      // @ts-expect-error log is not in the types\n      const logFn = self.log || createDebug.log\n      logFn.apply(self, args)\n    }\n\n    debug.namespace = namespace\n    // @ts-expect-error useColors is not in the types\n    debug.useColors = createDebug.useColors()\n    debug.color = createDebug.selectColor(namespace)\n    debug.extend = extend\n    debug.destroy = createDebug.destroy // XXX Temporary. Will be removed in the next major release.\n\n    Object.defineProperty(debug, 'enabled', {\n      enumerable: true,\n      configurable: false,\n      get: () => {\n        if (enableOverride !== null) {\n          return enableOverride\n        }\n        // @ts-expect-error namespaces is not in the types\n        if (namespacesCache !== createDebug.namespaces) {\n          // @ts-expect-error namespaces is not in the types\n          namespacesCache = createDebug.namespaces\n          enabledCache = createDebug.enabled(namespace)\n        }\n\n        return enabledCache\n      },\n      set: v => {\n        enableOverride = v\n      }\n    })\n\n    // Env-specific initialization logic for debug instances\n    // @ts-expect-error init is not in the types\n    if (typeof createDebug.init === 'function') {\n      // @ts-expect-error init is not in the types\n      createDebug.init(debug)\n    }\n\n    // @ts-expect-error some properties are added dynamically\n    return debug\n  }\n\n  function extend (this: any, namespace: string, delimiter: string): any {\n    const newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace)\n    newDebug.log = this.log\n    return newDebug\n  }\n\n  /**\n   * Enables a debug mode by namespaces. This can include modes\n   * separated by a colon and wildcards.\n   *\n   * @param {string} namespaces\n   */\n  function enable (namespaces: string): void {\n    // @ts-expect-error save is not in the types\n    createDebug.save(namespaces)\n    // @ts-expect-error namespaces is not in the types\n    createDebug.namespaces = namespaces\n\n    createDebug.names = []\n    createDebug.skips = []\n\n    let i\n    const split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/)\n    const len = split.length\n\n    for (i = 0; i < len; i++) {\n      if (!split[i]) {\n        // ignore empty strings\n        continue\n      }\n\n      namespaces = split[i].replace(/\\*/g, '.*?')\n\n      if (namespaces[0] === '-') {\n        createDebug.skips.push(new RegExp('^' + namespaces.substr(1) + '$'))\n      } else {\n        createDebug.names.push(new RegExp('^' + namespaces + '$'))\n      }\n    }\n  }\n\n  /**\n   * Disable debug output.\n   *\n   * @returns {string} namespaces\n   */\n  function disable (): string {\n    const namespaces = [\n      ...createDebug.names.map(toNamespace),\n      ...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)\n    ].join(',')\n    createDebug.enable('')\n    return namespaces\n  }\n\n  /**\n   * Returns true if the given mode name is enabled, false otherwise.\n   *\n   * @param {string} name\n   * @returns {boolean}\n   */\n  function enabled (name: string): boolean {\n    if (name[name.length - 1] === '*') {\n      return true\n    }\n\n    let i\n    let len\n\n    for (i = 0, len = createDebug.skips.length; i < len; i++) {\n      if (createDebug.skips[i].test(name)) {\n        return false\n      }\n    }\n\n    for (i = 0, len = createDebug.names.length; i < len; i++) {\n      if (createDebug.names[i].test(name)) {\n        return true\n      }\n    }\n\n    return false\n  }\n\n  /**\n   * Convert regexp to namespace\n   */\n  function toNamespace (regexp: RegExp): string {\n    return regexp.toString()\n      .substring(2, regexp.toString().length - 2)\n      .replace(/\\.\\*\\?$/, '*')\n  }\n\n  /**\n   * Coerce `val`.\n   */\n  function coerce (val: any): any {\n    if (val instanceof Error) {\n      return val.stack ?? val.message\n    }\n    return val\n  }\n\n  /**\n   * XXX DO NOT USE. This is a temporary stub function.\n   * XXX It WILL be removed in the next major release.\n   */\n  function destroy (): void {\n    console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.')\n  }\n\n  // @ts-expect-error setupFormatters is not in the types\n  createDebug.setupFormatters(createDebug.formatters)\n\n  // @ts-expect-error load is not in the types\n  createDebug.enable(createDebug.load())\n\n  // @ts-expect-error some properties are added dynamically\n  return createDebug\n}\n", "/* eslint-disable no-console */\n/* eslint-disable @typescript-eslint/restrict-plus-operands */\n/* eslint-disable @typescript-eslint/strict-boolean-expressions */\n/* eslint-env browser */\n\n/**\n * This is the web browser implementation of `debug()`.\n */\nimport humanize from 'ms'\nimport setup from './common.js'\n\nconst storage = localstorage()\n\n/**\n * Colors.\n */\nconst colors = [\n  '#0000CC',\n  '#0000FF',\n  '#0033CC',\n  '#0033FF',\n  '#0066CC',\n  '#0066FF',\n  '#0099CC',\n  '#0099FF',\n  '#00CC00',\n  '#00CC33',\n  '#00CC66',\n  '#00CC99',\n  '#00CCCC',\n  '#00CCFF',\n  '#3300CC',\n  '#3300FF',\n  '#3333CC',\n  '#3333FF',\n  '#3366CC',\n  '#3366FF',\n  '#3399CC',\n  '#3399FF',\n  '#33CC00',\n  '#33CC33',\n  '#33CC66',\n  '#33CC99',\n  '#33CCCC',\n  '#33CCFF',\n  '#6600CC',\n  '#6600FF',\n  '#6633CC',\n  '#6633FF',\n  '#66CC00',\n  '#66CC33',\n  '#9900CC',\n  '#9900FF',\n  '#9933CC',\n  '#9933FF',\n  '#99CC00',\n  '#99CC33',\n  '#CC0000',\n  '#CC0033',\n  '#CC0066',\n  '#CC0099',\n  '#CC00CC',\n  '#CC00FF',\n  '#CC3300',\n  '#CC3333',\n  '#CC3366',\n  '#CC3399',\n  '#CC33CC',\n  '#CC33FF',\n  '#CC6600',\n  '#CC6633',\n  '#CC9900',\n  '#CC9933',\n  '#CCCC00',\n  '#CCCC33',\n  '#FF0000',\n  '#FF0033',\n  '#FF0066',\n  '#FF0099',\n  '#FF00CC',\n  '#FF00FF',\n  '#FF3300',\n  '#FF3333',\n  '#FF3366',\n  '#FF3399',\n  '#FF33CC',\n  '#FF33FF',\n  '#FF6600',\n  '#FF6633',\n  '#FF9900',\n  '#FF9933',\n  '#FFCC00',\n  '#FFCC33'\n]\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\n// eslint-disable-next-line complexity\nfunction useColors (): boolean {\n  // NB: In an Electron preload script, document will be defined but not fully\n  // initialized. Since we know we're in Chrome, we'll just detect this case\n  // explicitly\n  // @ts-expect-error window.process.type and window.process.__nwjs are not in the types\n  if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {\n    return true\n  }\n\n  // Internet Explorer and Edge do not support colors.\n  if (typeof navigator !== 'undefined' && (navigator.userAgent?.toLowerCase().match(/(edge|trident)\\/(\\d+)/) != null)) {\n    return false\n  }\n\n  // Is webkit? http://stackoverflow.com/a/16459606/376773\n  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n  // @ts-expect-error document.documentElement.style.WebkitAppearance is not in the types\n  return (typeof document !== 'undefined' && document.documentElement?.style?.WebkitAppearance) ||\n    // Is firebug? http://stackoverflow.com/a/398120/376773\n    // @ts-expect-error window.console.firebug and window.console.exception are not in the types\n    (typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||\n    // Is firefox >= v31?\n    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n    (typeof navigator !== 'undefined' && (navigator.userAgent?.toLowerCase().match(/firefox\\/(\\d+)/) != null) && parseInt(RegExp.$1, 10) >= 31) ||\n    // Double check webkit in userAgent just in case we are in a worker\n    (typeof navigator !== 'undefined' && navigator.userAgent?.toLowerCase().match(/applewebkit\\/(\\d+)/))\n}\n\n/**\n * Colorize log arguments if enabled.\n */\nfunction formatArgs (this: any, args: any[]): void {\n  args[0] = (this.useColors ? '%c' : '') +\n    this.namespace +\n    (this.useColors ? ' %c' : ' ') +\n    args[0] +\n    (this.useColors ? '%c ' : ' ') +\n    '+' + humanize(this.diff)\n\n  if (!this.useColors) {\n    return\n  }\n\n  const c = 'color: ' + this.color\n  args.splice(1, 0, c, 'color: inherit')\n\n  // The final \"%c\" is somewhat tricky, because there could be other\n  // arguments passed either before or after the %c, so we need to\n  // figure out the correct index to insert the CSS into\n  let index = 0\n  let lastC = 0\n  args[0].replace(/%[a-zA-Z%]/g, (match: string) => {\n    if (match === '%%') {\n      return\n    }\n    index++\n    if (match === '%c') {\n      // We only are interested in the *last* %c\n      // (the user may have provided their own)\n      lastC = index\n    }\n  })\n\n  args.splice(lastC, 0, c)\n}\n\n/**\n * Invokes `console.debug()` when available.\n * No-op when `console.debug` is not a \"function\".\n * If `console.debug` is not available, falls back\n * to `console.log`.\n */\nconst log = console.debug ?? console.log ?? (() => { })\n\n/**\n * Save `namespaces`.\n *\n * @param {string} namespaces\n */\nfunction save (namespaces: string): void {\n  try {\n    if (namespaces) {\n      storage?.setItem('debug', namespaces)\n    } else {\n      storage?.removeItem('debug')\n    }\n  } catch (error) {\n    // Swallow\n    // XXX (@Qix-) should we be logging these?\n  }\n}\n\n/**\n * Load `namespaces`.\n *\n * @returns {string} returns the previously persisted debug modes\n */\nfunction load (): string | null | undefined {\n  let r\n  try {\n    r = storage?.getItem('debug')\n  } catch (error) {\n    // Swallow\n    // XXX (@Qix-) should we be logging these?\n  }\n\n  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n  if (!r && typeof globalThis.process !== 'undefined' && 'env' in globalThis.process) {\n    r = globalThis.process.env.DEBUG\n  }\n\n  return r\n}\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n */\nfunction localstorage (): Storage | undefined {\n  try {\n    // TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context\n    // The Browser also has localStorage in the global context.\n    return localStorage\n  } catch (error) {\n    // Swallow\n    // XXX (@Qix-) should we be logging these?\n  }\n}\n\nfunction setupFormatters (formatters: any): void {\n  /**\n   * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n   */\n  formatters.j = function (v: any) {\n    try {\n      return JSON.stringify(v)\n    } catch (error: any) {\n      return '[UnexpectedJSONParseError]: ' + error.message\n    }\n  }\n}\n\nexport default setup({ formatArgs, save, load, useColors, setupFormatters, colors, storage, log })\n", "/**\n * @packageDocumentation\n *\n * This module is a fork of the [debug](https://www.npmjs.com/package/debug) module. It has been converted to TypeScript and the output is ESM.\n *\n * It is API compatible with no extra features or bug fixes, it should only be used if you want a 100% ESM application.\n *\n * ESM should be arriving in `debug@5.x.x` so this module can be retired after that.\n *\n * Please see [debug](https://www.npmjs.com/package/debug) for API details.\n */\n\n/**\n * Module dependencies.\n */\nimport weald from './node.js'\nimport type ms from 'ms'\n\nexport interface Debug {\n  (namespace: string): Debugger\n  coerce(val: any): any\n  disable(...args: string[]): string\n  enable(namespaces: string | boolean): void\n  enabled(namespaces: string): boolean\n  formatArgs(this: Debugger, args: any[]): void\n  log(...args: any[]): any\n  selectColor(namespace: string): string | number\n  humanize: typeof ms\n\n  names: RegExp[]\n  skips: RegExp[]\n\n  formatters: Formatters\n\n  inspectOpts?: {\n    hideDate?: boolean | number | null\n    colors?: boolean | number | null\n    depth?: boolean | number | null\n    showHidden?: boolean | number | null\n  }\n}\n\nexport type Formatters = Record<string, (v: any) => string>\n\nexport interface Debugger {\n  (formatter: any, ...args: any[]): void\n\n  color: string\n  diff: number\n  enabled: boolean\n  log(...args: any[]): any\n  namespace: string\n  destroy(): boolean\n  extend(namespace: string, delimiter?: string): Debugger\n}\n\nexport default weald\n", "/**\n * @packageDocumentation\n *\n * A logger for libp2p based on [weald](https://www.npmjs.com/package/weald), a TypeScript port of the venerable [debug](https://www.npmjs.com/package/debug) module.\n *\n * @example\n *\n * ```TypeScript\n * import { logger } from '@libp2p/logger'\n *\n * const log = logger('libp2p:my:component:name')\n *\n * try {\n *   // an operation\n *   log('something happened: %s', 'it was ok')\n * } catch (err) {\n *   log.error('something bad happened: %o', err)\n * }\n *\n * log('with this peer: %p', {})\n * log('and this base58btc: %b', Uint8Array.from([0, 1, 2, 3]))\n * log('and this base32: %t', Uint8Array.from([4, 5, 6, 7]))\n * ```\n *\n * ```console\n * $ DEBUG=libp2p:* node index.js\n * something happened: it was ok\n * something bad happened: <stack trace>\n * with this peer: 12D3Foo\n * with this base58btc: Qmfoo\n * with this base32: bafyfoo\n * ```\n */\n\nimport { base32 } from 'multiformats/bases/base32'\nimport { base58btc } from 'multiformats/bases/base58'\nimport { base64 } from 'multiformats/bases/base64'\nimport debug from 'weald'\nimport { truncatePeerId } from './utils.js'\nimport type { PeerId } from '@libp2p/interface'\nimport type { Multiaddr } from '@multiformats/multiaddr'\nimport type { Key } from 'interface-datastore'\nimport type { CID } from 'multiformats/cid'\n\n// Add a formatter for converting to a base58 string\ndebug.formatters.b = (v?: Uint8Array): string => {\n  return v == null ? 'undefined' : base58btc.baseEncode(v)\n}\n\n// Add a formatter for converting to a base32 string\ndebug.formatters.t = (v?: Uint8Array): string => {\n  return v == null ? 'undefined' : base32.baseEncode(v)\n}\n\n// Add a formatter for converting to a base64 string\ndebug.formatters.m = (v?: Uint8Array): string => {\n  return v == null ? 'undefined' : base64.baseEncode(v)\n}\n\n// Add a formatter for stringifying peer ids\ndebug.formatters.p = (v?: PeerId): string => {\n  return v == null ? 'undefined' : v.toString()\n}\n\n// Add a formatter for stringifying CIDs\ndebug.formatters.c = (v?: CID): string => {\n  return v == null ? 'undefined' : v.toString()\n}\n\n// Add a formatter for stringifying Datastore keys\ndebug.formatters.k = (v: Key): string => {\n  return v == null ? 'undefined' : v.toString()\n}\n\n// Add a formatter for stringifying Multiaddrs\ndebug.formatters.a = (v?: Multiaddr): string => {\n  return v == null ? 'undefined' : v.toString()\n}\n\n// Add a formatter for stringifying Errors\ndebug.formatters.e = (v?: Error): string => {\n  return v == null ? 'undefined' : notEmpty(v.stack) ?? notEmpty(v.message) ?? v.toString()\n}\n\nexport interface Logger {\n  (formatter: any, ...args: any[]): void\n  error(formatter: any, ...args: any[]): void\n  trace(formatter: any, ...args: any[]): void\n  enabled: boolean\n}\n\nexport interface ComponentLogger {\n  forComponent(name: string): Logger\n}\n\nfunction createDisabledLogger (namespace: string): debug.Debugger {\n  const logger = (): void => {}\n  logger.enabled = false\n  logger.color = ''\n  logger.diff = 0\n  logger.log = (): void => {}\n  logger.namespace = namespace\n  logger.destroy = () => true\n  logger.extend = () => logger\n\n  return logger\n}\n\nexport interface PeerLoggerOptions {\n  prefixLength: number\n  suffixLength: number\n}\n\n/**\n * Create a component logger that will prefix any log messages with a truncated\n * peer id.\n *\n * @example\n *\n * ```TypeScript\n * import { peerLogger } from '@libp2p/logger'\n * import { peerIdFromString } from '@libp2p/peer-id'\n *\n * const peerId = peerIdFromString('12D3FooBar')\n * const logger = peerLogger(peerId)\n *\n * const log = logger.forComponent('my-component')\n * log.info('hello world')\n * // logs \"12\u2026oBar:my-component hello world\"\n * ```\n */\nexport function peerLogger (peerId: PeerId, options: Partial<PeerLoggerOptions> = {}): ComponentLogger {\n  return prefixLogger(truncatePeerId(peerId, options))\n}\n\n/**\n * Create a component logger that will prefix any log messages with the passed\n * string.\n *\n * @example\n *\n * ```TypeScript\n * import { prefixLogger } from '@libp2p/logger'\n *\n * const logger = prefixLogger('my-node')\n *\n * const log = logger.forComponent('my-component')\n * log.info('hello world')\n * // logs \"my-node:my-component hello world\"\n * ```\n */\nexport function prefixLogger (prefix: string): ComponentLogger {\n  return {\n    forComponent (name: string) {\n      return logger(`${prefix}:${name}`)\n    }\n  }\n}\n\n/**\n * Create a component logger\n *\n * @example\n *\n * ```TypeScript\n * import { defaultLogger } from '@libp2p/logger'\n * import { peerIdFromString } from '@libp2p/peer-id'\n *\n * const logger = defaultLogger()\n *\n * const log = logger.forComponent('my-component')\n * log.info('hello world')\n * // logs \"my-component hello world\"\n * ```\n */\nexport function defaultLogger (): ComponentLogger {\n  return {\n    forComponent (name: string) {\n      return logger(name)\n    }\n  }\n}\n\n/**\n * Creates a logger for the passed component name.\n *\n * @example\n *\n * ```TypeScript\n * import { logger } from '@libp2p/logger'\n *\n * const log = logger('my-component')\n * log.info('hello world')\n * // logs \"my-component hello world\"\n * ```\n */\nexport function logger (name: string): Logger {\n  // trace logging is a no-op by default\n  let trace: debug.Debugger = createDisabledLogger(`${name}:trace`)\n\n  // look at all the debug names and see if trace logging has explicitly been enabled\n  if (debug.enabled(`${name}:trace`) && debug.names.map((r: any) => r.toString()).find((n: string) => n.includes(':trace')) != null) {\n    trace = debug(`${name}:trace`)\n  }\n\n  return Object.assign(debug(name), {\n    error: debug(`${name}:error`),\n    trace\n  })\n}\n\nexport function disable (): void {\n  debug.disable()\n}\n\nexport function enable (namespaces: string): void {\n  debug.enable(namespaces)\n}\n\nexport function enabled (namespaces: string): boolean {\n  return debug.enabled(namespaces)\n}\n\nfunction notEmpty (str?: string): string | undefined {\n  if (str == null) {\n    return\n  }\n\n  str = str.trim()\n\n  if (str.length === 0) {\n    return\n  }\n\n  return str\n}\n", "/**\n * @packageDocumentation\n *\n * Lets you look at the contents of an async iterator and decide what to do\n *\n * @example\n *\n * ```javascript\n * import peekable from 'it-peekable'\n *\n * // This can also be an iterator, generator, etc\n * const values = [0, 1, 2, 3, 4]\n *\n * const it = peekable(value)\n *\n * const first = it.peek()\n *\n * console.info(first) // 0\n *\n * it.push(first)\n *\n * console.info([...it])\n * // [ 0, 1, 2, 3, 4 ]\n * ```\n *\n * Async sources must be awaited:\n *\n * ```javascript\n * import peekable from 'it-peekable'\n *\n * const values = async function * () {\n *   yield * [0, 1, 2, 3, 4]\n * }\n *\n * const it = peekable(values())\n *\n * const first = await it.peek()\n *\n * console.info(first) // 0\n *\n * it.push(first)\n *\n * console.info(await all(it))\n * // [ 0, 1, 2, 3, 4 ]\n * ```\n */\n\nexport interface Peek <T> {\n  peek(): IteratorResult<T, undefined>\n}\n\nexport interface AsyncPeek <T> {\n  peek(): Promise<IteratorResult<T, undefined>>\n}\n\nexport interface Push <T> {\n  push(value: T): void\n}\n\nexport type Peekable <T> = Iterable<T> & Peek<T> & Push<T> & Iterator<T>\n\nexport type AsyncPeekable <T> = AsyncIterable<T> & AsyncPeek<T> & Push<T> & AsyncIterator<T>\n\nfunction peekable <T> (iterable: Iterable<T>): Peekable<T>\nfunction peekable <T> (iterable: AsyncIterable<T>): AsyncPeekable<T>\nfunction peekable <T> (iterable: Iterable<T> | AsyncIterable<T>): Peekable<T> | AsyncPeekable<T> {\n  // @ts-expect-error can't use Symbol.asyncIterator to index iterable since it might be Iterable\n  const [iterator, symbol] = iterable[Symbol.asyncIterator] != null\n    // @ts-expect-error can't use Symbol.asyncIterator to index iterable since it might be Iterable\n    ? [iterable[Symbol.asyncIterator](), Symbol.asyncIterator]\n    // @ts-expect-error can't use Symbol.iterator to index iterable since it might be AsyncIterable\n    : [iterable[Symbol.iterator](), Symbol.iterator]\n\n  const queue: any[] = []\n\n  // @ts-expect-error can't use symbol to index peekable\n  return {\n    peek: () => {\n      return iterator.next()\n    },\n    push: (value: any) => {\n      queue.push(value)\n    },\n    next: () => {\n      if (queue.length > 0) {\n        return {\n          done: false,\n          value: queue.shift()\n        }\n      }\n\n      return iterator.next()\n    },\n    [symbol] () {\n      return this\n    }\n  }\n}\n\nexport default peekable\n", "/**\n * @packageDocumentation\n *\n * Filter values out of an (async)iterable\n *\n * @example\n *\n * ```javascript\n * import all from 'it-all'\n * import filter from 'it-filter'\n *\n * // This can also be an iterator, generator, etc\n * const values = [0, 1, 2, 3, 4]\n *\n * const fn = (val, index) => val > 2 // Return boolean to keep item\n *\n * const arr = all(filter(values, fn))\n *\n * console.info(arr) // 3, 4\n * ```\n *\n * Async sources and filter functions must be awaited:\n *\n * ```javascript\n * import all from 'it-all'\n * import filter from 'it-filter'\n *\n * const values = async function * () {\n *   yield * [0, 1, 2, 3, 4]\n * }\n *\n * const fn = async val => (val, index) > 2 // Return boolean or promise of boolean to keep item\n *\n * const arr = await all(filter(values, fn))\n *\n * console.info(arr) // 3, 4\n * ```\n */\n\nimport peek from 'it-peekable'\n\nfunction isAsyncIterable <T> (thing: any): thing is AsyncIterable<T> {\n  return thing[Symbol.asyncIterator] != null\n}\n\n/**\n * Filters the passed (async) iterable by using the filter function\n */\nfunction filter <T> (source: Iterable<T>, fn: (val: T, index: number) => Promise<boolean>): AsyncGenerator<T, void, undefined>\nfunction filter <T> (source: Iterable<T>, fn: (val: T, index: number) => boolean): Generator<T, void, undefined>\nfunction filter <T> (source: Iterable<T> | AsyncIterable<T>, fn: (val: T, index: number) => boolean | Promise<boolean>): AsyncGenerator<T, void, undefined>\nfunction filter <T> (source: Iterable<T> | AsyncIterable<T>, fn: (val: T, index: number) => boolean | Promise<boolean>): Generator<T, void, undefined> | AsyncGenerator<T, void, undefined> {\n  let index = 0\n\n  if (isAsyncIterable(source)) {\n    return (async function * () {\n      for await (const entry of source) {\n        if (await fn(entry, index++)) {\n          yield entry\n        }\n      }\n    })()\n  }\n\n  // if mapping function returns a promise we have to return an async generator\n  const peekable = peek(source)\n  const { value, done } = peekable.next()\n\n  if (done === true) {\n    return (function * () {}())\n  }\n\n  const res = fn(value, index++)\n\n  // @ts-expect-error .then is not present on O\n  if (typeof res.then === 'function') {\n    return (async function * () {\n      if (await res) {\n        yield value\n      }\n\n      for await (const entry of peekable) {\n        if (await fn(entry, index++)) {\n          yield entry\n        }\n      }\n    })()\n  }\n\n  const func = fn as (val: T, index: number) => boolean\n\n  return (function * () {\n    if (res === true) {\n      yield value\n    }\n\n    for (const entry of peekable) {\n      if (func(entry, index++)) {\n        yield entry\n      }\n    }\n  })()\n}\n\nexport default filter\n", "export default function pDefer() {\n\tconst deferred = {};\n\n\tdeferred.promise = new Promise((resolve, reject) => {\n\t\tdeferred.resolve = resolve;\n\t\tdeferred.reject = reject;\n\t});\n\n\treturn deferred;\n}\n", "/**\n * An abort error class that extends error\n */\nexport class AbortError extends Error {\n  public type: string\n  public code: string | string\n\n  constructor (message?: string, code?: string, name?: string) {\n    super(message ?? 'The operation was aborted')\n    this.type = 'aborted'\n    this.name = name ?? 'AbortError'\n    this.code = code ?? 'ABORT_ERR'\n  }\n}\n\nexport interface RaceSignalOptions {\n  /**\n   * The message for the error thrown if the signal aborts\n   */\n  errorMessage?: string\n\n  /**\n   * The code for the error thrown if the signal aborts\n   */\n  errorCode?: string\n\n  /**\n   * The name for the error thrown if the signal aborts\n   */\n  errorName?: string\n}\n\n/**\n * Race a promise against an abort signal\n */\nexport async function raceSignal <T> (promise: Promise<T>, signal?: AbortSignal, opts?: RaceSignalOptions): Promise<T> {\n  if (signal == null) {\n    return promise\n  }\n\n  if (signal.aborted) {\n    // the passed promise may yet resolve or reject but the use has signalled\n    // they are no longer interested so smother the error\n    promise.catch(() => {})\n    return Promise.reject(new AbortError(opts?.errorMessage, opts?.errorCode, opts?.errorName))\n  }\n\n  let listener\n\n  // create the error here so we have more context in the stack trace\n  const error = new AbortError(opts?.errorMessage, opts?.errorCode, opts?.errorName)\n\n  try {\n    return await Promise.race([\n      promise,\n      new Promise<T>((resolve, reject) => {\n        listener = () => {\n          reject(error)\n        }\n        signal.addEventListener('abort', listener)\n      })\n    ])\n  } finally {\n    if (listener != null) {\n      signal.removeEventListener('abort', listener)\n    }\n  }\n}\n", "/**\n * @packageDocumentation\n *\n * A pushable async generator that waits until the current value is consumed\n * before allowing a new value to be pushed.\n *\n * Useful for when you don't want to keep memory usage under control and/or\n * allow a downstream consumer to dictate how fast data flows through a pipe,\n * but you want to be able to apply a transform to that data.\n *\n * @example\n *\n * ```typescript\n * import { queuelessPushable } from 'it-queueless-pushable'\n *\n * const pushable = queuelessPushable<string>()\n *\n * // run asynchronously\n * Promise.resolve().then(async () => {\n *   // push a value - the returned promise will not resolve until the value is\n *   // read from the pushable\n *   await pushable.push('hello')\n * })\n *\n * // read a value\n * const result = await pushable.next()\n * console.info(result) // { done: false, value: 'hello' }\n * ```\n */\n\nimport deferred from 'p-defer'\nimport { raceSignal } from 'race-signal'\nimport type { AbortOptions } from 'abort-error'\nimport type { DeferredPromise } from 'p-defer'\nimport type { RaceSignalOptions } from 'race-signal'\n\nexport interface Pushable<T> extends AsyncGenerator<T, void, unknown> {\n  /**\n   * End the iterable after all values in the buffer (if any) have been yielded. If an\n   * error is passed the buffer is cleared immediately and the next iteration will\n   * throw the passed error\n   */\n  end(err?: Error, options?: AbortOptions & RaceSignalOptions): Promise<void>\n\n  /**\n   * Push a value into the iterable. Values are yielded from the iterable in the order\n   * they are pushed. Values not yet consumed from the iterable are buffered.\n   */\n  push(value: T, options?: AbortOptions & RaceSignalOptions): Promise<void>\n}\n\nclass QueuelessPushable <T> implements Pushable<T> {\n  private readNext: DeferredPromise<void>\n  private haveNext: DeferredPromise<void>\n  private ended: boolean\n  private nextResult: IteratorResult<T> | undefined\n  private error?: Error\n\n  constructor () {\n    this.ended = false\n\n    this.readNext = deferred()\n    this.haveNext = deferred()\n  }\n\n  [Symbol.asyncIterator] (): AsyncGenerator<T, void, unknown> {\n    return this\n  }\n\n  async next (): Promise<IteratorResult<T, void>> {\n    if (this.nextResult == null) {\n      // wait for the supplier to push a value\n      await this.haveNext.promise\n    }\n\n    if (this.nextResult == null) {\n      throw new Error('HaveNext promise resolved but nextResult was undefined')\n    }\n\n    const nextResult = this.nextResult\n    this.nextResult = undefined\n\n    // signal to the supplier that we read the value\n    this.readNext.resolve()\n    this.readNext = deferred()\n\n    return nextResult\n  }\n\n  async throw (err?: Error): Promise<IteratorReturnResult<undefined>> {\n    this.ended = true\n    this.error = err\n\n    if (err != null) {\n      // this can cause unhandled promise rejections if nothing is awaiting the\n      // next value so attach a dummy catch listener to the promise\n      this.haveNext.promise.catch(() => {})\n      this.haveNext.reject(err)\n    }\n\n    const result: IteratorReturnResult<undefined> = {\n      done: true,\n      value: undefined\n    }\n\n    return result\n  }\n\n  async return (): Promise<IteratorResult<T>> {\n    const result: IteratorReturnResult<undefined> = {\n      done: true,\n      value: undefined\n    }\n\n    this.ended = true\n    this.nextResult = result\n\n    // let the consumer know we have a new value\n    this.haveNext.resolve()\n\n    return result\n  }\n\n  async push (value: T, options?: AbortOptions & RaceSignalOptions): Promise<void> {\n    await this._push(value, options)\n  }\n\n  async end (err?: Error, options?: AbortOptions & RaceSignalOptions): Promise<void> {\n    if (err != null) {\n      await this.throw(err)\n    } else {\n      // abortable return\n      await this._push(undefined, options)\n    }\n  }\n\n  private async _push (value?: T, options?: AbortOptions & RaceSignalOptions): Promise<void> {\n    if (value != null && this.ended) {\n      throw this.error ?? new Error('Cannot push value onto an ended pushable')\n    }\n\n    // wait for all values to be read\n    while (this.nextResult != null) {\n      await this.readNext.promise\n    }\n\n    if (value != null) {\n      this.nextResult = { done: false, value }\n    } else {\n      this.ended = true\n      this.nextResult = { done: true, value: undefined }\n    }\n\n    // let the consumer know we have a new value\n    this.haveNext.resolve()\n    this.haveNext = deferred()\n\n    // wait for the consumer to have finished processing the value and requested\n    // the next one or for the passed signal to abort the waiting\n    await raceSignal(\n      this.readNext.promise,\n      options?.signal,\n      options\n    )\n  }\n}\n\nexport function queuelessPushable <T> (): Pushable<T> {\n  return new QueuelessPushable<T>()\n}\n", "/**\n * @packageDocumentation\n *\n * Merge several (async)iterables into one, yield values as they arrive.\n *\n * Nb. sources are iterated over in parallel so the order of emitted items is not guaranteed.\n *\n * @example\n *\n * ```javascript\n * import merge from 'it-merge'\n * import all from 'it-all'\n *\n * // This can also be an iterator, generator, etc\n * const values1 = [0, 1, 2, 3, 4]\n * const values2 = [5, 6, 7, 8, 9]\n *\n * const arr = all(merge(values1, values2))\n *\n * console.info(arr) // 0, 1, 2, 3, 4, 5, 6, 7, 8, 9\n * ```\n *\n * Async sources must be awaited:\n *\n * ```javascript\n * import merge from 'it-merge'\n * import all from 'it-all'\n *\n * // This can also be an iterator, async iterator, generator, etc\n * const values1 = async function * () {\n *   yield * [0, 1, 2, 3, 4]\n * }\n * const values2 = async function * () {\n *   yield * [5, 6, 7, 8, 9]\n * }\n *\n * const arr = await all(merge(values1(), values2()))\n *\n * console.info(arr) // 0, 1, 5, 6, 2, 3, 4, 7, 8, 9  <- nb. order is not guaranteed\n * ```\n */\n\nimport { queuelessPushable } from 'it-queueless-pushable'\nimport type { Pushable } from 'it-queueless-pushable'\n\nfunction isAsyncIterable <T> (thing: any): thing is AsyncIterable<T> {\n  return thing[Symbol.asyncIterator] != null\n}\n\nasync function addAllToPushable <T> (sources: Array<AsyncIterable<T> | Iterable<T>>, output: Pushable<T>, signal: AbortSignal): Promise<void> {\n  try {\n    await Promise.all(\n      sources.map(async (source) => {\n        for await (const item of source) {\n          await output.push(item, {\n            signal\n          })\n          signal.throwIfAborted()\n        }\n      })\n    )\n\n    await output.end(undefined, {\n      signal\n    })\n  } catch (err: any) {\n    await output.end(err, {\n      signal\n    })\n      .catch(() => {})\n  }\n}\n\nasync function * mergeSources <T> (sources: Array<AsyncIterable<T> | Iterable<T>>): AsyncGenerator<T, void, undefined> {\n  const controller = new AbortController()\n  const output = queuelessPushable<T>()\n\n  addAllToPushable(sources, output, controller.signal)\n    .catch(() => {})\n\n  try {\n    yield * output\n  } finally {\n    controller.abort()\n  }\n}\n\nfunction * mergeSyncSources <T> (syncSources: Array<Iterable<T>>): Generator<T, void, undefined> {\n  for (const source of syncSources) {\n    yield * source\n  }\n}\n\n/**\n * Treat one or more iterables as a single iterable.\n *\n * Nb. sources are iterated over in parallel so the\n * order of emitted items is not guaranteed.\n */\nfunction merge <T> (...sources: Array<Iterable<T>>): Generator<T, void, undefined>\nfunction merge <T> (...sources: Array<AsyncIterable<T> | Iterable<T>>): AsyncGenerator<T, void, undefined>\nfunction merge <T> (...sources: Array<AsyncIterable<T> | Iterable<T>>): AsyncGenerator<T, void, undefined> | Generator<T, void, undefined> {\n  const syncSources: Array<Iterable<T>> = []\n\n  for (const source of sources) {\n    if (!isAsyncIterable(source)) {\n      syncSources.push(source)\n    }\n  }\n\n  if (syncSources.length === sources.length) {\n    // all sources are synchronous\n    return mergeSyncSources(syncSources)\n  }\n\n  return mergeSources(sources)\n}\n\nexport default merge\n", "import { logger } from '@libp2p/logger'\nimport { NotFoundError } from 'interface-store'\nimport filter from 'it-filter'\nimport merge from 'it-merge'\nimport { BaseBlockstore } from './base.js'\nimport type { Blockstore, Pair } from 'interface-blockstore'\nimport type { AbortOptions, AwaitIterable } from 'interface-store'\nimport type { CID } from 'multiformats/cid'\n\nconst log = logger('blockstore:core:tiered')\n\n/**\n * A blockstore that can combine multiple stores. Puts and deletes\n * will write through to all blockstores. Has and get will\n * try each store sequentially. getAll will use every store but also\n * deduplicate any yielded pairs.\n */\nexport class TieredBlockstore extends BaseBlockstore {\n  private readonly stores: Blockstore[]\n\n  constructor (stores: Blockstore[]) {\n    super()\n\n    this.stores = stores.slice()\n  }\n\n  async put (key: CID, value: Uint8Array, options?: AbortOptions): Promise<CID> {\n    await Promise.all(\n      this.stores.map(async store => {\n        await store.put(key, value, options)\n      })\n    )\n\n    return key\n  }\n\n  async get (key: CID, options?: AbortOptions): Promise<Uint8Array> {\n    let error: Error | undefined\n\n    for (const store of this.stores) {\n      try {\n        const res = await store.get(key, options)\n\n        if (res != null) {\n          return res\n        }\n      } catch (err: any) {\n        error = err\n        log.error(err)\n      }\n    }\n\n    throw error ?? new NotFoundError()\n  }\n\n  async has (key: CID, options?: AbortOptions): Promise<boolean> {\n    for (const s of this.stores) {\n      if (await s.has(key, options)) {\n        return true\n      }\n    }\n\n    return false\n  }\n\n  async delete (key: CID, options?: AbortOptions): Promise<void> {\n    await Promise.all(\n      this.stores.map(async store => {\n        await store.delete(key, options)\n      })\n    )\n  }\n\n  async * putMany (source: AwaitIterable<Pair>, options: AbortOptions = {}): AsyncIterable<CID> {\n    for await (const pair of source) {\n      await this.put(pair.cid, pair.block, options)\n      yield pair.cid\n    }\n  }\n\n  async * deleteMany (source: AwaitIterable<CID>, options: AbortOptions = {}): AsyncIterable<CID> {\n    for await (const cid of source) {\n      await this.delete(cid, options)\n      yield cid\n    }\n  }\n\n  async * getAll (options?: AbortOptions): AwaitIterable<Pair> {\n    // deduplicate yielded pairs\n    const seen = new Set<string>()\n\n    yield * filter(merge(...this.stores.map(s => s.getAll(options))), (pair) => {\n      const cidStr = pair.cid.toString()\n\n      if (seen.has(cidStr)) {\n        return false\n      }\n\n      seen.add(cidStr)\n\n      return true\n    })\n  }\n}\n"],
  "mappings": "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",
  "names": ["index_exports", "__export", "BaseBlockstore", "BlackHoleBlockstore", "MemoryBlockstore", "TieredBlockstore", "BaseBlockstore", "key", "options", "val", "source", "cid", "block", "NotFoundError", "_NotFoundError", "message", "empty", "equals", "aa", "bb", "ii", "coerce", "o", "base", "ALPHABET", "name", "BASE_MAP", "j", "i", "x", "xc", "BASE", "LEADER", "FACTOR", "iFACTOR", "encode", "source", "zeroes", "length", "pbegin", "pend", "size", "b58", "carry", "it1", "it2", "str", "decodeUnsafe", "psz", "b256", "it3", "it4", "vch", "decode", "string", "buffer", "src", "_brrp__multiformats_scope_baseX", "base_x_default", "Encoder", "name", "prefix", "baseEncode", "bytes", "Decoder", "baseDecode", "prefixCodePoint", "text", "decoder", "or", "ComposedDecoder", "decoders", "input", "left", "right", "Codec", "from", "encode", "decode", "baseX", "alphabet", "base_x_default", "coerce", "string", "alphabetIdx", "bitsPerChar", "end", "out", "bits", "buffer", "written", "i", "value", "data", "pad", "mask", "createAlphabetIdx", "rfc4648", "base32", "rfc4648", "base32upper", "base32pad", "base32padupper", "base32hex", "base32hexupper", "base32hexpad", "base32hexpadupper", "base32z", "base36", "baseX", "base36upper", "base58btc", "baseX", "base58flickr", "encode_1", "encode", "MSB", "REST", "MSBALL", "INT", "num", "out", "offset", "oldOffset", "decode", "read", "MSB$1", "REST$1", "buf", "res", "shift", "counter", "b", "l", "N1", "N2", "N3", "N4", "N5", "N6", "N7", "N8", "N9", "length", "value", "varint", "_brrp_varint", "varint_default", "decode", "data", "offset", "varint_default", "encodeTo", "int", "target", "encodingLength", "create", "code", "digest", "size", "sizeOffset", "encodingLength", "digestOffset", "bytes", "encodeTo", "Digest", "decode", "multihash", "coerce", "equals", "a", "b", "data", "format", "link", "base", "bytes", "version", "toStringV0", "baseCache", "base58btc", "toStringV1", "base32", "cache", "baseCache", "cid", "CID", "_CID", "version", "code", "multihash", "bytes", "DAG_PB_CODE", "SHA_256_CODE", "digest", "create", "other", "self", "unknown", "equals", "base", "format", "input", "value", "encodeCID", "cidSymbol", "decode", "remainder", "specs", "prefixSize", "multihashBytes", "coerce", "digestBytes", "Digest", "initialBytes", "offset", "next", "i", "length", "codec", "multihashCode", "digestSize", "size", "multihashSize", "source", "prefix", "parseCIDtoBytes", "decoder", "base58btc", "base32", "base36", "toStringV0", "toStringV1", "codeOffset", "encodingLength", "hashOffset", "encodeTo", "code", "MemoryBlockstore", "BaseBlockstore", "key", "val", "options", "base32", "buf", "NotFoundError", "value", "CID", "code", "decode", "BlackHoleBlockstore", "BaseBlockstore", "key", "value", "options", "NotFoundError", "cid", "base64", "rfc4648", "base64pad", "base64url", "base64urlpad", "ms", "value", "options", "parse", "fmtLong", "fmtShort", "error", "message", "isError", "str", "match", "n", "type", "dist_default", "msAbs", "plural", "name", "isPlural", "setup", "env", "createDebug", "coerce", "disable", "enable", "enabled", "dist_default", "destroy", "key", "selectColor", "namespace", "hash", "i", "prevTime", "enableOverride", "namespacesCache", "enabledCache", "debug", "args", "self", "curr", "ms", "index", "match", "format", "formatter", "val", "extend", "v", "delimiter", "newDebug", "namespaces", "split", "len", "toNamespace", "name", "regexp", "storage", "localstorage", "colors", "useColors", "formatArgs", "args", "dist_default", "c", "index", "lastC", "match", "log", "save", "namespaces", "load", "setupFormatters", "formatters", "v", "error", "browser_default", "setup", "src_default", "browser_default", "src_default", "v", "base58btc", "base32", "base64", "notEmpty", "createDisabledLogger", "namespace", "logger", "logger", "name", "trace", "createDisabledLogger", "src_default", "r", "n", "notEmpty", "str", "peekable", "iterable", "iterator", "symbol", "queue", "value", "src_default", "isAsyncIterable", "thing", "filter", "source", "fn", "index", "entry", "peekable", "src_default", "value", "done", "res", "func", "pDefer", "deferred", "resolve", "reject", "AbortError", "message", "code", "name", "raceSignal", "promise", "signal", "opts", "listener", "error", "resolve", "reject", "QueuelessPushable", "pDefer", "nextResult", "err", "result", "value", "options", "raceSignal", "queuelessPushable", "isAsyncIterable", "thing", "addAllToPushable", "sources", "output", "signal", "source", "item", "err", "mergeSources", "controller", "queuelessPushable", "mergeSyncSources", "syncSources", "merge", "src_default", "log", "logger", "TieredBlockstore", "BaseBlockstore", "stores", "key", "value", "options", "store", "error", "res", "err", "NotFoundError", "s", "source", "pair", "cid", "seen", "src_default", "cidStr"]
}
