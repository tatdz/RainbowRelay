{
  "version": 3,
  "sources": ["../../../node_modules/murmurhash3js-revisited/lib/murmurHash3js.js", "../../../node_modules/murmurhash3js-revisited/index.js", "../../../node_modules/sparse-array/index.js", "../../../node_modules/eventemitter3/index.js", "../src/index.ts", "../../../node_modules/it-last/src/index.ts", "../../../node_modules/multiformats/src/bases/base32.ts", "../../../node_modules/multiformats/src/bytes.ts", "../../../node_modules/multiformats/src/vendor/base-x.js", "../../../node_modules/multiformats/src/bases/base.ts", "../../../node_modules/multiformats/src/bases/base36.ts", "../../../node_modules/multiformats/src/bases/base58.ts", "../../../node_modules/multiformats/src/vendor/varint.js", "../../../node_modules/multiformats/src/varint.ts", "../../../node_modules/multiformats/src/hashes/digest.ts", "../../../node_modules/multiformats/src/cid.ts", "../src/errors.ts", "../../../node_modules/cborg/lib/is.js", "../../../node_modules/cborg/lib/token.js", "../../../node_modules/cborg/lib/byte-utils.js", "../../../node_modules/cborg/lib/bl.js", "../../../node_modules/cborg/lib/common.js", "../../../node_modules/cborg/lib/0uint.js", "../../../node_modules/cborg/lib/1negint.js", "../../../node_modules/cborg/lib/2bytes.js", "../../../node_modules/cborg/lib/3string.js", "../../../node_modules/cborg/lib/4array.js", "../../../node_modules/cborg/lib/5map.js", "../../../node_modules/cborg/lib/6tag.js", "../../../node_modules/cborg/lib/7float.js", "../../../node_modules/cborg/lib/jump.js", "../../../node_modules/cborg/lib/encode.js", "../../../node_modules/cborg/lib/decode.js", "../../../node_modules/@ipld/dag-cbor/src/index.js", "../../../node_modules/cborg/lib/json/encode.js", "../../../node_modules/cborg/lib/json/decode.js", "../../../node_modules/multiformats/src/hashes/hasher.ts", "../../../node_modules/multiformats/src/bases/base64.ts", "../../../node_modules/@ipld/dag-json/src/index.js", "../../../node_modules/@ipld/dag-pb/src/pb-decode.js", "../../../node_modules/@ipld/dag-pb/src/pb-encode.js", "../../../node_modules/@ipld/dag-pb/src/util.js", "../../../node_modules/@ipld/dag-pb/src/index.js", "../../../node_modules/multiformats/src/codecs/json.ts", "../../../node_modules/multiformats/src/codecs/raw.ts", "../../../node_modules/multiformats/src/hashes/identity.ts", "../src/utils/resolve-object-path.ts", "../src/resolvers/dag-cbor.ts", "../src/resolvers/dag-json.ts", "../../../node_modules/progress-events/src/index.ts", "../src/utils/extract-data-from-block.ts", "../src/utils/validate-offset-and-length.ts", "../src/resolvers/identity.ts", "../src/resolvers/json.ts", "../src/resolvers/raw.ts", "../../ipfs-unixfs/src/errors.ts", "../../../node_modules/uint8arrays/src/alloc.ts", "../../../node_modules/uint8-varint/src/index.ts", "../../../node_modules/protons-runtime/src/utils/float.ts", "../../../node_modules/protons-runtime/src/utils/longbits.ts", "../../../node_modules/protons-runtime/src/utils/utf8.ts", "../../../node_modules/protons-runtime/src/utils/reader.ts", "../../../node_modules/protons-runtime/src/decode.ts", "../../../node_modules/multiformats/src/bases/base10.ts", "../../../node_modules/multiformats/src/bases/base16.ts", "../../../node_modules/multiformats/src/bases/base2.ts", "../../../node_modules/multiformats/src/bases/base256emoji.ts", "../../../node_modules/multiformats/src/bases/base8.ts", "../../../node_modules/multiformats/src/bases/identity.ts", "../../../node_modules/multiformats/src/hashes/sha2-browser.ts", "../../../node_modules/multiformats/src/basics.ts", "../../../node_modules/uint8arrays/src/util/bases.ts", "../../../node_modules/uint8arrays/src/from-string.ts", "../../../node_modules/protons-runtime/src/utils/pool.ts", "../../../node_modules/protons-runtime/src/utils/writer.ts", "../../../node_modules/protons-runtime/src/encode.ts", "../../../node_modules/protons-runtime/src/codec.ts", "../../../node_modules/protons-runtime/src/codecs/enum.ts", "../../../node_modules/protons-runtime/src/codecs/message.ts", "../../ipfs-unixfs/src/unixfs.ts", "../../ipfs-unixfs/src/index.ts", "../../../node_modules/@multiformats/murmur3/src/index.js", "../../../node_modules/hamt-sharding/src/bucket.ts", "../../../node_modules/uint8arrays/src/concat.ts", "../../../node_modules/hamt-sharding/src/consumable-buffer.ts", "../../../node_modules/hamt-sharding/src/consumable-hash.ts", "../../../node_modules/hamt-sharding/src/index.ts", "../src/utils/find-cid-in-shard.ts", "../../../node_modules/it-peekable/src/index.ts", "../../../node_modules/it-filter/src/index.ts", "../../../node_modules/it-map/src/index.ts", "../../../node_modules/p-defer/index.js", "../../../node_modules/it-parallel/src/index.ts", "../../../node_modules/it-pushable/src/fifo.ts", "../../../node_modules/it-pushable/src/index.ts", "../../../node_modules/race-signal/src/index.ts", "../../../node_modules/it-queueless-pushable/src/index.ts", "../../../node_modules/it-merge/src/index.ts", "../../../node_modules/it-pipe/src/index.ts", "../src/resolvers/unixfs-v1/content/directory.ts", "../../../node_modules/eventemitter3/index.mjs", "../../../node_modules/p-timeout/index.js", "../../../node_modules/p-queue/dist/lower-bound.js", "../../../node_modules/p-queue/dist/priority-queue.js", "../../../node_modules/p-queue/dist/index.js", "../src/resolvers/unixfs-v1/content/file.ts", "../src/resolvers/unixfs-v1/content/hamt-sharded-directory.ts", "../src/resolvers/unixfs-v1/index.ts", "../src/resolvers/index.ts"],
  "sourcesContent": ["/* jshint -W086: true */\n// +----------------------------------------------------------------------+\n// | murmurHash3js.js v3.0.1 // https://github.com/pid/murmurHash3js\n// | A javascript implementation of MurmurHash3's x86 hashing algorithms. |\n// |----------------------------------------------------------------------|\n// | Copyright (c) 2012-2015 Karan Lyons                                       |\n// | https://github.com/karanlyons/murmurHash3.js/blob/c1778f75792abef7bdd74bc85d2d4e1a3d25cfe9/murmurHash3.js |\n// | Freely distributable under the MIT license.                          |\n// +----------------------------------------------------------------------+\n\n;(function (root, undefined) {\n    'use strict';\n\n    // Create a local object that'll be exported or referenced globally.\n    var library = {\n        'version': '3.0.0',\n        'x86': {},\n        'x64': {},\n        'inputValidation': true\n    };\n\n    // PRIVATE FUNCTIONS\n    // -----------------\n\n    function _validBytes(bytes) {\n        // check the input is an array or a typed array\n        if (!Array.isArray(bytes) && !ArrayBuffer.isView(bytes)) {\n            return false;\n        }\n\n        // check all bytes are actually bytes\n        for (var i = 0; i < bytes.length; i++) {\n            if (!Number.isInteger(bytes[i]) || bytes[i] < 0 || bytes[i] > 255) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    function _x86Multiply(m, n) {\n        //\n        // Given two 32bit ints, returns the two multiplied together as a\n        // 32bit int.\n        //\n\n        return ((m & 0xffff) * n) + ((((m >>> 16) * n) & 0xffff) << 16);\n    }\n\n    function _x86Rotl(m, n) {\n        //\n        // Given a 32bit int and an int representing a number of bit positions,\n        // returns the 32bit int rotated left by that number of positions.\n        //\n\n        return (m << n) | (m >>> (32 - n));\n    }\n\n    function _x86Fmix(h) {\n        //\n        // Given a block, returns murmurHash3's final x86 mix of that block.\n        //\n\n        h ^= h >>> 16;\n        h = _x86Multiply(h, 0x85ebca6b);\n        h ^= h >>> 13;\n        h = _x86Multiply(h, 0xc2b2ae35);\n        h ^= h >>> 16;\n\n        return h;\n    }\n\n    function _x64Add(m, n) {\n        //\n        // Given two 64bit ints (as an array of two 32bit ints) returns the two\n        // added together as a 64bit int (as an array of two 32bit ints).\n        //\n\n        m = [m[0] >>> 16, m[0] & 0xffff, m[1] >>> 16, m[1] & 0xffff];\n        n = [n[0] >>> 16, n[0] & 0xffff, n[1] >>> 16, n[1] & 0xffff];\n        var o = [0, 0, 0, 0];\n\n        o[3] += m[3] + n[3];\n        o[2] += o[3] >>> 16;\n        o[3] &= 0xffff;\n\n        o[2] += m[2] + n[2];\n        o[1] += o[2] >>> 16;\n        o[2] &= 0xffff;\n\n        o[1] += m[1] + n[1];\n        o[0] += o[1] >>> 16;\n        o[1] &= 0xffff;\n\n        o[0] += m[0] + n[0];\n        o[0] &= 0xffff;\n\n        return [(o[0] << 16) | o[1], (o[2] << 16) | o[3]];\n    }\n\n    function _x64Multiply(m, n) {\n        //\n        // Given two 64bit ints (as an array of two 32bit ints) returns the two\n        // multiplied together as a 64bit int (as an array of two 32bit ints).\n        //\n\n        m = [m[0] >>> 16, m[0] & 0xffff, m[1] >>> 16, m[1] & 0xffff];\n        n = [n[0] >>> 16, n[0] & 0xffff, n[1] >>> 16, n[1] & 0xffff];\n        var o = [0, 0, 0, 0];\n\n        o[3] += m[3] * n[3];\n        o[2] += o[3] >>> 16;\n        o[3] &= 0xffff;\n\n        o[2] += m[2] * n[3];\n        o[1] += o[2] >>> 16;\n        o[2] &= 0xffff;\n\n        o[2] += m[3] * n[2];\n        o[1] += o[2] >>> 16;\n        o[2] &= 0xffff;\n\n        o[1] += m[1] * n[3];\n        o[0] += o[1] >>> 16;\n        o[1] &= 0xffff;\n\n        o[1] += m[2] * n[2];\n        o[0] += o[1] >>> 16;\n        o[1] &= 0xffff;\n\n        o[1] += m[3] * n[1];\n        o[0] += o[1] >>> 16;\n        o[1] &= 0xffff;\n\n        o[0] += (m[0] * n[3]) + (m[1] * n[2]) + (m[2] * n[1]) + (m[3] * n[0]);\n        o[0] &= 0xffff;\n\n        return [(o[0] << 16) | o[1], (o[2] << 16) | o[3]];\n    }\n\n    function _x64Rotl(m, n) {\n        //\n        // Given a 64bit int (as an array of two 32bit ints) and an int\n        // representing a number of bit positions, returns the 64bit int (as an\n        // array of two 32bit ints) rotated left by that number of positions.\n        //\n\n        n %= 64;\n\n        if (n === 32) {\n            return [m[1], m[0]];\n        } else if (n < 32) {\n            return [(m[0] << n) | (m[1] >>> (32 - n)), (m[1] << n) | (m[0] >>> (32 - n))];\n        } else {\n            n -= 32;\n            return [(m[1] << n) | (m[0] >>> (32 - n)), (m[0] << n) | (m[1] >>> (32 - n))];\n        }\n    }\n\n    function _x64LeftShift(m, n) {\n        //\n        // Given a 64bit int (as an array of two 32bit ints) and an int\n        // representing a number of bit positions, returns the 64bit int (as an\n        // array of two 32bit ints) shifted left by that number of positions.\n        //\n\n        n %= 64;\n\n        if (n === 0) {\n            return m;\n        } else if (n < 32) {\n            return [(m[0] << n) | (m[1] >>> (32 - n)), m[1] << n];\n        } else {\n            return [m[1] << (n - 32), 0];\n        }\n    }\n\n    function _x64Xor(m, n) {\n        //\n        // Given two 64bit ints (as an array of two 32bit ints) returns the two\n        // xored together as a 64bit int (as an array of two 32bit ints).\n        //\n\n        return [m[0] ^ n[0], m[1] ^ n[1]];\n    }\n\n    function _x64Fmix(h) {\n        //\n        // Given a block, returns murmurHash3's final x64 mix of that block.\n        // (`[0, h[0] >>> 1]` is a 33 bit unsigned right shift. This is the\n        // only place where we need to right shift 64bit ints.)\n        //\n\n        h = _x64Xor(h, [0, h[0] >>> 1]);\n        h = _x64Multiply(h, [0xff51afd7, 0xed558ccd]);\n        h = _x64Xor(h, [0, h[0] >>> 1]);\n        h = _x64Multiply(h, [0xc4ceb9fe, 0x1a85ec53]);\n        h = _x64Xor(h, [0, h[0] >>> 1]);\n\n        return h;\n    }\n\n    // PUBLIC FUNCTIONS\n    // ----------------\n\n    library.x86.hash32 = function (bytes, seed) {\n        //\n        // Given a string and an optional seed as an int, returns a 32 bit hash\n        // using the x86 flavor of MurmurHash3, as an unsigned int.\n        //\n        if (library.inputValidation && !_validBytes(bytes)) {\n            return undefined;\n        }\n        seed = seed || 0;\n\n        var remainder = bytes.length % 4;\n        var blocks = bytes.length - remainder;\n\n        var h1 = seed;\n\n        var k1 = 0;\n\n        var c1 = 0xcc9e2d51;\n        var c2 = 0x1b873593;\n\n        for (var i = 0; i < blocks; i = i + 4) {\n            k1 = (bytes[i]) | (bytes[i + 1] << 8) | (bytes[i + 2] << 16) | (bytes[i + 3] << 24);\n\n            k1 = _x86Multiply(k1, c1);\n            k1 = _x86Rotl(k1, 15);\n            k1 = _x86Multiply(k1, c2);\n\n            h1 ^= k1;\n            h1 = _x86Rotl(h1, 13);\n            h1 = _x86Multiply(h1, 5) + 0xe6546b64;\n        }\n\n        k1 = 0;\n\n        switch (remainder) {\n            case 3:\n                k1 ^= bytes[i + 2] << 16;\n\n            case 2:\n                k1 ^= bytes[i + 1] << 8;\n\n            case 1:\n                k1 ^= bytes[i];\n                k1 = _x86Multiply(k1, c1);\n                k1 = _x86Rotl(k1, 15);\n                k1 = _x86Multiply(k1, c2);\n                h1 ^= k1;\n        }\n\n        h1 ^= bytes.length;\n        h1 = _x86Fmix(h1);\n\n        return h1 >>> 0;\n    };\n\n    library.x86.hash128 = function (bytes, seed) {\n        //\n        // Given a string and an optional seed as an int, returns a 128 bit\n        // hash using the x86 flavor of MurmurHash3, as an unsigned hex.\n        //\n        if (library.inputValidation && !_validBytes(bytes)) {\n            return undefined;\n        }\n\n        seed = seed || 0;\n        var remainder = bytes.length % 16;\n        var blocks = bytes.length - remainder;\n\n        var h1 = seed;\n        var h2 = seed;\n        var h3 = seed;\n        var h4 = seed;\n\n        var k1 = 0;\n        var k2 = 0;\n        var k3 = 0;\n        var k4 = 0;\n\n        var c1 = 0x239b961b;\n        var c2 = 0xab0e9789;\n        var c3 = 0x38b34ae5;\n        var c4 = 0xa1e38b93;\n\n        for (var i = 0; i < blocks; i = i + 16) {\n            k1 = (bytes[i]) | (bytes[i + 1] << 8) | (bytes[i + 2] << 16) | (bytes[i + 3] << 24);\n            k2 = (bytes[i + 4]) | (bytes[i + 5] << 8) | (bytes[i + 6] << 16) | (bytes[i + 7] << 24);\n            k3 = (bytes[i + 8]) | (bytes[i + 9] << 8) | (bytes[i + 10] << 16) | (bytes[i + 11] << 24);\n            k4 = (bytes[i + 12]) | (bytes[i + 13] << 8) | (bytes[i + 14] << 16) | (bytes[i + 15] << 24);\n\n            k1 = _x86Multiply(k1, c1);\n            k1 = _x86Rotl(k1, 15);\n            k1 = _x86Multiply(k1, c2);\n            h1 ^= k1;\n\n            h1 = _x86Rotl(h1, 19);\n            h1 += h2;\n            h1 = _x86Multiply(h1, 5) + 0x561ccd1b;\n\n            k2 = _x86Multiply(k2, c2);\n            k2 = _x86Rotl(k2, 16);\n            k2 = _x86Multiply(k2, c3);\n            h2 ^= k2;\n\n            h2 = _x86Rotl(h2, 17);\n            h2 += h3;\n            h2 = _x86Multiply(h2, 5) + 0x0bcaa747;\n\n            k3 = _x86Multiply(k3, c3);\n            k3 = _x86Rotl(k3, 17);\n            k3 = _x86Multiply(k3, c4);\n            h3 ^= k3;\n\n            h3 = _x86Rotl(h3, 15);\n            h3 += h4;\n            h3 = _x86Multiply(h3, 5) + 0x96cd1c35;\n\n            k4 = _x86Multiply(k4, c4);\n            k4 = _x86Rotl(k4, 18);\n            k4 = _x86Multiply(k4, c1);\n            h4 ^= k4;\n\n            h4 = _x86Rotl(h4, 13);\n            h4 += h1;\n            h4 = _x86Multiply(h4, 5) + 0x32ac3b17;\n        }\n\n        k1 = 0;\n        k2 = 0;\n        k3 = 0;\n        k4 = 0;\n\n        switch (remainder) {\n            case 15:\n                k4 ^= bytes[i + 14] << 16;\n\n            case 14:\n                k4 ^= bytes[i + 13] << 8;\n\n            case 13:\n                k4 ^= bytes[i + 12];\n                k4 = _x86Multiply(k4, c4);\n                k4 = _x86Rotl(k4, 18);\n                k4 = _x86Multiply(k4, c1);\n                h4 ^= k4;\n\n            case 12:\n                k3 ^= bytes[i + 11] << 24;\n\n            case 11:\n                k3 ^= bytes[i + 10] << 16;\n\n            case 10:\n                k3 ^= bytes[i + 9] << 8;\n\n            case 9:\n                k3 ^= bytes[i + 8];\n                k3 = _x86Multiply(k3, c3);\n                k3 = _x86Rotl(k3, 17);\n                k3 = _x86Multiply(k3, c4);\n                h3 ^= k3;\n\n            case 8:\n                k2 ^= bytes[i + 7] << 24;\n\n            case 7:\n                k2 ^= bytes[i + 6] << 16;\n\n            case 6:\n                k2 ^= bytes[i + 5] << 8;\n\n            case 5:\n                k2 ^= bytes[i + 4];\n                k2 = _x86Multiply(k2, c2);\n                k2 = _x86Rotl(k2, 16);\n                k2 = _x86Multiply(k2, c3);\n                h2 ^= k2;\n\n            case 4:\n                k1 ^= bytes[i + 3] << 24;\n\n            case 3:\n                k1 ^= bytes[i + 2] << 16;\n\n            case 2:\n                k1 ^= bytes[i + 1] << 8;\n\n            case 1:\n                k1 ^= bytes[i];\n                k1 = _x86Multiply(k1, c1);\n                k1 = _x86Rotl(k1, 15);\n                k1 = _x86Multiply(k1, c2);\n                h1 ^= k1;\n        }\n\n        h1 ^= bytes.length;\n        h2 ^= bytes.length;\n        h3 ^= bytes.length;\n        h4 ^= bytes.length;\n\n        h1 += h2;\n        h1 += h3;\n        h1 += h4;\n        h2 += h1;\n        h3 += h1;\n        h4 += h1;\n\n        h1 = _x86Fmix(h1);\n        h2 = _x86Fmix(h2);\n        h3 = _x86Fmix(h3);\n        h4 = _x86Fmix(h4);\n\n        h1 += h2;\n        h1 += h3;\n        h1 += h4;\n        h2 += h1;\n        h3 += h1;\n        h4 += h1;\n\n        return (\"00000000\" + (h1 >>> 0).toString(16)).slice(-8) + (\"00000000\" + (h2 >>> 0).toString(16)).slice(-8) + (\"00000000\" + (h3 >>> 0).toString(16)).slice(-8) + (\"00000000\" + (h4 >>> 0).toString(16)).slice(-8);\n    };\n\n    library.x64.hash128 = function (bytes, seed) {\n        //\n        // Given a string and an optional seed as an int, returns a 128 bit\n        // hash using the x64 flavor of MurmurHash3, as an unsigned hex.\n        //\n        if (library.inputValidation && !_validBytes(bytes)) {\n            return undefined;\n        }\n        seed = seed || 0;\n\n        var remainder = bytes.length % 16;\n        var blocks = bytes.length - remainder;\n\n        var h1 = [0, seed];\n        var h2 = [0, seed];\n\n        var k1 = [0, 0];\n        var k2 = [0, 0];\n\n        var c1 = [0x87c37b91, 0x114253d5];\n        var c2 = [0x4cf5ad43, 0x2745937f];\n\n        for (var i = 0; i < blocks; i = i + 16) {\n            k1 = [(bytes[i + 4]) | (bytes[i + 5] << 8) | (bytes[i + 6] << 16) | (bytes[i + 7] << 24), (bytes[i]) |\n                (bytes[i + 1] << 8) | (bytes[i + 2] << 16) | (bytes[i + 3] << 24)];\n            k2 = [(bytes[i + 12]) | (bytes[i + 13] << 8) | (bytes[i + 14] << 16) | (bytes[i + 15] << 24), (bytes[i + 8]) |\n                (bytes[i + 9] << 8) | (bytes[i + 10] << 16) | (bytes[i + 11] << 24)];\n\n            k1 = _x64Multiply(k1, c1);\n            k1 = _x64Rotl(k1, 31);\n            k1 = _x64Multiply(k1, c2);\n            h1 = _x64Xor(h1, k1);\n\n            h1 = _x64Rotl(h1, 27);\n            h1 = _x64Add(h1, h2);\n            h1 = _x64Add(_x64Multiply(h1, [0, 5]), [0, 0x52dce729]);\n\n            k2 = _x64Multiply(k2, c2);\n            k2 = _x64Rotl(k2, 33);\n            k2 = _x64Multiply(k2, c1);\n            h2 = _x64Xor(h2, k2);\n\n            h2 = _x64Rotl(h2, 31);\n            h2 = _x64Add(h2, h1);\n            h2 = _x64Add(_x64Multiply(h2, [0, 5]), [0, 0x38495ab5]);\n        }\n\n        k1 = [0, 0];\n        k2 = [0, 0];\n\n        switch (remainder) {\n            case 15:\n                k2 = _x64Xor(k2, _x64LeftShift([0, bytes[i + 14]], 48));\n\n            case 14:\n                k2 = _x64Xor(k2, _x64LeftShift([0, bytes[i + 13]], 40));\n\n            case 13:\n                k2 = _x64Xor(k2, _x64LeftShift([0, bytes[i + 12]], 32));\n\n            case 12:\n                k2 = _x64Xor(k2, _x64LeftShift([0, bytes[i + 11]], 24));\n\n            case 11:\n                k2 = _x64Xor(k2, _x64LeftShift([0, bytes[i + 10]], 16));\n\n            case 10:\n                k2 = _x64Xor(k2, _x64LeftShift([0, bytes[i + 9]], 8));\n\n            case 9:\n                k2 = _x64Xor(k2, [0, bytes[i + 8]]);\n                k2 = _x64Multiply(k2, c2);\n                k2 = _x64Rotl(k2, 33);\n                k2 = _x64Multiply(k2, c1);\n                h2 = _x64Xor(h2, k2);\n\n            case 8:\n                k1 = _x64Xor(k1, _x64LeftShift([0, bytes[i + 7]], 56));\n\n            case 7:\n                k1 = _x64Xor(k1, _x64LeftShift([0, bytes[i + 6]], 48));\n\n            case 6:\n                k1 = _x64Xor(k1, _x64LeftShift([0, bytes[i + 5]], 40));\n\n            case 5:\n                k1 = _x64Xor(k1, _x64LeftShift([0, bytes[i + 4]], 32));\n\n            case 4:\n                k1 = _x64Xor(k1, _x64LeftShift([0, bytes[i + 3]], 24));\n\n            case 3:\n                k1 = _x64Xor(k1, _x64LeftShift([0, bytes[i + 2]], 16));\n\n            case 2:\n                k1 = _x64Xor(k1, _x64LeftShift([0, bytes[i + 1]], 8));\n\n            case 1:\n                k1 = _x64Xor(k1, [0, bytes[i]]);\n                k1 = _x64Multiply(k1, c1);\n                k1 = _x64Rotl(k1, 31);\n                k1 = _x64Multiply(k1, c2);\n                h1 = _x64Xor(h1, k1);\n        }\n\n        h1 = _x64Xor(h1, [0, bytes.length]);\n        h2 = _x64Xor(h2, [0, bytes.length]);\n\n        h1 = _x64Add(h1, h2);\n        h2 = _x64Add(h2, h1);\n\n        h1 = _x64Fmix(h1);\n        h2 = _x64Fmix(h2);\n\n        h1 = _x64Add(h1, h2);\n        h2 = _x64Add(h2, h1);\n\n        return (\"00000000\" + (h1[0] >>> 0).toString(16)).slice(-8) + (\"00000000\" + (h1[1] >>> 0).toString(16)).slice(-8) + (\"00000000\" + (h2[0] >>> 0).toString(16)).slice(-8) + (\"00000000\" + (h2[1] >>> 0).toString(16)).slice(-8);\n    };\n\n    // INITIALIZATION\n    // --------------\n\n    // Export murmurHash3 for CommonJS, either as an AMD module or just as part\n    // of the global object.\n    if (typeof exports !== 'undefined') {\n\n        if (typeof module !== 'undefined' && module.exports) {\n            exports = module.exports = library;\n        }\n\n        exports.murmurHash3 = library;\n\n    } else if (typeof define === 'function' && define.amd) {\n\n        define([], function () {\n            return library;\n        });\n    } else {\n\n        // Use murmurHash3.noConflict to restore `murmurHash3` back to its\n        // original value. Returns a reference to the library object, to allow\n        // it to be used under a different name.\n        library._murmurHash3 = root.murmurHash3;\n\n        library.noConflict = function () {\n            root.murmurHash3 = library._murmurHash3;\n            library._murmurHash3 = undefined;\n            library.noConflict = undefined;\n\n            return library;\n        };\n\n        root.murmurHash3 = library;\n    }\n})(this);\n", "module.exports = require('./lib/murmurHash3js');\n", "'use strict'\n\n// JS treats subjects of bitwise operators as SIGNED 32 bit numbers,\n// which means the maximum amount of bits we can store inside each byte\n// is 7..\nconst BITS_PER_BYTE = 7\n\nmodule.exports = class SparseArray {\n  constructor () {\n    this._bitArrays = []\n    this._data = []\n    this._length = 0\n    this._changedLength = false\n    this._changedData = false\n  }\n\n  set (index, value) {\n    let pos = this._internalPositionFor(index, false)\n    if (value === undefined) {\n      // unsetting\n      if (pos !== -1) {\n        // remove item from bit array and array itself\n        this._unsetInternalPos(pos)\n        this._unsetBit(index)\n        this._changedLength = true\n        this._changedData = true\n      }\n    } else {\n      let needsSort = false\n      if (pos === -1) {\n        pos = this._data.length\n        this._setBit(index)\n        this._changedData = true\n      } else {\n        needsSort = true\n      }\n      this._setInternalPos(pos, index, value, needsSort)\n      this._changedLength = true\n    }\n  }\n\n  unset (index) {\n    this.set(index, undefined)\n  }\n\n  get (index) {\n    this._sortData()\n    const pos = this._internalPositionFor(index, true)\n    if (pos === -1) {\n      return undefined\n    }\n    return this._data[pos][1]\n  }\n\n  push (value) {\n    this.set(this.length, value)\n    return this.length\n  }\n\n  get length () {\n    this._sortData()\n    if (this._changedLength) {\n      const last = this._data[this._data.length - 1]\n      this._length = last ? last[0] + 1 : 0\n      this._changedLength = false\n    }\n    return this._length\n  }\n\n  forEach (iterator) {\n    let i = 0\n    while(i < this.length) {\n      iterator(this.get(i), i, this)\n      i++\n    }\n  }\n\n  map (iterator) {\n    let i = 0\n    let mapped = new Array(this.length)\n    while(i < this.length) {\n      mapped[i] = iterator(this.get(i), i, this)\n      i++\n    }\n    return mapped\n  }\n\n  reduce (reducer, initialValue) {\n    let i = 0\n    let acc = initialValue\n    while(i < this.length) {\n      const value = this.get(i)\n      acc = reducer(acc, value, i)\n      i++\n    }\n    return acc\n  }\n\n  find (finder) {\n    let i = 0, found, last\n    while ((i < this.length) && !found) {\n      last = this.get(i)\n      found = finder(last)\n      i++\n    }\n    return found ? last : undefined\n  }\n\n  _internalPositionFor (index, noCreate) {\n    const bytePos = this._bytePosFor(index, noCreate)\n    if (bytePos >= this._bitArrays.length) {\n      return -1\n    }\n    const byte = this._bitArrays[bytePos]\n    const bitPos = index - bytePos * BITS_PER_BYTE\n    const exists = (byte & (1 << bitPos)) > 0\n    if (!exists) {\n      return -1\n    }\n    const previousPopCount = this._bitArrays.slice(0, bytePos).reduce(popCountReduce, 0)\n\n    const mask = ~(0xffffffff << (bitPos + 1))\n    const bytePopCount = popCount(byte & mask)\n    const arrayPos = previousPopCount + bytePopCount - 1\n    return arrayPos\n  }\n\n  _bytePosFor (index, noCreate) {\n    const bytePos = Math.floor(index / BITS_PER_BYTE)\n    const targetLength = bytePos + 1\n    while (!noCreate && this._bitArrays.length < targetLength) {\n      this._bitArrays.push(0)\n    }\n    return bytePos\n  }\n\n  _setBit (index) {\n    const bytePos = this._bytePosFor(index, false)\n    this._bitArrays[bytePos] |= (1 << (index - (bytePos * BITS_PER_BYTE)))\n  }\n\n  _unsetBit(index) {\n    const bytePos = this._bytePosFor(index, false)\n    this._bitArrays[bytePos] &= ~(1 << (index - (bytePos * BITS_PER_BYTE)))\n  }\n\n  _setInternalPos(pos, index, value, needsSort) {\n    const data =this._data\n    const elem = [index, value]\n    if (needsSort) {\n      this._sortData()\n      data[pos] = elem\n    } else {\n      // new element. just shove it into the array\n      // but be nice about where we shove it\n      // in order to make sorting it later easier\n      if (data.length) {\n        if (data[data.length - 1][0] >= index) {\n          data.push(elem)\n        } else if (data[0][0] <= index) {\n          data.unshift(elem)\n        } else {\n          const randomIndex = Math.round(data.length / 2)\n          this._data = data.slice(0, randomIndex).concat(elem).concat(data.slice(randomIndex))\n        }\n      } else {\n        this._data.push(elem)\n      }\n      this._changedData = true\n      this._changedLength = true\n    }\n  }\n\n  _unsetInternalPos (pos) {\n    this._data.splice(pos, 1)\n  }\n\n  _sortData () {\n    if (this._changedData) {\n      this._data.sort(sortInternal)\n    }\n\n    this._changedData = false\n  }\n\n  bitField () {\n    const bytes = []\n    let pendingBitsForResultingByte = 8\n    let pendingBitsForNewByte = 0\n    let resultingByte = 0\n    let newByte\n    const pending = this._bitArrays.slice()\n    while (pending.length || pendingBitsForNewByte) {\n      if (pendingBitsForNewByte === 0) {\n        newByte = pending.shift()\n        pendingBitsForNewByte = 7\n      }\n\n      const usingBits = Math.min(pendingBitsForNewByte, pendingBitsForResultingByte)\n      const mask = ~(0b11111111 << usingBits)\n      const masked = newByte & mask\n      resultingByte |= masked << (8 - pendingBitsForResultingByte)\n      newByte = newByte >>> usingBits\n      pendingBitsForNewByte -= usingBits\n      pendingBitsForResultingByte -= usingBits\n\n      if (!pendingBitsForResultingByte || (!pendingBitsForNewByte && !pending.length)) {\n        bytes.push(resultingByte)\n        resultingByte = 0\n        pendingBitsForResultingByte = 8\n      }\n    }\n\n    // remove trailing zeroes\n    for(var i = bytes.length - 1; i > 0; i--) {\n      const value = bytes[i]\n      if (value === 0) {\n        bytes.pop()\n      } else {\n        break\n      }\n    }\n\n    return bytes\n  }\n\n  compactArray () {\n    this._sortData()\n    return this._data.map(valueOnly)\n  }\n}\n\nfunction popCountReduce (count, byte) {\n  return count + popCount(byte)\n}\n\nfunction popCount(_v) {\n  let v = _v\n  v = v - ((v >> 1) & 0x55555555)                    // reuse input as temporary\n  v = (v & 0x33333333) + ((v >> 2) & 0x33333333)     // temp\n  return ((v + (v >> 4) & 0xF0F0F0F) * 0x1010101) >> 24\n}\n\nfunction sortInternal (a, b) {\n  return a[0] - b[0]\n}\n\nfunction valueOnly (elem) {\n  return elem[1]\n}", "'use strict';\n\nvar has = Object.prototype.hasOwnProperty\n  , prefix = '~';\n\n/**\n * Constructor to create a storage for our `EE` objects.\n * An `Events` instance is a plain object whose properties are event names.\n *\n * @constructor\n * @private\n */\nfunction Events() {}\n\n//\n// We try to not inherit from `Object.prototype`. In some engines creating an\n// instance in this way is faster than calling `Object.create(null)` directly.\n// If `Object.create(null)` is not supported we prefix the event names with a\n// character to make sure that the built-in object properties are not\n// overridden or used as an attack vector.\n//\nif (Object.create) {\n  Events.prototype = Object.create(null);\n\n  //\n  // This hack is needed because the `__proto__` property is still inherited in\n  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.\n  //\n  if (!new Events().__proto__) prefix = false;\n}\n\n/**\n * Representation of a single event listener.\n *\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} [once=false] Specify if the listener is a one-time listener.\n * @constructor\n * @private\n */\nfunction EE(fn, context, once) {\n  this.fn = fn;\n  this.context = context;\n  this.once = once || false;\n}\n\n/**\n * Add a listener for a given event.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} once Specify if the listener is a one-time listener.\n * @returns {EventEmitter}\n * @private\n */\nfunction addListener(emitter, event, fn, context, once) {\n  if (typeof fn !== 'function') {\n    throw new TypeError('The listener must be a function');\n  }\n\n  var listener = new EE(fn, context || emitter, once)\n    , evt = prefix ? prefix + event : event;\n\n  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;\n  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);\n  else emitter._events[evt] = [emitter._events[evt], listener];\n\n  return emitter;\n}\n\n/**\n * Clear event by name.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} evt The Event name.\n * @private\n */\nfunction clearEvent(emitter, evt) {\n  if (--emitter._eventsCount === 0) emitter._events = new Events();\n  else delete emitter._events[evt];\n}\n\n/**\n * Minimal `EventEmitter` interface that is molded against the Node.js\n * `EventEmitter` interface.\n *\n * @constructor\n * @public\n */\nfunction EventEmitter() {\n  this._events = new Events();\n  this._eventsCount = 0;\n}\n\n/**\n * Return an array listing the events for which the emitter has registered\n * listeners.\n *\n * @returns {Array}\n * @public\n */\nEventEmitter.prototype.eventNames = function eventNames() {\n  var names = []\n    , events\n    , name;\n\n  if (this._eventsCount === 0) return names;\n\n  for (name in (events = this._events)) {\n    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);\n  }\n\n  if (Object.getOwnPropertySymbols) {\n    return names.concat(Object.getOwnPropertySymbols(events));\n  }\n\n  return names;\n};\n\n/**\n * Return the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Array} The registered listeners.\n * @public\n */\nEventEmitter.prototype.listeners = function listeners(event) {\n  var evt = prefix ? prefix + event : event\n    , handlers = this._events[evt];\n\n  if (!handlers) return [];\n  if (handlers.fn) return [handlers.fn];\n\n  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {\n    ee[i] = handlers[i].fn;\n  }\n\n  return ee;\n};\n\n/**\n * Return the number of listeners listening to a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Number} The number of listeners.\n * @public\n */\nEventEmitter.prototype.listenerCount = function listenerCount(event) {\n  var evt = prefix ? prefix + event : event\n    , listeners = this._events[evt];\n\n  if (!listeners) return 0;\n  if (listeners.fn) return 1;\n  return listeners.length;\n};\n\n/**\n * Calls each of the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Boolean} `true` if the event had listeners, else `false`.\n * @public\n */\nEventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return false;\n\n  var listeners = this._events[evt]\n    , len = arguments.length\n    , args\n    , i;\n\n  if (listeners.fn) {\n    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);\n\n    switch (len) {\n      case 1: return listeners.fn.call(listeners.context), true;\n      case 2: return listeners.fn.call(listeners.context, a1), true;\n      case 3: return listeners.fn.call(listeners.context, a1, a2), true;\n      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;\n      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n    }\n\n    for (i = 1, args = new Array(len -1); i < len; i++) {\n      args[i - 1] = arguments[i];\n    }\n\n    listeners.fn.apply(listeners.context, args);\n  } else {\n    var length = listeners.length\n      , j;\n\n    for (i = 0; i < length; i++) {\n      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);\n\n      switch (len) {\n        case 1: listeners[i].fn.call(listeners[i].context); break;\n        case 2: listeners[i].fn.call(listeners[i].context, a1); break;\n        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;\n        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;\n        default:\n          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {\n            args[j - 1] = arguments[j];\n          }\n\n          listeners[i].fn.apply(listeners[i].context, args);\n      }\n    }\n  }\n\n  return true;\n};\n\n/**\n * Add a listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.on = function on(event, fn, context) {\n  return addListener(this, event, fn, context, false);\n};\n\n/**\n * Add a one-time listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.once = function once(event, fn, context) {\n  return addListener(this, event, fn, context, true);\n};\n\n/**\n * Remove the listeners of a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn Only remove the listeners that match this function.\n * @param {*} context Only remove the listeners that have this context.\n * @param {Boolean} once Only remove one-time listeners.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return this;\n  if (!fn) {\n    clearEvent(this, evt);\n    return this;\n  }\n\n  var listeners = this._events[evt];\n\n  if (listeners.fn) {\n    if (\n      listeners.fn === fn &&\n      (!once || listeners.once) &&\n      (!context || listeners.context === context)\n    ) {\n      clearEvent(this, evt);\n    }\n  } else {\n    for (var i = 0, events = [], length = listeners.length; i < length; i++) {\n      if (\n        listeners[i].fn !== fn ||\n        (once && !listeners[i].once) ||\n        (context && listeners[i].context !== context)\n      ) {\n        events.push(listeners[i]);\n      }\n    }\n\n    //\n    // Reset the array, or remove it completely if we have no more listeners.\n    //\n    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;\n    else clearEvent(this, evt);\n  }\n\n  return this;\n};\n\n/**\n * Remove all listeners, or those of the specified event.\n *\n * @param {(String|Symbol)} [event] The event name.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n  var evt;\n\n  if (event) {\n    evt = prefix ? prefix + event : event;\n    if (this._events[evt]) clearEvent(this, evt);\n  } else {\n    this._events = new Events();\n    this._eventsCount = 0;\n  }\n\n  return this;\n};\n\n//\n// Alias methods names because people roll like that.\n//\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\nEventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n//\n// Expose the prefix.\n//\nEventEmitter.prefixed = prefix;\n\n//\n// Allow `EventEmitter` to be imported as module namespace.\n//\nEventEmitter.EventEmitter = EventEmitter;\n\n//\n// Expose the module.\n//\nif ('undefined' !== typeof module) {\n  module.exports = EventEmitter;\n}\n", "/**\n * @packageDocumentation\n *\n * The UnixFS Exporter provides a means to read DAGs from a blockstore given a CID.\n *\n * @example\n *\n * ```TypeScript\n * // import a file and export it again\n * import { importer } from 'ipfs-unixfs-importer'\n * import { exporter } from 'ipfs-unixfs-exporter'\n * import { MemoryBlockstore } from 'blockstore-core/memory'\n *\n * // Should contain the blocks we are trying to export\n * const blockstore = new MemoryBlockstore()\n * const files = []\n *\n * for await (const file of importer([{\n *   path: '/foo/bar.txt',\n *   content: new Uint8Array([0, 1, 2, 3])\n * }], blockstore)) {\n *   files.push(file)\n * }\n *\n * console.info(files[0].cid) // Qmbaz\n *\n * const entry = await exporter(files[0].cid, blockstore)\n *\n * if (entry.type !== 'file') {\n *   throw new Error('Unexpected entry type')\n * }\n *\n * console.info(entry.cid) // Qmqux\n * console.info(entry.path) // Qmbaz/foo/bar.txt\n * console.info(entry.name) // bar.txt\n * console.info(entry.unixfs.fileSize()) // 4\n *\n * // stream content from unixfs node\n * const size = entry.unixfs.fileSize()\n * const bytes = new Uint8Array(Number(size))\n * let offset = 0\n *\n * for await (const buf of entry.content()) {\n *   bytes.set(buf, offset)\n *   offset += buf.byteLength\n * }\n *\n * console.info(bytes) // 0, 1, 2, 3\n * ```\n */\n\nimport last from 'it-last'\nimport { CID } from 'multiformats/cid'\nimport { BadPathError, NotFoundError } from './errors.js'\nimport resolve from './resolvers/index.js'\nimport type { PBNode } from '@ipld/dag-pb'\nimport type { Bucket } from 'hamt-sharding'\nimport type { Blockstore } from 'interface-blockstore'\nimport type { UnixFS } from 'ipfs-unixfs'\nimport type { ProgressOptions, ProgressEvent } from 'progress-events'\n\nexport * from './errors.js'\n\nexport interface ExportProgress {\n  /**\n   * How many bytes of the file have been read\n   */\n  bytesRead: bigint\n\n  /**\n   * How many bytes of the file will be read - n.b. this may be\n   * smaller than `fileSize` if `offset`/`length` have been\n   * specified\n   */\n  totalBytes: bigint\n\n  /**\n   * The size of the file being read - n.b. this may be\n   * larger than `total` if `offset`/`length` has been\n   * specified\n   */\n  fileSize: bigint\n}\n\nexport interface ExportWalk {\n  cid: CID\n}\n\n/**\n * Progress events emitted by the exporter\n */\nexport type ExporterProgressEvents =\n  ProgressEvent<'unixfs:exporter:progress:unixfs:file', ExportProgress> |\n  ProgressEvent<'unixfs:exporter:progress:unixfs:raw', ExportProgress> |\n  ProgressEvent<'unixfs:exporter:progress:raw', ExportProgress> |\n  ProgressEvent<'unixfs:exporter:progress:identity', ExportProgress> |\n  ProgressEvent<'unixfs:exporter:walk:file', ExportWalk> |\n  ProgressEvent<'unixfs:exporter:walk:directory', ExportWalk> |\n  ProgressEvent<'unixfs:exporter:walk:hamt-sharded-directory', ExportWalk> |\n  ProgressEvent<'unixfs:exporter:walk:raw', ExportWalk>\n\nexport interface ExporterOptions extends ProgressOptions<ExporterProgressEvents> {\n  /**\n   * An optional offset to start reading at.\n   *\n   * If the CID resolves to a file this will be a byte offset within that file,\n   * otherwise if it's a directory it will be a directory entry offset within\n   * the directory listing. (default: undefined)\n   */\n  offset?: number\n\n  /**\n   * An optional length to read.\n   *\n   * If the CID resolves to a file this will be the number of bytes read from\n   * the file, otherwise if it's a directory it will be the number of directory\n   * entries read from the directory listing. (default: undefined)\n   */\n  length?: number\n\n  /**\n   * This signal can be used to abort any long-lived operations such as fetching\n   * blocks from the network. (default: undefined)\n   */\n  signal?: AbortSignal\n\n  /**\n   * When a DAG layer is encountered, all child nodes are loaded in parallel but\n   * processed as they arrive. This allows us to load sibling nodes in advance\n   * of yielding their bytes. Pass a value here to control the number of blocks\n   * loaded in parallel. If a strict depth-first traversal is required, this\n   * value should be set to `1`, otherwise the traversal order will tend to\n   * resemble a breadth-first fan-out and yield a have stable ordering.\n   * (default: undefined)\n   */\n  blockReadConcurrency?: number\n}\n\nexport interface Exportable<T> {\n  /**\n   * A disambiguator to allow TypeScript to work out the type of the entry.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * if (entry.type === 'file') {\n   *   // access UnixFSFile properties safely\n   * }\n   *\n   * if (entry.type === 'directory') {\n   *   // access UnixFSDirectory properties safely\n   * }\n   * ```\n   */\n  type: 'file' | 'directory' | 'object' | 'raw' | 'identity'\n\n  /**\n   * The name of the entry\n   */\n  name: string\n\n  /**\n   * The path of the entry within the DAG in which it was encountered\n   */\n  path: string\n\n  /**\n   * The CID of the entry\n   */\n  cid: CID\n\n  /**\n   * How far down the DAG the entry is\n   */\n  depth: number\n\n  /**\n   * The size of the entry\n   */\n  size: bigint\n\n  /**\n   * @example File content\n   *\n   * When `entry` is a file or a `raw` node, `offset` and/or `length` arguments can be passed to `entry.content()` to return slices of data:\n   *\n   * ```TypeScript\n   * const length = 5\n   * const data = new Uint8Array(length)\n   * let offset = 0\n   *\n   * for await (const chunk of entry.content({\n   *   offset: 0,\n   *   length\n   * })) {\n   *   data.set(chunk, offset)\n   *   offset += chunk.length\n   * }\n   *\n   * // `data` contains the first 5 bytes of the file\n   * return data\n   * ```\n   *\n   * @example Directory content\n   *\n   * If `entry` is a directory, passing `offset` and/or `length` to `entry.content()` will limit the number of files returned from the directory.\n   *\n   * ```TypeScript\n   * const entries = []\n   *\n   * for await (const entry of dir.content({\n   *   offset: 0,\n   *   length: 5\n   * })) {\n   *   entries.push(entry)\n   * }\n   *\n   * // `entries` contains the first 5 files/directories in the directory\n   * ```\n   */\n  content(options?: ExporterOptions): AsyncGenerator<T, void, unknown>\n}\n\n/**\n * If the entry is a file, `entry.content()` returns an async iterator that yields one or more Uint8Arrays containing the file content:\n *\n * ```TypeScript\n * if (entry.type === 'file') {\n *   for await (const chunk of entry.content()) {\n *     // chunk is a Buffer\n *   }\n * }\n * ```\n */\nexport interface UnixFSFile extends Exportable<Uint8Array> {\n  type: 'file'\n  unixfs: UnixFS\n  node: PBNode\n}\n\n/**\n * If the entry is a directory, `entry.content()` returns further `entry` objects:\n *\n * ```TypeScript\n * if (entry.type === 'directory') {\n *   for await (const entry of dir.content()) {\n *     console.info(entry.name)\n *   }\n * }\n * ```\n */\nexport interface UnixFSDirectory extends Exportable<UnixFSEntry> {\n  type: 'directory'\n  unixfs: UnixFS\n  node: PBNode\n}\n\n/**\n * Entries with a `dag-cbor` or `dag-json` codec {@link CID} return JavaScript object entries\n */\nexport interface ObjectNode extends Exportable<any> {\n  type: 'object'\n  node: Uint8Array\n}\n\n/**\n * Entries with a `raw` codec {@link CID} return raw entries.\n *\n * `entry.content()` returns an async iterator that yields a buffer containing the node content:\n *\n * ```TypeScript\n * for await (const chunk of entry.content()) {\n *   // chunk is a Buffer\n * }\n * ```\n *\n * Unless you an options object containing `offset` and `length` keys as an argument to `entry.content()`, `chunk` will be equal to `entry.node`.\n */\nexport interface RawNode extends Exportable<Uint8Array> {\n  type: 'raw'\n  node: Uint8Array\n}\n\n/**\n * Entries with a `identity` codec {@link CID} return identity entries.\n *\n * These are entries where the data payload is stored in the CID itself,\n * otherwise they are identical to {@link RawNode}s.\n */\nexport interface IdentityNode extends Exportable<Uint8Array> {\n  type: 'identity'\n  node: Uint8Array\n}\n\n/**\n * A UnixFSEntry is a representation of the types of node that can be\n * encountered in a DAG.\n */\nexport type UnixFSEntry = UnixFSFile | UnixFSDirectory | ObjectNode | RawNode | IdentityNode\n\nexport interface NextResult {\n  cid: CID\n  name: string\n  path: string\n  toResolve: string[]\n}\n\nexport interface ResolveResult {\n  entry: UnixFSEntry\n  next?: NextResult\n}\n\nexport interface Resolve { (cid: CID, name: string, path: string, toResolve: string[], depth: number, blockstore: ReadableStorage, options: ExporterOptions): Promise<ResolveResult> }\nexport interface Resolver { (cid: CID, name: string, path: string, toResolve: string[], resolve: Resolve, depth: number, blockstore: ReadableStorage, options: ExporterOptions): Promise<ResolveResult> }\n\nexport type UnixfsV1FileContent = AsyncIterable<Uint8Array> | Iterable<Uint8Array>\nexport type UnixfsV1DirectoryContent = AsyncIterable<UnixFSEntry> | Iterable<UnixFSEntry>\nexport type UnixfsV1Content = UnixfsV1FileContent | UnixfsV1DirectoryContent\nexport interface UnixfsV1Resolver { (cid: CID, node: PBNode, unixfs: UnixFS, path: string, resolve: Resolve, depth: number, blockstore: ReadableStorage): (options: ExporterOptions) => UnixfsV1Content }\n\nexport interface ShardTraversalContext {\n  hamtDepth: number\n  rootBucket: Bucket<boolean>\n  lastBucket: Bucket<boolean>\n}\n\n/**\n * A subset of the {@link Blockstore} interface that just contains the get\n * method.\n */\nexport type ReadableStorage = Pick<Blockstore, 'get'>\n\nconst toPathComponents = (path: string = ''): string[] => {\n  // split on / unless escaped with \\\n  return (path\n    .trim()\n    .match(/([^\\\\^/]|\\\\\\/)+/g) ?? [])\n    .filter(Boolean)\n}\n\nconst cidAndRest = (path: string | Uint8Array | CID): { cid: CID, toResolve: string[] } => {\n  if (path instanceof Uint8Array) {\n    return {\n      cid: CID.decode(path),\n      toResolve: []\n    }\n  }\n\n  const cid = CID.asCID(path)\n  if (cid != null) {\n    return {\n      cid,\n      toResolve: []\n    }\n  }\n\n  if (typeof path === 'string') {\n    if (path.indexOf('/ipfs/') === 0) {\n      path = path.substring(6)\n    }\n\n    const output = toPathComponents(path)\n\n    return {\n      cid: CID.parse(output[0]),\n      toResolve: output.slice(1)\n    }\n  }\n\n  throw new BadPathError(`Unknown path type ${path}`)\n}\n\n/**\n * Returns an async iterator that yields entries for all segments in a path\n *\n * @example\n *\n * ```TypeScript\n * import { walkPath } from 'ipfs-unixfs-exporter'\n *\n * const entries = []\n *\n * for await (const entry of walkPath('Qmfoo/foo/bar/baz.txt', blockstore)) {\n *   entries.push(entry)\n * }\n *\n * // entries contains 4x `entry` objects\n * ```\n */\nexport async function * walkPath (path: string | CID, blockstore: ReadableStorage, options: ExporterOptions = {}): AsyncGenerator<UnixFSEntry, void, any> {\n  let {\n    cid,\n    toResolve\n  } = cidAndRest(path)\n  let name = cid.toString()\n  let entryPath = name\n  const startingDepth = toResolve.length\n\n  while (true) {\n    const result = await resolve(cid, name, entryPath, toResolve, startingDepth, blockstore, options)\n\n    if (result.entry == null && result.next == null) {\n      throw new NotFoundError(`Could not resolve ${path}`)\n    }\n\n    if (result.entry != null) {\n      yield result.entry\n    }\n\n    if (result.next == null) {\n      return\n    }\n\n    // resolve further parts\n    toResolve = result.next.toResolve\n    cid = result.next.cid\n    name = result.next.name\n    entryPath = result.next.path\n  }\n}\n\n/**\n * Uses the given blockstore instance to fetch an IPFS node by a CID or path.\n *\n * Returns a {@link Promise} which resolves to a {@link UnixFSEntry}.\n *\n * @example\n *\n * ```typescript\n * import { exporter } from 'ipfs-unixfs-exporter'\n * import { CID } from 'multiformats/cid'\n *\n * const cid = CID.parse('QmFoo')\n *\n * const entry = await exporter(cid, blockstore, {\n *   signal: AbortSignal.timeout(50000)\n * })\n *\n * if (entry.type === 'file') {\n *   for await (const chunk of entry.content()) {\n *     // chunk is a Uint8Array\n *   }\n * }\n * ```\n */\nexport async function exporter (path: string | CID, blockstore: ReadableStorage, options: ExporterOptions = {}): Promise<UnixFSEntry> {\n  const result = await last(walkPath(path, blockstore, options))\n\n  if (result == null) {\n    throw new NotFoundError(`Could not resolve ${path}`)\n  }\n\n  return result\n}\n\n/**\n * Returns an async iterator that yields all entries beneath a given CID or IPFS\n * path, as well as the containing directory.\n *\n * @example\n *\n * ```typescript\n * import { recursive } from 'ipfs-unixfs-exporter'\n *\n * const entries = []\n *\n * for await (const child of recursive('Qmfoo/foo/bar', blockstore)) {\n *   entries.push(entry)\n * }\n *\n * // entries contains all children of the `Qmfoo/foo/bar` directory and it's children\n * ```\n */\nexport async function * recursive (path: string | CID, blockstore: ReadableStorage, options: ExporterOptions = {}): AsyncGenerator<UnixFSEntry, void, any> {\n  const node = await exporter(path, blockstore, options)\n\n  if (node == null) {\n    return\n  }\n\n  yield node\n\n  if (node.type === 'directory') {\n    for await (const child of recurse(node, options)) {\n      yield child\n    }\n  }\n\n  async function * recurse (node: UnixFSDirectory, options: ExporterOptions): AsyncGenerator<UnixFSEntry, void, any> {\n    for await (const file of node.content(options)) {\n      yield file\n\n      if (file instanceof Uint8Array) {\n        continue\n      }\n\n      if (file.type === 'directory') {\n        yield * recurse(file, options)\n      }\n    }\n  }\n}\n", "/**\n * @packageDocumentation\n *\n * Return the last value from an (async)iterable.\n *\n * @example\n *\n * ```javascript\n * import last from 'it-last'\n *\n * // This can also be an iterator, generator, etc\n * const values = [0, 1, 2, 3, 4]\n *\n * const res = last(values)\n *\n * console.info(res) // 4\n * ```\n *\n * Async sources must be awaited:\n *\n * ```javascript\n * import last from 'it-last'\n *\n * const values = async function * () {\n *   yield * [0, 1, 2, 3, 4]\n * }\n *\n * const res = await last(values())\n *\n * console.info(res) // 4\n * ```\n */\n\nfunction isAsyncIterable <T> (thing: any): thing is AsyncIterable<T> {\n  return thing[Symbol.asyncIterator] != null\n}\n\n/**\n * Returns the last item of an (async) iterable, unless empty, in which case\n * return `undefined`\n */\nfunction last <T> (source: Iterable<T>): T | undefined\nfunction last <T> (source: Iterable<T> | AsyncIterable<T>): Promise<T | undefined>\nfunction last <T> (source: Iterable<T> | AsyncIterable<T>): Promise<T | undefined> | T | undefined {\n  if (isAsyncIterable(source)) {\n    return (async () => {\n      let res\n\n      for await (const entry of source) {\n        res = entry\n      }\n\n      return res\n    })()\n  }\n\n  let res\n\n  for (const entry of source) {\n    res = entry\n  }\n\n  return res\n}\n\nexport default last\n", "import { rfc4648 } from './base.js'\n\nexport const base32 = rfc4648({\n  prefix: 'b',\n  name: 'base32',\n  alphabet: 'abcdefghijklmnopqrstuvwxyz234567',\n  bitsPerChar: 5\n})\n\nexport const base32upper = rfc4648({\n  prefix: 'B',\n  name: 'base32upper',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567',\n  bitsPerChar: 5\n})\n\nexport const base32pad = rfc4648({\n  prefix: 'c',\n  name: 'base32pad',\n  alphabet: 'abcdefghijklmnopqrstuvwxyz234567=',\n  bitsPerChar: 5\n})\n\nexport const base32padupper = rfc4648({\n  prefix: 'C',\n  name: 'base32padupper',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=',\n  bitsPerChar: 5\n})\n\nexport const base32hex = rfc4648({\n  prefix: 'v',\n  name: 'base32hex',\n  alphabet: '0123456789abcdefghijklmnopqrstuv',\n  bitsPerChar: 5\n})\n\nexport const base32hexupper = rfc4648({\n  prefix: 'V',\n  name: 'base32hexupper',\n  alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV',\n  bitsPerChar: 5\n})\n\nexport const base32hexpad = rfc4648({\n  prefix: 't',\n  name: 'base32hexpad',\n  alphabet: '0123456789abcdefghijklmnopqrstuv=',\n  bitsPerChar: 5\n})\n\nexport const base32hexpadupper = rfc4648({\n  prefix: 'T',\n  name: 'base32hexpadupper',\n  alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV=',\n  bitsPerChar: 5\n})\n\nexport const base32z = rfc4648({\n  prefix: 'h',\n  name: 'base32z',\n  alphabet: 'ybndrfg8ejkmcpqxot1uwisza345h769',\n  bitsPerChar: 5\n})\n", "export const empty = new Uint8Array(0)\n\nexport function toHex (d: Uint8Array): string {\n  return d.reduce((hex, byte) => hex + byte.toString(16).padStart(2, '0'), '')\n}\n\nexport function fromHex (hex: string): Uint8Array {\n  const hexes = hex.match(/../g)\n  return hexes != null ? new Uint8Array(hexes.map(b => parseInt(b, 16))) : empty\n}\n\nexport function equals (aa: Uint8Array, bb: Uint8Array): boolean {\n  if (aa === bb) { return true }\n  if (aa.byteLength !== bb.byteLength) {\n    return false\n  }\n\n  for (let ii = 0; ii < aa.byteLength; ii++) {\n    if (aa[ii] !== bb[ii]) {\n      return false\n    }\n  }\n\n  return true\n}\n\nexport function coerce (o: ArrayBufferView | ArrayBuffer | Uint8Array): Uint8Array {\n  if (o instanceof Uint8Array && o.constructor.name === 'Uint8Array') { return o }\n  if (o instanceof ArrayBuffer) { return new Uint8Array(o) }\n  if (ArrayBuffer.isView(o)) {\n    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength)\n  }\n  throw new Error('Unknown type, must be binary type')\n}\n\nexport function isBinary (o: unknown): o is ArrayBuffer | ArrayBufferView {\n  return o instanceof ArrayBuffer || ArrayBuffer.isView(o)\n}\n\nexport function fromString (str: string): Uint8Array {\n  return new TextEncoder().encode(str)\n}\n\nexport function toString (b: Uint8Array): string {\n  return new TextDecoder().decode(b)\n}\n", "/* eslint-disable */\n// base-x encoding / decoding\n// Copyright (c) 2018 base-x contributors\n// Copyright (c) 2014-2018 The Bitcoin Core developers (base58.cpp)\n// Distributed under the MIT software license, see the accompanying\n// file LICENSE or http://www.opensource.org/licenses/mit-license.php.\n/**\n * @param {string} ALPHABET\n * @param {any} name\n */\nfunction base (ALPHABET, name) {\n  if (ALPHABET.length >= 255) { throw new TypeError('Alphabet too long') }\n  var BASE_MAP = new Uint8Array(256);\n  for (var j = 0; j < BASE_MAP.length; j++) {\n    BASE_MAP[j] = 255;\n  }\n  for (var i = 0; i < ALPHABET.length; i++) {\n    var x = ALPHABET.charAt(i);\n    var xc = x.charCodeAt(0);\n    if (BASE_MAP[xc] !== 255) { throw new TypeError(x + ' is ambiguous') }\n    BASE_MAP[xc] = i;\n  }\n  var BASE = ALPHABET.length;\n  var LEADER = ALPHABET.charAt(0);\n  var FACTOR = Math.log(BASE) / Math.log(256); // log(BASE) / log(256), rounded up\n  var iFACTOR = Math.log(256) / Math.log(BASE); // log(256) / log(BASE), rounded up\n  /**\n   * @param {any[] | Iterable<number>} source\n   */\n  function encode (source) {\n    // @ts-ignore\n    if (source instanceof Uint8Array) ; else if (ArrayBuffer.isView(source)) {\n      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);\n    } else if (Array.isArray(source)) {\n      source = Uint8Array.from(source);\n    }\n    if (!(source instanceof Uint8Array)) { throw new TypeError('Expected Uint8Array') }\n    if (source.length === 0) { return '' }\n        // Skip & count leading zeroes.\n    var zeroes = 0;\n    var length = 0;\n    var pbegin = 0;\n    var pend = source.length;\n    while (pbegin !== pend && source[pbegin] === 0) {\n      pbegin++;\n      zeroes++;\n    }\n        // Allocate enough space in big-endian base58 representation.\n    var size = ((pend - pbegin) * iFACTOR + 1) >>> 0;\n    var b58 = new Uint8Array(size);\n        // Process the bytes.\n    while (pbegin !== pend) {\n      var carry = source[pbegin];\n            // Apply \"b58 = b58 * 256 + ch\".\n      var i = 0;\n      for (var it1 = size - 1; (carry !== 0 || i < length) && (it1 !== -1); it1--, i++) {\n        carry += (256 * b58[it1]) >>> 0;\n        b58[it1] = (carry % BASE) >>> 0;\n        carry = (carry / BASE) >>> 0;\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i;\n      pbegin++;\n    }\n        // Skip leading zeroes in base58 result.\n    var it2 = size - length;\n    while (it2 !== size && b58[it2] === 0) {\n      it2++;\n    }\n        // Translate the result into a string.\n    var str = LEADER.repeat(zeroes);\n    for (; it2 < size; ++it2) { str += ALPHABET.charAt(b58[it2]); }\n    return str\n  }\n  /**\n   * @param {string | string[]} source\n   */\n  function decodeUnsafe (source) {\n    if (typeof source !== 'string') { throw new TypeError('Expected String') }\n    if (source.length === 0) { return new Uint8Array() }\n    var psz = 0;\n        // Skip leading spaces.\n    if (source[psz] === ' ') { return }\n        // Skip and count leading '1's.\n    var zeroes = 0;\n    var length = 0;\n    while (source[psz] === LEADER) {\n      zeroes++;\n      psz++;\n    }\n        // Allocate enough space in big-endian base256 representation.\n    var size = (((source.length - psz) * FACTOR) + 1) >>> 0; // log(58) / log(256), rounded up.\n    var b256 = new Uint8Array(size);\n        // Process the characters.\n    while (source[psz]) {\n            // Decode character\n      var carry = BASE_MAP[source.charCodeAt(psz)];\n            // Invalid character\n      if (carry === 255) { return }\n      var i = 0;\n      for (var it3 = size - 1; (carry !== 0 || i < length) && (it3 !== -1); it3--, i++) {\n        carry += (BASE * b256[it3]) >>> 0;\n        b256[it3] = (carry % 256) >>> 0;\n        carry = (carry / 256) >>> 0;\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i;\n      psz++;\n    }\n        // Skip trailing spaces.\n    if (source[psz] === ' ') { return }\n        // Skip leading zeroes in b256.\n    var it4 = size - length;\n    while (it4 !== size && b256[it4] === 0) {\n      it4++;\n    }\n    var vch = new Uint8Array(zeroes + (size - it4));\n    var j = zeroes;\n    while (it4 !== size) {\n      vch[j++] = b256[it4++];\n    }\n    return vch\n  }\n  /**\n   * @param {string | string[]} string\n   */\n  function decode (string) {\n    var buffer = decodeUnsafe(string);\n    if (buffer) { return buffer }\n    throw new Error(`Non-${name} character`)\n  }\n  return {\n    encode: encode,\n    decodeUnsafe: decodeUnsafe,\n    decode: decode\n  }\n}\nvar src = base;\n\nvar _brrp__multiformats_scope_baseX = src;\n\nexport default _brrp__multiformats_scope_baseX;\n", "import { coerce } from '../bytes.js'\nimport basex from '../vendor/base-x.js'\nimport type { BaseCodec, BaseDecoder, BaseEncoder, CombobaseDecoder, Multibase, MultibaseCodec, MultibaseDecoder, MultibaseEncoder, UnibaseDecoder } from './interface.js'\n\ninterface EncodeFn { (bytes: Uint8Array): string }\ninterface DecodeFn { (text: string): Uint8Array }\n\n/**\n * Class represents both BaseEncoder and MultibaseEncoder meaning it\n * can be used to encode to multibase or base encode without multibase\n * prefix.\n */\nclass Encoder<Base extends string, Prefix extends string> implements MultibaseEncoder<Prefix>, BaseEncoder {\n  readonly name: Base\n  readonly prefix: Prefix\n  readonly baseEncode: EncodeFn\n\n  constructor (name: Base, prefix: Prefix, baseEncode: EncodeFn) {\n    this.name = name\n    this.prefix = prefix\n    this.baseEncode = baseEncode\n  }\n\n  encode (bytes: Uint8Array): Multibase<Prefix> {\n    if (bytes instanceof Uint8Array) {\n      return `${this.prefix}${this.baseEncode(bytes)}`\n    } else {\n      throw Error('Unknown type, must be binary type')\n    }\n  }\n}\n\n/**\n * Class represents both BaseDecoder and MultibaseDecoder so it could be used\n * to decode multibases (with matching prefix) or just base decode strings\n * with corresponding base encoding.\n */\nclass Decoder<Base extends string, Prefix extends string> implements MultibaseDecoder<Prefix>, UnibaseDecoder<Prefix>, BaseDecoder {\n  readonly name: Base\n  readonly prefix: Prefix\n  readonly baseDecode: DecodeFn\n  private readonly prefixCodePoint: number\n\n  constructor (name: Base, prefix: Prefix, baseDecode: DecodeFn) {\n    this.name = name\n    this.prefix = prefix\n    const prefixCodePoint = prefix.codePointAt(0)\n    /* c8 ignore next 3 */\n    if (prefixCodePoint === undefined) {\n      throw new Error('Invalid prefix character')\n    }\n    this.prefixCodePoint = prefixCodePoint\n    this.baseDecode = baseDecode\n  }\n\n  decode (text: string): Uint8Array {\n    if (typeof text === 'string') {\n      if (text.codePointAt(0) !== this.prefixCodePoint) {\n        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`)\n      }\n      return this.baseDecode(text.slice(this.prefix.length))\n    } else {\n      throw Error('Can only multibase decode strings')\n    }\n  }\n\n  or<OtherPrefix extends string> (decoder: UnibaseDecoder<OtherPrefix> | ComposedDecoder<OtherPrefix>): ComposedDecoder<Prefix | OtherPrefix> {\n    return or(this, decoder)\n  }\n}\n\ntype Decoders<Prefix extends string> = Record<Prefix, UnibaseDecoder<Prefix>>\n\nclass ComposedDecoder<Prefix extends string> implements MultibaseDecoder<Prefix>, CombobaseDecoder<Prefix> {\n  readonly decoders: Decoders<Prefix>\n\n  constructor (decoders: Decoders<Prefix>) {\n    this.decoders = decoders\n  }\n\n  or <OtherPrefix extends string> (decoder: UnibaseDecoder<OtherPrefix> | ComposedDecoder<OtherPrefix>): ComposedDecoder<Prefix | OtherPrefix> {\n    return or(this, decoder)\n  }\n\n  decode (input: string): Uint8Array {\n    const prefix = input[0] as Prefix\n    const decoder = this.decoders[prefix]\n    if (decoder != null) {\n      return decoder.decode(input)\n    } else {\n      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)\n    }\n  }\n}\n\nexport function or <L extends string, R extends string> (left: UnibaseDecoder<L> | CombobaseDecoder<L>, right: UnibaseDecoder<R> | CombobaseDecoder<R>): ComposedDecoder<L | R> {\n  return new ComposedDecoder({\n    ...(left.decoders ?? { [(left as UnibaseDecoder<L>).prefix]: left }),\n    ...(right.decoders ?? { [(right as UnibaseDecoder<R>).prefix]: right })\n  } as Decoders<L | R>)\n}\n\nexport class Codec<Base extends string, Prefix extends string> implements MultibaseCodec<Prefix>, MultibaseEncoder<Prefix>, MultibaseDecoder<Prefix>, BaseCodec, BaseEncoder, BaseDecoder {\n  readonly name: Base\n  readonly prefix: Prefix\n  readonly baseEncode: EncodeFn\n  readonly baseDecode: DecodeFn\n  readonly encoder: Encoder<Base, Prefix>\n  readonly decoder: Decoder<Base, Prefix>\n\n  constructor (name: Base, prefix: Prefix, baseEncode: EncodeFn, baseDecode: DecodeFn) {\n    this.name = name\n    this.prefix = prefix\n    this.baseEncode = baseEncode\n    this.baseDecode = baseDecode\n    this.encoder = new Encoder(name, prefix, baseEncode)\n    this.decoder = new Decoder(name, prefix, baseDecode)\n  }\n\n  encode (input: Uint8Array): string {\n    return this.encoder.encode(input)\n  }\n\n  decode (input: string): Uint8Array {\n    return this.decoder.decode(input)\n  }\n}\n\nexport function from <Base extends string, Prefix extends string> ({ name, prefix, encode, decode }: { name: Base, prefix: Prefix, encode: EncodeFn, decode: DecodeFn }): Codec<Base, Prefix> {\n  return new Codec(name, prefix, encode, decode)\n}\n\nexport function baseX <Base extends string, Prefix extends string> ({ name, prefix, alphabet }: { name: Base, prefix: Prefix, alphabet: string }): Codec<Base, Prefix> {\n  const { encode, decode } = basex(alphabet, name)\n  return from({\n    prefix,\n    name,\n    encode,\n    decode: (text: string): Uint8Array => coerce(decode(text))\n  })\n}\n\nfunction decode (string: string, alphabetIdx: Record<string, number>, bitsPerChar: number, name: string): Uint8Array {\n  // Count the padding bytes:\n  let end = string.length\n  while (string[end - 1] === '=') {\n    --end\n  }\n\n  // Allocate the output:\n  const out = new Uint8Array((end * bitsPerChar / 8) | 0)\n\n  // Parse the data:\n  let bits = 0 // Number of bits currently in the buffer\n  let buffer = 0 // Bits waiting to be written out, MSB first\n  let written = 0 // Next byte to write\n  for (let i = 0; i < end; ++i) {\n    // Read one character from the string:\n    const value = alphabetIdx[string[i]]\n    if (value === undefined) {\n      throw new SyntaxError(`Non-${name} character`)\n    }\n\n    // Append the bits to the buffer:\n    buffer = (buffer << bitsPerChar) | value\n    bits += bitsPerChar\n\n    // Write out some bits if the buffer has a byte's worth:\n    if (bits >= 8) {\n      bits -= 8\n      out[written++] = 0xff & (buffer >> bits)\n    }\n  }\n\n  // Verify that we have received just enough bits:\n  if (bits >= bitsPerChar || (0xff & (buffer << (8 - bits))) !== 0) {\n    throw new SyntaxError('Unexpected end of data')\n  }\n\n  return out\n}\n\nfunction encode (data: Uint8Array, alphabet: string, bitsPerChar: number): string {\n  const pad = alphabet[alphabet.length - 1] === '='\n  const mask = (1 << bitsPerChar) - 1\n  let out = ''\n\n  let bits = 0 // Number of bits currently in the buffer\n  let buffer = 0 // Bits waiting to be written out, MSB first\n  for (let i = 0; i < data.length; ++i) {\n    // Slurp data into the buffer:\n    buffer = (buffer << 8) | data[i]\n    bits += 8\n\n    // Write out as much as we can:\n    while (bits > bitsPerChar) {\n      bits -= bitsPerChar\n      out += alphabet[mask & (buffer >> bits)]\n    }\n  }\n\n  // Partial character:\n  if (bits !== 0) {\n    out += alphabet[mask & (buffer << (bitsPerChar - bits))]\n  }\n\n  // Add padding characters until we hit a byte boundary:\n  if (pad) {\n    while (((out.length * bitsPerChar) & 7) !== 0) {\n      out += '='\n    }\n  }\n\n  return out\n}\n\nfunction createAlphabetIdx (alphabet: string): Record<string, number> {\n  // Build the character lookup table:\n  const alphabetIdx: Record<string, number> = {}\n  for (let i = 0; i < alphabet.length; ++i) {\n    alphabetIdx[alphabet[i]] = i\n  }\n  return alphabetIdx\n}\n\n/**\n * RFC4648 Factory\n */\nexport function rfc4648 <Base extends string, Prefix extends string> ({ name, prefix, bitsPerChar, alphabet }: { name: Base, prefix: Prefix, bitsPerChar: number, alphabet: string }): Codec<Base, Prefix> {\n  const alphabetIdx = createAlphabetIdx(alphabet)\n  return from({\n    prefix,\n    name,\n    encode (input: Uint8Array): string {\n      return encode(input, alphabet, bitsPerChar)\n    },\n    decode (input: string): Uint8Array {\n      return decode(input, alphabetIdx, bitsPerChar, name)\n    }\n  })\n}\n", "import { baseX } from './base.js'\n\nexport const base36 = baseX({\n  prefix: 'k',\n  name: 'base36',\n  alphabet: '0123456789abcdefghijklmnopqrstuvwxyz'\n})\n\nexport const base36upper = baseX({\n  prefix: 'K',\n  name: 'base36upper',\n  alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n})\n", "import { baseX } from './base.js'\n\nexport const base58btc = baseX({\n  name: 'base58btc',\n  prefix: 'z',\n  alphabet: '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'\n})\n\nexport const base58flickr = baseX({\n  name: 'base58flickr',\n  prefix: 'Z',\n  alphabet: '123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ'\n})\n", "/* eslint-disable */\nvar encode_1 = encode;\n\nvar MSB = 0x80\n  , REST = 0x7F\n  , MSBALL = ~REST\n  , INT = Math.pow(2, 31);\n\n/**\n * @param {number} num\n * @param {number[]} out\n * @param {number} offset\n */\nfunction encode(num, out, offset) {\n  out = out || [];\n  offset = offset || 0;\n  var oldOffset = offset;\n\n  while(num >= INT) {\n    out[offset++] = (num & 0xFF) | MSB;\n    num /= 128;\n  }\n  while(num & MSBALL) {\n    out[offset++] = (num & 0xFF) | MSB;\n    num >>>= 7;\n  }\n  out[offset] = num | 0;\n  \n  // @ts-ignore\n  encode.bytes = offset - oldOffset + 1;\n  \n  return out\n}\n\nvar decode = read;\n\nvar MSB$1 = 0x80\n  , REST$1 = 0x7F;\n\n/**\n * @param {string | any[]} buf\n * @param {number} offset\n */\nfunction read(buf, offset) {\n  var res    = 0\n    , offset = offset || 0\n    , shift  = 0\n    , counter = offset\n    , b\n    , l = buf.length;\n\n  do {\n    if (counter >= l) {\n      // @ts-ignore\n      read.bytes = 0;\n      throw new RangeError('Could not decode varint')\n    }\n    b = buf[counter++];\n    res += shift < 28\n      ? (b & REST$1) << shift\n      : (b & REST$1) * Math.pow(2, shift);\n    shift += 7;\n  } while (b >= MSB$1)\n\n  // @ts-ignore\n  read.bytes = counter - offset;\n\n  return res\n}\n\nvar N1 = Math.pow(2,  7);\nvar N2 = Math.pow(2, 14);\nvar N3 = Math.pow(2, 21);\nvar N4 = Math.pow(2, 28);\nvar N5 = Math.pow(2, 35);\nvar N6 = Math.pow(2, 42);\nvar N7 = Math.pow(2, 49);\nvar N8 = Math.pow(2, 56);\nvar N9 = Math.pow(2, 63);\n\nvar length = function (/** @type {number} */ value) {\n  return (\n    value < N1 ? 1\n  : value < N2 ? 2\n  : value < N3 ? 3\n  : value < N4 ? 4\n  : value < N5 ? 5\n  : value < N6 ? 6\n  : value < N7 ? 7\n  : value < N8 ? 8\n  : value < N9 ? 9\n  :              10\n  )\n};\n\nvar varint = {\n    encode: encode_1\n  , decode: decode\n  , encodingLength: length\n};\n\nvar _brrp_varint = varint;\n\nexport default _brrp_varint;\n", "import varint from './vendor/varint.js'\n\nexport function decode (data: Uint8Array, offset = 0): [number, number] {\n  const code = varint.decode(data, offset)\n  return [code, varint.decode.bytes]\n}\n\nexport function encodeTo (int: number, target: Uint8Array, offset = 0): Uint8Array {\n  varint.encode(int, target, offset)\n  return target\n}\n\nexport function encodingLength (int: number): number {\n  return varint.encodingLength(int)\n}\n", "import { coerce, equals as equalBytes } from '../bytes.js'\nimport * as varint from '../varint.js'\nimport type { MultihashDigest } from './interface.js'\n\n/**\n * Creates a multihash digest.\n */\nexport function create <Code extends number> (code: Code, digest: Uint8Array): Digest<Code, number> {\n  const size = digest.byteLength\n  const sizeOffset = varint.encodingLength(code)\n  const digestOffset = sizeOffset + varint.encodingLength(size)\n\n  const bytes = new Uint8Array(digestOffset + size)\n  varint.encodeTo(code, bytes, 0)\n  varint.encodeTo(size, bytes, sizeOffset)\n  bytes.set(digest, digestOffset)\n\n  return new Digest(code, size, digest, bytes)\n}\n\n/**\n * Turns bytes representation of multihash digest into an instance.\n */\nexport function decode (multihash: Uint8Array): MultihashDigest {\n  const bytes = coerce(multihash)\n  const [code, sizeOffset] = varint.decode(bytes)\n  const [size, digestOffset] = varint.decode(bytes.subarray(sizeOffset))\n  const digest = bytes.subarray(sizeOffset + digestOffset)\n\n  if (digest.byteLength !== size) {\n    throw new Error('Incorrect length')\n  }\n\n  return new Digest(code, size, digest, bytes)\n}\n\nexport function equals (a: MultihashDigest, b: unknown): b is MultihashDigest {\n  if (a === b) {\n    return true\n  } else {\n    const data = b as { code?: unknown, size?: unknown, bytes?: unknown }\n\n    return (\n      a.code === data.code &&\n      a.size === data.size &&\n      data.bytes instanceof Uint8Array &&\n      equalBytes(a.bytes, data.bytes)\n    )\n  }\n}\n\n/**\n * Represents a multihash digest which carries information about the\n * hashing algorithm and an actual hash digest.\n */\nexport class Digest<Code extends number, Size extends number> implements MultihashDigest {\n  readonly code: Code\n  readonly size: Size\n  readonly digest: Uint8Array\n  readonly bytes: Uint8Array\n\n  /**\n   * Creates a multihash digest.\n   */\n  constructor (code: Code, size: Size, digest: Uint8Array, bytes: Uint8Array) {\n    this.code = code\n    this.size = size\n    this.digest = digest\n    this.bytes = bytes\n  }\n}\n\n/**\n * Used to check that the passed multihash has the passed code\n */\nexport function hasCode <T extends number> (digest: MultihashDigest, code: T): digest is MultihashDigest<T> {\n  return digest.code === code\n}\n", "import { base32 } from './bases/base32.js'\nimport { base36 } from './bases/base36.js'\nimport { base58btc } from './bases/base58.js'\nimport { coerce } from './bytes.js'\nimport * as Digest from './hashes/digest.js'\nimport * as varint from './varint.js'\nimport type * as API from './link/interface.js'\n\n// This way TS will also expose all the types from module\nexport * from './link/interface.js'\n\nexport function format <T extends API.Link<unknown, number, number, API.Version>, Prefix extends string> (link: T, base?: API.MultibaseEncoder<Prefix>): API.ToString<T, Prefix> {\n  const { bytes, version } = link\n  switch (version) {\n    case 0:\n      return toStringV0(\n        bytes,\n        baseCache(link),\n        base as API.MultibaseEncoder<'z'> ?? base58btc.encoder\n      )\n    default:\n      return toStringV1(\n        bytes,\n        baseCache(link),\n        (base ?? base32.encoder) as API.MultibaseEncoder<Prefix>\n      )\n  }\n}\n\nexport function toJSON <Link extends API.UnknownLink> (link: Link): API.LinkJSON<Link> {\n  return {\n    '/': format(link)\n  }\n}\n\nexport function fromJSON <Link extends API.UnknownLink> (json: API.LinkJSON<Link>): CID<unknown, number, number, API.Version> {\n  return CID.parse(json['/'])\n}\n\nconst cache = new WeakMap<API.UnknownLink, Map<string, string>>()\n\nfunction baseCache (cid: API.UnknownLink): Map<string, string> {\n  const baseCache = cache.get(cid)\n  if (baseCache == null) {\n    const baseCache = new Map()\n    cache.set(cid, baseCache)\n    return baseCache\n  }\n  return baseCache\n}\n\nexport class CID<Data = unknown, Format extends number = number, Alg extends number = number, Version extends API.Version = API.Version> implements API.Link<Data, Format, Alg, Version> {\n  readonly code: Format\n  readonly version: Version\n  readonly multihash: API.MultihashDigest<Alg>\n  readonly bytes: Uint8Array\n  readonly '/': Uint8Array\n\n  /**\n   * @param version - Version of the CID\n   * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv\n   * @param multihash - (Multi)hash of the of the content.\n   */\n  constructor (version: Version, code: Format, multihash: API.MultihashDigest<Alg>, bytes: Uint8Array) {\n    this.code = code\n    this.version = version\n    this.multihash = multihash\n    this.bytes = bytes\n\n    // flag to serializers that this is a CID and\n    // should be treated specially\n    this['/'] = bytes\n  }\n\n  /**\n   * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`\n   * please either use `CID.asCID(cid)` or switch to new signalling mechanism\n   *\n   * @deprecated\n   */\n  get asCID (): this {\n    return this\n  }\n\n  // ArrayBufferView\n  get byteOffset (): number {\n    return this.bytes.byteOffset\n  }\n\n  // ArrayBufferView\n  get byteLength (): number {\n    return this.bytes.byteLength\n  }\n\n  toV0 (): CID<Data, API.DAG_PB, API.SHA_256, 0> {\n    switch (this.version) {\n      case 0: {\n        return this as CID<Data, API.DAG_PB, API.SHA_256, 0>\n      }\n      case 1: {\n        const { code, multihash } = this\n\n        if (code !== DAG_PB_CODE) {\n          throw new Error('Cannot convert a non dag-pb CID to CIDv0')\n        }\n\n        // sha2-256\n        if (multihash.code !== SHA_256_CODE) {\n          throw new Error('Cannot convert non sha2-256 multihash CID to CIDv0')\n        }\n\n        return (\n          CID.createV0(\n            multihash as API.MultihashDigest<API.SHA_256>\n          )\n        )\n      }\n      default: {\n        throw Error(\n          `Can not convert CID version ${this.version} to version 0. This is a bug please report`\n        )\n      }\n    }\n  }\n\n  toV1 (): CID<Data, Format, Alg, 1> {\n    switch (this.version) {\n      case 0: {\n        const { code, digest } = this.multihash\n        const multihash = Digest.create(code, digest)\n        return (\n          CID.createV1(this.code, multihash)\n        )\n      }\n      case 1: {\n        return this as CID<Data, Format, Alg, 1>\n      }\n      default: {\n        throw Error(\n          `Can not convert CID version ${this.version} to version 1. This is a bug please report`\n        )\n      }\n    }\n  }\n\n  equals (other: unknown): other is CID<Data, Format, Alg, Version> {\n    return CID.equals(this, other)\n  }\n\n  static equals <Data, Format extends number, Alg extends number, Version extends API.Version>(self: API.Link<Data, Format, Alg, Version>, other: unknown): other is CID {\n    const unknown = other as { code?: unknown, version?: unknown, multihash?: unknown }\n    return (\n      unknown != null &&\n      self.code === unknown.code &&\n      self.version === unknown.version &&\n      Digest.equals(self.multihash, unknown.multihash)\n    )\n  }\n\n  toString (base?: API.MultibaseEncoder<string>): string {\n    return format(this, base)\n  }\n\n  toJSON (): API.LinkJSON<this> {\n    return { '/': format(this) }\n  }\n\n  link (): this {\n    return this\n  }\n\n  readonly [Symbol.toStringTag] = 'CID';\n\n  // Legacy\n\n  [Symbol.for('nodejs.util.inspect.custom')] (): string {\n    return `CID(${this.toString()})`\n  }\n\n  /**\n   * Takes any input `value` and returns a `CID` instance if it was\n   * a `CID` otherwise returns `null`. If `value` is instanceof `CID`\n   * it will return value back. If `value` is not instance of this CID\n   * class, but is compatible CID it will return new instance of this\n   * `CID` class. Otherwise returns null.\n   *\n   * This allows two different incompatible versions of CID library to\n   * co-exist and interop as long as binary interface is compatible.\n   */\n  static asCID <Data, Format extends number, Alg extends number, Version extends API.Version, U>(input: API.Link<Data, Format, Alg, Version> | U): CID<Data, Format, Alg, Version> | null {\n    if (input == null) {\n      return null\n    }\n\n    const value = input as any\n    if (value instanceof CID) {\n      // If value is instance of CID then we're all set.\n      return value\n    } else if ((value['/'] != null && value['/'] === value.bytes) || value.asCID === value) {\n      // If value isn't instance of this CID class but `this.asCID === this` or\n      // `value['/'] === value.bytes` is true it is CID instance coming from a\n      // different implementation (diff version or duplicate). In that case we\n      // rebase it to this `CID` implementation so caller is guaranteed to get\n      // instance with expected API.\n      const { version, code, multihash, bytes } = value\n      return new CID(\n        version,\n        code,\n        multihash as API.MultihashDigest<Alg>,\n        bytes ?? encodeCID(version, code, multihash.bytes)\n      )\n    } else if (value[cidSymbol] === true) {\n      // If value is a CID from older implementation that used to be tagged via\n      // symbol we still rebase it to the this `CID` implementation by\n      // delegating that to a constructor.\n      const { version, multihash, code } = value\n      const digest = Digest.decode(multihash) as API.MultihashDigest<Alg>\n      return CID.create(version, code, digest)\n    } else {\n      // Otherwise value is not a CID (or an incompatible version of it) in\n      // which case we return `null`.\n      return null\n    }\n  }\n\n  /**\n   * @param version - Version of the CID\n   * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv\n   * @param digest - (Multi)hash of the of the content.\n   */\n  static create <Data, Format extends number, Alg extends number, Version extends API.Version>(version: Version, code: Format, digest: API.MultihashDigest<Alg>): CID<Data, Format, Alg, Version> {\n    if (typeof code !== 'number') {\n      throw new Error('String codecs are no longer supported')\n    }\n\n    if (!(digest.bytes instanceof Uint8Array)) {\n      throw new Error('Invalid digest')\n    }\n\n    switch (version) {\n      case 0: {\n        if (code !== DAG_PB_CODE) {\n          throw new Error(\n            `Version 0 CID must use dag-pb (code: ${DAG_PB_CODE}) block encoding`\n          )\n        } else {\n          return new CID(version, code, digest, digest.bytes)\n        }\n      }\n      case 1: {\n        const bytes = encodeCID(version, code, digest.bytes)\n        return new CID(version, code, digest, bytes)\n      }\n      default: {\n        throw new Error('Invalid version')\n      }\n    }\n  }\n\n  /**\n   * Simplified version of `create` for CIDv0.\n   */\n  static createV0 <T = unknown>(digest: API.MultihashDigest<typeof SHA_256_CODE>): CID<T, typeof DAG_PB_CODE, typeof SHA_256_CODE, 0> {\n    return CID.create(0, DAG_PB_CODE, digest)\n  }\n\n  /**\n   * Simplified version of `create` for CIDv1.\n   *\n   * @param code - Content encoding format code.\n   * @param digest - Multihash of the content.\n   */\n  static createV1 <Data, Code extends number, Alg extends number>(code: Code, digest: API.MultihashDigest<Alg>): CID<Data, Code, Alg, 1> {\n    return CID.create(1, code, digest)\n  }\n\n  /**\n   * Decoded a CID from its binary representation. The byte array must contain\n   * only the CID with no additional bytes.\n   *\n   * An error will be thrown if the bytes provided do not contain a valid\n   * binary representation of a CID.\n   */\n  static decode <Data, Code extends number, Alg extends number, Version extends API.Version>(bytes: API.ByteView<API.Link<Data, Code, Alg, Version>>): CID<Data, Code, Alg, Version> {\n    const [cid, remainder] = CID.decodeFirst(bytes)\n    if (remainder.length !== 0) {\n      throw new Error('Incorrect length')\n    }\n    return cid\n  }\n\n  /**\n   * Decoded a CID from its binary representation at the beginning of a byte\n   * array.\n   *\n   * Returns an array with the first element containing the CID and the second\n   * element containing the remainder of the original byte array. The remainder\n   * will be a zero-length byte array if the provided bytes only contained a\n   * binary CID representation.\n   */\n  static decodeFirst <T, C extends number, A extends number, V extends API.Version>(bytes: API.ByteView<API.Link<T, C, A, V>>): [CID<T, C, A, V>, Uint8Array] {\n    const specs = CID.inspectBytes(bytes)\n    const prefixSize = specs.size - specs.multihashSize\n    const multihashBytes = coerce(\n      bytes.subarray(prefixSize, prefixSize + specs.multihashSize)\n    )\n    if (multihashBytes.byteLength !== specs.multihashSize) {\n      throw new Error('Incorrect length')\n    }\n    const digestBytes = multihashBytes.subarray(\n      specs.multihashSize - specs.digestSize\n    )\n    const digest = new Digest.Digest(\n      specs.multihashCode,\n      specs.digestSize,\n      digestBytes,\n      multihashBytes\n    )\n    const cid =\n      specs.version === 0\n        ? CID.createV0(digest as API.MultihashDigest<API.SHA_256>)\n        : CID.createV1(specs.codec, digest)\n    return [cid as CID<T, C, A, V>, bytes.subarray(specs.size)]\n  }\n\n  /**\n   * Inspect the initial bytes of a CID to determine its properties.\n   *\n   * Involves decoding up to 4 varints. Typically this will require only 4 to 6\n   * bytes but for larger multicodec code values and larger multihash digest\n   * lengths these varints can be quite large. It is recommended that at least\n   * 10 bytes be made available in the `initialBytes` argument for a complete\n   * inspection.\n   */\n  static inspectBytes <T, C extends number, A extends number, V extends API.Version>(initialBytes: API.ByteView<API.Link<T, C, A, V>>): { version: V, codec: C, multihashCode: A, digestSize: number, multihashSize: number, size: number } {\n    let offset = 0\n    const next = (): number => {\n      const [i, length] = varint.decode(initialBytes.subarray(offset))\n      offset += length\n      return i\n    }\n\n    let version = next() as V\n    let codec = DAG_PB_CODE as C\n    if (version as number === 18) {\n      // CIDv0\n      version = 0 as V\n      offset = 0\n    } else {\n      codec = next() as C\n    }\n\n    if (version !== 0 && version !== 1) {\n      throw new RangeError(`Invalid CID version ${version}`)\n    }\n\n    const prefixSize = offset\n    const multihashCode = next() as A // multihash code\n    const digestSize = next() // multihash length\n    const size = offset + digestSize\n    const multihashSize = size - prefixSize\n\n    return { version, codec, multihashCode, digestSize, multihashSize, size }\n  }\n\n  /**\n   * Takes cid in a string representation and creates an instance. If `base`\n   * decoder is not provided will use a default from the configuration. It will\n   * throw an error if encoding of the CID is not compatible with supplied (or\n   * a default decoder).\n   */\n  static parse <Prefix extends string, Data, Code extends number, Alg extends number, Version extends API.Version>(source: API.ToString<API.Link<Data, Code, Alg, Version>, Prefix>, base?: API.MultibaseDecoder<Prefix>): CID<Data, Code, Alg, Version> {\n    const [prefix, bytes] = parseCIDtoBytes(source, base)\n\n    const cid = CID.decode(bytes)\n\n    if (cid.version === 0 && source[0] !== 'Q') {\n      throw Error('Version 0 CID string must not include multibase prefix')\n    }\n\n    // Cache string representation to avoid computing it on `this.toString()`\n    baseCache(cid).set(prefix, source)\n\n    return cid\n  }\n}\n\nfunction parseCIDtoBytes <Prefix extends string, Data, Code extends number, Alg extends number, Version extends API.Version> (source: API.ToString<API.Link<Data, Code, Alg, Version>, Prefix>, base?: API.MultibaseDecoder<Prefix>): [Prefix, API.ByteView<API.Link<Data, Code, Alg, Version>>] {\n  switch (source[0]) {\n    // CIDv0 is parsed differently\n    case 'Q': {\n      const decoder = base ?? base58btc\n      return [\n        base58btc.prefix as Prefix,\n        decoder.decode(`${base58btc.prefix}${source}`)\n      ]\n    }\n    case base58btc.prefix: {\n      const decoder = base ?? base58btc\n      return [base58btc.prefix as Prefix, decoder.decode(source)]\n    }\n    case base32.prefix: {\n      const decoder = base ?? base32\n      return [base32.prefix as Prefix, decoder.decode(source)]\n    }\n    case base36.prefix: {\n      const decoder = base ?? base36\n      return [base36.prefix as Prefix, decoder.decode(source)]\n    }\n    default: {\n      if (base == null) {\n        throw Error(\n          'To parse non base32, base36 or base58btc encoded CID multibase decoder must be provided'\n        )\n      }\n      return [source[0] as Prefix, base.decode(source)]\n    }\n  }\n}\n\nfunction toStringV0 (bytes: Uint8Array, cache: Map<string, string>, base: API.MultibaseEncoder<'z'>): string {\n  const { prefix } = base\n  if (prefix !== base58btc.prefix) {\n    throw Error(`Cannot string encode V0 in ${base.name} encoding`)\n  }\n\n  const cid = cache.get(prefix)\n  if (cid == null) {\n    const cid = base.encode(bytes).slice(1)\n    cache.set(prefix, cid)\n    return cid\n  } else {\n    return cid\n  }\n}\n\nfunction toStringV1 <Prefix extends string> (bytes: Uint8Array, cache: Map<string, string>, base: API.MultibaseEncoder<Prefix>): string {\n  const { prefix } = base\n  const cid = cache.get(prefix)\n  if (cid == null) {\n    const cid = base.encode(bytes)\n    cache.set(prefix, cid)\n    return cid\n  } else {\n    return cid\n  }\n}\n\nconst DAG_PB_CODE = 0x70\nconst SHA_256_CODE = 0x12\n\nfunction encodeCID (version: API.Version, code: number, multihash: Uint8Array): Uint8Array {\n  const codeOffset = varint.encodingLength(version)\n  const hashOffset = codeOffset + varint.encodingLength(code)\n  const bytes = new Uint8Array(hashOffset + multihash.byteLength)\n  varint.encodeTo(version, bytes, 0)\n  varint.encodeTo(code, bytes, codeOffset)\n  bytes.set(multihash, hashOffset)\n  return bytes\n}\n\nconst cidSymbol = Symbol.for('@ipld/js-cid/CID')\n", "export class BadPathError extends Error {\n  static name = 'BadPathError'\n  static code = 'ERR_BAD_PATH'\n  name = BadPathError.name\n  code = BadPathError.code\n\n  constructor (message = 'Bad path') {\n    super(message)\n  }\n}\n\nexport class NotFoundError extends Error {\n  static name = 'NotFoundError'\n  static code = 'ERR_NOT_FOUND'\n  name = NotFoundError.name\n  code = NotFoundError.code\n\n  constructor (message = 'Not found') {\n    super(message)\n  }\n}\n\nexport class NoResolverError extends Error {\n  static name = 'NoResolverError'\n  static code = 'ERR_NO_RESOLVER'\n  name = NoResolverError.name\n  code = NoResolverError.code\n\n  constructor (message = 'No resolver') {\n    super(message)\n  }\n}\n\nexport class NotUnixFSError extends Error {\n  static name = 'NotUnixFSError'\n  static code = 'ERR_NOT_UNIXFS'\n  name = NotUnixFSError.name\n  code = NotUnixFSError.code\n\n  constructor (message = 'Not UnixFS') {\n    super(message)\n  }\n}\n\nexport class OverReadError extends Error {\n  static name = 'OverReadError'\n  static code = 'ERR_OVER_READ'\n  name = OverReadError.name\n  code = OverReadError.code\n\n  constructor (message = 'Over read') {\n    super(message)\n  }\n}\n\nexport class UnderReadError extends Error {\n  static name = 'UnderReadError'\n  static code = 'ERR_UNDER_READ'\n  name = UnderReadError.name\n  code = UnderReadError.code\n\n  constructor (message = 'Under read') {\n    super(message)\n  }\n}\n\nexport class NoPropError extends Error {\n  static name = 'NoPropError'\n  static code = 'ERR_NO_PROP'\n  name = NoPropError.name\n  code = NoPropError.code\n\n  constructor (message = 'No Property found') {\n    super(message)\n  }\n}\n\nexport class InvalidParametersError extends Error {\n  static name = 'InvalidParametersError'\n  static code = 'ERR_INVALID_PARAMS'\n  name = InvalidParametersError.name\n  code = InvalidParametersError.code\n\n  constructor (message = 'Invalid parameters') {\n    super(message)\n  }\n}\n", "// This is an unfortunate replacement for @sindresorhus/is that we need to\n// re-implement for performance purposes. In particular the is.observable()\n// check is expensive, and unnecessary for our purposes. The values returned\n// are compatible with @sindresorhus/is, however.\n\nconst typeofs = [\n  'string',\n  'number',\n  'bigint',\n  'symbol'\n]\n\nconst objectTypeNames = [\n  'Function',\n  'Generator',\n  'AsyncGenerator',\n  'GeneratorFunction',\n  'AsyncGeneratorFunction',\n  'AsyncFunction',\n  'Observable',\n  'Array',\n  'Buffer',\n  'Object',\n  'RegExp',\n  'Date',\n  'Error',\n  'Map',\n  'Set',\n  'WeakMap',\n  'WeakSet',\n  'ArrayBuffer',\n  'SharedArrayBuffer',\n  'DataView',\n  'Promise',\n  'URL',\n  'HTMLElement',\n  'Int8Array',\n  'Uint8Array',\n  'Uint8ClampedArray',\n  'Int16Array',\n  'Uint16Array',\n  'Int32Array',\n  'Uint32Array',\n  'Float32Array',\n  'Float64Array',\n  'BigInt64Array',\n  'BigUint64Array'\n]\n\n/**\n * @param {any} value\n * @returns {string}\n */\nexport function is (value) {\n  if (value === null) {\n    return 'null'\n  }\n  if (value === undefined) {\n    return 'undefined'\n  }\n  if (value === true || value === false) {\n    return 'boolean'\n  }\n  const typeOf = typeof value\n  if (typeofs.includes(typeOf)) {\n    return typeOf\n  }\n  /* c8 ignore next 4 */\n  // not going to bother testing this, it's not going to be valid anyway\n  if (typeOf === 'function') {\n    return 'Function'\n  }\n  if (Array.isArray(value)) {\n    return 'Array'\n  }\n  if (isBuffer(value)) {\n    return 'Buffer'\n  }\n  const objectType = getObjectType(value)\n  if (objectType) {\n    return objectType\n  }\n  /* c8 ignore next */\n  return 'Object'\n}\n\n/**\n * @param {any} value\n * @returns {boolean}\n */\nfunction isBuffer (value) {\n  return value && value.constructor && value.constructor.isBuffer && value.constructor.isBuffer.call(null, value)\n}\n\n/**\n * @param {any} value\n * @returns {string|undefined}\n */\nfunction getObjectType (value) {\n  const objectTypeName = Object.prototype.toString.call(value).slice(8, -1)\n  if (objectTypeNames.includes(objectTypeName)) {\n    return objectTypeName\n  }\n  /* c8 ignore next */\n  return undefined\n}\n", "class Type {\n  /**\n   * @param {number} major\n   * @param {string} name\n   * @param {boolean} terminal\n   */\n  constructor (major, name, terminal) {\n    this.major = major\n    this.majorEncoded = major << 5\n    this.name = name\n    this.terminal = terminal\n  }\n\n  /* c8 ignore next 3 */\n  toString () {\n    return `Type[${this.major}].${this.name}`\n  }\n\n  /**\n   * @param {Type} typ\n   * @returns {number}\n   */\n  compare (typ) {\n    /* c8 ignore next 1 */\n    return this.major < typ.major ? -1 : this.major > typ.major ? 1 : 0\n  }\n}\n\n// convert to static fields when better supported\nType.uint = new Type(0, 'uint', true)\nType.negint = new Type(1, 'negint', true)\nType.bytes = new Type(2, 'bytes', true)\nType.string = new Type(3, 'string', true)\nType.array = new Type(4, 'array', false)\nType.map = new Type(5, 'map', false)\nType.tag = new Type(6, 'tag', false) // terminal?\nType.float = new Type(7, 'float', true)\nType.false = new Type(7, 'false', true)\nType.true = new Type(7, 'true', true)\nType.null = new Type(7, 'null', true)\nType.undefined = new Type(7, 'undefined', true)\nType.break = new Type(7, 'break', true)\n// Type.indefiniteLength = new Type(0, 'indefiniteLength', true)\n\nclass Token {\n  /**\n   * @param {Type} type\n   * @param {any} [value]\n   * @param {number} [encodedLength]\n   */\n  constructor (type, value, encodedLength) {\n    this.type = type\n    this.value = value\n    this.encodedLength = encodedLength\n    /** @type {Uint8Array|undefined} */\n    this.encodedBytes = undefined\n    /** @type {Uint8Array|undefined} */\n    this.byteValue = undefined\n  }\n\n  /* c8 ignore next 3 */\n  toString () {\n    return `Token[${this.type}].${this.value}`\n  }\n}\n\nexport { Type, Token }\n", "// Use Uint8Array directly in the browser, use Buffer in Node.js but don't\n// speak its name directly to avoid bundlers pulling in the `Buffer` polyfill\n\n// @ts-ignore\nexport const useBuffer = globalThis.process &&\n  // @ts-ignore\n  !globalThis.process.browser &&\n  // @ts-ignore\n  globalThis.Buffer &&\n  // @ts-ignore\n  typeof globalThis.Buffer.isBuffer === 'function'\n\nconst textDecoder = new TextDecoder()\nconst textEncoder = new TextEncoder()\n\n/**\n * @param {Uint8Array} buf\n * @returns {boolean}\n */\nfunction isBuffer (buf) {\n  // @ts-ignore\n  return useBuffer && globalThis.Buffer.isBuffer(buf)\n}\n\n/**\n * @param {Uint8Array|number[]} buf\n * @returns {Uint8Array}\n */\nexport function asU8A (buf) {\n  /* c8 ignore next */\n  if (!(buf instanceof Uint8Array)) {\n    return Uint8Array.from(buf)\n  }\n  return isBuffer(buf) ? new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength) : buf\n}\n\nexport const toString = useBuffer\n  ? // eslint-disable-line operator-linebreak\n    /**\n     * @param {Uint8Array} bytes\n     * @param {number} start\n     * @param {number} end\n     */\n    (bytes, start, end) => {\n      return end - start > 64\n        ? // eslint-disable-line operator-linebreak\n      // @ts-ignore\n        globalThis.Buffer.from(bytes.subarray(start, end)).toString('utf8')\n        : utf8Slice(bytes, start, end)\n    }\n  /* c8 ignore next 11 */\n  : // eslint-disable-line operator-linebreak\n    /**\n     * @param {Uint8Array} bytes\n     * @param {number} start\n     * @param {number} end\n     */\n    (bytes, start, end) => {\n      return end - start > 64\n        ? textDecoder.decode(bytes.subarray(start, end))\n        : utf8Slice(bytes, start, end)\n    }\n\nexport const fromString = useBuffer\n  ? // eslint-disable-line operator-linebreak\n    /**\n     * @param {string} string\n     */\n    (string) => {\n      return string.length > 64\n        ? // eslint-disable-line operator-linebreak\n      // @ts-ignore\n        globalThis.Buffer.from(string)\n        : utf8ToBytes(string)\n    }\n  /* c8 ignore next 7 */\n  : // eslint-disable-line operator-linebreak\n    /**\n     * @param {string} string\n     */\n    (string) => {\n      return string.length > 64 ? textEncoder.encode(string) : utf8ToBytes(string)\n    }\n\n/**\n * Buffer variant not fast enough for what we need\n * @param {number[]} arr\n * @returns {Uint8Array}\n */\nexport const fromArray = (arr) => {\n  return Uint8Array.from(arr)\n}\n\nexport const slice = useBuffer\n  ? // eslint-disable-line operator-linebreak\n    /**\n     * @param {Uint8Array} bytes\n     * @param {number} start\n     * @param {number} end\n     */\n    (bytes, start, end) => {\n      if (isBuffer(bytes)) {\n        return new Uint8Array(bytes.subarray(start, end))\n      }\n      return bytes.slice(start, end)\n    }\n  /* c8 ignore next 9 */\n  : // eslint-disable-line operator-linebreak\n    /**\n     * @param {Uint8Array} bytes\n     * @param {number} start\n     * @param {number} end\n     */\n    (bytes, start, end) => {\n      return bytes.slice(start, end)\n    }\n\nexport const concat = useBuffer\n  ? // eslint-disable-line operator-linebreak\n    /**\n     * @param {Uint8Array[]} chunks\n     * @param {number} length\n     * @returns {Uint8Array}\n     */\n    (chunks, length) => {\n      // might get a stray plain Array here\n      /* c8 ignore next 1 */\n      chunks = chunks.map((c) => c instanceof Uint8Array\n        ? c\n        // this case is occasionally missed during test runs so becomes coverage-flaky\n        /* c8 ignore next 4 */\n        : // eslint-disable-line operator-linebreak\n        // @ts-ignore\n        globalThis.Buffer.from(c))\n      // @ts-ignore\n      return asU8A(globalThis.Buffer.concat(chunks, length))\n    }\n  /* c8 ignore next 19 */\n  : // eslint-disable-line operator-linebreak\n    /**\n     * @param {Uint8Array[]} chunks\n     * @param {number} length\n     * @returns {Uint8Array}\n     */\n    (chunks, length) => {\n      const out = new Uint8Array(length)\n      let off = 0\n      for (let b of chunks) {\n        if (off + b.length > out.length) {\n          // final chunk that's bigger than we need\n          b = b.subarray(0, out.length - off)\n        }\n        out.set(b, off)\n        off += b.length\n      }\n      return out\n    }\n\nexport const alloc = useBuffer\n  ? // eslint-disable-line operator-linebreak\n    /**\n     * @param {number} size\n     * @returns {Uint8Array}\n     */\n    (size) => {\n      // we always write over the contents we expose so this should be safe\n      // @ts-ignore\n      return globalThis.Buffer.allocUnsafe(size)\n    }\n  /* c8 ignore next 8 */\n  : // eslint-disable-line operator-linebreak\n    /**\n     * @param {number} size\n     * @returns {Uint8Array}\n     */\n    (size) => {\n      return new Uint8Array(size)\n    }\n\nexport const toHex = useBuffer\n  ? // eslint-disable-line operator-linebreak\n    /**\n     * @param {Uint8Array} d\n     * @returns {string}\n     */\n    (d) => {\n      if (typeof d === 'string') {\n        return d\n      }\n      // @ts-ignore\n      return globalThis.Buffer.from(toBytes(d)).toString('hex')\n    }\n  /* c8 ignore next 12 */\n  : // eslint-disable-line operator-linebreak\n    /**\n     * @param {Uint8Array} d\n     * @returns {string}\n     */\n    (d) => {\n      if (typeof d === 'string') {\n        return d\n      }\n      // @ts-ignore not smart enough to figure this out\n      return Array.prototype.reduce.call(toBytes(d), (p, c) => `${p}${c.toString(16).padStart(2, '0')}`, '')\n    }\n\nexport const fromHex = useBuffer\n  ? // eslint-disable-line operator-linebreak\n  /**\n   * @param {string|Uint8Array} hex\n   * @returns {Uint8Array}\n   */\n    (hex) => {\n      if (hex instanceof Uint8Array) {\n        return hex\n      }\n      // @ts-ignore\n      return globalThis.Buffer.from(hex, 'hex')\n    }\n  /* c8 ignore next 17 */\n  : // eslint-disable-line operator-linebreak\n  /**\n   * @param {string|Uint8Array} hex\n   * @returns {Uint8Array}\n   */\n    (hex) => {\n      if (hex instanceof Uint8Array) {\n        return hex\n      }\n      if (!hex.length) {\n        return new Uint8Array(0)\n      }\n      return new Uint8Array(hex.split('')\n        .map((/** @type {string} */ c, /** @type {number} */ i, /** @type {string[]} */ d) => i % 2 === 0 ? `0x${c}${d[i + 1]}` : '')\n        .filter(Boolean)\n        .map((/** @type {string} */ e) => parseInt(e, 16)))\n    }\n\n/**\n * @param {Uint8Array|ArrayBuffer|ArrayBufferView} obj\n * @returns {Uint8Array}\n */\nfunction toBytes (obj) {\n  if (obj instanceof Uint8Array && obj.constructor.name === 'Uint8Array') {\n    return obj\n  }\n  if (obj instanceof ArrayBuffer) {\n    return new Uint8Array(obj)\n  }\n  if (ArrayBuffer.isView(obj)) {\n    return new Uint8Array(obj.buffer, obj.byteOffset, obj.byteLength)\n  }\n  /* c8 ignore next */\n  throw new Error('Unknown type, must be binary type')\n}\n\n/**\n * @param {Uint8Array} b1\n * @param {Uint8Array} b2\n * @returns {number}\n */\nexport function compare (b1, b2) {\n  /* c8 ignore next 5 */\n  if (isBuffer(b1) && isBuffer(b2)) {\n    // probably not possible to get here in the current API\n    // @ts-ignore Buffer\n    return b1.compare(b2)\n  }\n  for (let i = 0; i < b1.length; i++) {\n    if (b1[i] === b2[i]) {\n      continue\n    }\n    return b1[i] < b2[i] ? -1 : 1\n  } /* c8 ignore next 3 */\n  return 0\n}\n\n// The below code is taken from https://github.com/google/closure-library/blob/8598d87242af59aac233270742c8984e2b2bdbe0/closure/goog/crypt/crypt.js#L117-L143\n// Licensed Apache-2.0.\n\n/**\n * @param {string} str\n * @returns {number[]}\n */\nfunction utf8ToBytes (str) {\n  const out = []\n  let p = 0\n  for (let i = 0; i < str.length; i++) {\n    let c = str.charCodeAt(i)\n    if (c < 128) {\n      out[p++] = c\n    } else if (c < 2048) {\n      out[p++] = (c >> 6) | 192\n      out[p++] = (c & 63) | 128\n    } else if (\n      ((c & 0xFC00) === 0xD800) && (i + 1) < str.length &&\n      ((str.charCodeAt(i + 1) & 0xFC00) === 0xDC00)) {\n      // Surrogate Pair\n      c = 0x10000 + ((c & 0x03FF) << 10) + (str.charCodeAt(++i) & 0x03FF)\n      out[p++] = (c >> 18) | 240\n      out[p++] = ((c >> 12) & 63) | 128\n      out[p++] = ((c >> 6) & 63) | 128\n      out[p++] = (c & 63) | 128\n    } else {\n      out[p++] = (c >> 12) | 224\n      out[p++] = ((c >> 6) & 63) | 128\n      out[p++] = (c & 63) | 128\n    }\n  }\n  return out\n}\n\n// The below code is mostly taken from https://github.com/feross/buffer\n// Licensed MIT. Copyright (c) Feross Aboukhadijeh\n\n/**\n * @param {Uint8Array} buf\n * @param {number} offset\n * @param {number} end\n * @returns {string}\n */\nfunction utf8Slice (buf, offset, end) {\n  const res = []\n\n  while (offset < end) {\n    const firstByte = buf[offset]\n    let codePoint = null\n    let bytesPerSequence = (firstByte > 0xef) ? 4 : (firstByte > 0xdf) ? 3 : (firstByte > 0xbf) ? 2 : 1\n\n    if (offset + bytesPerSequence <= end) {\n      let secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[offset + 1]\n          if ((secondByte & 0xc0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1f) << 0x6 | (secondByte & 0x3f)\n            if (tempCodePoint > 0x7f) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[offset + 1]\n          thirdByte = buf[offset + 2]\n          if ((secondByte & 0xc0) === 0x80 && (thirdByte & 0xc0) === 0x80) {\n            tempCodePoint = (firstByte & 0xf) << 0xc | (secondByte & 0x3f) << 0x6 | (thirdByte & 0x3f)\n            /* c8 ignore next 3 */\n            if (tempCodePoint > 0x7ff && (tempCodePoint < 0xd800 || tempCodePoint > 0xdfff)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[offset + 1]\n          thirdByte = buf[offset + 2]\n          fourthByte = buf[offset + 3]\n          if ((secondByte & 0xc0) === 0x80 && (thirdByte & 0xc0) === 0x80 && (fourthByte & 0xc0) === 0x80) {\n            tempCodePoint = (firstByte & 0xf) << 0x12 | (secondByte & 0x3f) << 0xc | (thirdByte & 0x3f) << 0x6 | (fourthByte & 0x3f)\n            if (tempCodePoint > 0xffff && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    /* c8 ignore next 5 */\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xfffd\n      bytesPerSequence = 1\n    } else if (codePoint > 0xffff) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3ff | 0xd800)\n      codePoint = 0xdc00 | codePoint & 0x3ff\n    }\n\n    res.push(codePoint)\n    offset += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nconst MAX_ARGUMENTS_LENGTH = 0x1000\n\n/**\n * @param {number[]} codePoints\n * @returns {string}\n */\nexport function decodeCodePointsArray (codePoints) {\n  const len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n  /* c8 ignore next 10 */\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  let res = ''\n  let i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n", "/**\n * Bl is a list of byte chunks, similar to https://github.com/rvagg/bl but for\n * writing rather than reading.\n * A Bl object accepts set() operations for individual bytes and copyTo() for\n * inserting byte arrays. These write operations don't automatically increment\n * the internal cursor so its \"length\" won't be changed. Instead, increment()\n * must be called to extend its length to cover the inserted data.\n * The toBytes() call will convert all internal memory to a single Uint8Array of\n * the correct length, truncating any data that is stored but hasn't been\n * included by an increment().\n * get() can retrieve a single byte.\n * All operations (except toBytes()) take an \"offset\" argument that will perform\n * the write at the offset _from the current cursor_. For most operations this\n * will be `0` to write at the current cursor position but it can be ahead of\n * the current cursor. Negative offsets probably work but are untested.\n */\n\n// TODO: ipjs doesn't support this, only for test files: https://github.com/mikeal/ipjs/blob/master/src/package/testFile.js#L39\nimport { alloc, concat, slice } from './byte-utils.js'\n\n// the ts-ignores in this file are almost all for the `Uint8Array|number[]` duality that exists\n// for perf reasons. Consider better approaches to this or removing it entirely, it is quite\n// risky because of some assumptions about small chunks === number[] and everything else === Uint8Array.\n\nconst defaultChunkSize = 256\n\nexport class Bl {\n  /**\n   * @param {number} [chunkSize]\n   */\n  constructor (chunkSize = defaultChunkSize) {\n    this.chunkSize = chunkSize\n    /** @type {number} */\n    this.cursor = 0\n    /** @type {number} */\n    this.maxCursor = -1\n    /** @type {(Uint8Array|number[])[]} */\n    this.chunks = []\n    // keep the first chunk around if we can to save allocations for future encodes\n    /** @type {Uint8Array|number[]|null} */\n    this._initReuseChunk = null\n  }\n\n  reset () {\n    this.cursor = 0\n    this.maxCursor = -1\n    if (this.chunks.length) {\n      this.chunks = []\n    }\n    if (this._initReuseChunk !== null) {\n      this.chunks.push(this._initReuseChunk)\n      this.maxCursor = this._initReuseChunk.length - 1\n    }\n  }\n\n  /**\n   * @param {Uint8Array|number[]} bytes\n   */\n  push (bytes) {\n    let topChunk = this.chunks[this.chunks.length - 1]\n    const newMax = this.cursor + bytes.length\n    if (newMax <= this.maxCursor + 1) {\n      // we have at least one chunk and we can fit these bytes into that chunk\n      const chunkPos = topChunk.length - (this.maxCursor - this.cursor) - 1\n      // @ts-ignore\n      topChunk.set(bytes, chunkPos)\n    } else {\n      // can't fit it in\n      if (topChunk) {\n        // trip the last chunk to `cursor` if we need to\n        const chunkPos = topChunk.length - (this.maxCursor - this.cursor) - 1\n        if (chunkPos < topChunk.length) {\n          // @ts-ignore\n          this.chunks[this.chunks.length - 1] = topChunk.subarray(0, chunkPos)\n          this.maxCursor = this.cursor - 1\n        }\n      }\n      if (bytes.length < 64 && bytes.length < this.chunkSize) {\n        // make a new chunk and copy the new one into it\n        topChunk = alloc(this.chunkSize)\n        this.chunks.push(topChunk)\n        this.maxCursor += topChunk.length\n        if (this._initReuseChunk === null) {\n          this._initReuseChunk = topChunk\n        }\n        // @ts-ignore\n        topChunk.set(bytes, 0)\n      } else {\n        // push the new bytes in as its own chunk\n        this.chunks.push(bytes)\n        this.maxCursor += bytes.length\n      }\n    }\n    this.cursor += bytes.length\n  }\n\n  /**\n   * @param {boolean} [reset]\n   * @returns {Uint8Array}\n   */\n  toBytes (reset = false) {\n    let byts\n    if (this.chunks.length === 1) {\n      const chunk = this.chunks[0]\n      if (reset && this.cursor > chunk.length / 2) {\n        /* c8 ignore next 2 */\n        // @ts-ignore\n        byts = this.cursor === chunk.length ? chunk : chunk.subarray(0, this.cursor)\n        this._initReuseChunk = null\n        this.chunks = []\n      } else {\n        // @ts-ignore\n        byts = slice(chunk, 0, this.cursor)\n      }\n    } else {\n      // @ts-ignore\n      byts = concat(this.chunks, this.cursor)\n    }\n    if (reset) {\n      this.reset()\n    }\n    return byts\n  }\n}\n", "const decodeErrPrefix = 'CBOR decode error:'\nconst encodeErrPrefix = 'CBOR encode error:'\n\nconst uintMinorPrefixBytes = []\nuintMinorPrefixBytes[23] = 1\nuintMinorPrefixBytes[24] = 2\nuintMinorPrefixBytes[25] = 3\nuintMinorPrefixBytes[26] = 5\nuintMinorPrefixBytes[27] = 9\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} need\n */\nfunction assertEnoughData (data, pos, need) {\n  if (data.length - pos < need) {\n    throw new Error(`${decodeErrPrefix} not enough data for type`)\n  }\n}\n\nexport {\n  decodeErrPrefix,\n  encodeErrPrefix,\n  uintMinorPrefixBytes,\n  assertEnoughData\n}\n", "/* globals BigInt */\n\nimport { Token, Type } from './token.js'\nimport { decodeErrPrefix, assertEnoughData } from './common.js'\n\nexport const uintBoundaries = [24, 256, 65536, 4294967296, BigInt('18446744073709551616')]\n\n/**\n * @typedef {import('./bl.js').Bl} Bl\n * @typedef {import('../interface').DecodeOptions} DecodeOptions\n */\n\n/**\n * @param {Uint8Array} data\n * @param {number} offset\n * @param {DecodeOptions} options\n * @returns {number}\n */\nexport function readUint8 (data, offset, options) {\n  assertEnoughData(data, offset, 1)\n  const value = data[offset]\n  if (options.strict === true && value < uintBoundaries[0]) {\n    throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`)\n  }\n  return value\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} offset\n * @param {DecodeOptions} options\n * @returns {number}\n */\nexport function readUint16 (data, offset, options) {\n  assertEnoughData(data, offset, 2)\n  const value = (data[offset] << 8) | data[offset + 1]\n  if (options.strict === true && value < uintBoundaries[1]) {\n    throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`)\n  }\n  return value\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} offset\n * @param {DecodeOptions} options\n * @returns {number}\n */\nexport function readUint32 (data, offset, options) {\n  assertEnoughData(data, offset, 4)\n  const value = (data[offset] * 16777216 /* 2 ** 24 */) + (data[offset + 1] << 16) + (data[offset + 2] << 8) + data[offset + 3]\n  if (options.strict === true && value < uintBoundaries[2]) {\n    throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`)\n  }\n  return value\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} offset\n * @param {DecodeOptions} options\n * @returns {number|bigint}\n */\nexport function readUint64 (data, offset, options) {\n  // assume BigInt, convert back to Number if within safe range\n  assertEnoughData(data, offset, 8)\n  const hi = (data[offset] * 16777216 /* 2 ** 24 */) + (data[offset + 1] << 16) + (data[offset + 2] << 8) + data[offset + 3]\n  const lo = (data[offset + 4] * 16777216 /* 2 ** 24 */) + (data[offset + 5] << 16) + (data[offset + 6] << 8) + data[offset + 7]\n  const value = (BigInt(hi) << BigInt(32)) + BigInt(lo)\n  if (options.strict === true && value < uintBoundaries[3]) {\n    throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`)\n  }\n  if (value <= Number.MAX_SAFE_INTEGER) {\n    return Number(value)\n  }\n  if (options.allowBigInt === true) {\n    return value\n  }\n  throw new Error(`${decodeErrPrefix} integers outside of the safe integer range are not supported`)\n}\n\n/* not required thanks to quick[] list\nconst oneByteTokens = new Array(24).fill(0).map((v, i) => new Token(Type.uint, i, 1))\nexport function decodeUintCompact (data, pos, minor, options) {\n  return oneByteTokens[minor]\n}\n*/\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeUint8 (data, pos, _minor, options) {\n  return new Token(Type.uint, readUint8(data, pos + 1, options), 2)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeUint16 (data, pos, _minor, options) {\n  return new Token(Type.uint, readUint16(data, pos + 1, options), 3)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeUint32 (data, pos, _minor, options) {\n  return new Token(Type.uint, readUint32(data, pos + 1, options), 5)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeUint64 (data, pos, _minor, options) {\n  return new Token(Type.uint, readUint64(data, pos + 1, options), 9)\n}\n\n/**\n * @param {Bl} buf\n * @param {Token} token\n */\nexport function encodeUint (buf, token) {\n  return encodeUintValue(buf, 0, token.value)\n}\n\n/**\n * @param {Bl} buf\n * @param {number} major\n * @param {number|bigint} uint\n */\nexport function encodeUintValue (buf, major, uint) {\n  if (uint < uintBoundaries[0]) {\n    const nuint = Number(uint)\n    // pack into one byte, minor=0, additional=value\n    buf.push([major | nuint])\n  } else if (uint < uintBoundaries[1]) {\n    const nuint = Number(uint)\n    // pack into two byte, minor=0, additional=24\n    buf.push([major | 24, nuint])\n  } else if (uint < uintBoundaries[2]) {\n    const nuint = Number(uint)\n    // pack into three byte, minor=0, additional=25\n    buf.push([major | 25, nuint >>> 8, nuint & 0xff])\n  } else if (uint < uintBoundaries[3]) {\n    const nuint = Number(uint)\n    // pack into five byte, minor=0, additional=26\n    buf.push([major | 26, (nuint >>> 24) & 0xff, (nuint >>> 16) & 0xff, (nuint >>> 8) & 0xff, nuint & 0xff])\n  } else {\n    const buint = BigInt(uint)\n    if (buint < uintBoundaries[4]) {\n      // pack into nine byte, minor=0, additional=27\n      const set = [major | 27, 0, 0, 0, 0, 0, 0, 0]\n      // simulate bitwise above 32 bits\n      let lo = Number(buint & BigInt(0xffffffff))\n      let hi = Number(buint >> BigInt(32) & BigInt(0xffffffff))\n      set[8] = lo & 0xff\n      lo = lo >> 8\n      set[7] = lo & 0xff\n      lo = lo >> 8\n      set[6] = lo & 0xff\n      lo = lo >> 8\n      set[5] = lo & 0xff\n      set[4] = hi & 0xff\n      hi = hi >> 8\n      set[3] = hi & 0xff\n      hi = hi >> 8\n      set[2] = hi & 0xff\n      hi = hi >> 8\n      set[1] = hi & 0xff\n      buf.push(set)\n    } else {\n      throw new Error(`${decodeErrPrefix} encountered BigInt larger than allowable range`)\n    }\n  }\n}\n\n/**\n * @param {Token} token\n * @returns {number}\n */\nencodeUint.encodedSize = function encodedSize (token) {\n  return encodeUintValue.encodedSize(token.value)\n}\n\n/**\n * @param {number} uint\n * @returns {number}\n */\nencodeUintValue.encodedSize = function encodedSize (uint) {\n  if (uint < uintBoundaries[0]) {\n    return 1\n  }\n  if (uint < uintBoundaries[1]) {\n    return 2\n  }\n  if (uint < uintBoundaries[2]) {\n    return 3\n  }\n  if (uint < uintBoundaries[3]) {\n    return 5\n  }\n  return 9\n}\n\n/**\n * @param {Token} tok1\n * @param {Token} tok2\n * @returns {number}\n */\nencodeUint.compareTokens = function compareTokens (tok1, tok2) {\n  return tok1.value < tok2.value ? -1 : tok1.value > tok2.value ? 1 : /* c8 ignore next */ 0\n}\n", "/* eslint-env es2020 */\n\nimport { Token, Type } from './token.js'\nimport * as uint from './0uint.js'\nimport { decodeErrPrefix } from './common.js'\n\n/**\n * @typedef {import('./bl.js').Bl} Bl\n * @typedef {import('../interface').DecodeOptions} DecodeOptions\n */\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeNegint8 (data, pos, _minor, options) {\n  return new Token(Type.negint, -1 - uint.readUint8(data, pos + 1, options), 2)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeNegint16 (data, pos, _minor, options) {\n  return new Token(Type.negint, -1 - uint.readUint16(data, pos + 1, options), 3)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeNegint32 (data, pos, _minor, options) {\n  return new Token(Type.negint, -1 - uint.readUint32(data, pos + 1, options), 5)\n}\n\nconst neg1b = BigInt(-1)\nconst pos1b = BigInt(1)\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeNegint64 (data, pos, _minor, options) {\n  const int = uint.readUint64(data, pos + 1, options)\n  if (typeof int !== 'bigint') {\n    const value = -1 - int\n    if (value >= Number.MIN_SAFE_INTEGER) {\n      return new Token(Type.negint, value, 9)\n    }\n  }\n  if (options.allowBigInt !== true) {\n    throw new Error(`${decodeErrPrefix} integers outside of the safe integer range are not supported`)\n  }\n  return new Token(Type.negint, neg1b - BigInt(int), 9)\n}\n\n/**\n * @param {Bl} buf\n * @param {Token} token\n */\nexport function encodeNegint (buf, token) {\n  const negint = token.value\n  const unsigned = (typeof negint === 'bigint' ? (negint * neg1b - pos1b) : (negint * -1 - 1))\n  uint.encodeUintValue(buf, token.type.majorEncoded, unsigned)\n}\n\n/**\n * @param {Token} token\n * @returns {number}\n */\nencodeNegint.encodedSize = function encodedSize (token) {\n  const negint = token.value\n  const unsigned = (typeof negint === 'bigint' ? (negint * neg1b - pos1b) : (negint * -1 - 1))\n  /* c8 ignore next 4 */\n  // handled by quickEncode, we shouldn't get here but it's included for completeness\n  if (unsigned < uint.uintBoundaries[0]) {\n    return 1\n  }\n  if (unsigned < uint.uintBoundaries[1]) {\n    return 2\n  }\n  if (unsigned < uint.uintBoundaries[2]) {\n    return 3\n  }\n  if (unsigned < uint.uintBoundaries[3]) {\n    return 5\n  }\n  return 9\n}\n\n/**\n * @param {Token} tok1\n * @param {Token} tok2\n * @returns {number}\n */\nencodeNegint.compareTokens = function compareTokens (tok1, tok2) {\n  // opposite of the uint comparison since we store the uint version in bytes\n  return tok1.value < tok2.value ? 1 : tok1.value > tok2.value ? -1 : /* c8 ignore next */ 0\n}\n", "import { Token, Type } from './token.js'\nimport { assertEnoughData, decodeErrPrefix } from './common.js'\nimport * as uint from './0uint.js'\nimport { compare, fromString, slice } from './byte-utils.js'\n\n/**\n * @typedef {import('./bl.js').Bl} Bl\n * @typedef {import('../interface').DecodeOptions} DecodeOptions\n */\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} prefix\n * @param {number} length\n * @returns {Token}\n */\nfunction toToken (data, pos, prefix, length) {\n  assertEnoughData(data, pos, prefix + length)\n  const buf = slice(data, pos + prefix, pos + prefix + length)\n  return new Token(Type.bytes, buf, prefix + length)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} minor\n * @param {DecodeOptions} _options\n * @returns {Token}\n */\nexport function decodeBytesCompact (data, pos, minor, _options) {\n  return toToken(data, pos, 1, minor)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeBytes8 (data, pos, _minor, options) {\n  return toToken(data, pos, 2, uint.readUint8(data, pos + 1, options))\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeBytes16 (data, pos, _minor, options) {\n  return toToken(data, pos, 3, uint.readUint16(data, pos + 1, options))\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeBytes32 (data, pos, _minor, options) {\n  return toToken(data, pos, 5, uint.readUint32(data, pos + 1, options))\n}\n\n// TODO: maybe we shouldn't support this ..\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeBytes64 (data, pos, _minor, options) {\n  const l = uint.readUint64(data, pos + 1, options)\n  if (typeof l === 'bigint') {\n    throw new Error(`${decodeErrPrefix} 64-bit integer bytes lengths not supported`)\n  }\n  return toToken(data, pos, 9, l)\n}\n\n/**\n * `encodedBytes` allows for caching when we do a byte version of a string\n * for key sorting purposes\n * @param {Token} token\n * @returns {Uint8Array}\n */\nfunction tokenBytes (token) {\n  if (token.encodedBytes === undefined) {\n    token.encodedBytes = token.type === Type.string ? fromString(token.value) : token.value\n  }\n  // @ts-ignore c'mon\n  return token.encodedBytes\n}\n\n/**\n * @param {Bl} buf\n * @param {Token} token\n */\nexport function encodeBytes (buf, token) {\n  const bytes = tokenBytes(token)\n  uint.encodeUintValue(buf, token.type.majorEncoded, bytes.length)\n  buf.push(bytes)\n}\n\n/**\n * @param {Token} token\n * @returns {number}\n */\nencodeBytes.encodedSize = function encodedSize (token) {\n  const bytes = tokenBytes(token)\n  return uint.encodeUintValue.encodedSize(bytes.length) + bytes.length\n}\n\n/**\n * @param {Token} tok1\n * @param {Token} tok2\n * @returns {number}\n */\nencodeBytes.compareTokens = function compareTokens (tok1, tok2) {\n  return compareBytes(tokenBytes(tok1), tokenBytes(tok2))\n}\n\n/**\n * @param {Uint8Array} b1\n * @param {Uint8Array} b2\n * @returns {number}\n */\nexport function compareBytes (b1, b2) {\n  return b1.length < b2.length ? -1 : b1.length > b2.length ? 1 : compare(b1, b2)\n}\n", "import { Token, Type } from './token.js'\nimport { assertEnoughData, decodeErrPrefix } from './common.js'\nimport * as uint from './0uint.js'\nimport { encodeBytes } from './2bytes.js'\nimport { toString, slice } from './byte-utils.js'\n\n/**\n * @typedef {import('./bl.js').Bl} Bl\n * @typedef {import('../interface').DecodeOptions} DecodeOptions\n */\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} prefix\n * @param {number} length\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nfunction toToken (data, pos, prefix, length, options) {\n  const totLength = prefix + length\n  assertEnoughData(data, pos, totLength)\n  const tok = new Token(Type.string, toString(data, pos + prefix, pos + totLength), totLength)\n  if (options.retainStringBytes === true) {\n    tok.byteValue = slice(data, pos + prefix, pos + totLength)\n  }\n  return tok\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeStringCompact (data, pos, minor, options) {\n  return toToken(data, pos, 1, minor, options)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeString8 (data, pos, _minor, options) {\n  return toToken(data, pos, 2, uint.readUint8(data, pos + 1, options), options)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeString16 (data, pos, _minor, options) {\n  return toToken(data, pos, 3, uint.readUint16(data, pos + 1, options), options)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeString32 (data, pos, _minor, options) {\n  return toToken(data, pos, 5, uint.readUint32(data, pos + 1, options), options)\n}\n\n// TODO: maybe we shouldn't support this ..\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeString64 (data, pos, _minor, options) {\n  const l = uint.readUint64(data, pos + 1, options)\n  if (typeof l === 'bigint') {\n    throw new Error(`${decodeErrPrefix} 64-bit integer string lengths not supported`)\n  }\n  return toToken(data, pos, 9, l, options)\n}\n\nexport const encodeString = encodeBytes\n", "import { Token, Type } from './token.js'\nimport * as uint from './0uint.js'\nimport { decodeErrPrefix } from './common.js'\n\n/**\n * @typedef {import('./bl.js').Bl} Bl\n * @typedef {import('../interface').DecodeOptions} DecodeOptions\n */\n\n/**\n * @param {Uint8Array} _data\n * @param {number} _pos\n * @param {number} prefix\n * @param {number} length\n * @returns {Token}\n */\nfunction toToken (_data, _pos, prefix, length) {\n  return new Token(Type.array, length, prefix)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} minor\n * @param {DecodeOptions} _options\n * @returns {Token}\n */\nexport function decodeArrayCompact (data, pos, minor, _options) {\n  return toToken(data, pos, 1, minor)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeArray8 (data, pos, _minor, options) {\n  return toToken(data, pos, 2, uint.readUint8(data, pos + 1, options))\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeArray16 (data, pos, _minor, options) {\n  return toToken(data, pos, 3, uint.readUint16(data, pos + 1, options))\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeArray32 (data, pos, _minor, options) {\n  return toToken(data, pos, 5, uint.readUint32(data, pos + 1, options))\n}\n\n// TODO: maybe we shouldn't support this ..\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeArray64 (data, pos, _minor, options) {\n  const l = uint.readUint64(data, pos + 1, options)\n  if (typeof l === 'bigint') {\n    throw new Error(`${decodeErrPrefix} 64-bit integer array lengths not supported`)\n  }\n  return toToken(data, pos, 9, l)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeArrayIndefinite (data, pos, _minor, options) {\n  if (options.allowIndefinite === false) {\n    throw new Error(`${decodeErrPrefix} indefinite length items not allowed`)\n  }\n  return toToken(data, pos, 1, Infinity)\n}\n\n/**\n * @param {Bl} buf\n * @param {Token} token\n */\nexport function encodeArray (buf, token) {\n  uint.encodeUintValue(buf, Type.array.majorEncoded, token.value)\n}\n\n// using an array as a map key, are you sure about this? we can only sort\n// by map length here, it's up to the encoder to decide to look deeper\nencodeArray.compareTokens = uint.encodeUint.compareTokens\n\n/**\n * @param {Token} token\n * @returns {number}\n */\nencodeArray.encodedSize = function encodedSize (token) {\n  return uint.encodeUintValue.encodedSize(token.value)\n}\n", "import { Token, Type } from './token.js'\nimport * as uint from './0uint.js'\nimport { decodeErrPrefix } from './common.js'\n\n/**\n * @typedef {import('./bl.js').Bl} Bl\n * @typedef {import('../interface').DecodeOptions} DecodeOptions\n */\n\n/**\n * @param {Uint8Array} _data\n * @param {number} _pos\n * @param {number} prefix\n * @param {number} length\n * @returns {Token}\n */\nfunction toToken (_data, _pos, prefix, length) {\n  return new Token(Type.map, length, prefix)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} minor\n * @param {DecodeOptions} _options\n * @returns {Token}\n */\nexport function decodeMapCompact (data, pos, minor, _options) {\n  return toToken(data, pos, 1, minor)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeMap8 (data, pos, _minor, options) {\n  return toToken(data, pos, 2, uint.readUint8(data, pos + 1, options))\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeMap16 (data, pos, _minor, options) {\n  return toToken(data, pos, 3, uint.readUint16(data, pos + 1, options))\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeMap32 (data, pos, _minor, options) {\n  return toToken(data, pos, 5, uint.readUint32(data, pos + 1, options))\n}\n\n// TODO: maybe we shouldn't support this ..\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeMap64 (data, pos, _minor, options) {\n  const l = uint.readUint64(data, pos + 1, options)\n  if (typeof l === 'bigint') {\n    throw new Error(`${decodeErrPrefix} 64-bit integer map lengths not supported`)\n  }\n  return toToken(data, pos, 9, l)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeMapIndefinite (data, pos, _minor, options) {\n  if (options.allowIndefinite === false) {\n    throw new Error(`${decodeErrPrefix} indefinite length items not allowed`)\n  }\n  return toToken(data, pos, 1, Infinity)\n}\n\n/**\n * @param {Bl} buf\n * @param {Token} token\n */\nexport function encodeMap (buf, token) {\n  uint.encodeUintValue(buf, Type.map.majorEncoded, token.value)\n}\n\n// using a map as a map key, are you sure about this? we can only sort\n// by map length here, it's up to the encoder to decide to look deeper\nencodeMap.compareTokens = uint.encodeUint.compareTokens\n\n/**\n * @param {Token} token\n * @returns {number}\n */\nencodeMap.encodedSize = function encodedSize (token) {\n  return uint.encodeUintValue.encodedSize(token.value)\n}\n", "import { Token, Type } from './token.js'\nimport * as uint from './0uint.js'\n\n/**\n * @typedef {import('./bl.js').Bl} Bl\n * @typedef {import('../interface').DecodeOptions} DecodeOptions\n */\n\n/**\n * @param {Uint8Array} _data\n * @param {number} _pos\n * @param {number} minor\n * @param {DecodeOptions} _options\n * @returns {Token}\n */\nexport function decodeTagCompact (_data, _pos, minor, _options) {\n  return new Token(Type.tag, minor, 1)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeTag8 (data, pos, _minor, options) {\n  return new Token(Type.tag, uint.readUint8(data, pos + 1, options), 2)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeTag16 (data, pos, _minor, options) {\n  return new Token(Type.tag, uint.readUint16(data, pos + 1, options), 3)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeTag32 (data, pos, _minor, options) {\n  return new Token(Type.tag, uint.readUint32(data, pos + 1, options), 5)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeTag64 (data, pos, _minor, options) {\n  return new Token(Type.tag, uint.readUint64(data, pos + 1, options), 9)\n}\n\n/**\n * @param {Bl} buf\n * @param {Token} token\n */\nexport function encodeTag (buf, token) {\n  uint.encodeUintValue(buf, Type.tag.majorEncoded, token.value)\n}\n\nencodeTag.compareTokens = uint.encodeUint.compareTokens\n\n/**\n * @param {Token} token\n * @returns {number}\n */\nencodeTag.encodedSize = function encodedSize (token) {\n  return uint.encodeUintValue.encodedSize(token.value)\n}\n", "// TODO: shift some of the bytes logic to bytes-utils so we can use Buffer\n// where possible\n\nimport { Token, Type } from './token.js'\nimport { decodeErrPrefix } from './common.js'\nimport { encodeUint } from './0uint.js'\n\n/**\n * @typedef {import('./bl.js').Bl} Bl\n * @typedef {import('../interface').DecodeOptions} DecodeOptions\n * @typedef {import('../interface').EncodeOptions} EncodeOptions\n */\n\nconst MINOR_FALSE = 20\nconst MINOR_TRUE = 21\nconst MINOR_NULL = 22\nconst MINOR_UNDEFINED = 23\n\n/**\n * @param {Uint8Array} _data\n * @param {number} _pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeUndefined (_data, _pos, _minor, options) {\n  if (options.allowUndefined === false) {\n    throw new Error(`${decodeErrPrefix} undefined values are not supported`)\n  } else if (options.coerceUndefinedToNull === true) {\n    return new Token(Type.null, null, 1)\n  }\n  return new Token(Type.undefined, undefined, 1)\n}\n\n/**\n * @param {Uint8Array} _data\n * @param {number} _pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeBreak (_data, _pos, _minor, options) {\n  if (options.allowIndefinite === false) {\n    throw new Error(`${decodeErrPrefix} indefinite length items not allowed`)\n  }\n  return new Token(Type.break, undefined, 1)\n}\n\n/**\n * @param {number} value\n * @param {number} bytes\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nfunction createToken (value, bytes, options) {\n  if (options) {\n    if (options.allowNaN === false && Number.isNaN(value)) {\n      throw new Error(`${decodeErrPrefix} NaN values are not supported`)\n    }\n    if (options.allowInfinity === false && (value === Infinity || value === -Infinity)) {\n      throw new Error(`${decodeErrPrefix} Infinity values are not supported`)\n    }\n  }\n  return new Token(Type.float, value, bytes)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeFloat16 (data, pos, _minor, options) {\n  return createToken(readFloat16(data, pos + 1), 3, options)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeFloat32 (data, pos, _minor, options) {\n  return createToken(readFloat32(data, pos + 1), 5, options)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeFloat64 (data, pos, _minor, options) {\n  return createToken(readFloat64(data, pos + 1), 9, options)\n}\n\n/**\n * @param {Bl} buf\n * @param {Token} token\n * @param {EncodeOptions} options\n */\nexport function encodeFloat (buf, token, options) {\n  const float = token.value\n\n  if (float === false) {\n    buf.push([Type.float.majorEncoded | MINOR_FALSE])\n  } else if (float === true) {\n    buf.push([Type.float.majorEncoded | MINOR_TRUE])\n  } else if (float === null) {\n    buf.push([Type.float.majorEncoded | MINOR_NULL])\n  } else if (float === undefined) {\n    buf.push([Type.float.majorEncoded | MINOR_UNDEFINED])\n  } else {\n    let decoded\n    let success = false\n    if (!options || options.float64 !== true) {\n      encodeFloat16(float)\n      decoded = readFloat16(ui8a, 1)\n      if (float === decoded || Number.isNaN(float)) {\n        ui8a[0] = 0xf9\n        buf.push(ui8a.slice(0, 3))\n        success = true\n      } else {\n        encodeFloat32(float)\n        decoded = readFloat32(ui8a, 1)\n        if (float === decoded) {\n          ui8a[0] = 0xfa\n          buf.push(ui8a.slice(0, 5))\n          success = true\n        }\n      }\n    }\n    if (!success) {\n      encodeFloat64(float)\n      decoded = readFloat64(ui8a, 1)\n      ui8a[0] = 0xfb\n      buf.push(ui8a.slice(0, 9))\n    }\n  }\n}\n\n/**\n * @param {Token} token\n * @param {EncodeOptions} options\n * @returns {number}\n */\nencodeFloat.encodedSize = function encodedSize (token, options) {\n  const float = token.value\n\n  if (float === false || float === true || float === null || float === undefined) {\n    return 1\n  }\n\n  if (!options || options.float64 !== true) {\n    encodeFloat16(float)\n    let decoded = readFloat16(ui8a, 1)\n    if (float === decoded || Number.isNaN(float)) {\n      return 3\n    }\n    encodeFloat32(float)\n    decoded = readFloat32(ui8a, 1)\n    if (float === decoded) {\n      return 5\n    }\n  }\n  return 9\n}\n\nconst buffer = new ArrayBuffer(9)\nconst dataView = new DataView(buffer, 1)\nconst ui8a = new Uint8Array(buffer, 0)\n\n/**\n * @param {number} inp\n */\nfunction encodeFloat16 (inp) {\n  if (inp === Infinity) {\n    dataView.setUint16(0, 0x7c00, false)\n  } else if (inp === -Infinity) {\n    dataView.setUint16(0, 0xfc00, false)\n  } else if (Number.isNaN(inp)) {\n    dataView.setUint16(0, 0x7e00, false)\n  } else {\n    dataView.setFloat32(0, inp)\n    const valu32 = dataView.getUint32(0)\n    const exponent = (valu32 & 0x7f800000) >> 23\n    const mantissa = valu32 & 0x7fffff\n\n    /* c8 ignore next 6 */\n    if (exponent === 0xff) {\n      // too big, Infinity, but this should be hard (impossible?) to trigger\n      dataView.setUint16(0, 0x7c00, false)\n    } else if (exponent === 0x00) {\n      // 0.0, -0.0 and subnormals, shouldn't be possible to get here because 0.0 should be counted as an int\n      dataView.setUint16(0, ((inp & 0x80000000) >> 16) | (mantissa >> 13), false)\n    } else { // standard numbers\n      // chunks of logic here borrowed from https://github.com/PJK/libcbor/blob/c78f437182533e3efa8d963ff4b945bb635c2284/src/cbor/encoding.c#L127\n      const logicalExponent = exponent - 127\n      // Now we know that 2^exponent <= 0 logically\n      /* c8 ignore next 6 */\n      if (logicalExponent < -24) {\n        /* No unambiguous representation exists, this float is not a half float\n          and is too small to be represented using a half, round off to zero.\n          Consistent with the reference implementation. */\n        // should be difficult (impossible?) to get here in JS\n        dataView.setUint16(0, 0)\n      } else if (logicalExponent < -14) {\n        /* Offset the remaining decimal places by shifting the significand, the\n          value is lost. This is an implementation decision that works around the\n          absence of standard half-float in the language. */\n        dataView.setUint16(0, ((valu32 & 0x80000000) >> 16) | /* sign bit */ (1 << (24 + logicalExponent)), false)\n      } else {\n        dataView.setUint16(0, ((valu32 & 0x80000000) >> 16) | ((logicalExponent + 15) << 10) | (mantissa >> 13), false)\n      }\n    }\n  }\n}\n\n/**\n * @param {Uint8Array} ui8a\n * @param {number} pos\n * @returns {number}\n */\nfunction readFloat16 (ui8a, pos) {\n  if (ui8a.length - pos < 2) {\n    throw new Error(`${decodeErrPrefix} not enough data for float16`)\n  }\n\n  const half = (ui8a[pos] << 8) + ui8a[pos + 1]\n  if (half === 0x7c00) {\n    return Infinity\n  }\n  if (half === 0xfc00) {\n    return -Infinity\n  }\n  if (half === 0x7e00) {\n    return NaN\n  }\n  const exp = (half >> 10) & 0x1f\n  const mant = half & 0x3ff\n  let val\n  if (exp === 0) {\n    val = mant * (2 ** -24)\n  } else if (exp !== 31) {\n    val = (mant + 1024) * (2 ** (exp - 25))\n  /* c8 ignore next 4 */\n  } else {\n    // may not be possible to get here\n    val = mant === 0 ? Infinity : NaN\n  }\n  return (half & 0x8000) ? -val : val\n}\n\n/**\n * @param {number} inp\n */\nfunction encodeFloat32 (inp) {\n  dataView.setFloat32(0, inp, false)\n}\n\n/**\n * @param {Uint8Array} ui8a\n * @param {number} pos\n * @returns {number}\n */\nfunction readFloat32 (ui8a, pos) {\n  if (ui8a.length - pos < 4) {\n    throw new Error(`${decodeErrPrefix} not enough data for float32`)\n  }\n  const offset = (ui8a.byteOffset || 0) + pos\n  return new DataView(ui8a.buffer, offset, 4).getFloat32(0, false)\n}\n\n/**\n * @param {number} inp\n */\nfunction encodeFloat64 (inp) {\n  dataView.setFloat64(0, inp, false)\n}\n\n/**\n * @param {Uint8Array} ui8a\n * @param {number} pos\n * @returns {number}\n */\nfunction readFloat64 (ui8a, pos) {\n  if (ui8a.length - pos < 8) {\n    throw new Error(`${decodeErrPrefix} not enough data for float64`)\n  }\n  const offset = (ui8a.byteOffset || 0) + pos\n  return new DataView(ui8a.buffer, offset, 8).getFloat64(0, false)\n}\n\n/**\n * @param {Token} _tok1\n * @param {Token} _tok2\n * @returns {number}\n */\nencodeFloat.compareTokens = encodeUint.compareTokens\n/*\nencodeFloat.compareTokens = function compareTokens (_tok1, _tok2) {\n  return _tok1\n  throw new Error(`${encodeErrPrefix} cannot use floats as map keys`)\n}\n*/\n", "import { Token, Type } from './token.js'\nimport * as uint from './0uint.js'\nimport * as negint from './1negint.js'\nimport * as bytes from './2bytes.js'\nimport * as string from './3string.js'\nimport * as array from './4array.js'\nimport * as map from './5map.js'\nimport * as tag from './6tag.js'\nimport * as float from './7float.js'\nimport { decodeErrPrefix } from './common.js'\nimport { fromArray } from './byte-utils.js'\n\n/**\n * @typedef {import('../interface').DecodeOptions} DecodeOptions\n */\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} minor\n */\nfunction invalidMinor (data, pos, minor) {\n  throw new Error(`${decodeErrPrefix} encountered invalid minor (${minor}) for major ${data[pos] >>> 5}`)\n}\n\n/**\n * @param {string} msg\n * @returns {()=>any}\n */\nfunction errorer (msg) {\n  return () => { throw new Error(`${decodeErrPrefix} ${msg}`) }\n}\n\n/** @type {((data:Uint8Array, pos:number, minor:number, options?:DecodeOptions) => any)[]} */\nexport const jump = []\n\n// unsigned integer, 0x00..0x17 (0..23)\nfor (let i = 0; i <= 0x17; i++) {\n  jump[i] = invalidMinor // uint.decodeUintCompact, handled by quick[]\n}\njump[0x18] = uint.decodeUint8 // unsigned integer, one-byte uint8_t follows\njump[0x19] = uint.decodeUint16 // unsigned integer, two-byte uint16_t follows\njump[0x1a] = uint.decodeUint32 // unsigned integer, four-byte uint32_t follows\njump[0x1b] = uint.decodeUint64 // unsigned integer, eight-byte uint64_t follows\njump[0x1c] = invalidMinor\njump[0x1d] = invalidMinor\njump[0x1e] = invalidMinor\njump[0x1f] = invalidMinor\n// negative integer, -1-0x00..-1-0x17 (-1..-24)\nfor (let i = 0x20; i <= 0x37; i++) {\n  jump[i] = invalidMinor // negintDecode, handled by quick[]\n}\njump[0x38] = negint.decodeNegint8 // negative integer, -1-n one-byte uint8_t for n follows\njump[0x39] = negint.decodeNegint16 // negative integer, -1-n two-byte uint16_t for n follows\njump[0x3a] = negint.decodeNegint32 // negative integer, -1-n four-byte uint32_t for follows\njump[0x3b] = negint.decodeNegint64 // negative integer, -1-n eight-byte uint64_t for follows\njump[0x3c] = invalidMinor\njump[0x3d] = invalidMinor\njump[0x3e] = invalidMinor\njump[0x3f] = invalidMinor\n// byte string, 0x00..0x17 bytes follow\nfor (let i = 0x40; i <= 0x57; i++) {\n  jump[i] = bytes.decodeBytesCompact\n}\njump[0x58] = bytes.decodeBytes8 // byte string, one-byte uint8_t for n, and then n bytes follow\njump[0x59] = bytes.decodeBytes16 // byte string, two-byte uint16_t for n, and then n bytes follow\njump[0x5a] = bytes.decodeBytes32 // byte string, four-byte uint32_t for n, and then n bytes follow\njump[0x5b] = bytes.decodeBytes64 // byte string, eight-byte uint64_t for n, and then n bytes follow\njump[0x5c] = invalidMinor\njump[0x5d] = invalidMinor\njump[0x5e] = invalidMinor\njump[0x5f] = errorer('indefinite length bytes/strings are not supported') // byte string, byte strings follow, terminated by \"break\"\n// UTF-8 string 0x00..0x17 bytes follow\nfor (let i = 0x60; i <= 0x77; i++) {\n  jump[i] = string.decodeStringCompact\n}\njump[0x78] = string.decodeString8 // UTF-8 string, one-byte uint8_t for n, and then n bytes follow\njump[0x79] = string.decodeString16 // UTF-8 string, two-byte uint16_t for n, and then n bytes follow\njump[0x7a] = string.decodeString32 // UTF-8 string, four-byte uint32_t for n, and then n bytes follow\njump[0x7b] = string.decodeString64 // UTF-8 string, eight-byte uint64_t for n, and then n bytes follow\njump[0x7c] = invalidMinor\njump[0x7d] = invalidMinor\njump[0x7e] = invalidMinor\njump[0x7f] = errorer('indefinite length bytes/strings are not supported') // UTF-8 strings follow, terminated by \"break\"\n// array, 0x00..0x17 data items follow\nfor (let i = 0x80; i <= 0x97; i++) {\n  jump[i] = array.decodeArrayCompact\n}\njump[0x98] = array.decodeArray8 // array, one-byte uint8_t for n, and then n data items follow\njump[0x99] = array.decodeArray16 // array, two-byte uint16_t for n, and then n data items follow\njump[0x9a] = array.decodeArray32 // array, four-byte uint32_t for n, and then n data items follow\njump[0x9b] = array.decodeArray64 // array, eight-byte uint64_t for n, and then n data items follow\njump[0x9c] = invalidMinor\njump[0x9d] = invalidMinor\njump[0x9e] = invalidMinor\njump[0x9f] = array.decodeArrayIndefinite // array, data items follow, terminated by \"break\"\n// map, 0x00..0x17 pairs of data items follow\nfor (let i = 0xa0; i <= 0xb7; i++) {\n  jump[i] = map.decodeMapCompact\n}\njump[0xb8] = map.decodeMap8 // map, one-byte uint8_t for n, and then n pairs of data items follow\njump[0xb9] = map.decodeMap16 // map, two-byte uint16_t for n, and then n pairs of data items follow\njump[0xba] = map.decodeMap32 // map, four-byte uint32_t for n, and then n pairs of data items follow\njump[0xbb] = map.decodeMap64 // map, eight-byte uint64_t for n, and then n pairs of data items follow\njump[0xbc] = invalidMinor\njump[0xbd] = invalidMinor\njump[0xbe] = invalidMinor\njump[0xbf] = map.decodeMapIndefinite // map, pairs of data items follow, terminated by \"break\"\n// tags\nfor (let i = 0xc0; i <= 0xd7; i++) {\n  jump[i] = tag.decodeTagCompact\n}\njump[0xd8] = tag.decodeTag8\njump[0xd9] = tag.decodeTag16\njump[0xda] = tag.decodeTag32\njump[0xdb] = tag.decodeTag64\njump[0xdc] = invalidMinor\njump[0xdd] = invalidMinor\njump[0xde] = invalidMinor\njump[0xdf] = invalidMinor\n// 0xe0..0xf3 simple values, unsupported\nfor (let i = 0xe0; i <= 0xf3; i++) {\n  jump[i] = errorer('simple values are not supported')\n}\njump[0xf4] = invalidMinor // false, handled by quick[]\njump[0xf5] = invalidMinor // true, handled by quick[]\njump[0xf6] = invalidMinor // null, handled by quick[]\njump[0xf7] = float.decodeUndefined // undefined\njump[0xf8] = errorer('simple values are not supported') // simple value, one byte follows, unsupported\njump[0xf9] = float.decodeFloat16 // half-precision float (two-byte IEEE 754)\njump[0xfa] = float.decodeFloat32 // single-precision float (four-byte IEEE 754)\njump[0xfb] = float.decodeFloat64 // double-precision float (eight-byte IEEE 754)\njump[0xfc] = invalidMinor\njump[0xfd] = invalidMinor\njump[0xfe] = invalidMinor\njump[0xff] = float.decodeBreak // \"break\" stop code\n\n/** @type {Token[]} */\nexport const quick = []\n// ints <24\nfor (let i = 0; i < 24; i++) {\n  quick[i] = new Token(Type.uint, i, 1)\n}\n// negints >= -24\nfor (let i = -1; i >= -24; i--) {\n  quick[31 - i] = new Token(Type.negint, i, 1)\n}\n// empty bytes\nquick[0x40] = new Token(Type.bytes, new Uint8Array(0), 1)\n// empty string\nquick[0x60] = new Token(Type.string, '', 1)\n// empty list\nquick[0x80] = new Token(Type.array, 0, 1)\n// empty map\nquick[0xa0] = new Token(Type.map, 0, 1)\n// false\nquick[0xf4] = new Token(Type.false, false, 1)\n// true\nquick[0xf5] = new Token(Type.true, true, 1)\n// null\nquick[0xf6] = new Token(Type.null, null, 1)\n\n/**\n * @param {Token} token\n * @returns {Uint8Array|undefined}\n */\nexport function quickEncodeToken (token) {\n  switch (token.type) {\n    case Type.false:\n      return fromArray([0xf4])\n    case Type.true:\n      return fromArray([0xf5])\n    case Type.null:\n      return fromArray([0xf6])\n    case Type.bytes:\n      if (!token.value.length) {\n        return fromArray([0x40])\n      }\n      return\n    case Type.string:\n      if (token.value === '') {\n        return fromArray([0x60])\n      }\n      return\n    case Type.array:\n      if (token.value === 0) {\n        return fromArray([0x80])\n      }\n      /* c8 ignore next 2 */\n      // shouldn't be possible if this were called when there was only one token\n      return\n    case Type.map:\n      if (token.value === 0) {\n        return fromArray([0xa0])\n      }\n      /* c8 ignore next 2 */\n      // shouldn't be possible if this were called when there was only one token\n      return\n    case Type.uint:\n      if (token.value < 24) {\n        return fromArray([Number(token.value)])\n      }\n      return\n    case Type.negint:\n      if (token.value >= -24) {\n        return fromArray([31 - Number(token.value)])\n      }\n  }\n}\n", "import { is } from './is.js'\nimport { Token, Type } from './token.js'\nimport { Bl } from './bl.js'\nimport { encodeErrPrefix } from './common.js'\nimport { quickEncodeToken } from './jump.js'\nimport { asU8A } from './byte-utils.js'\n\nimport { encodeUint } from './0uint.js'\nimport { encodeNegint } from './1negint.js'\nimport { encodeBytes } from './2bytes.js'\nimport { encodeString } from './3string.js'\nimport { encodeArray } from './4array.js'\nimport { encodeMap } from './5map.js'\nimport { encodeTag } from './6tag.js'\nimport { encodeFloat } from './7float.js'\n\n/**\n * @typedef {import('../interface').EncodeOptions} EncodeOptions\n * @typedef {import('../interface').OptionalTypeEncoder} OptionalTypeEncoder\n * @typedef {import('../interface').Reference} Reference\n * @typedef {import('../interface').StrictTypeEncoder} StrictTypeEncoder\n * @typedef {import('../interface').TokenTypeEncoder} TokenTypeEncoder\n * @typedef {import('../interface').TokenOrNestedTokens} TokenOrNestedTokens\n */\n\n/** @type {EncodeOptions} */\nconst defaultEncodeOptions = {\n  float64: false,\n  mapSorter,\n  quickEncodeToken\n}\n\n/** @returns {TokenTypeEncoder[]} */\nexport function makeCborEncoders () {\n  const encoders = []\n  encoders[Type.uint.major] = encodeUint\n  encoders[Type.negint.major] = encodeNegint\n  encoders[Type.bytes.major] = encodeBytes\n  encoders[Type.string.major] = encodeString\n  encoders[Type.array.major] = encodeArray\n  encoders[Type.map.major] = encodeMap\n  encoders[Type.tag.major] = encodeTag\n  encoders[Type.float.major] = encodeFloat\n  return encoders\n}\n\nconst cborEncoders = makeCborEncoders()\n\nconst buf = new Bl()\n\n/** @implements {Reference} */\nclass Ref {\n  /**\n   * @param {object|any[]} obj\n   * @param {Reference|undefined} parent\n   */\n  constructor (obj, parent) {\n    this.obj = obj\n    this.parent = parent\n  }\n\n  /**\n   * @param {object|any[]} obj\n   * @returns {boolean}\n   */\n  includes (obj) {\n    /** @type {Reference|undefined} */\n    let p = this\n    do {\n      if (p.obj === obj) {\n        return true\n      }\n    } while (p = p.parent) // eslint-disable-line\n    return false\n  }\n\n  /**\n   * @param {Reference|undefined} stack\n   * @param {object|any[]} obj\n   * @returns {Reference}\n   */\n  static createCheck (stack, obj) {\n    if (stack && stack.includes(obj)) {\n      throw new Error(`${encodeErrPrefix} object contains circular references`)\n    }\n    return new Ref(obj, stack)\n  }\n}\n\nconst simpleTokens = {\n  null: new Token(Type.null, null),\n  undefined: new Token(Type.undefined, undefined),\n  true: new Token(Type.true, true),\n  false: new Token(Type.false, false),\n  emptyArray: new Token(Type.array, 0),\n  emptyMap: new Token(Type.map, 0)\n}\n\n/** @type {{[typeName: string]: StrictTypeEncoder}} */\nconst typeEncoders = {\n  /**\n   * @param {any} obj\n   * @param {string} _typ\n   * @param {EncodeOptions} _options\n   * @param {Reference} [_refStack]\n   * @returns {TokenOrNestedTokens}\n   */\n  number (obj, _typ, _options, _refStack) {\n    if (!Number.isInteger(obj) || !Number.isSafeInteger(obj)) {\n      return new Token(Type.float, obj)\n    } else if (obj >= 0) {\n      return new Token(Type.uint, obj)\n    } else {\n      return new Token(Type.negint, obj)\n    }\n  },\n\n  /**\n   * @param {any} obj\n   * @param {string} _typ\n   * @param {EncodeOptions} _options\n   * @param {Reference} [_refStack]\n   * @returns {TokenOrNestedTokens}\n   */\n  bigint (obj, _typ, _options, _refStack) {\n    if (obj >= BigInt(0)) {\n      return new Token(Type.uint, obj)\n    } else {\n      return new Token(Type.negint, obj)\n    }\n  },\n\n  /**\n   * @param {any} obj\n   * @param {string} _typ\n   * @param {EncodeOptions} _options\n   * @param {Reference} [_refStack]\n   * @returns {TokenOrNestedTokens}\n   */\n  Uint8Array (obj, _typ, _options, _refStack) {\n    return new Token(Type.bytes, obj)\n  },\n\n  /**\n   * @param {any} obj\n   * @param {string} _typ\n   * @param {EncodeOptions} _options\n   * @param {Reference} [_refStack]\n   * @returns {TokenOrNestedTokens}\n   */\n  string (obj, _typ, _options, _refStack) {\n    return new Token(Type.string, obj)\n  },\n\n  /**\n   * @param {any} obj\n   * @param {string} _typ\n   * @param {EncodeOptions} _options\n   * @param {Reference} [_refStack]\n   * @returns {TokenOrNestedTokens}\n   */\n  boolean (obj, _typ, _options, _refStack) {\n    return obj ? simpleTokens.true : simpleTokens.false\n  },\n\n  /**\n   * @param {any} _obj\n   * @param {string} _typ\n   * @param {EncodeOptions} _options\n   * @param {Reference} [_refStack]\n   * @returns {TokenOrNestedTokens}\n   */\n  null (_obj, _typ, _options, _refStack) {\n    return simpleTokens.null\n  },\n\n  /**\n   * @param {any} _obj\n   * @param {string} _typ\n   * @param {EncodeOptions} _options\n   * @param {Reference} [_refStack]\n   * @returns {TokenOrNestedTokens}\n   */\n  undefined (_obj, _typ, _options, _refStack) {\n    return simpleTokens.undefined\n  },\n\n  /**\n   * @param {any} obj\n   * @param {string} _typ\n   * @param {EncodeOptions} _options\n   * @param {Reference} [_refStack]\n   * @returns {TokenOrNestedTokens}\n   */\n  ArrayBuffer (obj, _typ, _options, _refStack) {\n    return new Token(Type.bytes, new Uint8Array(obj))\n  },\n\n  /**\n   * @param {any} obj\n   * @param {string} _typ\n   * @param {EncodeOptions} _options\n   * @param {Reference} [_refStack]\n   * @returns {TokenOrNestedTokens}\n   */\n  DataView (obj, _typ, _options, _refStack) {\n    return new Token(Type.bytes, new Uint8Array(obj.buffer, obj.byteOffset, obj.byteLength))\n  },\n\n  /**\n   * @param {any} obj\n   * @param {string} _typ\n   * @param {EncodeOptions} options\n   * @param {Reference} [refStack]\n   * @returns {TokenOrNestedTokens}\n   */\n  Array (obj, _typ, options, refStack) {\n    if (!obj.length) {\n      if (options.addBreakTokens === true) {\n        return [simpleTokens.emptyArray, new Token(Type.break)]\n      }\n      return simpleTokens.emptyArray\n    }\n    refStack = Ref.createCheck(refStack, obj)\n    const entries = []\n    let i = 0\n    for (const e of obj) {\n      entries[i++] = objectToTokens(e, options, refStack)\n    }\n    if (options.addBreakTokens) {\n      return [new Token(Type.array, obj.length), entries, new Token(Type.break)]\n    }\n    return [new Token(Type.array, obj.length), entries]\n  },\n\n  /**\n   * @param {any} obj\n   * @param {string} typ\n   * @param {EncodeOptions} options\n   * @param {Reference} [refStack]\n   * @returns {TokenOrNestedTokens}\n   */\n  Object (obj, typ, options, refStack) {\n    // could be an Object or a Map\n    const isMap = typ !== 'Object'\n    // it's slightly quicker to use Object.keys() than Object.entries()\n    const keys = isMap ? obj.keys() : Object.keys(obj)\n    const length = isMap ? obj.size : keys.length\n    if (!length) {\n      if (options.addBreakTokens === true) {\n        return [simpleTokens.emptyMap, new Token(Type.break)]\n      }\n      return simpleTokens.emptyMap\n    }\n    refStack = Ref.createCheck(refStack, obj)\n    /** @type {TokenOrNestedTokens[]} */\n    const entries = []\n    let i = 0\n    for (const key of keys) {\n      entries[i++] = [\n        objectToTokens(key, options, refStack),\n        objectToTokens(isMap ? obj.get(key) : obj[key], options, refStack)\n      ]\n    }\n    sortMapEntries(entries, options)\n    if (options.addBreakTokens) {\n      return [new Token(Type.map, length), entries, new Token(Type.break)]\n    }\n    return [new Token(Type.map, length), entries]\n  }\n}\n\ntypeEncoders.Map = typeEncoders.Object\ntypeEncoders.Buffer = typeEncoders.Uint8Array\nfor (const typ of 'Uint8Clamped Uint16 Uint32 Int8 Int16 Int32 BigUint64 BigInt64 Float32 Float64'.split(' ')) {\n  typeEncoders[`${typ}Array`] = typeEncoders.DataView\n}\n\n/**\n * @param {any} obj\n * @param {EncodeOptions} [options]\n * @param {Reference} [refStack]\n * @returns {TokenOrNestedTokens}\n */\nfunction objectToTokens (obj, options = {}, refStack) {\n  const typ = is(obj)\n  const customTypeEncoder = (options && options.typeEncoders && /** @type {OptionalTypeEncoder} */ options.typeEncoders[typ]) || typeEncoders[typ]\n  if (typeof customTypeEncoder === 'function') {\n    const tokens = customTypeEncoder(obj, typ, options, refStack)\n    if (tokens != null) {\n      return tokens\n    }\n  }\n  const typeEncoder = typeEncoders[typ]\n  if (!typeEncoder) {\n    throw new Error(`${encodeErrPrefix} unsupported type: ${typ}`)\n  }\n  return typeEncoder(obj, typ, options, refStack)\n}\n\n/*\nCBOR key sorting is a mess.\n\nThe canonicalisation recommendation from https://tools.ietf.org/html/rfc7049#section-3.9\nincludes the wording:\n\n> The keys in every map must be sorted lowest value to highest.\n> Sorting is performed on the bytes of the representation of the key\n> data items without paying attention to the 3/5 bit splitting for\n> major types.\n> ...\n>  *  If two keys have different lengths, the shorter one sorts\n      earlier;\n>  *  If two keys have the same length, the one with the lower value\n      in (byte-wise) lexical order sorts earlier.\n\n1. It is not clear what \"bytes of the representation of the key\" means: is it\n   the CBOR representation, or the binary representation of the object itself?\n   Consider the int and uint difference here.\n2. It is not clear what \"without paying attention to\" means: do we include it\n   and compare on that? Or do we omit the special prefix byte, (mostly) treating\n   the key in its plain binary representation form.\n\nThe FIDO 2.0: Client To Authenticator Protocol spec takes the original CBOR\nwording and clarifies it according to their understanding.\nhttps://fidoalliance.org/specs/fido-v2.0-rd-20170927/fido-client-to-authenticator-protocol-v2.0-rd-20170927.html#message-encoding\n\n> The keys in every map must be sorted lowest value to highest. Sorting is\n> performed on the bytes of the representation of the key data items without\n> paying attention to the 3/5 bit splitting for major types. The sorting rules\n> are:\n>  * If the major types are different, the one with the lower value in numerical\n>    order sorts earlier.\n>  * If two keys have different lengths, the shorter one sorts earlier;\n>  * If two keys have the same length, the one with the lower value in\n>    (byte-wise) lexical order sorts earlier.\n\nSome other implementations, such as borc, do a full encode then do a\nlength-first, byte-wise-second comparison:\nhttps://github.com/dignifiedquire/borc/blob/b6bae8b0bcde7c3976b0f0f0957208095c392a36/src/encoder.js#L358\nhttps://github.com/dignifiedquire/borc/blob/b6bae8b0bcde7c3976b0f0f0957208095c392a36/src/utils.js#L143-L151\n\nThis has the benefit of being able to easily handle arbitrary keys, including\ncomplex types (maps and arrays).\n\nWe'll opt for the FIDO approach, since it affords some efficies since we don't\nneed a full encode of each key to determine order and can defer to the types\nto determine how to most efficiently order their values (i.e. int and uint\nordering can be done on the numbers, no need for byte-wise, for example).\n\nRecommendation: stick to single key types or you'll get into trouble, and prefer\nstring keys because it's much simpler that way.\n*/\n\n/*\n(UPDATE, Dec 2020)\nhttps://tools.ietf.org/html/rfc8949 is the updated CBOR spec and clarifies some\nof the questions above with a new recommendation for sorting order being much\ncloser to what would be expected in other environments (i.e. no length-first\nweirdness).\nThis new sorting order is not yet implemented here but could be added as an\noption. \"Determinism\" (canonicity) is system dependent and it's difficult to\nchange existing systems that are built with existing expectations. So if a new\nordering is introduced here, the old needs to be kept as well with the user\nhaving the option.\n*/\n\n/**\n * @param {TokenOrNestedTokens[]} entries\n * @param {EncodeOptions} options\n */\nfunction sortMapEntries (entries, options) {\n  if (options.mapSorter) {\n    entries.sort(options.mapSorter)\n  }\n}\n\n/**\n * @param {(Token|Token[])[]} e1\n * @param {(Token|Token[])[]} e2\n * @returns {number}\n */\nfunction mapSorter (e1, e2) {\n  // the key position ([0]) could have a single token or an array\n  // almost always it'll be a single token but complex key might get involved\n  /* c8 ignore next 2 */\n  const keyToken1 = Array.isArray(e1[0]) ? e1[0][0] : e1[0]\n  const keyToken2 = Array.isArray(e2[0]) ? e2[0][0] : e2[0]\n\n  // different key types\n  if (keyToken1.type !== keyToken2.type) {\n    return keyToken1.type.compare(keyToken2.type)\n  }\n\n  const major = keyToken1.type.major\n  // TODO: handle case where cmp === 0 but there are more keyToken e. complex type)\n  const tcmp = cborEncoders[major].compareTokens(keyToken1, keyToken2)\n  /* c8 ignore next 5 */\n  if (tcmp === 0) {\n    // duplicate key or complex type where the first token matched,\n    // i.e. a map or array and we're only comparing the opening token\n    console.warn('WARNING: complex key types used, CBOR key sorting guarantees are gone')\n  }\n  return tcmp\n}\n\n/**\n * @param {Bl} buf\n * @param {TokenOrNestedTokens} tokens\n * @param {TokenTypeEncoder[]} encoders\n * @param {EncodeOptions} options\n */\nfunction tokensToEncoded (buf, tokens, encoders, options) {\n  if (Array.isArray(tokens)) {\n    for (const token of tokens) {\n      tokensToEncoded(buf, token, encoders, options)\n    }\n  } else {\n    encoders[tokens.type.major](buf, tokens, options)\n  }\n}\n\n/**\n * @param {any} data\n * @param {TokenTypeEncoder[]} encoders\n * @param {EncodeOptions} options\n * @returns {Uint8Array}\n */\nfunction encodeCustom (data, encoders, options) {\n  const tokens = objectToTokens(data, options)\n  if (!Array.isArray(tokens) && options.quickEncodeToken) {\n    const quickBytes = options.quickEncodeToken(tokens)\n    if (quickBytes) {\n      return quickBytes\n    }\n    const encoder = encoders[tokens.type.major]\n    if (encoder.encodedSize) {\n      const size = encoder.encodedSize(tokens, options)\n      const buf = new Bl(size)\n      encoder(buf, tokens, options)\n      /* c8 ignore next 4 */\n      // this would be a problem with encodedSize() functions\n      if (buf.chunks.length !== 1) {\n        throw new Error(`Unexpected error: pre-calculated length for ${tokens} was wrong`)\n      }\n      return asU8A(buf.chunks[0])\n    }\n  }\n  buf.reset()\n  tokensToEncoded(buf, tokens, encoders, options)\n  return buf.toBytes(true)\n}\n\n/**\n * @param {any} data\n * @param {EncodeOptions} [options]\n * @returns {Uint8Array}\n */\nfunction encode (data, options) {\n  options = Object.assign({}, defaultEncodeOptions, options)\n  return encodeCustom(data, cborEncoders, options)\n}\n\nexport { objectToTokens, encode, encodeCustom, Ref }\n", "import { decodeErrPrefix } from './common.js'\nimport { Type } from './token.js'\nimport { jump, quick } from './jump.js'\n\n/**\n * @typedef {import('./token.js').Token} Token\n * @typedef {import('../interface').DecodeOptions} DecodeOptions\n * @typedef {import('../interface').DecodeTokenizer} DecodeTokenizer\n */\n\nconst defaultDecodeOptions = {\n  strict: false,\n  allowIndefinite: true,\n  allowUndefined: true,\n  allowBigInt: true\n}\n\n/**\n * @implements {DecodeTokenizer}\n */\nclass Tokeniser {\n  /**\n   * @param {Uint8Array} data\n   * @param {DecodeOptions} options\n   */\n  constructor (data, options = {}) {\n    this._pos = 0\n    this.data = data\n    this.options = options\n  }\n\n  pos () {\n    return this._pos\n  }\n\n  done () {\n    return this._pos >= this.data.length\n  }\n\n  next () {\n    const byt = this.data[this._pos]\n    let token = quick[byt]\n    if (token === undefined) {\n      const decoder = jump[byt]\n      /* c8 ignore next 4 */\n      // if we're here then there's something wrong with our jump or quick lists!\n      if (!decoder) {\n        throw new Error(`${decodeErrPrefix} no decoder for major type ${byt >>> 5} (byte 0x${byt.toString(16).padStart(2, '0')})`)\n      }\n      const minor = byt & 31\n      token = decoder(this.data, this._pos, minor, this.options)\n    }\n    // @ts-ignore we get to assume encodedLength is set (crossing fingers slightly)\n    this._pos += token.encodedLength\n    return token\n  }\n}\n\nconst DONE = Symbol.for('DONE')\nconst BREAK = Symbol.for('BREAK')\n\n/**\n * @param {Token} token\n * @param {DecodeTokenizer} tokeniser\n * @param {DecodeOptions} options\n * @returns {any|BREAK|DONE}\n */\nfunction tokenToArray (token, tokeniser, options) {\n  const arr = []\n  for (let i = 0; i < token.value; i++) {\n    const value = tokensToObject(tokeniser, options)\n    if (value === BREAK) {\n      if (token.value === Infinity) {\n        // normal end to indefinite length array\n        break\n      }\n      throw new Error(`${decodeErrPrefix} got unexpected break to lengthed array`)\n    }\n    if (value === DONE) {\n      throw new Error(`${decodeErrPrefix} found array but not enough entries (got ${i}, expected ${token.value})`)\n    }\n    arr[i] = value\n  }\n  return arr\n}\n\n/**\n * @param {Token} token\n * @param {DecodeTokenizer} tokeniser\n * @param {DecodeOptions} options\n * @returns {any|BREAK|DONE}\n */\nfunction tokenToMap (token, tokeniser, options) {\n  const useMaps = options.useMaps === true\n  const obj = useMaps ? undefined : {}\n  const m = useMaps ? new Map() : undefined\n  for (let i = 0; i < token.value; i++) {\n    const key = tokensToObject(tokeniser, options)\n    if (key === BREAK) {\n      if (token.value === Infinity) {\n        // normal end to indefinite length map\n        break\n      }\n      throw new Error(`${decodeErrPrefix} got unexpected break to lengthed map`)\n    }\n    if (key === DONE) {\n      throw new Error(`${decodeErrPrefix} found map but not enough entries (got ${i} [no key], expected ${token.value})`)\n    }\n    if (useMaps !== true && typeof key !== 'string') {\n      throw new Error(`${decodeErrPrefix} non-string keys not supported (got ${typeof key})`)\n    }\n    if (options.rejectDuplicateMapKeys === true) {\n      // @ts-ignore\n      if ((useMaps && m.has(key)) || (!useMaps && (key in obj))) {\n        throw new Error(`${decodeErrPrefix} found repeat map key \"${key}\"`)\n      }\n    }\n    const value = tokensToObject(tokeniser, options)\n    if (value === DONE) {\n      throw new Error(`${decodeErrPrefix} found map but not enough entries (got ${i} [no value], expected ${token.value})`)\n    }\n    if (useMaps) {\n      // @ts-ignore TODO reconsider this .. maybe needs to be strict about key types\n      m.set(key, value)\n    } else {\n      // @ts-ignore TODO reconsider this .. maybe needs to be strict about key types\n      obj[key] = value\n    }\n  }\n  // @ts-ignore c'mon man\n  return useMaps ? m : obj\n}\n\n/**\n * @param {DecodeTokenizer} tokeniser\n * @param {DecodeOptions} options\n * @returns {any|BREAK|DONE}\n */\nfunction tokensToObject (tokeniser, options) {\n  // should we support array as an argument?\n  // check for tokenIter[Symbol.iterator] and replace tokenIter with what that returns?\n  if (tokeniser.done()) {\n    return DONE\n  }\n\n  const token = tokeniser.next()\n\n  if (token.type === Type.break) {\n    return BREAK\n  }\n\n  if (token.type.terminal) {\n    return token.value\n  }\n\n  if (token.type === Type.array) {\n    return tokenToArray(token, tokeniser, options)\n  }\n\n  if (token.type === Type.map) {\n    return tokenToMap(token, tokeniser, options)\n  }\n\n  if (token.type === Type.tag) {\n    if (options.tags && typeof options.tags[token.value] === 'function') {\n      const tagged = tokensToObject(tokeniser, options)\n      return options.tags[token.value](tagged)\n    }\n    throw new Error(`${decodeErrPrefix} tag not supported (${token.value})`)\n  }\n  /* c8 ignore next */\n  throw new Error('unsupported')\n}\n\n/**\n * @param {Uint8Array} data\n * @param {DecodeOptions} [options]\n * @returns {[any, Uint8Array]}\n */\nfunction decodeFirst (data, options) {\n  if (!(data instanceof Uint8Array)) {\n    throw new Error(`${decodeErrPrefix} data to decode must be a Uint8Array`)\n  }\n  options = Object.assign({}, defaultDecodeOptions, options)\n  const tokeniser = options.tokenizer || new Tokeniser(data, options)\n  const decoded = tokensToObject(tokeniser, options)\n  if (decoded === DONE) {\n    throw new Error(`${decodeErrPrefix} did not find any content to decode`)\n  }\n  if (decoded === BREAK) {\n    throw new Error(`${decodeErrPrefix} got unexpected break`)\n  }\n  return [decoded, data.subarray(tokeniser.pos())]\n}\n\n/**\n * @param {Uint8Array} data\n * @param {DecodeOptions} [options]\n * @returns {any}\n */\nfunction decode (data, options) {\n  const [decoded, remainder] = decodeFirst(data, options)\n  if (remainder.length > 0) {\n    throw new Error(`${decodeErrPrefix} too many terminals, data makes no sense`)\n  }\n  return decoded\n}\n\nexport { Tokeniser, tokensToObject, decode, decodeFirst }\n", "import * as cborg from 'cborg'\nimport { CID } from 'multiformats/cid'\n\n// https://github.com/ipfs/go-ipfs/issues/3570#issuecomment-273931692\nconst CID_CBOR_TAG = 42\n\n/**\n * @template T\n * @typedef {import('multiformats/codecs/interface').ByteView<T>} ByteView\n */\n\n/**\n * @template T\n * @typedef {import('multiformats/codecs/interface').ArrayBufferView<T>} ArrayBufferView\n */\n\n/**\n * @template T\n * @param {ByteView<T> | ArrayBufferView<T>} buf\n * @returns {ByteView<T>}\n */\nexport function toByteView (buf) {\n  if (buf instanceof ArrayBuffer) {\n    return new Uint8Array(buf, 0, buf.byteLength)\n  }\n\n  return buf\n}\n\n/**\n * cidEncoder will receive all Objects during encode, it needs to filter out\n * anything that's not a CID and return `null` for that so it's encoded as\n * normal.\n *\n * @param {any} obj\n * @returns {cborg.Token[]|null}\n */\nfunction cidEncoder (obj) {\n  if (obj.asCID !== obj && obj['/'] !== obj.bytes) {\n    return null // any other kind of object\n  }\n  const cid = CID.asCID(obj)\n  /* c8 ignore next 4 */\n  // very unlikely case, and it'll probably throw a recursion error in cborg\n  if (!cid) {\n    return null\n  }\n  const bytes = new Uint8Array(cid.bytes.byteLength + 1)\n  bytes.set(cid.bytes, 1) // prefix is 0x00, for historical reasons\n  return [\n    new cborg.Token(cborg.Type.tag, CID_CBOR_TAG),\n    new cborg.Token(cborg.Type.bytes, bytes)\n  ]\n}\n\n// eslint-disable-next-line jsdoc/require-returns-check\n/**\n * Intercept all `undefined` values from an object walk and reject the entire\n * object if we find one.\n *\n * @returns {null}\n */\nfunction undefinedEncoder () {\n  throw new Error('`undefined` is not supported by the IPLD Data Model and cannot be encoded')\n}\n\n/**\n * Intercept all `number` values from an object walk and reject the entire\n * object if we find something that doesn't fit the IPLD data model (NaN &\n * Infinity).\n *\n * @param {number} num\n * @returns {null}\n */\nfunction numberEncoder (num) {\n  if (Number.isNaN(num)) {\n    throw new Error('`NaN` is not supported by the IPLD Data Model and cannot be encoded')\n  }\n  if (num === Infinity || num === -Infinity) {\n    throw new Error('`Infinity` and `-Infinity` is not supported by the IPLD Data Model and cannot be encoded')\n  }\n  return null\n}\n\nconst _encodeOptions = {\n  float64: true,\n  typeEncoders: {\n    Object: cidEncoder,\n    undefined: undefinedEncoder,\n    number: numberEncoder\n  }\n}\n\nexport const encodeOptions = {\n  ..._encodeOptions,\n  typeEncoders: {\n    ..._encodeOptions.typeEncoders\n  }\n}\n\n/**\n * @param {Uint8Array} bytes\n * @returns {CID}\n */\nfunction cidDecoder (bytes) {\n  if (bytes[0] !== 0) {\n    throw new Error('Invalid CID for CBOR tag 42; expected leading 0x00')\n  }\n  return CID.decode(bytes.subarray(1)) // ignore leading 0x00\n}\n\nconst _decodeOptions = {\n  allowIndefinite: false,\n  coerceUndefinedToNull: true,\n  allowNaN: false,\n  allowInfinity: false,\n  allowBigInt: true, // this will lead to BigInt for ints outside of\n  // safe-integer range, which may surprise users\n  strict: true,\n  useMaps: false,\n  rejectDuplicateMapKeys: true,\n  /** @type {import('cborg').TagDecoder[]} */\n  tags: []\n}\n_decodeOptions.tags[CID_CBOR_TAG] = cidDecoder\n\nexport const decodeOptions = {\n  ..._decodeOptions,\n  tags: _decodeOptions.tags.slice()\n}\n\nexport const name = 'dag-cbor'\nexport const code = 0x71\n\n/**\n * @template T\n * @param {T} node\n * @returns {ByteView<T>}\n */\nexport const encode = (node) => cborg.encode(node, _encodeOptions)\n\n/**\n * @template T\n * @param {ByteView<T> | ArrayBufferView<T>} data\n * @returns {T}\n */\nexport const decode = (data) => cborg.decode(toByteView(data), _decodeOptions)\n", "import { Type } from '../token.js'\nimport { encodeCustom } from '../encode.js'\nimport { encodeErrPrefix } from '../common.js'\nimport { asU8A, fromString } from '../byte-utils.js'\n\n/**\n * @typedef {import('../../interface').EncodeOptions} EncodeOptions\n * @typedef {import('../token').Token} Token\n * @typedef {import('../bl').Bl} Bl\n */\n\nclass JSONEncoder extends Array {\n  constructor () {\n    super()\n    /** @type {{type:Type,elements:number}[]} */\n    this.inRecursive = []\n  }\n\n  /**\n   * @param {Bl} buf\n   */\n  prefix (buf) {\n    const recurs = this.inRecursive[this.inRecursive.length - 1]\n    if (recurs) {\n      if (recurs.type === Type.array) {\n        recurs.elements++\n        if (recurs.elements !== 1) { // >first\n          buf.push([44]) // ','\n        }\n      }\n      if (recurs.type === Type.map) {\n        recurs.elements++\n        if (recurs.elements !== 1) { // >first\n          if (recurs.elements % 2 === 1) { // key\n            buf.push([44]) // ','\n          } else {\n            buf.push([58]) // ':'\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * @param {Bl} buf\n   * @param {Token} token\n   */\n  [Type.uint.major] (buf, token) {\n    this.prefix(buf)\n    const is = String(token.value)\n    const isa = []\n    for (let i = 0; i < is.length; i++) {\n      isa[i] = is.charCodeAt(i)\n    }\n    buf.push(isa)\n  }\n\n  /**\n   * @param {Bl} buf\n   * @param {Token} token\n   */\n  [Type.negint.major] (buf, token) {\n    // @ts-ignore hack\n    this[Type.uint.major](buf, token)\n  }\n\n  /**\n   * @param {Bl} _buf\n   * @param {Token} _token\n   */\n  [Type.bytes.major] (_buf, _token) {\n    throw new Error(`${encodeErrPrefix} unsupported type: Uint8Array`)\n  }\n\n  /**\n   * @param {Bl} buf\n   * @param {Token} token\n   */\n  [Type.string.major] (buf, token) {\n    this.prefix(buf)\n    // buf.push(34) // '\"'\n    // encodeUtf8(token.value, byts)\n    // buf.push(34) // '\"'\n    const byts = fromString(JSON.stringify(token.value))\n    buf.push(byts.length > 32 ? asU8A(byts) : byts)\n  }\n\n  /**\n   * @param {Bl} buf\n   * @param {Token} _token\n   */\n  [Type.array.major] (buf, _token) {\n    this.prefix(buf)\n    this.inRecursive.push({ type: Type.array, elements: 0 })\n    buf.push([91]) // '['\n  }\n\n  /**\n   * @param {Bl} buf\n   * @param {Token} _token\n   */\n  [Type.map.major] (buf, _token) {\n    this.prefix(buf)\n    this.inRecursive.push({ type: Type.map, elements: 0 })\n    buf.push([123]) // '{'\n  }\n\n  /**\n   * @param {Bl} _buf\n   * @param {Token} _token\n   */\n  [Type.tag.major] (_buf, _token) {}\n\n  /**\n   * @param {Bl} buf\n   * @param {Token} token\n   */\n  [Type.float.major] (buf, token) {\n    if (token.type.name === 'break') {\n      const recurs = this.inRecursive.pop()\n      if (recurs) {\n        if (recurs.type === Type.array) {\n          buf.push([93]) // ']'\n        } else if (recurs.type === Type.map) {\n          buf.push([125]) // '}'\n        /* c8 ignore next 3 */\n        } else {\n          throw new Error('Unexpected recursive type; this should not happen!')\n        }\n        return\n      }\n      /* c8 ignore next 2 */\n      throw new Error('Unexpected break; this should not happen!')\n    }\n    if (token.value === undefined) {\n      throw new Error(`${encodeErrPrefix} unsupported type: undefined`)\n    }\n\n    this.prefix(buf)\n    if (token.type.name === 'true') {\n      buf.push([116, 114, 117, 101]) // 'true'\n      return\n    } else if (token.type.name === 'false') {\n      buf.push([102, 97, 108, 115, 101]) // 'false'\n      return\n    } else if (token.type.name === 'null') {\n      buf.push([110, 117, 108, 108]) // 'null'\n      return\n    }\n\n    // number\n    const is = String(token.value)\n    const isa = []\n    let dp = false\n    for (let i = 0; i < is.length; i++) {\n      isa[i] = is.charCodeAt(i)\n      if (!dp && (isa[i] === 46 || isa[i] === 101 || isa[i] === 69)) { // '[.eE]'\n        dp = true\n      }\n    }\n    if (!dp) { // need a decimal point for floats\n      isa.push(46) // '.'\n      isa.push(48) // '0'\n    }\n    buf.push(isa)\n  }\n}\n\n// The below code is mostly taken and modified from https://github.com/feross/buffer\n// Licensed MIT. Copyright (c) Feross Aboukhadijeh\n// function encodeUtf8 (string, byts) {\n//   let codePoint\n//   const length = string.length\n//   let leadSurrogate = null\n\n//   for (let i = 0; i < length; ++i) {\n//     codePoint = string.charCodeAt(i)\n\n//     // is surrogate component\n//     if (codePoint > 0xd7ff && codePoint < 0xe000) {\n//       // last char was a lead\n//       if (!leadSurrogate) {\n//         // no lead yet\n//         /* c8 ignore next 9 */\n//         if (codePoint > 0xdbff) {\n//           // unexpected trail\n//           byts.push(0xef, 0xbf, 0xbd)\n//           continue\n//         } else if (i + 1 === length) {\n//           // unpaired lead\n//           byts.push(0xef, 0xbf, 0xbd)\n//           continue\n//         }\n\n//         // valid lead\n//         leadSurrogate = codePoint\n\n//         continue\n//       }\n\n//       // 2 leads in a row\n//       /* c8 ignore next 5 */\n//       if (codePoint < 0xdc00) {\n//         byts.push(0xef, 0xbf, 0xbd)\n//         leadSurrogate = codePoint\n//         continue\n//       }\n\n//       // valid surrogate pair\n//       codePoint = (leadSurrogate - 0xd800 << 10 | codePoint - 0xdc00) + 0x10000\n//     /* c8 ignore next 4 */\n//     } else if (leadSurrogate) {\n//       // valid bmp char, but last char was a lead\n//       byts.push(0xef, 0xbf, 0xbd)\n//     }\n\n//     leadSurrogate = null\n\n//     // encode utf8\n//     if (codePoint < 0x80) {\n//       // special JSON escapes\n//       switch (codePoint) {\n//         case 8: // '\\b'\n//           byts.push(92, 98) // '\\\\b'\n//           continue\n//         case 9: // '\\t'\n//           byts.push(92, 116) // '\\\\t'\n//           continue\n//         case 10: // '\\n'\n//           byts.push(92, 110) // '\\\\n'\n//           continue\n//         case 12: // '\\f'\n//           byts.push(92, 102) // '\\\\f'\n//           continue\n//         case 13: // '\\r'\n//           byts.push(92, 114) // '\\\\r'\n//           continue\n//         case 34: // '\"'\n//           byts.push(92, 34) // '\\\\\"'\n//           continue\n//         case 92: // '\\\\'\n//           byts.push(92, 92) // '\\\\\\\\'\n//           continue\n//       }\n\n//       byts.push(codePoint)\n//     } else if (codePoint < 0x800) {\n//       /* c8 ignore next 1 */\n//       byts.push(\n//         codePoint >> 0x6 | 0xc0,\n//         codePoint & 0x3f | 0x80\n//       )\n//     } else if (codePoint < 0x10000) {\n//       /* c8 ignore next 1 */\n//       byts.push(\n//         codePoint >> 0xc | 0xe0,\n//         codePoint >> 0x6 & 0x3f | 0x80,\n//         codePoint & 0x3f | 0x80\n//       )\n//     /* c8 ignore next 9 */\n//     } else if (codePoint < 0x110000) {\n//       byts.push(\n//         codePoint >> 0x12 | 0xf0,\n//         codePoint >> 0xc & 0x3f | 0x80,\n//         codePoint >> 0x6 & 0x3f | 0x80,\n//         codePoint & 0x3f | 0x80\n//       )\n//     } else {\n//       /* c8 ignore next 2 */\n//       throw new Error('Invalid code point')\n//     }\n//   }\n// }\n\n/**\n * @param {(Token|Token[])[]} e1\n * @param {(Token|Token[])[]} e2\n * @returns {number}\n */\nfunction mapSorter (e1, e2) {\n  if (Array.isArray(e1[0]) || Array.isArray(e2[0])) {\n    throw new Error(`${encodeErrPrefix} complex map keys are not supported`)\n  }\n  const keyToken1 = e1[0]\n  const keyToken2 = e2[0]\n  if (keyToken1.type !== Type.string || keyToken2.type !== Type.string) {\n    throw new Error(`${encodeErrPrefix} non-string map keys are not supported`)\n  }\n  if (keyToken1 < keyToken2) {\n    return -1\n  }\n  if (keyToken1 > keyToken2) {\n    return 1\n  }\n  /* c8 ignore next 1 */\n  throw new Error(`${encodeErrPrefix} unexpected duplicate map keys, this is not supported`)\n}\n\nconst defaultEncodeOptions = { addBreakTokens: true, mapSorter }\n\n/**\n * @param {any} data\n * @param {EncodeOptions} [options]\n * @returns {Uint8Array}\n */\nfunction encode (data, options) {\n  options = Object.assign({}, defaultEncodeOptions, options)\n  // @ts-ignore TokenTypeEncoder[] requires compareTokens() on each encoder, we don't use them here\n  return encodeCustom(data, new JSONEncoder(), options)\n}\n\nexport { encode }\n", "import { decode as _decode, decodeFirst as _decodeFirst } from '../decode.js'\nimport { Token, Type } from '../token.js'\nimport { decodeCodePointsArray } from '../byte-utils.js'\nimport { decodeErrPrefix } from '../common.js'\n\n/**\n * @typedef {import('../../interface').DecodeOptions} DecodeOptions\n * @typedef {import('../../interface').DecodeTokenizer} DecodeTokenizer\n */\n\n/**\n * @implements {DecodeTokenizer}\n */\nclass Tokenizer {\n  /**\n   * @param {Uint8Array} data\n   * @param {DecodeOptions} options\n   */\n  constructor (data, options = {}) {\n    this._pos = 0\n    this.data = data\n    this.options = options\n    /** @type {string[]} */\n    this.modeStack = ['value']\n    this.lastToken = ''\n  }\n\n  pos () {\n    return this._pos\n  }\n\n  /**\n   * @returns {boolean}\n   */\n  done () {\n    return this._pos >= this.data.length\n  }\n\n  /**\n   * @returns {number}\n   */\n  ch () {\n    return this.data[this._pos]\n  }\n\n  /**\n   * @returns {string}\n   */\n  currentMode () {\n    return this.modeStack[this.modeStack.length - 1]\n  }\n\n  skipWhitespace () {\n    let c = this.ch()\n    // @ts-ignore\n    while (c === 32 /* ' ' */ || c === 9 /* '\\t' */ || c === 13 /* '\\r' */ || c === 10 /* '\\n' */) {\n      c = this.data[++this._pos]\n    }\n  }\n\n  /**\n   * @param {number[]} str\n   */\n  expect (str) {\n    if (this.data.length - this._pos < str.length) {\n      throw new Error(`${decodeErrPrefix} unexpected end of input at position ${this._pos}`)\n    }\n    for (let i = 0; i < str.length; i++) {\n      if (this.data[this._pos++] !== str[i]) {\n        throw new Error(`${decodeErrPrefix} unexpected token at position ${this._pos}, expected to find '${String.fromCharCode(...str)}'`)\n      }\n    }\n  }\n\n  parseNumber () {\n    const startPos = this._pos\n    let negative = false\n    let float = false\n\n    /**\n     * @param {number[]} chars\n     */\n    const swallow = (chars) => {\n      while (!this.done()) {\n        const ch = this.ch()\n        if (chars.includes(ch)) {\n          this._pos++\n        } else {\n          break\n        }\n      }\n    }\n\n    // lead\n    if (this.ch() === 45) { // '-'\n      negative = true\n      this._pos++\n    }\n    if (this.ch() === 48) { // '0'\n      this._pos++\n      if (this.ch() === 46) { // '.'\n        this._pos++\n        float = true\n      } else {\n        return new Token(Type.uint, 0, this._pos - startPos)\n      }\n    }\n    swallow([48, 49, 50, 51, 52, 53, 54, 55, 56, 57]) // DIGIT\n    if (negative && this._pos === startPos + 1) {\n      throw new Error(`${decodeErrPrefix} unexpected token at position ${this._pos}`)\n    }\n    if (!this.done() && this.ch() === 46) { // '.'\n      if (float) {\n        throw new Error(`${decodeErrPrefix} unexpected token at position ${this._pos}`)\n      }\n      float = true\n      this._pos++\n      swallow([48, 49, 50, 51, 52, 53, 54, 55, 56, 57]) // DIGIT\n    }\n    if (!this.done() && (this.ch() === 101 || this.ch() === 69)) { // '[eE]'\n      float = true\n      this._pos++\n      if (!this.done() && (this.ch() === 43 || this.ch() === 45)) { // '+', '-'\n        this._pos++\n      }\n      swallow([48, 49, 50, 51, 52, 53, 54, 55, 56, 57]) // DIGIT\n    }\n    // @ts-ignore\n    const numStr = String.fromCharCode.apply(null, this.data.subarray(startPos, this._pos))\n    const num = parseFloat(numStr)\n    if (float) {\n      return new Token(Type.float, num, this._pos - startPos)\n    }\n    if (this.options.allowBigInt !== true || Number.isSafeInteger(num)) {\n      return new Token(num >= 0 ? Type.uint : Type.negint, num, this._pos - startPos)\n    }\n    return new Token(num >= 0 ? Type.uint : Type.negint, BigInt(numStr), this._pos - startPos)\n  }\n\n  /**\n   * @returns {Token}\n   */\n  parseString () {\n    /* c8 ignore next 4 */\n    if (this.ch() !== 34) { // '\"'\n      // this would be a programming error\n      throw new Error(`${decodeErrPrefix} unexpected character at position ${this._pos}; this shouldn't happen`)\n    }\n    this._pos++\n\n    // check for simple fast-path, all printable ascii, no escapes\n    // >0x10000 elements may fail fn.apply() (http://stackoverflow.com/a/22747272/680742)\n    for (let i = this._pos, l = 0; i < this.data.length && l < 0x10000; i++, l++) {\n      const ch = this.data[i]\n      if (ch === 92 || ch < 32 || ch >= 128) { // '\\', ' ', control-chars or non-trivial\n        break\n      }\n      if (ch === 34) { // '\"'\n        // @ts-ignore\n        const str = String.fromCharCode.apply(null, this.data.subarray(this._pos, i))\n        this._pos = i + 1\n        return new Token(Type.string, str, l)\n      }\n    }\n\n    const startPos = this._pos\n    const chars = []\n\n    const readu4 = () => {\n      if (this._pos + 4 >= this.data.length) {\n        throw new Error(`${decodeErrPrefix} unexpected end of unicode escape sequence at position ${this._pos}`)\n      }\n      let u4 = 0\n      for (let i = 0; i < 4; i++) {\n        let ch = this.ch()\n        if (ch >= 48 && ch <= 57) { // '0' && '9'\n          ch -= 48\n        } else if (ch >= 97 && ch <= 102) { // 'a' && 'f'\n          ch = ch - 97 + 10\n        } else if (ch >= 65 && ch <= 70) { // 'A' && 'F'\n          ch = ch - 65 + 10\n        } else {\n          throw new Error(`${decodeErrPrefix} unexpected unicode escape character at position ${this._pos}`)\n        }\n        u4 = u4 * 16 + ch\n        this._pos++\n      }\n      return u4\n    }\n\n    // mostly taken from feross/buffer and adjusted to fit\n    const readUtf8Char = () => {\n      const firstByte = this.ch()\n      let codePoint = null\n      /* c8 ignore next 1 */\n      let bytesPerSequence = (firstByte > 0xef) ? 4 : (firstByte > 0xdf) ? 3 : (firstByte > 0xbf) ? 2 : 1\n\n      if (this._pos + bytesPerSequence > this.data.length) {\n        throw new Error(`${decodeErrPrefix} unexpected unicode sequence at position ${this._pos}`)\n      }\n\n      let secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        /* c8 ignore next 6 */\n        // this case is dealt with by the caller function\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = this.data[this._pos + 1]\n          if ((secondByte & 0xc0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1f) << 0x6 | (secondByte & 0x3f)\n            if (tempCodePoint > 0x7f) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = this.data[this._pos + 1]\n          thirdByte = this.data[this._pos + 2]\n          if ((secondByte & 0xc0) === 0x80 && (thirdByte & 0xc0) === 0x80) {\n            tempCodePoint = (firstByte & 0xf) << 0xc | (secondByte & 0x3f) << 0x6 | (thirdByte & 0x3f)\n            /* c8 ignore next 3 */\n            if (tempCodePoint > 0x7ff && (tempCodePoint < 0xd800 || tempCodePoint > 0xdfff)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = this.data[this._pos + 1]\n          thirdByte = this.data[this._pos + 2]\n          fourthByte = this.data[this._pos + 3]\n          if ((secondByte & 0xc0) === 0x80 && (thirdByte & 0xc0) === 0x80 && (fourthByte & 0xc0) === 0x80) {\n            tempCodePoint = (firstByte & 0xf) << 0x12 | (secondByte & 0x3f) << 0xc | (thirdByte & 0x3f) << 0x6 | (fourthByte & 0x3f)\n            if (tempCodePoint > 0xffff && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n\n      /* c8 ignore next 5 */\n      if (codePoint === null) {\n        // we did not generate a valid codePoint so insert a\n        // replacement char (U+FFFD) and advance only 1 byte\n        codePoint = 0xfffd\n        bytesPerSequence = 1\n      } else if (codePoint > 0xffff) {\n        // encode to utf16 (surrogate pair dance)\n        codePoint -= 0x10000\n        chars.push(codePoint >>> 10 & 0x3ff | 0xd800)\n        codePoint = 0xdc00 | codePoint & 0x3ff\n      }\n\n      chars.push(codePoint)\n      this._pos += bytesPerSequence\n    }\n\n    // TODO: could take the approach of a quick first scan for special chars like encoding/json/decode.go#unquoteBytes\n    // and converting all of the ascii chars from the base array in bulk\n    while (!this.done()) {\n      const ch = this.ch()\n      let ch1\n      switch (ch) {\n        case 92: // '\\'\n          this._pos++\n          if (this.done()) {\n            throw new Error(`${decodeErrPrefix} unexpected string termination at position ${this._pos}`)\n          }\n          ch1 = this.ch()\n          this._pos++\n          switch (ch1) {\n            case 34: // '\"'\n            case 39: // '\\''\n            case 92: // '\\'\n            case 47: // '/'\n              chars.push(ch1)\n              break\n            case 98: // 'b'\n              chars.push(8)\n              break\n            case 116: // 't'\n              chars.push(9)\n              break\n            case 110: // 'n'\n              chars.push(10)\n              break\n            case 102: // 'f'\n              chars.push(12)\n              break\n            case 114: // 'r'\n              chars.push(13)\n              break\n            case 117: // 'u'\n              chars.push(readu4())\n              break\n            default:\n              throw new Error(`${decodeErrPrefix} unexpected string escape character at position ${this._pos}`)\n          }\n          break\n        case 34: // '\"'\n          this._pos++\n          return new Token(Type.string, decodeCodePointsArray(chars), this._pos - startPos)\n        default:\n          if (ch < 32) { // ' '\n            throw new Error(`${decodeErrPrefix} invalid control character at position ${this._pos}`)\n          } else if (ch < 0x80) {\n            chars.push(ch)\n            this._pos++\n          } else {\n            readUtf8Char()\n          }\n      }\n    }\n\n    throw new Error(`${decodeErrPrefix} unexpected end of string at position ${this._pos}`)\n  }\n\n  /**\n   * @returns {Token}\n   */\n  parseValue () {\n    switch (this.ch()) {\n      case 123: // '{'\n        this.modeStack.push('obj-start')\n        this._pos++\n        return new Token(Type.map, Infinity, 1)\n      case 91: // '['\n        this.modeStack.push('array-start')\n        this._pos++\n        return new Token(Type.array, Infinity, 1)\n      case 34: { // '\"'\n        return this.parseString()\n      }\n      case 110: // 'n' / null\n        this.expect([110, 117, 108, 108]) // 'null'\n        return new Token(Type.null, null, 4)\n      case 102: // 'f' / // false\n        this.expect([102, 97, 108, 115, 101]) // 'false'\n        return new Token(Type.false, false, 5)\n      case 116: // 't' / // true\n        this.expect([116, 114, 117, 101]) // 'true'\n        return new Token(Type.true, true, 4)\n      case 45: // '-'\n      case 48: // '0'\n      case 49: // '1'\n      case 50: // '2'\n      case 51: // '3'\n      case 52: // '4'\n      case 53: // '5'\n      case 54: // '6'\n      case 55: // '7'\n      case 56: // '8'\n      case 57: // '9'\n        return this.parseNumber()\n      default:\n        throw new Error(`${decodeErrPrefix} unexpected character at position ${this._pos}`)\n    }\n  }\n\n  /**\n   * @returns {Token}\n   */\n  next () {\n    this.skipWhitespace()\n    switch (this.currentMode()) {\n      case 'value':\n        this.modeStack.pop()\n        return this.parseValue()\n      case 'array-value': {\n        this.modeStack.pop()\n        if (this.ch() === 93) { // ']'\n          this._pos++\n          this.skipWhitespace()\n          return new Token(Type.break, undefined, 1)\n        }\n        if (this.ch() !== 44) { // ','\n          throw new Error(`${decodeErrPrefix} unexpected character at position ${this._pos}, was expecting array delimiter but found '${String.fromCharCode(this.ch())}'`)\n        }\n        this._pos++\n        this.modeStack.push('array-value')\n        this.skipWhitespace()\n        return this.parseValue()\n      }\n      case 'array-start': {\n        this.modeStack.pop()\n        if (this.ch() === 93) { // ']'\n          this._pos++\n          this.skipWhitespace()\n          return new Token(Type.break, undefined, 1)\n        }\n        this.modeStack.push('array-value')\n        this.skipWhitespace()\n        return this.parseValue()\n      }\n      // @ts-ignore\n      case 'obj-key':\n        if (this.ch() === 125) { // '}'\n          this.modeStack.pop()\n          this._pos++\n          this.skipWhitespace()\n          return new Token(Type.break, undefined, 1)\n        }\n        if (this.ch() !== 44) { // ','\n          throw new Error(`${decodeErrPrefix} unexpected character at position ${this._pos}, was expecting object delimiter but found '${String.fromCharCode(this.ch())}'`)\n        }\n        this._pos++\n        this.skipWhitespace()\n      case 'obj-start': { // eslint-disable-line no-fallthrough\n        this.modeStack.pop()\n        if (this.ch() === 125) { // '}'\n          this._pos++\n          this.skipWhitespace()\n          return new Token(Type.break, undefined, 1)\n        }\n        const token = this.parseString()\n        this.skipWhitespace()\n        if (this.ch() !== 58) { // ':'\n          throw new Error(`${decodeErrPrefix} unexpected character at position ${this._pos}, was expecting key/value delimiter ':' but found '${String.fromCharCode(this.ch())}'`)\n        }\n        this._pos++\n        this.modeStack.push('obj-value')\n        return token\n      }\n      case 'obj-value': {\n        this.modeStack.pop()\n        this.modeStack.push('obj-key')\n        this.skipWhitespace()\n        return this.parseValue()\n      }\n      /* c8 ignore next 2 */\n      default:\n        throw new Error(`${decodeErrPrefix} unexpected parse state at position ${this._pos}; this shouldn't happen`)\n    }\n  }\n}\n\n/**\n * @param {Uint8Array} data\n * @param {DecodeOptions} [options]\n * @returns {any}\n */\nfunction decode (data, options) {\n  options = Object.assign({ tokenizer: new Tokenizer(data, options) }, options)\n  return _decode(data, options)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {DecodeOptions} [options]\n * @returns {[any, Uint8Array]}\n */\nfunction decodeFirst (data, options) {\n  options = Object.assign({ tokenizer: new Tokenizer(data, options) }, options)\n  return _decodeFirst(data, options)\n}\n\nexport { decode, decodeFirst, Tokenizer }\n", "import * as Digest from './digest.js'\nimport type { MultihashHasher } from './interface.js'\n\ntype Await<T> = Promise<T> | T\n\nexport function from <Name extends string, Code extends number> ({ name, code, encode }: { name: Name, code: Code, encode(input: Uint8Array): Await<Uint8Array> }): Hasher<Name, Code> {\n  return new Hasher(name, code, encode)\n}\n\n/**\n * Hasher represents a hashing algorithm implementation that produces as\n * `MultihashDigest`.\n */\nexport class Hasher<Name extends string, Code extends number> implements MultihashHasher<Code> {\n  readonly name: Name\n  readonly code: Code\n  readonly encode: (input: Uint8Array) => Await<Uint8Array>\n\n  constructor (name: Name, code: Code, encode: (input: Uint8Array) => Await<Uint8Array>) {\n    this.name = name\n    this.code = code\n    this.encode = encode\n  }\n\n  digest (input: Uint8Array): Await<Digest.Digest<Code, number>> {\n    if (input instanceof Uint8Array) {\n      const result = this.encode(input)\n      return result instanceof Uint8Array\n        ? Digest.create(this.code, result)\n        /* c8 ignore next 1 */\n        : result.then(digest => Digest.create(this.code, digest))\n    } else {\n      throw Error('Unknown type, must be binary type')\n      /* c8 ignore next 1 */\n    }\n  }\n}\n", "import { rfc4648 } from './base.js'\n\nexport const base64 = rfc4648({\n  prefix: 'm',\n  name: 'base64',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',\n  bitsPerChar: 6\n})\n\nexport const base64pad = rfc4648({\n  prefix: 'M',\n  name: 'base64pad',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=',\n  bitsPerChar: 6\n})\n\nexport const base64url = rfc4648({\n  prefix: 'u',\n  name: 'base64url',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_',\n  bitsPerChar: 6\n})\n\nexport const base64urlpad = rfc4648({\n  prefix: 'U',\n  name: 'base64urlpad',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=',\n  bitsPerChar: 6\n})\n", "/* eslint max-depth: [\"error\", 7] */\nimport { Token, Type } from 'cborg'\nimport * as cborgJson from 'cborg/json'\nimport { CID } from 'multiformats'\nimport { base64 } from 'multiformats/bases/base64'\n\n/**\n * @template T\n * @typedef {import('multiformats/codecs/interface').ByteView<T>} ByteView\n */\n/**\n * @template T\n * @typedef {import('multiformats/codecs/interface').ArrayBufferView<T>} ArrayBufferView\n */\n/**\n * @template T\n * @typedef {import('multiformats').ToString<T>} ToString\n */\n/**\n * @typedef {import('cborg/interface').DecodeTokenizer} DecodeTokenizer\n */\n\n/**\n * @template T\n * @param {ByteView<T> | ArrayBufferView<T>} buf\n * @returns {ByteView<T>}\n */\nfunction toByteView (buf) {\n  if (buf instanceof ArrayBuffer) {\n    return new Uint8Array(buf, 0, buf.byteLength)\n  }\n\n  return buf\n}\n\n/**\n * cidEncoder will receive all Objects during encode, it needs to filter out\n * anything that's not a CID and return `null` for that so it's encoded as\n * normal. Encoding a CID means replacing it with a `{\"/\":\"<CidString>}`\n * object as per the DAG-JSON spec.\n *\n * @param {any} obj\n * @returns {Token[]|null}\n */\nfunction cidEncoder (obj) {\n  if (obj.asCID !== obj && obj['/'] !== obj.bytes) {\n    return null // any other kind of object\n  }\n  const cid = CID.asCID(obj)\n  /* c8 ignore next 4 */\n  // very unlikely case, and it'll probably throw a recursion error in cborg\n  if (!cid) {\n    return null\n  }\n  const cidString = cid.toString()\n\n  return [\n    new Token(Type.map, Infinity, 1),\n    new Token(Type.string, '/', 1), // key\n    new Token(Type.string, cidString, cidString.length), // value\n    new Token(Type.break, undefined, 1)\n  ]\n}\n\n/**\n * bytesEncoder will receive all Uint8Arrays (and friends) during encode, it\n * needs to replace it with a `{\"/\":{\"bytes\":\"Base64ByteString\"}}` object as\n * per the DAG-JSON spec.\n *\n * @param {Uint8Array} bytes\n * @returns {Token[]|null}\n */\nfunction bytesEncoder (bytes) {\n  const bytesString = base64.encode(bytes).slice(1) // no mbase prefix\n  return [\n    new Token(Type.map, Infinity, 1),\n    new Token(Type.string, '/', 1), // key\n    new Token(Type.map, Infinity, 1), // value\n    new Token(Type.string, 'bytes', 5), // inner key\n    new Token(Type.string, bytesString, bytesString.length), // inner value\n    new Token(Type.break, undefined, 1),\n    new Token(Type.break, undefined, 1)\n  ]\n}\n\n/**\n * taBytesEncoder wraps bytesEncoder() but for the more exotic typed arrays so\n * that we access the underlying ArrayBuffer data\n *\n * @param {Int8Array|Uint16Array|Int16Array|Uint32Array|Int32Array|Float32Array|Float64Array|Uint8ClampedArray|BigInt64Array|BigUint64Array} obj\n * @returns {Token[]|null}\n */\nfunction taBytesEncoder (obj) {\n  return bytesEncoder(new Uint8Array(obj.buffer, obj.byteOffset, obj.byteLength))\n}\n\n/**\n * abBytesEncoder wraps bytesEncoder() but for plain ArrayBuffers\n *\n * @param {ArrayBuffer} ab\n * @returns {Token[]|null}\n */\nfunction abBytesEncoder (ab) {\n  return bytesEncoder(new Uint8Array(ab))\n}\n\n// eslint-disable-next-line jsdoc/require-returns-check\n/**\n * Intercept all `undefined` values from an object walk and reject the entire\n * object if we find one.\n *\n * @returns {null}\n */\nfunction undefinedEncoder () {\n  throw new Error('`undefined` is not supported by the IPLD Data Model and cannot be encoded')\n}\n\n/**\n * Intercept all `number` values from an object walk and reject the entire\n * object if we find something that doesn't fit the IPLD data model (NaN &\n * Infinity).\n *\n * @param {number} num\n * @returns {null}\n */\nfunction numberEncoder (num) {\n  if (Number.isNaN(num)) {\n    throw new Error('`NaN` is not supported by the IPLD Data Model and cannot be encoded')\n  }\n  if (num === Infinity || num === -Infinity) {\n    throw new Error('`Infinity` and `-Infinity` is not supported by the IPLD Data Model and cannot be encoded')\n  }\n  return null // process with standard number encoder\n}\n\nconst encodeOptions = {\n  typeEncoders: {\n    Object: cidEncoder,\n    Buffer: bytesEncoder,\n    Uint8Array: bytesEncoder,\n    Int8Array: taBytesEncoder,\n    Uint16Array: taBytesEncoder,\n    Int16Array: taBytesEncoder,\n    Uint32Array: taBytesEncoder,\n    Int32Array: taBytesEncoder,\n    Float32Array: taBytesEncoder,\n    Float64Array: taBytesEncoder,\n    Uint8ClampedArray: taBytesEncoder,\n    BigInt64Array: taBytesEncoder,\n    BigUint64Array: taBytesEncoder,\n    DataView: taBytesEncoder,\n    ArrayBuffer: abBytesEncoder,\n    undefined: undefinedEncoder,\n    number: numberEncoder\n  }\n}\n\n/**\n * @implements {DecodeTokenizer}\n */\nclass DagJsonTokenizer extends cborgJson.Tokenizer {\n  /**\n   * @param {Uint8Array} data\n   * @param {object} [options]\n   */\n  constructor (data, options) {\n    super(data, options)\n    /** @type {Token[]} */\n    this.tokenBuffer = []\n  }\n\n  /**\n   * @returns {boolean}\n   */\n  done () {\n    return this.tokenBuffer.length === 0 && super.done()\n  }\n\n  /**\n   * @returns {Token}\n   */\n  _next () {\n    if (this.tokenBuffer.length > 0) {\n      // @ts-ignore https://github.com/Microsoft/TypeScript/issues/30406\n      return this.tokenBuffer.pop()\n    }\n    return super.next()\n  }\n\n  /**\n   * Implements rules outlined in https://github.com/ipld/specs/pull/356\n   *\n   * @returns {Token}\n   */\n  next () {\n    const token = this._next()\n\n    if (token.type === Type.map) {\n      const keyToken = this._next()\n      if (keyToken.type === Type.string && keyToken.value === '/') {\n        const valueToken = this._next()\n        if (valueToken.type === Type.string) { // *must* be a CID\n          const breakToken = this._next() // swallow the end-of-map token\n          if (breakToken.type !== Type.break) {\n            throw new Error('Invalid encoded CID form')\n          }\n          this.tokenBuffer.push(valueToken) // CID.parse will pick this up after our tag token\n          return new Token(Type.tag, 42, 0)\n        }\n        if (valueToken.type === Type.map) {\n          const innerKeyToken = this._next()\n          if (innerKeyToken.type === Type.string && innerKeyToken.value === 'bytes') {\n            const innerValueToken = this._next()\n            if (innerValueToken.type === Type.string) { // *must* be Bytes\n              for (let i = 0; i < 2; i++) {\n                const breakToken = this._next() // swallow two end-of-map tokens\n                if (breakToken.type !== Type.break) {\n                  throw new Error('Invalid encoded Bytes form')\n                }\n              }\n              const bytes = base64.decode(`m${innerValueToken.value}`)\n              return new Token(Type.bytes, bytes, innerValueToken.value.length)\n            }\n            this.tokenBuffer.push(innerValueToken) // bail\n          }\n          this.tokenBuffer.push(innerKeyToken) // bail\n        }\n        this.tokenBuffer.push(valueToken) // bail\n      }\n      this.tokenBuffer.push(keyToken) // bail\n    }\n    return token\n  }\n}\n\nconst decodeOptions = {\n  allowIndefinite: false,\n  allowUndefined: false,\n  allowNaN: false,\n  allowInfinity: false,\n  allowBigInt: true, // this will lead to BigInt for ints outside of\n  // safe-integer range, which may surprise users\n  strict: true,\n  useMaps: false,\n  rejectDuplicateMapKeys: true,\n  /** @type {import('cborg').TagDecoder[]} */\n  tags: []\n}\n\n// we're going to get TAG(42)STRING(\"bafy...\") from the tokenizer so we only need\n// to deal with the STRING(\"bafy...\") at this point\ndecodeOptions.tags[42] = CID.parse\n\nexport const name = 'dag-json'\nexport const code = 0x0129\n\n/**\n * @template T\n * @param {T} node\n * @returns {ByteView<T>}\n */\nexport const encode = (node) => cborgJson.encode(node, encodeOptions)\n\n/**\n * @template T\n * @param {ByteView<T> | ArrayBufferView<T>} data\n * @returns {T}\n */\nexport const decode = (data) => {\n  const buf = toByteView(data)\n  // the tokenizer is stateful so we need a single instance of it\n  const options = Object.assign(decodeOptions, { tokenizer: new DagJsonTokenizer(buf, decodeOptions) })\n  return cborgJson.decode(buf, options)\n}\n\n/**\n * @template T\n * @param {T} node\n * @returns {ToString<T>}\n */\nexport const format = (node) => utf8Decoder.decode(encode(node))\nexport { format as stringify }\nconst utf8Decoder = new TextDecoder()\n\n/**\n * @template T\n * @param {ToString<T>} data\n * @returns {T}\n */\nexport const parse = (data) => decode(utf8Encoder.encode(data))\nconst utf8Encoder = new TextEncoder()\n", "const textDecoder = new TextDecoder()\n\n/**\n * @typedef {import('./interface.js').RawPBLink} RawPBLink\n */\n\n/**\n * @typedef {import('./interface.js').RawPBNode} RawPBNode\n */\n\n/**\n * @param {Uint8Array} bytes\n * @param {number} offset\n * @returns {[number, number]}\n */\nfunction decodeVarint (bytes, offset) {\n  let v = 0\n\n  for (let shift = 0; ; shift += 7) {\n    /* c8 ignore next 3 */\n    if (shift >= 64) {\n      throw new Error('protobuf: varint overflow')\n    }\n    /* c8 ignore next 3 */\n    if (offset >= bytes.length) {\n      throw new Error('protobuf: unexpected end of data')\n    }\n\n    const b = bytes[offset++]\n    v += shift < 28 ? (b & 0x7f) << shift : (b & 0x7f) * (2 ** shift)\n    if (b < 0x80) {\n      break\n    }\n  }\n  return [v, offset]\n}\n\n/**\n * @param {Uint8Array} bytes\n * @param {number} offset\n * @returns {[Uint8Array, number]}\n */\nfunction decodeBytes (bytes, offset) {\n  let byteLen\n  ;[byteLen, offset] = decodeVarint(bytes, offset)\n  const postOffset = offset + byteLen\n\n  /* c8 ignore next 3 */\n  if (byteLen < 0 || postOffset < 0) {\n    throw new Error('protobuf: invalid length')\n  }\n  /* c8 ignore next 3 */\n  if (postOffset > bytes.length) {\n    throw new Error('protobuf: unexpected end of data')\n  }\n\n  return [bytes.subarray(offset, postOffset), postOffset]\n}\n\n/**\n * @param {Uint8Array} bytes\n * @param {number} index\n * @returns {[number, number, number]}\n */\nfunction decodeKey (bytes, index) {\n  let wire\n  ;[wire, index] = decodeVarint(bytes, index)\n  // [wireType, fieldNum, newIndex]\n  return [wire & 0x7, wire >> 3, index]\n}\n\n/**\n * @param {Uint8Array} bytes\n * @returns {RawPBLink}\n */\nfunction decodeLink (bytes) {\n  /** @type {RawPBLink} */\n  const link = {}\n  const l = bytes.length\n  let index = 0\n\n  while (index < l) {\n    let wireType, fieldNum\n    ;[wireType, fieldNum, index] = decodeKey(bytes, index)\n\n    if (fieldNum === 1) {\n      if (link.Hash) {\n        throw new Error('protobuf: (PBLink) duplicate Hash section')\n      }\n      if (wireType !== 2) {\n        throw new Error(`protobuf: (PBLink) wrong wireType (${wireType}) for Hash`)\n      }\n      if (link.Name !== undefined) {\n        throw new Error('protobuf: (PBLink) invalid order, found Name before Hash')\n      }\n      if (link.Tsize !== undefined) {\n        throw new Error('protobuf: (PBLink) invalid order, found Tsize before Hash')\n      }\n\n      [link.Hash, index] = decodeBytes(bytes, index)\n    } else if (fieldNum === 2) {\n      if (link.Name !== undefined) {\n        throw new Error('protobuf: (PBLink) duplicate Name section')\n      }\n      if (wireType !== 2) {\n        throw new Error(`protobuf: (PBLink) wrong wireType (${wireType}) for Name`)\n      }\n      if (link.Tsize !== undefined) {\n        throw new Error('protobuf: (PBLink) invalid order, found Tsize before Name')\n      }\n\n      let byts\n      ;[byts, index] = decodeBytes(bytes, index)\n      link.Name = textDecoder.decode(byts)\n    } else if (fieldNum === 3) {\n      if (link.Tsize !== undefined) {\n        throw new Error('protobuf: (PBLink) duplicate Tsize section')\n      }\n      if (wireType !== 0) {\n        throw new Error(`protobuf: (PBLink) wrong wireType (${wireType}) for Tsize`)\n      }\n\n      [link.Tsize, index] = decodeVarint(bytes, index)\n    } else {\n      throw new Error(`protobuf: (PBLink) invalid fieldNumber, expected 1, 2 or 3, got ${fieldNum}`)\n    }\n  }\n\n  /* c8 ignore next 3 */\n  if (index > l) {\n    throw new Error('protobuf: (PBLink) unexpected end of data')\n  }\n\n  return link\n}\n\n/**\n * @param {Uint8Array} bytes\n * @returns {RawPBNode}\n */\nexport function decodeNode (bytes) {\n  const l = bytes.length\n  let index = 0\n  /** @type {RawPBLink[]|void} */\n  let links = undefined // eslint-disable-line no-undef-init\n  let linksBeforeData = false\n  /** @type {Uint8Array|void} */\n  let data = undefined // eslint-disable-line no-undef-init\n\n  while (index < l) {\n    let wireType, fieldNum\n    ;[wireType, fieldNum, index] = decodeKey(bytes, index)\n\n    if (wireType !== 2) {\n      throw new Error(`protobuf: (PBNode) invalid wireType, expected 2, got ${wireType}`)\n    }\n\n    if (fieldNum === 1) {\n      if (data) {\n        throw new Error('protobuf: (PBNode) duplicate Data section')\n      }\n\n      [data, index] = decodeBytes(bytes, index)\n      if (links) {\n        linksBeforeData = true\n      }\n    } else if (fieldNum === 2) {\n      if (linksBeforeData) { // interleaved Links/Data/Links\n        throw new Error('protobuf: (PBNode) duplicate Links section')\n      } else if (!links) {\n        links = []\n      }\n      let byts\n      ;[byts, index] = decodeBytes(bytes, index)\n      links.push(decodeLink(byts))\n    } else {\n      throw new Error(`protobuf: (PBNode) invalid fieldNumber, expected 1 or 2, got ${fieldNum}`)\n    }\n  }\n\n  /* c8 ignore next 3 */\n  if (index > l) {\n    throw new Error('protobuf: (PBNode) unexpected end of data')\n  }\n\n  /** @type {RawPBNode} */\n  const node = {}\n  if (data) {\n    node.Data = data\n  }\n  node.Links = links || []\n  return node\n}\n", "const textEncoder = new TextEncoder()\nconst maxInt32 = 2 ** 32\nconst maxUInt32 = 2 ** 31\n\n/**\n * @typedef {import('./interface.js').RawPBLink} RawPBLink\n */\n\n/**\n * @typedef {import('./interface.js').RawPBNode} RawPBNode\n */\n\n// the encoders work backward from the end of the bytes array\n\n/**\n * encodeLink() is passed a slice of the parent byte array that ends where this\n * link needs to end, so it packs to the right-most part of the passed `bytes`\n *\n * @param {RawPBLink} link\n * @param {Uint8Array} bytes\n * @returns {number}\n */\nfunction encodeLink (link, bytes) {\n  let i = bytes.length\n\n  if (typeof link.Tsize === 'number') {\n    if (link.Tsize < 0) {\n      throw new Error('Tsize cannot be negative')\n    }\n    if (!Number.isSafeInteger(link.Tsize)) {\n      throw new Error('Tsize too large for encoding')\n    }\n    i = encodeVarint(bytes, i, link.Tsize) - 1\n    bytes[i] = 0x18\n  }\n\n  if (typeof link.Name === 'string') {\n    const nameBytes = textEncoder.encode(link.Name)\n    i -= nameBytes.length\n    bytes.set(nameBytes, i)\n    i = encodeVarint(bytes, i, nameBytes.length) - 1\n    bytes[i] = 0x12\n  }\n\n  if (link.Hash) {\n    i -= link.Hash.length\n    bytes.set(link.Hash, i)\n    i = encodeVarint(bytes, i, link.Hash.length) - 1\n    bytes[i] = 0xa\n  }\n\n  return bytes.length - i\n}\n\n/**\n * Encodes a PBNode into a new byte array of precisely the correct size\n *\n * @param {RawPBNode} node\n * @returns {Uint8Array}\n */\nexport function encodeNode (node) {\n  const size = sizeNode(node)\n  const bytes = new Uint8Array(size)\n  let i = size\n\n  if (node.Data) {\n    i -= node.Data.length\n    bytes.set(node.Data, i)\n    i = encodeVarint(bytes, i, node.Data.length) - 1\n    bytes[i] = 0xa\n  }\n\n  if (node.Links) {\n    for (let index = node.Links.length - 1; index >= 0; index--) {\n      const size = encodeLink(node.Links[index], bytes.subarray(0, i))\n      i -= size\n      i = encodeVarint(bytes, i, size) - 1\n      bytes[i] = 0x12\n    }\n  }\n\n  return bytes\n}\n\n/**\n * work out exactly how many bytes this link takes up\n *\n * @param {RawPBLink} link\n * @returns\n */\nfunction sizeLink (link) {\n  let n = 0\n\n  if (link.Hash) {\n    const l = link.Hash.length\n    n += 1 + l + sov(l)\n  }\n\n  if (typeof link.Name === 'string') {\n    const l = textEncoder.encode(link.Name).length\n    n += 1 + l + sov(l)\n  }\n\n  if (typeof link.Tsize === 'number') {\n    n += 1 + sov(link.Tsize)\n  }\n\n  return n\n}\n\n/**\n * Work out exactly how many bytes this node takes up\n *\n * @param {RawPBNode} node\n * @returns {number}\n */\nfunction sizeNode (node) {\n  let n = 0\n\n  if (node.Data) {\n    const l = node.Data.length\n    n += 1 + l + sov(l)\n  }\n\n  if (node.Links) {\n    for (const link of node.Links) {\n      const l = sizeLink(link)\n      n += 1 + l + sov(l)\n    }\n  }\n\n  return n\n}\n\n/**\n * @param {Uint8Array} bytes\n * @param {number} offset\n * @param {number} v\n * @returns {number}\n */\nfunction encodeVarint (bytes, offset, v) {\n  offset -= sov(v)\n  const base = offset\n\n  while (v >= maxUInt32) {\n    bytes[offset++] = (v & 0x7f) | 0x80\n    v /= 128\n  }\n\n  while (v >= 128) {\n    bytes[offset++] = (v & 0x7f) | 0x80\n    v >>>= 7\n  }\n\n  bytes[offset] = v\n\n  return base\n}\n\n/**\n * size of varint\n *\n * @param {number} x\n * @returns {number}\n */\nfunction sov (x) {\n  if (x % 2 === 0) {\n    x++\n  }\n  return Math.floor((len64(x) + 6) / 7)\n}\n\n/**\n * golang math/bits, how many bits does it take to represent this integer?\n *\n * @param {number} x\n * @returns {number}\n */\nfunction len64 (x) {\n  let n = 0\n  if (x >= maxInt32) {\n    x = Math.floor(x / maxInt32)\n    n = 32\n  }\n  if (x >= (1 << 16)) {\n    x >>>= 16\n    n += 16\n  }\n  if (x >= (1 << 8)) {\n    x >>>= 8\n    n += 8\n  }\n  return n + len8tab[x]\n}\n\n// golang math/bits\nconst len8tab = [\n  0, 1, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4,\n  5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\n  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\n  7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,\n  7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,\n  7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,\n  7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,\n  8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,\n  8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,\n  8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,\n  8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,\n  8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,\n  8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,\n  8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,\n  8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8\n]\n", "import { CID } from 'multiformats/cid'\n\n/* eslint-disable complexity, no-nested-ternary */\n\n/**\n * @typedef {import('./interface.js').PBLink} PBLink\n * @typedef {import('./interface.js').PBNode} PBNode\n */\n\n/**\n * @template T\n * @typedef {import('multiformats/codecs/interface').ByteView<T>} ByteView\n */\n\n/**\n * @template T\n * @typedef {import('multiformats/codecs/interface').ArrayBufferView<T>} ArrayBufferView\n */\n\nconst pbNodeProperties = ['Data', 'Links']\nconst pbLinkProperties = ['Hash', 'Name', 'Tsize']\n\nconst textEncoder = new TextEncoder()\n\n/**\n * @param {PBLink} a\n * @param {PBLink} b\n * @returns {number}\n */\nfunction linkComparator (a, b) {\n  if (a === b) {\n    return 0\n  }\n\n  const abuf = a.Name ? textEncoder.encode(a.Name) : []\n  const bbuf = b.Name ? textEncoder.encode(b.Name) : []\n\n  let x = abuf.length\n  let y = bbuf.length\n\n  for (let i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (abuf[i] !== bbuf[i]) {\n      x = abuf[i]\n      y = bbuf[i]\n      break\n    }\n  }\n\n  return x < y ? -1 : y < x ? 1 : 0\n}\n\n/**\n * @param {any} node\n * @param {string[]} properties\n * @returns {boolean}\n */\nfunction hasOnlyProperties (node, properties) {\n  return !Object.keys(node).some((p) => !properties.includes(p))\n}\n\n/**\n * Converts a CID, or a PBLink-like object to a PBLink\n *\n * @param {any} link\n * @returns {PBLink}\n */\nfunction asLink (link) {\n  if (typeof link.asCID === 'object') {\n    const Hash = CID.asCID(link)\n    if (!Hash) {\n      throw new TypeError('Invalid DAG-PB form')\n    }\n    return { Hash }\n  }\n\n  if (typeof link !== 'object' || Array.isArray(link)) {\n    throw new TypeError('Invalid DAG-PB form')\n  }\n\n  const pbl = {}\n\n  if (link.Hash) {\n    let cid = CID.asCID(link.Hash)\n    try {\n      if (!cid) {\n        if (typeof link.Hash === 'string') {\n          cid = CID.parse(link.Hash)\n        } else if (link.Hash instanceof Uint8Array) {\n          cid = CID.decode(link.Hash)\n        }\n      }\n    } catch (/** @type {any} */ e) {\n      throw new TypeError(`Invalid DAG-PB form: ${e.message}`)\n    }\n\n    if (cid) {\n      pbl.Hash = cid\n    }\n  }\n\n  if (!pbl.Hash) {\n    throw new TypeError('Invalid DAG-PB form')\n  }\n\n  if (typeof link.Name === 'string') {\n    pbl.Name = link.Name\n  }\n\n  if (typeof link.Tsize === 'number') {\n    pbl.Tsize = link.Tsize\n  }\n\n  return pbl\n}\n\n/**\n * @param {any} node\n * @returns {PBNode}\n */\nexport function prepare (node) {\n  if (node instanceof Uint8Array || typeof node === 'string') {\n    node = { Data: node }\n  }\n\n  if (typeof node !== 'object' || Array.isArray(node)) {\n    throw new TypeError('Invalid DAG-PB form')\n  }\n\n  /** @type {PBNode} */\n  const pbn = {}\n\n  if (node.Data !== undefined) {\n    if (typeof node.Data === 'string') {\n      pbn.Data = textEncoder.encode(node.Data)\n    } else if (node.Data instanceof Uint8Array) {\n      pbn.Data = node.Data\n    } else {\n      throw new TypeError('Invalid DAG-PB form')\n    }\n  }\n\n  if (node.Links !== undefined) {\n    if (Array.isArray(node.Links)) {\n      pbn.Links = node.Links.map(asLink)\n      pbn.Links.sort(linkComparator)\n    } else {\n      throw new TypeError('Invalid DAG-PB form')\n    }\n  } else {\n    pbn.Links = []\n  }\n\n  return pbn\n}\n\n/**\n * @param {PBNode} node\n */\nexport function validate (node) {\n  /*\n  type PBLink struct {\n    Hash optional Link\n    Name optional String\n    Tsize optional Int\n  }\n\n  type PBNode struct {\n    Links [PBLink]\n    Data optional Bytes\n  }\n  */\n  // @ts-ignore private property for TS\n  if (!node || typeof node !== 'object' || Array.isArray(node) || node instanceof Uint8Array || (node['/'] && node['/'] === node.bytes)) {\n    throw new TypeError('Invalid DAG-PB form')\n  }\n\n  if (!hasOnlyProperties(node, pbNodeProperties)) {\n    throw new TypeError('Invalid DAG-PB form (extraneous properties)')\n  }\n\n  if (node.Data !== undefined && !(node.Data instanceof Uint8Array)) {\n    throw new TypeError('Invalid DAG-PB form (Data must be bytes)')\n  }\n\n  if (!Array.isArray(node.Links)) {\n    throw new TypeError('Invalid DAG-PB form (Links must be a list)')\n  }\n\n  for (let i = 0; i < node.Links.length; i++) {\n    const link = node.Links[i]\n    // @ts-ignore private property for TS\n    if (!link || typeof link !== 'object' || Array.isArray(link) || link instanceof Uint8Array || (link['/'] && link['/'] === link.bytes)) {\n      throw new TypeError('Invalid DAG-PB form (bad link)')\n    }\n\n    if (!hasOnlyProperties(link, pbLinkProperties)) {\n      throw new TypeError('Invalid DAG-PB form (extraneous properties on link)')\n    }\n\n    if (link.Hash === undefined) {\n      throw new TypeError('Invalid DAG-PB form (link must have a Hash)')\n    }\n\n    // @ts-ignore private property for TS\n    if (link.Hash == null || !link.Hash['/'] || link.Hash['/'] !== link.Hash.bytes) {\n      throw new TypeError('Invalid DAG-PB form (link Hash must be a CID)')\n    }\n\n    if (link.Name !== undefined && typeof link.Name !== 'string') {\n      throw new TypeError('Invalid DAG-PB form (link Name must be a string)')\n    }\n\n    if (link.Tsize !== undefined) {\n      if (typeof link.Tsize !== 'number' || link.Tsize % 1 !== 0) {\n        throw new TypeError('Invalid DAG-PB form (link Tsize must be an integer)')\n      }\n      if (link.Tsize < 0) {\n        throw new TypeError('Invalid DAG-PB form (link Tsize cannot be negative)')\n      }\n    }\n\n    if (i > 0 && linkComparator(link, node.Links[i - 1]) === -1) {\n      throw new TypeError('Invalid DAG-PB form (links must be sorted by Name bytes)')\n    }\n  }\n}\n\n/**\n * @param {Uint8Array} data\n * @param {PBLink[]} [links]\n * @returns {PBNode}\n */\nexport function createNode (data, links = []) {\n  return prepare({ Data: data, Links: links })\n}\n\n/**\n * @param {string} name\n * @param {number} size\n * @param {CID} cid\n * @returns {PBLink}\n */\nexport function createLink (name, size, cid) {\n  return asLink({ Hash: cid, Name: name, Tsize: size })\n}\n\n/**\n * @template T\n * @param {ByteView<T> | ArrayBufferView<T>} buf\n * @returns {ByteView<T>}\n */\nexport function toByteView (buf) {\n  if (buf instanceof ArrayBuffer) {\n    return new Uint8Array(buf, 0, buf.byteLength)\n  }\n\n  return buf\n}\n", "import { CID } from 'multiformats/cid'\nimport { decodeNode } from './pb-decode.js'\nimport { encodeNode } from './pb-encode.js'\nimport { prepare, validate, createNode, createLink, toByteView } from './util.js'\n\n/**\n * @template T\n * @typedef {import('multiformats/codecs/interface').ByteView<T>} ByteView\n */\n\n/**\n * @template T\n * @typedef {import('multiformats/codecs/interface').ArrayBufferView<T>} ArrayBufferView\n */\n\n/**\n * @typedef {import('./interface.js').PBLink} PBLink\n * @typedef {import('./interface.js').PBNode} PBNode\n */\n\nexport const name = 'dag-pb'\nexport const code = 0x70\n\n/**\n * @param {PBNode} node\n * @returns {ByteView<PBNode>}\n */\nexport function encode (node) {\n  validate(node)\n\n  const pbn = {}\n  if (node.Links) {\n    pbn.Links = node.Links.map((l) => {\n      const link = {}\n      if (l.Hash) {\n        link.Hash = l.Hash.bytes // cid -> bytes\n      }\n      if (l.Name !== undefined) {\n        link.Name = l.Name\n      }\n      if (l.Tsize !== undefined) {\n        link.Tsize = l.Tsize\n      }\n      return link\n    })\n  }\n  if (node.Data) {\n    pbn.Data = node.Data\n  }\n\n  return encodeNode(pbn)\n}\n\n/**\n * @param {ByteView<PBNode> | ArrayBufferView<PBNode>} bytes\n * @returns {PBNode}\n */\nexport function decode (bytes) {\n  const buf = toByteView(bytes)\n  const pbn = decodeNode(buf)\n\n  const node = {}\n\n  if (pbn.Data) {\n    node.Data = pbn.Data\n  }\n\n  if (pbn.Links) {\n    node.Links = pbn.Links.map((l) => {\n      const link = {}\n      try {\n        link.Hash = CID.decode(l.Hash)\n      } catch {\n        // ignore parse fail\n      }\n      if (!link.Hash) {\n        throw new Error('Invalid Hash field found in link, expected CID')\n      }\n      if (l.Name !== undefined) {\n        link.Name = l.Name\n      }\n      if (l.Tsize !== undefined) {\n        link.Tsize = l.Tsize\n      }\n      return link\n    })\n  }\n\n  return node\n}\n\nexport { prepare, validate, createNode, createLink }\n", "import type { ArrayBufferView, ByteView } from './interface.js'\n\nconst textEncoder = new TextEncoder()\nconst textDecoder = new TextDecoder()\n\nexport const name = 'json'\nexport const code = 0x0200\n\nexport function encode <T> (node: T): ByteView<T> {\n  return textEncoder.encode(JSON.stringify(node))\n}\n\nexport function decode <T> (data: ByteView<T> | ArrayBufferView<T>): T {\n  return JSON.parse(textDecoder.decode(data))\n}\n", "import { coerce } from '../bytes.js'\nimport type { ArrayBufferView, ByteView } from './interface.js'\n\nexport const name = 'raw'\nexport const code = 0x55\n\nexport function encode (node: Uint8Array): ByteView<Uint8Array> {\n  return coerce(node)\n}\n\nexport function decode (data: ByteView<Uint8Array> | ArrayBufferView<Uint8Array>): Uint8Array {\n  return coerce(data)\n}\n", "import { coerce } from '../bytes.js'\nimport * as Digest from './digest.js'\n\nconst code: 0x0 = 0x0\nconst name = 'identity'\n\nconst encode: (input: Uint8Array) => Uint8Array = coerce\n\nfunction digest (input: Uint8Array): Digest.Digest<typeof code, number> {\n  return Digest.create(code, encode(input))\n}\n\nexport const identity = { code, name, encode, digest }\n", "import { CID } from 'multiformats/cid'\nimport { NoPropError } from '../errors.js'\nimport type { ResolveResult } from '../index.js'\n\nexport function resolveObjectPath (object: any, block: Uint8Array, cid: CID, name: string, path: string, toResolve: string[], depth: number): ResolveResult {\n  let subObject = object\n  let subPath = path\n\n  while (toResolve.length > 0) {\n    const prop = toResolve[0]\n\n    if (prop in subObject) {\n      // remove the bit of the path we have resolved\n      toResolve.shift()\n      subPath = `${subPath}/${prop}`\n\n      const subObjectCid = CID.asCID(subObject[prop])\n      if (subObjectCid != null) {\n        return {\n          entry: {\n            type: 'object',\n            name,\n            path,\n            cid,\n            node: block,\n            depth,\n            size: BigInt(block.length),\n            content: async function * () {\n              yield object\n            }\n          },\n          next: {\n            cid: subObjectCid,\n            name: prop,\n            path: subPath,\n            toResolve\n          }\n        }\n      }\n\n      subObject = subObject[prop]\n    } else {\n      // cannot resolve further\n      throw new NoPropError(`No property named ${prop} found in node ${cid}`)\n    }\n  }\n\n  return {\n    entry: {\n      type: 'object',\n      name,\n      path,\n      cid,\n      node: block,\n      depth,\n      size: BigInt(block.length),\n      content: async function * () {\n        yield object\n      }\n    }\n  }\n}\n", "import * as dagCbor from '@ipld/dag-cbor'\nimport { resolveObjectPath } from '../utils/resolve-object-path.js'\nimport type { Resolver } from '../index.js'\n\nconst resolve: Resolver = async (cid, name, path, toResolve, resolve, depth, blockstore, options) => {\n  const block = await blockstore.get(cid, options)\n  const object = dagCbor.decode<any>(block)\n\n  return resolveObjectPath(object, block, cid, name, path, toResolve, depth)\n}\n\nexport default resolve\n", "import * as dagJson from '@ipld/dag-json'\nimport { resolveObjectPath } from '../utils/resolve-object-path.js'\nimport type { Resolver } from '../index.js'\n\nconst resolve: Resolver = async (cid, name, path, toResolve, resolve, depth, blockstore, options) => {\n  const block = await blockstore.get(cid, options)\n  const object = dagJson.decode<any>(block)\n\n  return resolveObjectPath(object, block, cid, name, path, toResolve, depth)\n}\n\nexport default resolve\n", "/**\n * Progress events are emitted during long running operations\n */\nexport interface ProgressEvent<T extends string = any, D = unknown> {\n  /**\n   * The event type\n   */\n  type: T\n\n  /**\n   * Context-specific event information\n   */\n  detail: D\n}\n\n/**\n * An implementation of the ProgressEvent interface, this is essentially\n * a typed `CustomEvent` with a `type` property that lets us disambiguate\n * events passed to `progress` callbacks.\n */\nexport class CustomProgressEvent<D = unknown, T extends string = any> extends Event implements ProgressEvent<T, D> {\n  public type: T\n  public detail: D\n\n  constructor (type: T, detail?: D) {\n    super(type)\n\n    this.type = type\n    // @ts-expect-error detail may be undefined\n    this.detail = detail\n  }\n}\n\n/**\n * Define an `onProgress` callback that can be invoked with `ProgressEvent`s\n *\n * @example\n *\n * ```typescript\n * type MyOperationProgressEvents =\n *   ProgressEvent<'operation:start'> |\n *   ProgressEvent<'operation:success', Result> |\n *   ProgressEvent<'operation:error', Error>\n *\n * export interface MyOperationOptions extends ProgressOptions<MyOperationProgressEvents> {\n *  // define options here\n * }\n * ```\n */\nexport interface ProgressOptions<Event extends ProgressEvent = any> {\n  onProgress?: (evt: Event) => void\n}\n", "function extractDataFromBlock (block: Uint8Array, blockStart: bigint, requestedStart: bigint, requestedEnd: bigint): Uint8Array {\n  const blockLength = BigInt(block.length)\n  const blockEnd = BigInt(blockStart + blockLength)\n\n  if (requestedStart >= blockEnd || requestedEnd < blockStart) {\n    // If we are looking for a byte range that is starts after the start of the block,\n    // return an empty block.  This can happen when internal nodes contain data\n    return new Uint8Array(0)\n  }\n\n  if (requestedEnd >= blockStart && requestedEnd < blockEnd) {\n    // If the end byte is in the current block, truncate the block to the end byte\n    block = block.subarray(0, Number(requestedEnd - blockStart))\n  }\n\n  if (requestedStart >= blockStart && requestedStart < blockEnd) {\n    // If the start byte is in the current block, skip to the start byte\n    block = block.subarray(Number(requestedStart - blockStart))\n  }\n\n  return block\n}\n\nexport default extractDataFromBlock\n", "import { InvalidParametersError } from '../errors.js'\n\nconst validateOffsetAndLength = (size: number | bigint, offset: number | bigint = 0, length: number | bigint = size): { start: bigint, end: bigint } => {\n  const fileSize = BigInt(size)\n  const start = BigInt(offset ?? 0)\n  let end = BigInt(length)\n\n  if (end !== fileSize) {\n    end = start + end\n  }\n\n  if (end > fileSize) {\n    end = fileSize\n  }\n\n  if (start < 0n) {\n    throw new InvalidParametersError('Offset must be greater than or equal to 0')\n  }\n\n  if (start > fileSize) {\n    throw new InvalidParametersError('Offset must be less than the file size')\n  }\n\n  if (end < 0n) {\n    throw new InvalidParametersError('Length must be greater than or equal to 0')\n  }\n\n  if (end > fileSize) {\n    throw new InvalidParametersError('Length must be less than the file size')\n  }\n\n  return {\n    start,\n    end\n  }\n}\n\nexport default validateOffsetAndLength\n", "import * as mh from 'multiformats/hashes/digest'\nimport { CustomProgressEvent } from 'progress-events'\nimport { NotFoundError } from '../errors.js'\nimport extractDataFromBlock from '../utils/extract-data-from-block.js'\nimport validateOffsetAndLength from '../utils/validate-offset-and-length.js'\nimport type { ExporterOptions, Resolver, ExportProgress } from '../index.js'\n\nconst rawContent = (node: Uint8Array): ((options?: ExporterOptions) => AsyncGenerator<Uint8Array, void, undefined>) => {\n  async function * contentGenerator (options: ExporterOptions = {}): AsyncGenerator<Uint8Array, void, undefined> {\n    const {\n      start,\n      end\n    } = validateOffsetAndLength(node.length, options.offset, options.length)\n\n    const buf = extractDataFromBlock(node, 0n, start, end)\n\n    options.onProgress?.(new CustomProgressEvent<ExportProgress>('unixfs:exporter:progress:identity', {\n      bytesRead: BigInt(buf.byteLength),\n      totalBytes: end - start,\n      fileSize: BigInt(node.byteLength)\n    }))\n\n    yield buf\n  }\n\n  return contentGenerator\n}\n\nconst resolve: Resolver = async (cid, name, path, toResolve, resolve, depth, blockstore, options) => {\n  if (toResolve.length > 0) {\n    throw new NotFoundError(`No link named ${path} found in raw node ${cid}`)\n  }\n  const buf = mh.decode(cid.multihash.bytes)\n\n  return {\n    entry: {\n      type: 'identity',\n      name,\n      path,\n      cid,\n      content: rawContent(buf.digest),\n      depth,\n      size: BigInt(buf.digest.length),\n      node: buf.digest\n    }\n  }\n}\n\nexport default resolve\n", "import * as json from 'multiformats/codecs/json'\nimport { resolveObjectPath } from '../utils/resolve-object-path.js'\nimport type { Resolver } from '../index.js'\n\nconst resolve: Resolver = async (cid, name, path, toResolve, resolve, depth, blockstore, options) => {\n  const block = await blockstore.get(cid, options)\n  const object = json.decode<any>(block)\n\n  return resolveObjectPath(object, block, cid, name, path, toResolve, depth)\n}\n\nexport default resolve\n", "import { CustomProgressEvent } from 'progress-events'\nimport { NotFoundError } from '../errors.js'\nimport extractDataFromBlock from '../utils/extract-data-from-block.js'\nimport validateOffsetAndLength from '../utils/validate-offset-and-length.js'\nimport type { ExporterOptions, Resolver, ExportProgress } from '../index.js'\n\nconst rawContent = (node: Uint8Array): ((options?: ExporterOptions) => AsyncGenerator<Uint8Array, void, undefined>) => {\n  async function * contentGenerator (options: ExporterOptions = {}): AsyncGenerator<Uint8Array, void, undefined> {\n    const {\n      start,\n      end\n    } = validateOffsetAndLength(node.length, options.offset, options.length)\n\n    const buf = extractDataFromBlock(node, 0n, start, end)\n\n    options.onProgress?.(new CustomProgressEvent<ExportProgress>('unixfs:exporter:progress:raw', {\n      bytesRead: BigInt(buf.byteLength),\n      totalBytes: end - start,\n      fileSize: BigInt(node.byteLength)\n    }))\n\n    yield buf\n  }\n\n  return contentGenerator\n}\n\nconst resolve: Resolver = async (cid, name, path, toResolve, resolve, depth, blockstore, options) => {\n  if (toResolve.length > 0) {\n    throw new NotFoundError(`No link named ${path} found in raw node ${cid}`)\n  }\n\n  const block = await blockstore.get(cid, options)\n\n  return {\n    entry: {\n      type: 'raw',\n      name,\n      path,\n      cid,\n      content: rawContent(block),\n      depth,\n      size: BigInt(block.length),\n      node: block\n    }\n  }\n}\n\nexport default resolve\n", "export class InvalidTypeError extends Error {\n  static name = 'InvalidTypeError'\n  static code = 'ERR_INVALID_TYPE'\n  name = InvalidTypeError.name\n  code = InvalidTypeError.code\n\n  constructor (message = 'Invalid type') {\n    super(message)\n  }\n}\n\nexport class InvalidUnixFSMessageError extends Error {\n  static name = 'InvalidUnixFSMessageError'\n  static code = 'ERR_INVALID_MESSAGE'\n  name = InvalidUnixFSMessageError.name\n  code = InvalidUnixFSMessageError.code\n\n  constructor (message = 'Invalid message') {\n    super(message)\n  }\n}\n", "/**\n * Returns a `Uint8Array` of the requested size. Referenced memory will\n * be initialized to 0.\n */\nexport function alloc (size: number = 0): Uint8Array {\n  return new Uint8Array(size)\n}\n\n/**\n * Where possible returns a Uint8Array of the requested size that references\n * uninitialized memory. Only use if you are certain you will immediately\n * overwrite every value in the returned `Uint8Array`.\n */\nexport function allocUnsafe (size: number = 0): Uint8Array {\n  return new Uint8Array(size)\n}\n", "/* eslint-disable no-fallthrough */\nimport { allocUnsafe } from 'uint8arrays/alloc'\nimport type { Uint8ArrayList } from 'uint8arraylist'\n\nconst N1 = Math.pow(2, 7)\nconst N2 = Math.pow(2, 14)\nconst N3 = Math.pow(2, 21)\nconst N4 = Math.pow(2, 28)\nconst N5 = Math.pow(2, 35)\nconst N6 = Math.pow(2, 42)\nconst N7 = Math.pow(2, 49)\n\n/** Most significant bit of a byte */\nconst MSB = 0x80\n/** Rest of the bits in a byte */\nconst REST = 0x7f\n\nexport function encodingLength (value: number): number {\n  if (value < N1) {\n    return 1\n  }\n\n  if (value < N2) {\n    return 2\n  }\n\n  if (value < N3) {\n    return 3\n  }\n\n  if (value < N4) {\n    return 4\n  }\n\n  if (value < N5) {\n    return 5\n  }\n\n  if (value < N6) {\n    return 6\n  }\n\n  if (value < N7) {\n    return 7\n  }\n\n  if (Number.MAX_SAFE_INTEGER != null && value > Number.MAX_SAFE_INTEGER) {\n    throw new RangeError('Could not encode varint')\n  }\n\n  return 8\n}\n\nexport function encodeUint8Array (value: number, buf: Uint8Array, offset: number = 0): Uint8Array {\n  switch (encodingLength(value)) {\n    case 8: {\n      buf[offset++] = (value & 0xFF) | MSB\n      value /= 128\n    }\n    case 7: {\n      buf[offset++] = (value & 0xFF) | MSB\n      value /= 128\n    }\n    case 6: {\n      buf[offset++] = (value & 0xFF) | MSB\n      value /= 128\n    }\n    case 5: {\n      buf[offset++] = (value & 0xFF) | MSB\n      value /= 128\n    }\n    case 4: {\n      buf[offset++] = (value & 0xFF) | MSB\n      value >>>= 7\n    }\n    case 3: {\n      buf[offset++] = (value & 0xFF) | MSB\n      value >>>= 7\n    }\n    case 2: {\n      buf[offset++] = (value & 0xFF) | MSB\n      value >>>= 7\n    }\n    case 1: {\n      buf[offset++] = (value & 0xFF)\n      value >>>= 7\n      break\n    }\n    default: throw new Error('unreachable')\n  }\n  return buf\n}\n\nexport function encodeUint8ArrayList (value: number, buf: Uint8ArrayList, offset: number = 0): Uint8ArrayList {\n  switch (encodingLength(value)) {\n    case 8: {\n      buf.set(offset++, (value & 0xFF) | MSB)\n      value /= 128\n    }\n    case 7: {\n      buf.set(offset++, (value & 0xFF) | MSB)\n      value /= 128\n    }\n    case 6: {\n      buf.set(offset++, (value & 0xFF) | MSB)\n      value /= 128\n    }\n    case 5: {\n      buf.set(offset++, (value & 0xFF) | MSB)\n      value /= 128\n    }\n    case 4: {\n      buf.set(offset++, (value & 0xFF) | MSB)\n      value >>>= 7\n    }\n    case 3: {\n      buf.set(offset++, (value & 0xFF) | MSB)\n      value >>>= 7\n    }\n    case 2: {\n      buf.set(offset++, (value & 0xFF) | MSB)\n      value >>>= 7\n    }\n    case 1: {\n      buf.set(offset++, (value & 0xFF))\n      value >>>= 7\n      break\n    }\n    default: throw new Error('unreachable')\n  }\n  return buf\n}\n\nexport function decodeUint8Array (buf: Uint8Array, offset: number): number {\n  let b = buf[offset]\n  let res = 0\n\n  res += b & REST\n  if (b < MSB) {\n    return res\n  }\n\n  b = buf[offset + 1]\n  res += (b & REST) << 7\n  if (b < MSB) {\n    return res\n  }\n\n  b = buf[offset + 2]\n  res += (b & REST) << 14\n  if (b < MSB) {\n    return res\n  }\n\n  b = buf[offset + 3]\n  res += (b & REST) << 21\n  if (b < MSB) {\n    return res\n  }\n\n  b = buf[offset + 4]\n  res += (b & REST) * N4\n  if (b < MSB) {\n    return res\n  }\n\n  b = buf[offset + 5]\n  res += (b & REST) * N5\n  if (b < MSB) {\n    return res\n  }\n\n  b = buf[offset + 6]\n  res += (b & REST) * N6\n  if (b < MSB) {\n    return res\n  }\n\n  b = buf[offset + 7]\n  res += (b & REST) * N7\n  if (b < MSB) {\n    return res\n  }\n\n  throw new RangeError('Could not decode varint')\n}\n\nexport function decodeUint8ArrayList (buf: Uint8ArrayList, offset: number): number {\n  let b = buf.get(offset)\n  let res = 0\n\n  res += b & REST\n  if (b < MSB) {\n    return res\n  }\n\n  b = buf.get(offset + 1)\n  res += (b & REST) << 7\n  if (b < MSB) {\n    return res\n  }\n\n  b = buf.get(offset + 2)\n  res += (b & REST) << 14\n  if (b < MSB) {\n    return res\n  }\n\n  b = buf.get(offset + 3)\n  res += (b & REST) << 21\n  if (b < MSB) {\n    return res\n  }\n\n  b = buf.get(offset + 4)\n  res += (b & REST) * N4\n  if (b < MSB) {\n    return res\n  }\n\n  b = buf.get(offset + 5)\n  res += (b & REST) * N5\n  if (b < MSB) {\n    return res\n  }\n\n  b = buf.get(offset + 6)\n  res += (b & REST) * N6\n  if (b < MSB) {\n    return res\n  }\n\n  b = buf.get(offset + 7)\n  res += (b & REST) * N7\n  if (b < MSB) {\n    return res\n  }\n\n  throw new RangeError('Could not decode varint')\n}\n\nexport function encode (value: number): Uint8Array\nexport function encode (value: number, buf: Uint8Array, offset?: number): Uint8Array\nexport function encode (value: number, buf: Uint8ArrayList, offset?: number): Uint8ArrayList\nexport function encode <T extends Uint8Array | Uint8ArrayList = Uint8Array> (value: number, buf?: T, offset: number = 0): T {\n  if (buf == null) {\n    buf = allocUnsafe(encodingLength(value)) as T\n  }\n  if (buf instanceof Uint8Array) {\n    return encodeUint8Array(value, buf, offset) as T\n  } else {\n    return encodeUint8ArrayList(value, buf, offset) as T\n  }\n}\n\nexport function decode (buf: Uint8ArrayList | Uint8Array, offset: number = 0): number {\n  if (buf instanceof Uint8Array) {\n    return decodeUint8Array(buf, offset)\n  } else {\n    return decodeUint8ArrayList(buf, offset)\n  }\n}\n", "const f32 = new Float32Array([-0])\nconst f8b = new Uint8Array(f32.buffer)\n\n/**\n * Writes a 32 bit float to a buffer using little endian byte order\n */\nexport function writeFloatLE (val: number, buf: Uint8Array, pos: number): void {\n  f32[0] = val\n  buf[pos] = f8b[0]\n  buf[pos + 1] = f8b[1]\n  buf[pos + 2] = f8b[2]\n  buf[pos + 3] = f8b[3]\n}\n\n/**\n * Writes a 32 bit float to a buffer using big endian byte order\n */\nexport function writeFloatBE (val: number, buf: Uint8Array, pos: number): void {\n  f32[0] = val\n  buf[pos] = f8b[3]\n  buf[pos + 1] = f8b[2]\n  buf[pos + 2] = f8b[1]\n  buf[pos + 3] = f8b[0]\n}\n\n/**\n * Reads a 32 bit float from a buffer using little endian byte order\n */\nexport function readFloatLE (buf: Uint8Array, pos: number): number {\n  f8b[0] = buf[pos]\n  f8b[1] = buf[pos + 1]\n  f8b[2] = buf[pos + 2]\n  f8b[3] = buf[pos + 3]\n  return f32[0]\n}\n\n/**\n * Reads a 32 bit float from a buffer using big endian byte order\n */\nexport function readFloatBE (buf: Uint8Array, pos: number): number {\n  f8b[3] = buf[pos]\n  f8b[2] = buf[pos + 1]\n  f8b[1] = buf[pos + 2]\n  f8b[0] = buf[pos + 3]\n  return f32[0]\n}\n\nconst f64 = new Float64Array([-0])\nconst d8b = new Uint8Array(f64.buffer)\n\n/**\n * Writes a 64 bit double to a buffer using little endian byte order\n */\nexport function writeDoubleLE (val: number, buf: Uint8Array, pos: number): void {\n  f64[0] = val\n  buf[pos] = d8b[0]\n  buf[pos + 1] = d8b[1]\n  buf[pos + 2] = d8b[2]\n  buf[pos + 3] = d8b[3]\n  buf[pos + 4] = d8b[4]\n  buf[pos + 5] = d8b[5]\n  buf[pos + 6] = d8b[6]\n  buf[pos + 7] = d8b[7]\n}\n\n/**\n * Writes a 64 bit double to a buffer using big endian byte order\n */\nexport function writeDoubleBE (val: number, buf: Uint8Array, pos: number): void {\n  f64[0] = val\n  buf[pos] = d8b[7]\n  buf[pos + 1] = d8b[6]\n  buf[pos + 2] = d8b[5]\n  buf[pos + 3] = d8b[4]\n  buf[pos + 4] = d8b[3]\n  buf[pos + 5] = d8b[2]\n  buf[pos + 6] = d8b[1]\n  buf[pos + 7] = d8b[0]\n}\n\n/**\n * Reads a 64 bit double from a buffer using little endian byte order\n */\nexport function readDoubleLE (buf: Uint8Array, pos: number): number {\n  d8b[0] = buf[pos]\n  d8b[1] = buf[pos + 1]\n  d8b[2] = buf[pos + 2]\n  d8b[3] = buf[pos + 3]\n  d8b[4] = buf[pos + 4]\n  d8b[5] = buf[pos + 5]\n  d8b[6] = buf[pos + 6]\n  d8b[7] = buf[pos + 7]\n  return f64[0]\n}\n\n/**\n * Reads a 64 bit double from a buffer using big endian byte order\n */\nexport function readDoubleBE (buf: Uint8Array, pos: number): number {\n  d8b[7] = buf[pos]\n  d8b[6] = buf[pos + 1]\n  d8b[5] = buf[pos + 2]\n  d8b[4] = buf[pos + 3]\n  d8b[3] = buf[pos + 4]\n  d8b[2] = buf[pos + 5]\n  d8b[1] = buf[pos + 6]\n  d8b[0] = buf[pos + 7]\n  return f64[0]\n}\n", "// the largest BigInt we can safely downcast to a Number\nconst MAX_SAFE_NUMBER_INTEGER = BigInt(Number.MAX_SAFE_INTEGER)\nconst MIN_SAFE_NUMBER_INTEGER = BigInt(Number.MIN_SAFE_INTEGER)\n\n/**\n * Constructs new long bits.\n *\n * @classdesc Helper class for working with the low and high bits of a 64 bit value.\n * @memberof util\n * @function Object() { [native code] }\n * @param {number} lo - Low 32 bits, unsigned\n * @param {number} hi - High 32 bits, unsigned\n */\nexport class LongBits {\n  public lo: number\n  public hi: number\n\n  constructor (lo: number, hi: number) {\n    // note that the casts below are theoretically unnecessary as of today, but older statically\n    // generated converter code might still call the ctor with signed 32bits. kept for compat.\n\n    /**\n     * Low bits\n     */\n    this.lo = lo | 0\n\n    /**\n     * High bits\n     */\n    this.hi = hi | 0\n  }\n\n  /**\n   * Converts this long bits to a possibly unsafe JavaScript number\n   */\n  toNumber (unsigned: boolean = false): number {\n    if (!unsigned && (this.hi >>> 31) > 0) {\n      const lo = ~this.lo + 1 >>> 0\n      let hi = ~this.hi >>> 0\n      if (lo === 0) {\n        hi = hi + 1 >>> 0\n      }\n      return -(lo + hi * 4294967296)\n    }\n    return this.lo + this.hi * 4294967296\n  }\n\n  /**\n   * Converts this long bits to a bigint\n   */\n  toBigInt (unsigned: boolean = false): bigint {\n    if (unsigned) {\n      return BigInt(this.lo >>> 0) + (BigInt(this.hi >>> 0) << 32n)\n    }\n\n    if ((this.hi >>> 31) !== 0) {\n      const lo = ~this.lo + 1 >>> 0\n      let hi = ~this.hi >>> 0\n      if (lo === 0) {\n        hi = hi + 1 >>> 0\n      }\n      return -(BigInt(lo) + (BigInt(hi) << 32n))\n    }\n\n    return BigInt(this.lo >>> 0) + (BigInt(this.hi >>> 0) << 32n)\n  }\n\n  /**\n   * Converts this long bits to a string\n   */\n  toString (unsigned: boolean = false): string {\n    return this.toBigInt(unsigned).toString()\n  }\n\n  /**\n   * Zig-zag encodes this long bits\n   */\n  zzEncode (): this {\n    const mask = this.hi >> 31\n    this.hi = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0\n    this.lo = (this.lo << 1 ^ mask) >>> 0\n    return this\n  }\n\n  /**\n   * Zig-zag decodes this long bits\n   */\n  zzDecode (): this {\n    const mask = -(this.lo & 1)\n    this.lo = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0\n    this.hi = (this.hi >>> 1 ^ mask) >>> 0\n    return this\n  }\n\n  /**\n   * Calculates the length of this longbits when encoded as a varint.\n   */\n  length (): number {\n    const part0 = this.lo\n    const part1 = (this.lo >>> 28 | this.hi << 4) >>> 0\n    const part2 = this.hi >>> 24\n    return part2 === 0\n      ? part1 === 0\n        ? part0 < 16384\n          ? part0 < 128 ? 1 : 2\n          : part0 < 2097152 ? 3 : 4\n        : part1 < 16384\n          ? part1 < 128 ? 5 : 6\n          : part1 < 2097152 ? 7 : 8\n      : part2 < 128 ? 9 : 10\n  }\n\n  /**\n   * Constructs new long bits from the specified number\n   */\n  static fromBigInt (value: bigint): LongBits {\n    if (value === 0n) {\n      return zero\n    }\n\n    if (value < MAX_SAFE_NUMBER_INTEGER && value > MIN_SAFE_NUMBER_INTEGER) {\n      return this.fromNumber(Number(value))\n    }\n\n    const negative = value < 0n\n\n    if (negative) {\n      value = -value\n    }\n\n    let hi = value >> 32n\n    let lo = value - (hi << 32n)\n\n    if (negative) {\n      hi = ~hi | 0n\n      lo = ~lo | 0n\n\n      if (++lo > TWO_32) {\n        lo = 0n\n        if (++hi > TWO_32) { hi = 0n }\n      }\n    }\n\n    return new LongBits(Number(lo), Number(hi))\n  }\n\n  /**\n   * Constructs new long bits from the specified number\n   */\n  static fromNumber (value: number): LongBits {\n    if (value === 0) { return zero }\n    const sign = value < 0\n    if (sign) { value = -value }\n    let lo = value >>> 0\n    let hi = (value - lo) / 4294967296 >>> 0\n    if (sign) {\n      hi = ~hi >>> 0\n      lo = ~lo >>> 0\n      if (++lo > 4294967295) {\n        lo = 0\n        if (++hi > 4294967295) { hi = 0 }\n      }\n    }\n    return new LongBits(lo, hi)\n  }\n\n  /**\n   * Constructs new long bits from a number, long or string\n   */\n  static from (value: bigint | number | string | { low: number, high: number }): LongBits {\n    if (typeof value === 'number') {\n      return LongBits.fromNumber(value)\n    }\n    if (typeof value === 'bigint') {\n      return LongBits.fromBigInt(value)\n    }\n    if (typeof value === 'string') {\n      return LongBits.fromBigInt(BigInt(value))\n    }\n    return value.low != null || value.high != null ? new LongBits(value.low >>> 0, value.high >>> 0) : zero\n  }\n}\n\nconst zero = new LongBits(0, 0)\nzero.toBigInt = function () { return 0n }\nzero.zzEncode = zero.zzDecode = function () { return this }\nzero.length = function () { return 1 }\n\nconst TWO_32 = 4294967296n\n", "/**\n * Calculates the UTF8 byte length of a string\n */\nexport function length (string: string): number {\n  let len = 0\n  let c = 0\n  for (let i = 0; i < string.length; ++i) {\n    c = string.charCodeAt(i)\n\n    if (c < 128) {\n      len += 1\n    } else if (c < 2048) {\n      len += 2\n    } else if ((c & 0xFC00) === 0xD800 && (string.charCodeAt(i + 1) & 0xFC00) === 0xDC00) {\n      ++i\n      len += 4\n    } else {\n      len += 3\n    }\n  }\n\n  return len\n}\n\n/**\n * Reads UTF8 bytes as a string\n */\nexport function read (buffer: Uint8Array, start: number, end: number): string {\n  const len = end - start\n\n  if (len < 1) {\n    return ''\n  }\n\n  let parts: string[] | undefined\n  const chunk: number[] = []\n  let i = 0 // char offset\n  let t: number // temporary\n\n  while (start < end) {\n    t = buffer[start++]\n\n    if (t < 128) {\n      chunk[i++] = t\n    } else if (t > 191 && t < 224) {\n      chunk[i++] = (t & 31) << 6 | buffer[start++] & 63\n    } else if (t > 239 && t < 365) {\n      t = ((t & 7) << 18 | (buffer[start++] & 63) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63) - 0x10000\n      chunk[i++] = 0xD800 + (t >> 10)\n      chunk[i++] = 0xDC00 + (t & 1023)\n    } else {\n      chunk[i++] = (t & 15) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63\n    }\n\n    if (i > 8191) {\n      (parts ?? (parts = [])).push(String.fromCharCode.apply(String, chunk))\n      i = 0\n    }\n  }\n\n  if (parts != null) {\n    if (i > 0) {\n      parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)))\n    }\n\n    return parts.join('')\n  }\n\n  return String.fromCharCode.apply(String, chunk.slice(0, i))\n}\n\n/**\n * Writes a string as UTF8 bytes\n */\nexport function write (string: string, buffer: Uint8Array, offset: number): number {\n  const start = offset\n  let c1 // character 1\n  let c2 // character 2\n\n  for (let i = 0; i < string.length; ++i) {\n    c1 = string.charCodeAt(i)\n\n    if (c1 < 128) {\n      buffer[offset++] = c1\n    } else if (c1 < 2048) {\n      buffer[offset++] = c1 >> 6 | 192\n      buffer[offset++] = c1 & 63 | 128\n    } else if ((c1 & 0xFC00) === 0xD800 && ((c2 = string.charCodeAt(i + 1)) & 0xFC00) === 0xDC00) {\n      c1 = 0x10000 + ((c1 & 0x03FF) << 10) + (c2 & 0x03FF)\n      ++i\n      buffer[offset++] = c1 >> 18 | 240\n      buffer[offset++] = c1 >> 12 & 63 | 128\n      buffer[offset++] = c1 >> 6 & 63 | 128\n      buffer[offset++] = c1 & 63 | 128\n    } else {\n      buffer[offset++] = c1 >> 12 | 224\n      buffer[offset++] = c1 >> 6 & 63 | 128\n      buffer[offset++] = c1 & 63 | 128\n    }\n  }\n\n  return offset - start\n}\n", "import { decodeUint8Array, encodingLength } from 'uint8-varint'\nimport { readFloatLE, readDoubleLE } from './float.js'\nimport { LongBits } from './longbits.js'\nimport * as utf8 from './utf8.js'\nimport type { Reader } from '../index.js'\nimport type { Uint8ArrayList } from 'uint8arraylist'\n\n/* istanbul ignore next */\nfunction indexOutOfRange (reader: Reader, writeLength?: number): RangeError {\n  return RangeError(`index out of range: ${reader.pos} + ${writeLength ?? 1} > ${reader.len}`)\n}\n\nfunction readFixed32End (buf: Uint8Array, end: number): number { // note that this uses `end`, not `pos`\n  return (buf[end - 4] |\n        buf[end - 3] << 8 |\n        buf[end - 2] << 16 |\n        buf[end - 1] << 24) >>> 0\n}\n\n/**\n * Constructs a new reader instance using the specified buffer.\n */\nexport class Uint8ArrayReader implements Reader {\n  public buf: Uint8Array\n  public pos: number\n  public len: number\n\n  public _slice = Uint8Array.prototype.subarray\n\n  constructor (buffer: Uint8Array) {\n    /**\n     * Read buffer\n     */\n    this.buf = buffer\n\n    /**\n     * Read buffer position\n     */\n    this.pos = 0\n\n    /**\n     * Read buffer length\n     */\n    this.len = buffer.length\n  }\n\n  /**\n   * Reads a varint as an unsigned 32 bit value\n   */\n  uint32 (): number {\n    let value = 4294967295\n\n    value = (this.buf[this.pos] & 127) >>> 0; if (this.buf[this.pos++] < 128) return value\n    value = (value | (this.buf[this.pos] & 127) << 7) >>> 0; if (this.buf[this.pos++] < 128) return value\n    value = (value | (this.buf[this.pos] & 127) << 14) >>> 0; if (this.buf[this.pos++] < 128) return value\n    value = (value | (this.buf[this.pos] & 127) << 21) >>> 0; if (this.buf[this.pos++] < 128) return value\n    value = (value | (this.buf[this.pos] & 15) << 28) >>> 0; if (this.buf[this.pos++] < 128) return value\n\n    if ((this.pos += 5) > this.len) {\n      this.pos = this.len\n      throw indexOutOfRange(this, 10)\n    }\n\n    return value\n  }\n\n  /**\n   * Reads a varint as a signed 32 bit value\n   */\n  int32 (): number {\n    return this.uint32() | 0\n  }\n\n  /**\n   * Reads a zig-zag encoded varint as a signed 32 bit value\n   */\n  sint32 (): number {\n    const value = this.uint32()\n    return value >>> 1 ^ -(value & 1) | 0\n  }\n\n  /**\n   * Reads a varint as a boolean\n   */\n  bool (): boolean {\n    return this.uint32() !== 0\n  }\n\n  /**\n   * Reads fixed 32 bits as an unsigned 32 bit integer\n   */\n  fixed32 (): number {\n    if (this.pos + 4 > this.len) { throw indexOutOfRange(this, 4) }\n\n    const res = readFixed32End(this.buf, this.pos += 4)\n\n    return res\n  }\n\n  /**\n   * Reads fixed 32 bits as a signed 32 bit integer\n   */\n  sfixed32 (): number {\n    if (this.pos + 4 > this.len) {\n      throw indexOutOfRange(this, 4)\n    }\n\n    const res = readFixed32End(this.buf, this.pos += 4) | 0\n\n    return res\n  }\n\n  /**\n   * Reads a float (32 bit) as a number\n   */\n  float (): number {\n    if (this.pos + 4 > this.len) {\n      throw indexOutOfRange(this, 4)\n    }\n\n    const value = readFloatLE(this.buf, this.pos)\n    this.pos += 4\n    return value\n  }\n\n  /**\n   * Reads a double (64 bit float) as a number\n   */\n  double (): number {\n    /* istanbul ignore if */\n    if (this.pos + 8 > this.len) { throw indexOutOfRange(this, 4) }\n\n    const value = readDoubleLE(this.buf, this.pos)\n    this.pos += 8\n    return value\n  }\n\n  /**\n   * Reads a sequence of bytes preceded by its length as a varint\n   */\n  bytes (): Uint8Array {\n    const length = this.uint32()\n    const start = this.pos\n    const end = this.pos + length\n\n    /* istanbul ignore if */\n    if (end > this.len) {\n      throw indexOutOfRange(this, length)\n    }\n\n    this.pos += length\n\n    return start === end // fix for IE 10/Win8 and others' subarray returning array of size 1\n      ? new Uint8Array(0)\n      : this.buf.subarray(start, end)\n  }\n\n  /**\n   * Reads a string preceded by its byte length as a varint\n   */\n  string (): string {\n    const bytes = this.bytes()\n    return utf8.read(bytes, 0, bytes.length)\n  }\n\n  /**\n   * Skips the specified number of bytes if specified, otherwise skips a varint\n   */\n  skip (length?: number): this {\n    if (typeof length === 'number') {\n      /* istanbul ignore if */\n      if (this.pos + length > this.len) { throw indexOutOfRange(this, length) }\n      this.pos += length\n    } else {\n      do {\n        /* istanbul ignore if */\n        if (this.pos >= this.len) {\n          throw indexOutOfRange(this)\n        }\n      } while ((this.buf[this.pos++] & 128) !== 0)\n    }\n    return this\n  }\n\n  /**\n   * Skips the next element of the specified wire type\n   */\n  skipType (wireType: number): this {\n    switch (wireType) {\n      case 0:\n        this.skip()\n        break\n      case 1:\n        this.skip(8)\n        break\n      case 2:\n        this.skip(this.uint32())\n        break\n      case 3:\n        while ((wireType = this.uint32() & 7) !== 4) {\n          this.skipType(wireType)\n        }\n        break\n      case 5:\n        this.skip(4)\n        break\n\n        /* istanbul ignore next */\n      default:\n        throw Error(`invalid wire type ${wireType} at offset ${this.pos}`)\n    }\n    return this\n  }\n\n  private readLongVarint (): LongBits {\n    // tends to deopt with local vars for octet etc.\n    const bits = new LongBits(0, 0)\n    let i = 0\n    if (this.len - this.pos > 4) { // fast route (lo)\n      for (; i < 4; ++i) {\n        // 1st..4th\n        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0\n        if (this.buf[this.pos++] < 128) { return bits }\n      }\n      // 5th\n      bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0\n      bits.hi = (bits.hi | (this.buf[this.pos] & 127) >> 4) >>> 0\n      if (this.buf[this.pos++] < 128) { return bits }\n      i = 0\n    } else {\n      for (; i < 3; ++i) {\n        /* istanbul ignore if */\n        if (this.pos >= this.len) { throw indexOutOfRange(this) }\n        // 1st..3th\n        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0\n        if (this.buf[this.pos++] < 128) { return bits }\n      }\n      // 4th\n      bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0\n      return bits\n    }\n    if (this.len - this.pos > 4) { // fast route (hi)\n      for (; i < 5; ++i) {\n        // 6th..10th\n        bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0\n        if (this.buf[this.pos++] < 128) { return bits }\n      }\n    } else {\n      for (; i < 5; ++i) {\n        if (this.pos >= this.len) {\n          throw indexOutOfRange(this)\n        }\n\n        // 6th..10th\n        bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0\n        if (this.buf[this.pos++] < 128) { return bits }\n      }\n    }\n\n    throw Error('invalid varint encoding')\n  }\n\n  private readFixed64 (): LongBits {\n    if (this.pos + 8 > this.len) {\n      throw indexOutOfRange(this, 8)\n    }\n\n    const lo = readFixed32End(this.buf, this.pos += 4)\n    const hi = readFixed32End(this.buf, this.pos += 4)\n\n    return new LongBits(lo, hi)\n  }\n\n  /**\n   * Reads a varint as a signed 64 bit value\n   */\n  int64 (): bigint {\n    return this.readLongVarint().toBigInt()\n  }\n\n  /**\n   * Reads a varint as a signed 64 bit value returned as a possibly unsafe\n   * JavaScript number\n   */\n  int64Number (): number {\n    return this.readLongVarint().toNumber()\n  }\n\n  /**\n   * Reads a varint as a signed 64 bit value returned as a string\n   */\n  int64String (): string {\n    return this.readLongVarint().toString()\n  }\n\n  /**\n   * Reads a varint as an unsigned 64 bit value\n   */\n  uint64 (): bigint {\n    return this.readLongVarint().toBigInt(true)\n  }\n\n  /**\n   * Reads a varint as an unsigned 64 bit value returned as a possibly unsafe\n   * JavaScript number\n   */\n  uint64Number (): number {\n    const value = decodeUint8Array(this.buf, this.pos)\n    this.pos += encodingLength(value)\n    return value\n  }\n\n  /**\n   * Reads a varint as an unsigned 64 bit value returned as a string\n   */\n  uint64String (): string {\n    return this.readLongVarint().toString(true)\n  }\n\n  /**\n   * Reads a zig-zag encoded varint as a signed 64 bit value\n   */\n  sint64 (): bigint {\n    return this.readLongVarint().zzDecode().toBigInt()\n  }\n\n  /**\n   * Reads a zig-zag encoded varint as a signed 64 bit value returned as a\n   * possibly unsafe JavaScript number\n   */\n  sint64Number (): number {\n    return this.readLongVarint().zzDecode().toNumber()\n  }\n\n  /**\n   * Reads a zig-zag encoded varint as a signed 64 bit value returned as a\n   * string\n   */\n  sint64String (): string {\n    return this.readLongVarint().zzDecode().toString()\n  }\n\n  /**\n   * Reads fixed 64 bits\n   */\n  fixed64 (): bigint {\n    return this.readFixed64().toBigInt()\n  }\n\n  /**\n   * Reads fixed 64 bits returned as a possibly unsafe JavaScript number\n   */\n  fixed64Number (): number {\n    return this.readFixed64().toNumber()\n  }\n\n  /**\n   * Reads fixed 64 bits returned as a string\n   */\n  fixed64String (): string {\n    return this.readFixed64().toString()\n  }\n\n  /**\n   * Reads zig-zag encoded fixed 64 bits\n   */\n  sfixed64 (): bigint {\n    return this.readFixed64().toBigInt()\n  }\n\n  /**\n   * Reads zig-zag encoded fixed 64 bits returned as a possibly unsafe\n   * JavaScript number\n   */\n  sfixed64Number (): number {\n    return this.readFixed64().toNumber()\n  }\n\n  /**\n   * Reads zig-zag encoded fixed 64 bits returned as a string\n   */\n  sfixed64String (): string {\n    return this.readFixed64().toString()\n  }\n}\n\nexport function createReader (buf: Uint8Array | Uint8ArrayList): Reader {\n  return new Uint8ArrayReader(buf instanceof Uint8Array ? buf : buf.subarray())\n}\n", "import { createReader } from './utils/reader.js'\nimport type { Codec, DecodeOptions } from './codec.js'\nimport type { Uint8ArrayList } from 'uint8arraylist'\n\nexport function decodeMessage <T> (buf: Uint8Array | Uint8ArrayList, codec: Pick<Codec<T>, 'decode'>, opts?: DecodeOptions<T>): T {\n  const reader = createReader(buf)\n\n  return codec.decode(reader, undefined, opts)\n}\n", "import { baseX } from './base.js'\n\nexport const base10 = baseX({\n  prefix: '9',\n  name: 'base10',\n  alphabet: '0123456789'\n})\n", "import { rfc4648 } from './base.js'\n\nexport const base16 = rfc4648({\n  prefix: 'f',\n  name: 'base16',\n  alphabet: '0123456789abcdef',\n  bitsPerChar: 4\n})\n\nexport const base16upper = rfc4648({\n  prefix: 'F',\n  name: 'base16upper',\n  alphabet: '0123456789ABCDEF',\n  bitsPerChar: 4\n})\n", "import { rfc4648 } from './base.js'\n\nexport const base2 = rfc4648({\n  prefix: '0',\n  name: 'base2',\n  alphabet: '01',\n  bitsPerChar: 1\n})\n", "import { from } from './base.js'\n\nconst alphabet = Array.from('\uD83D\uDE80\uD83E\uDE90\u2604\uD83D\uDEF0\uD83C\uDF0C\uD83C\uDF11\uD83C\uDF12\uD83C\uDF13\uD83C\uDF14\uD83C\uDF15\uD83C\uDF16\uD83C\uDF17\uD83C\uDF18\uD83C\uDF0D\uD83C\uDF0F\uD83C\uDF0E\uD83D\uDC09\u2600\uD83D\uDCBB\uD83D\uDDA5\uD83D\uDCBE\uD83D\uDCBF\uD83D\uDE02\u2764\uD83D\uDE0D\uD83E\uDD23\uD83D\uDE0A\uD83D\uDE4F\uD83D\uDC95\uD83D\uDE2D\uD83D\uDE18\uD83D\uDC4D\uD83D\uDE05\uD83D\uDC4F\uD83D\uDE01\uD83D\uDD25\uD83E\uDD70\uD83D\uDC94\uD83D\uDC96\uD83D\uDC99\uD83D\uDE22\uD83E\uDD14\uD83D\uDE06\uD83D\uDE44\uD83D\uDCAA\uD83D\uDE09\u263A\uD83D\uDC4C\uD83E\uDD17\uD83D\uDC9C\uD83D\uDE14\uD83D\uDE0E\uD83D\uDE07\uD83C\uDF39\uD83E\uDD26\uD83C\uDF89\uD83D\uDC9E\u270C\u2728\uD83E\uDD37\uD83D\uDE31\uD83D\uDE0C\uD83C\uDF38\uD83D\uDE4C\uD83D\uDE0B\uD83D\uDC97\uD83D\uDC9A\uD83D\uDE0F\uD83D\uDC9B\uD83D\uDE42\uD83D\uDC93\uD83E\uDD29\uD83D\uDE04\uD83D\uDE00\uD83D\uDDA4\uD83D\uDE03\uD83D\uDCAF\uD83D\uDE48\uD83D\uDC47\uD83C\uDFB6\uD83D\uDE12\uD83E\uDD2D\u2763\uD83D\uDE1C\uD83D\uDC8B\uD83D\uDC40\uD83D\uDE2A\uD83D\uDE11\uD83D\uDCA5\uD83D\uDE4B\uD83D\uDE1E\uD83D\uDE29\uD83D\uDE21\uD83E\uDD2A\uD83D\uDC4A\uD83E\uDD73\uD83D\uDE25\uD83E\uDD24\uD83D\uDC49\uD83D\uDC83\uD83D\uDE33\u270B\uD83D\uDE1A\uD83D\uDE1D\uD83D\uDE34\uD83C\uDF1F\uD83D\uDE2C\uD83D\uDE43\uD83C\uDF40\uD83C\uDF37\uD83D\uDE3B\uD83D\uDE13\u2B50\u2705\uD83E\uDD7A\uD83C\uDF08\uD83D\uDE08\uD83E\uDD18\uD83D\uDCA6\u2714\uD83D\uDE23\uD83C\uDFC3\uD83D\uDC90\u2639\uD83C\uDF8A\uD83D\uDC98\uD83D\uDE20\u261D\uD83D\uDE15\uD83C\uDF3A\uD83C\uDF82\uD83C\uDF3B\uD83D\uDE10\uD83D\uDD95\uD83D\uDC9D\uD83D\uDE4A\uD83D\uDE39\uD83D\uDDE3\uD83D\uDCAB\uD83D\uDC80\uD83D\uDC51\uD83C\uDFB5\uD83E\uDD1E\uD83D\uDE1B\uD83D\uDD34\uD83D\uDE24\uD83C\uDF3C\uD83D\uDE2B\u26BD\uD83E\uDD19\u2615\uD83C\uDFC6\uD83E\uDD2B\uD83D\uDC48\uD83D\uDE2E\uD83D\uDE46\uD83C\uDF7B\uD83C\uDF43\uD83D\uDC36\uD83D\uDC81\uD83D\uDE32\uD83C\uDF3F\uD83E\uDDE1\uD83C\uDF81\u26A1\uD83C\uDF1E\uD83C\uDF88\u274C\u270A\uD83D\uDC4B\uD83D\uDE30\uD83E\uDD28\uD83D\uDE36\uD83E\uDD1D\uD83D\uDEB6\uD83D\uDCB0\uD83C\uDF53\uD83D\uDCA2\uD83E\uDD1F\uD83D\uDE41\uD83D\uDEA8\uD83D\uDCA8\uD83E\uDD2C\u2708\uD83C\uDF80\uD83C\uDF7A\uD83E\uDD13\uD83D\uDE19\uD83D\uDC9F\uD83C\uDF31\uD83D\uDE16\uD83D\uDC76\uD83E\uDD74\u25B6\u27A1\u2753\uD83D\uDC8E\uD83D\uDCB8\u2B07\uD83D\uDE28\uD83C\uDF1A\uD83E\uDD8B\uD83D\uDE37\uD83D\uDD7A\u26A0\uD83D\uDE45\uD83D\uDE1F\uD83D\uDE35\uD83D\uDC4E\uD83E\uDD32\uD83E\uDD20\uD83E\uDD27\uD83D\uDCCC\uD83D\uDD35\uD83D\uDC85\uD83E\uDDD0\uD83D\uDC3E\uD83C\uDF52\uD83D\uDE17\uD83E\uDD11\uD83C\uDF0A\uD83E\uDD2F\uD83D\uDC37\u260E\uD83D\uDCA7\uD83D\uDE2F\uD83D\uDC86\uD83D\uDC46\uD83C\uDFA4\uD83D\uDE47\uD83C\uDF51\u2744\uD83C\uDF34\uD83D\uDCA3\uD83D\uDC38\uD83D\uDC8C\uD83D\uDCCD\uD83E\uDD40\uD83E\uDD22\uD83D\uDC45\uD83D\uDCA1\uD83D\uDCA9\uD83D\uDC50\uD83D\uDCF8\uD83D\uDC7B\uD83E\uDD10\uD83E\uDD2E\uD83C\uDFBC\uD83E\uDD75\uD83D\uDEA9\uD83C\uDF4E\uD83C\uDF4A\uD83D\uDC7C\uD83D\uDC8D\uD83D\uDCE3\uD83E\uDD42')\nconst alphabetBytesToChars: string[] = (alphabet.reduce<string[]>((p, c, i) => { p[i] = c; return p }, ([])))\nconst alphabetCharsToBytes: number[] = (alphabet.reduce<number[]>((p, c, i) => {\n  const codePoint = c.codePointAt(0)\n  if (codePoint == null) {\n    throw new Error(`Invalid character: ${c}`)\n  }\n  p[codePoint] = i\n  return p\n}, ([])))\n\nfunction encode (data: Uint8Array): string {\n  return data.reduce((p, c) => {\n    p += alphabetBytesToChars[c]\n    return p\n  }, '')\n}\n\nfunction decode (str: string): Uint8Array {\n  const byts = []\n  for (const char of str) {\n    const codePoint = char.codePointAt(0)\n    if (codePoint == null) {\n      throw new Error(`Invalid character: ${char}`)\n    }\n    const byt = alphabetCharsToBytes[codePoint]\n    if (byt == null) {\n      throw new Error(`Non-base256emoji character: ${char}`)\n    }\n    byts.push(byt)\n  }\n  return new Uint8Array(byts)\n}\n\nexport const base256emoji = from({\n  prefix: '\uD83D\uDE80',\n  name: 'base256emoji',\n  encode,\n  decode\n})\n", "import { rfc4648 } from './base.js'\n\nexport const base8 = rfc4648({\n  prefix: '7',\n  name: 'base8',\n  alphabet: '01234567',\n  bitsPerChar: 3\n})\n", "import { fromString, toString } from '../bytes.js'\nimport { from } from './base.js'\n\nexport const identity = from({\n  prefix: '\\x00',\n  name: 'identity',\n  encode: (buf) => toString(buf),\n  decode: (str) => fromString(str)\n})\n", "/* global crypto */\n\nimport { from } from './hasher.js'\n\nfunction sha (name: AlgorithmIdentifier): (data: Uint8Array) => Promise<Uint8Array> {\n  return async data => new Uint8Array(await crypto.subtle.digest(name, data))\n}\n\nexport const sha256 = from({\n  name: 'sha2-256',\n  code: 0x12,\n  encode: sha('SHA-256')\n})\n\nexport const sha512 = from({\n  name: 'sha2-512',\n  code: 0x13,\n  encode: sha('SHA-512')\n})\n", "import * as base10 from './bases/base10.js'\nimport * as base16 from './bases/base16.js'\nimport * as base2 from './bases/base2.js'\nimport * as base256emoji from './bases/base256emoji.js'\nimport * as base32 from './bases/base32.js'\nimport * as base36 from './bases/base36.js'\nimport * as base58 from './bases/base58.js'\nimport * as base64 from './bases/base64.js'\nimport * as base8 from './bases/base8.js'\nimport * as identityBase from './bases/identity.js'\nimport * as json from './codecs/json.js'\nimport * as raw from './codecs/raw.js'\nimport * as identity from './hashes/identity.js'\nimport * as sha2 from './hashes/sha2.js'\nimport { CID, hasher, digest, varint, bytes } from './index.js'\n\nexport const bases = { ...identityBase, ...base2, ...base8, ...base10, ...base16, ...base32, ...base36, ...base58, ...base64, ...base256emoji }\nexport const hashes = { ...sha2, ...identity }\nexport const codecs = { raw, json }\n\nexport { CID, hasher, digest, varint, bytes }\n", "import { bases } from 'multiformats/basics'\nimport type { MultibaseCodec } from 'multiformats'\nimport { allocUnsafe } from '#alloc'\n\nfunction createCodec (name: string, prefix: string, encode: (buf: Uint8Array) => string, decode: (str: string) => Uint8Array): MultibaseCodec<any> {\n  return {\n    name,\n    prefix,\n    encoder: {\n      name,\n      prefix,\n      encode\n    },\n    decoder: {\n      decode\n    }\n  }\n}\n\nconst string = createCodec('utf8', 'u', (buf) => {\n  const decoder = new TextDecoder('utf8')\n  return 'u' + decoder.decode(buf)\n}, (str) => {\n  const encoder = new TextEncoder()\n  return encoder.encode(str.substring(1))\n})\n\nconst ascii = createCodec('ascii', 'a', (buf) => {\n  let string = 'a'\n\n  for (let i = 0; i < buf.length; i++) {\n    string += String.fromCharCode(buf[i])\n  }\n  return string\n}, (str) => {\n  str = str.substring(1)\n  const buf = allocUnsafe(str.length)\n\n  for (let i = 0; i < str.length; i++) {\n    buf[i] = str.charCodeAt(i)\n  }\n\n  return buf\n})\n\nexport type SupportedEncodings = 'utf8' | 'utf-8' | 'hex' | 'latin1' | 'ascii' | 'binary' | keyof typeof bases\n\nconst BASES: Record<SupportedEncodings, MultibaseCodec<any>> = {\n  utf8: string,\n  'utf-8': string,\n  hex: bases.base16,\n  latin1: ascii,\n  ascii,\n  binary: ascii,\n\n  ...bases\n}\n\nexport default BASES\n", "import bases, { type SupportedEncodings } from './util/bases.js'\n\nexport type { SupportedEncodings }\n\n/**\n * Create a `Uint8Array` from the passed string\n *\n * Supports `utf8`, `utf-8`, `hex`, and any encoding supported by the multiformats module.\n *\n * Also `ascii` which is similar to node's 'binary' encoding.\n */\nexport function fromString (string: string, encoding: SupportedEncodings = 'utf8'): Uint8Array {\n  const base = bases[encoding]\n\n  if (base == null) {\n    throw new Error(`Unsupported encoding \"${encoding}\"`)\n  }\n\n  // add multibase prefix\n  return base.decoder.decode(`${base.prefix}${string}`) // eslint-disable-line @typescript-eslint/restrict-template-expressions\n}\n", "import { allocUnsafe } from 'uint8arrays/alloc'\n\n/**\n * A general purpose buffer pool\n */\nexport default function pool (size?: number): (size: number) => Uint8Array {\n  const SIZE = size ?? 8192\n  const MAX = SIZE >>> 1\n  let slab: Uint8Array\n  let offset = SIZE\n  return function poolAlloc (size: number) {\n    if (size < 1 || size > MAX) {\n      return allocUnsafe(size)\n    }\n\n    if (offset + size > SIZE) {\n      slab = allocUnsafe(SIZE)\n      offset = 0\n    }\n\n    const buf = slab.subarray(offset, offset += size)\n\n    if ((offset & 7) !== 0) {\n      // align to 32 bit\n      offset = (offset | 7) + 1\n    }\n\n    return buf\n  }\n}\n", "import { encodeUint8Array, encodingLength } from 'uint8-varint'\nimport { allocUnsafe } from 'uint8arrays/alloc'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport { writeFloatLE, writeDoubleLE } from './float.js'\nimport { LongBits } from './longbits.js'\nimport pool from './pool.js'\nimport * as utf8 from './utf8.js'\nimport type { Writer } from '../index.js'\n\ninterface WriterOperation<T> {\n  (val: T, buf: Uint8Array, pos: number): any\n}\n\n/**\n * Constructs a new writer operation instance.\n *\n * @classdesc Scheduled writer operation\n */\nclass Op<T> {\n  /**\n   * Function to call\n   */\n  public fn: WriterOperation<T>\n\n  /**\n   * Value byte length\n   */\n  public len: number\n\n  /**\n   * Next operation\n   */\n  public next?: Op<any>\n\n  /**\n   * Value to write\n   */\n  public val: T\n\n  constructor (fn: WriterOperation<T>, len: number, val: T) {\n    this.fn = fn\n    this.len = len\n    this.next = undefined\n    this.val = val // type varies\n  }\n}\n\n/* istanbul ignore next */\nfunction noop (): void {} // eslint-disable-line no-empty-function\n\n/**\n * Constructs a new writer state instance\n */\nclass State {\n  /**\n   * Current head\n   */\n  public head: Op<any>\n\n  /**\n   * Current tail\n   */\n  public tail: Op<any>\n\n  /**\n   * Current buffer length\n   */\n  public len: number\n\n  /**\n   * Next state\n   */\n  public next?: State\n\n  constructor (writer: Uint8ArrayWriter) {\n    this.head = writer.head\n    this.tail = writer.tail\n    this.len = writer.len\n    this.next = writer.states\n  }\n}\n\nconst bufferPool = pool()\n\n/**\n * Allocates a buffer of the specified size\n */\nfunction alloc (size: number): Uint8Array {\n  if (globalThis.Buffer != null) {\n    return allocUnsafe(size)\n  }\n\n  return bufferPool(size)\n}\n\n/**\n * When a value is written, the writer calculates its byte length and puts it into a linked\n * list of operations to perform when finish() is called. This both allows us to allocate\n * buffers of the exact required size and reduces the amount of work we have to do compared\n * to first calculating over objects and then encoding over objects. In our case, the encoding\n * part is just a linked list walk calling operations with already prepared values.\n */\nclass Uint8ArrayWriter implements Writer {\n  /**\n   * Current length\n   */\n  public len: number\n\n  /**\n   * Operations head\n   */\n  public head: Op<any>\n\n  /**\n   * Operations tail\n   */\n  public tail: Op<any>\n\n  /**\n   * Linked forked states\n   */\n  public states?: any\n\n  constructor () {\n    this.len = 0\n    this.head = new Op(noop, 0, 0)\n    this.tail = this.head\n    this.states = null\n  }\n\n  /**\n   * Pushes a new operation to the queue\n   */\n  _push (fn: WriterOperation<any>, len: number, val: any): this {\n    this.tail = this.tail.next = new Op(fn, len, val)\n    this.len += len\n\n    return this\n  }\n\n  /**\n   * Writes an unsigned 32 bit value as a varint\n   */\n  uint32 (value: number): this {\n    // here, the call to this.push has been inlined and a varint specific Op subclass is used.\n    // uint32 is by far the most frequently used operation and benefits significantly from this.\n    this.len += (this.tail = this.tail.next = new VarintOp(\n      (value = value >>> 0) <\n                128\n        ? 1\n        : value < 16384\n          ? 2\n          : value < 2097152\n            ? 3\n            : value < 268435456\n              ? 4\n              : 5,\n      value)).len\n    return this\n  }\n\n  /**\n   * Writes a signed 32 bit value as a varint`\n   */\n  int32 (value: number): this {\n    return value < 0\n      ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) // 10 bytes per spec\n      : this.uint32(value)\n  }\n\n  /**\n   * Writes a 32 bit value as a varint, zig-zag encoded\n   */\n  sint32 (value: number): this {\n    return this.uint32((value << 1 ^ value >> 31) >>> 0)\n  }\n\n  /**\n   * Writes an unsigned 64 bit value as a varint\n   */\n  uint64 (value: bigint): this {\n    const bits = LongBits.fromBigInt(value)\n    return this._push(writeVarint64, bits.length(), bits)\n  }\n\n  /**\n   * Writes an unsigned 64 bit value as a varint\n   */\n  uint64Number (value: number): this {\n    return this._push(encodeUint8Array, encodingLength(value), value)\n  }\n\n  /**\n   * Writes an unsigned 64 bit value as a varint\n   */\n  uint64String (value: string): this {\n    return this.uint64(BigInt(value))\n  }\n\n  /**\n   * Writes a signed 64 bit value as a varint\n   */\n  int64 (value: bigint): this {\n    return this.uint64(value)\n  }\n\n  /**\n   * Writes a signed 64 bit value as a varint\n   */\n  int64Number (value: number): this {\n    return this.uint64Number(value)\n  }\n\n  /**\n   * Writes a signed 64 bit value as a varint\n   */\n  int64String (value: string): this {\n    return this.uint64String(value)\n  }\n\n  /**\n   * Writes a signed 64 bit value as a varint, zig-zag encoded\n   */\n  sint64 (value: bigint): this {\n    const bits = LongBits.fromBigInt(value).zzEncode()\n    return this._push(writeVarint64, bits.length(), bits)\n  }\n\n  /**\n   * Writes a signed 64 bit value as a varint, zig-zag encoded\n   */\n  sint64Number (value: number): this {\n    const bits = LongBits.fromNumber(value).zzEncode()\n    return this._push(writeVarint64, bits.length(), bits)\n  }\n\n  /**\n   * Writes a signed 64 bit value as a varint, zig-zag encoded\n   */\n  sint64String (value: string): this {\n    return this.sint64(BigInt(value))\n  }\n\n  /**\n   * Writes a boolish value as a varint\n   */\n  bool (value: boolean): this {\n    return this._push(writeByte, 1, value ? 1 : 0)\n  }\n\n  /**\n   * Writes an unsigned 32 bit value as fixed 32 bits\n   */\n  fixed32 (value: number): this {\n    return this._push(writeFixed32, 4, value >>> 0)\n  }\n\n  /**\n   * Writes a signed 32 bit value as fixed 32 bits\n   */\n  sfixed32 (value: number): this {\n    return this.fixed32(value)\n  }\n\n  /**\n   * Writes an unsigned 64 bit value as fixed 64 bits\n   */\n  fixed64 (value: bigint): this {\n    const bits = LongBits.fromBigInt(value)\n    return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi)\n  }\n\n  /**\n   * Writes an unsigned 64 bit value as fixed 64 bits\n   */\n  fixed64Number (value: number): this {\n    const bits = LongBits.fromNumber(value)\n    return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi)\n  }\n\n  /**\n   * Writes an unsigned 64 bit value as fixed 64 bits\n   */\n  fixed64String (value: string): this {\n    return this.fixed64(BigInt(value))\n  }\n\n  /**\n   * Writes a signed 64 bit value as fixed 64 bits\n   */\n  sfixed64 (value: bigint): this {\n    return this.fixed64(value)\n  }\n\n  /**\n   * Writes a signed 64 bit value as fixed 64 bits\n   */\n  sfixed64Number (value: number): this {\n    return this.fixed64Number(value)\n  }\n\n  /**\n   * Writes a signed 64 bit value as fixed 64 bits\n   */\n  sfixed64String (value: string): this {\n    return this.fixed64String(value)\n  }\n\n  /**\n   * Writes a float (32 bit)\n   */\n  float (value: number): this {\n    return this._push(writeFloatLE, 4, value)\n  }\n\n  /**\n   * Writes a double (64 bit float).\n   *\n   * @function\n   * @param {number} value - Value to write\n   * @returns {Writer} `this`\n   */\n  double (value: number): this {\n    return this._push(writeDoubleLE, 8, value)\n  }\n\n  /**\n   * Writes a sequence of bytes\n   */\n  bytes (value: Uint8Array): this {\n    const len = value.length >>> 0\n\n    if (len === 0) {\n      return this._push(writeByte, 1, 0)\n    }\n\n    return this.uint32(len)._push(writeBytes, len, value)\n  }\n\n  /**\n   * Writes a string\n   */\n  string (value: string): this {\n    const len = utf8.length(value)\n    return len !== 0\n      ? this.uint32(len)._push(utf8.write, len, value)\n      : this._push(writeByte, 1, 0)\n  }\n\n  /**\n   * Forks this writer's state by pushing it to a stack.\n   * Calling {@link Writer#reset|reset} or {@link Writer#ldelim|ldelim} resets the writer to the previous state.\n   */\n  fork (): this {\n    this.states = new State(this)\n    this.head = this.tail = new Op(noop, 0, 0)\n    this.len = 0\n    return this\n  }\n\n  /**\n   * Resets this instance to the last state\n   */\n  reset (): this {\n    if (this.states != null) {\n      this.head = this.states.head\n      this.tail = this.states.tail\n      this.len = this.states.len\n      this.states = this.states.next\n    } else {\n      this.head = this.tail = new Op(noop, 0, 0)\n      this.len = 0\n    }\n    return this\n  }\n\n  /**\n   * Resets to the last state and appends the fork state's current write length as a varint followed by its operations.\n   */\n  ldelim (): this {\n    const head = this.head\n    const tail = this.tail\n    const len = this.len\n    this.reset().uint32(len)\n    if (len !== 0) {\n      this.tail.next = head.next // skip noop\n      this.tail = tail\n      this.len += len\n    }\n    return this\n  }\n\n  /**\n   * Finishes the write operation\n   */\n  finish (): Uint8Array {\n    let head = this.head.next // skip noop\n    const buf = alloc(this.len)\n    let pos = 0\n    while (head != null) {\n      head.fn(head.val, buf, pos)\n      pos += head.len\n      head = head.next\n    }\n    // this.head = this.tail = null;\n    return buf\n  }\n}\n\nfunction writeByte (val: number, buf: Uint8Array, pos: number): void {\n  buf[pos] = val & 255\n}\n\nfunction writeVarint32 (val: number, buf: Uint8Array, pos: number): void {\n  while (val > 127) {\n    buf[pos++] = val & 127 | 128\n    val >>>= 7\n  }\n  buf[pos] = val\n}\n\n/**\n * Constructs a new varint writer operation instance.\n *\n * @classdesc Scheduled varint writer operation\n */\nclass VarintOp extends Op<number> {\n  public next?: Op<any>\n\n  constructor (len: number, val: number) {\n    super(writeVarint32, len, val)\n    this.next = undefined\n  }\n}\n\nfunction writeVarint64 (val: LongBits, buf: Uint8Array, pos: number): void {\n  while (val.hi !== 0) {\n    buf[pos++] = val.lo & 127 | 128\n    val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0\n    val.hi >>>= 7\n  }\n  while (val.lo > 127) {\n    buf[pos++] = val.lo & 127 | 128\n    val.lo = val.lo >>> 7\n  }\n  buf[pos++] = val.lo\n}\n\nfunction writeFixed32 (val: number, buf: Uint8Array, pos: number): void {\n  buf[pos] = val & 255\n  buf[pos + 1] = val >>> 8 & 255\n  buf[pos + 2] = val >>> 16 & 255\n  buf[pos + 3] = val >>> 24\n}\n\nfunction writeBytes (val: Uint8Array, buf: Uint8Array, pos: number): void {\n  buf.set(val, pos)\n}\n\nif (globalThis.Buffer != null) {\n  Uint8ArrayWriter.prototype.bytes = function (value: Uint8Array) {\n    const len = value.length >>> 0\n\n    this.uint32(len)\n\n    if (len > 0) {\n      this._push(writeBytesBuffer, len, value)\n    }\n\n    return this\n  }\n\n  Uint8ArrayWriter.prototype.string = function (value: string) {\n    const len = globalThis.Buffer.byteLength(value)\n\n    this.uint32(len)\n\n    if (len > 0) {\n      this._push(writeStringBuffer, len, value)\n    }\n\n    return this\n  }\n}\n\nfunction writeBytesBuffer (val: Uint8Array, buf: Uint8Array, pos: number): void {\n  buf.set(val, pos) // faster than copy (requires node >= 4 where Buffers extend Uint8Array and set is properly inherited)\n  // also works for plain array values\n}\n\nfunction writeStringBuffer (val: string, buf: Uint8Array, pos: number): void {\n  if (val.length < 40) {\n    // plain js is faster for short strings (probably due to redundant assertions)\n    utf8.write(val, buf, pos)\n    // @ts-expect-error buf isn't a Uint8Array?\n  } else if (buf.utf8Write != null) {\n    // @ts-expect-error buf isn't a Uint8Array?\n    buf.utf8Write(val, pos)\n  } else {\n    buf.set(uint8ArrayFromString(val), pos)\n  }\n}\n\n/**\n * Creates a new writer\n */\nexport function createWriter (): Writer {\n  return new Uint8ArrayWriter()\n}\n", "import { createWriter } from './utils/writer.js'\nimport type { Codec } from './codec.js'\n\nexport function encodeMessage <T> (message: Partial<T>, codec: Pick<Codec<T>, 'encode'>): Uint8Array {\n  const w = createWriter()\n\n  codec.encode(message, w, {\n    lengthDelimited: false\n  })\n\n  return w.finish()\n}\n", "import type { Writer, Reader } from './index.js'\n\n// https://developers.google.com/protocol-buffers/docs/encoding#structure\nexport enum CODEC_TYPES {\n  VARINT = 0,\n  BIT64,\n  LENGTH_DELIMITED,\n  START_GROUP,\n  END_GROUP,\n  BIT32\n}\n\nexport interface EncodeOptions {\n  lengthDelimited?: boolean\n  writeDefaults?: boolean\n}\n\nexport interface EncodeFunction<T> {\n  (value: Partial<T>, writer: Writer, opts?: EncodeOptions): void\n}\n\n// protobuf types that contain multiple values\ntype CollectionTypes = any[] | Map<any, any>\n\n// protobuf types that are not collections or messages\ntype PrimitiveTypes = boolean | number | string | bigint | Uint8Array\n\n// recursive array/map field length limits\ntype CollectionLimits <T> = {\n  [K in keyof T]: T[K] extends CollectionTypes ? number :\n    T[K] extends PrimitiveTypes ? never : Limits<T[K]>\n}\n\n// recursive array member array/map field length limits\ntype ArrayElementLimits <T> = {\n  [K in keyof T as `${string & K}$`]: T[K] extends Array<infer ElementType> ?\n      (ElementType extends PrimitiveTypes ? never : Limits<ElementType>) :\n      (T[K] extends PrimitiveTypes ? never : Limits<T[K]>)\n}\n\n// recursive map value array/map field length limits\ntype MapValueLimits <T> = {\n  [K in keyof T as `${string & K}$value`]: T[K] extends Map<any, infer MapValueType> ?\n      (MapValueType extends PrimitiveTypes ? never : Limits<MapValueType>) :\n      (T[K] extends PrimitiveTypes ? never : Limits<T[K]>)\n}\n\n// union of collection and array elements\ntype Limits<T> = Partial<CollectionLimits<T> & ArrayElementLimits<T> & MapValueLimits<T>>\n\nexport interface DecodeOptions<T> {\n  /**\n   * Runtime-specified limits for lengths of repeated/map fields\n   */\n  limits?: Limits<T>\n}\n\nexport interface DecodeFunction<T> {\n  (reader: Reader, length?: number, opts?: DecodeOptions<T>): T\n}\n\nexport interface Codec<T> {\n  name: string\n  type: CODEC_TYPES\n  encode: EncodeFunction<T>\n  decode: DecodeFunction<T>\n}\n\nexport function createCodec <T> (name: string, type: CODEC_TYPES, encode: EncodeFunction<T>, decode: DecodeFunction<T>): Codec<T> {\n  return {\n    name,\n    type,\n    encode,\n    decode\n  }\n}\n", "import { createCodec, CODEC_TYPES } from '../codec.js'\nimport type { DecodeFunction, EncodeFunction, Codec } from '../codec.js'\n\nexport function enumeration <T> (v: any): Codec<T> {\n  function findValue (val: string | number): number {\n    // Use the reverse mapping to look up the enum key for the stored value\n    // https://www.typescriptlang.org/docs/handbook/enums.html#reverse-mappings\n    if (v[val.toString()] == null) {\n      throw new Error('Invalid enum value')\n    }\n\n    return v[val]\n  }\n\n  const encode: EncodeFunction<number | string> = function enumEncode (val, writer) {\n    const enumValue = findValue(val)\n\n    writer.int32(enumValue)\n  }\n\n  const decode: DecodeFunction<number | string> = function enumDecode (reader) {\n    const val = reader.int32()\n\n    return findValue(val)\n  }\n\n  // @ts-expect-error yeah yeah\n  return createCodec('enum', CODEC_TYPES.VARINT, encode, decode)\n}\n", "import { createCodec, CODEC_TYPES, type EncodeFunction, type DecodeFunction, type Codec } from '../codec.js'\n\nexport interface Factory<A, T> {\n  new (obj: A): T\n}\n\nexport function message <T> (encode: EncodeFunction<T>, decode: DecodeFunction<T>): Codec<T> {\n  return createCodec('message', CODEC_TYPES.LENGTH_DELIMITED, encode, decode)\n}\n", "import { enumeration, encodeMessage, decodeMessage, message } from 'protons-runtime'\nimport type { Codec } from 'protons-runtime'\nimport type { Uint8ArrayList } from 'uint8arraylist'\n\nexport interface Data {\n  Type?: Data.DataType\n  Data?: Uint8Array\n  filesize?: bigint\n  blocksizes: bigint[]\n  hashType?: bigint\n  fanout?: bigint\n  mode?: number\n  mtime?: UnixTime\n}\n\nexport namespace Data {\n  export enum DataType {\n    Raw = 'Raw',\n    Directory = 'Directory',\n    File = 'File',\n    Metadata = 'Metadata',\n    Symlink = 'Symlink',\n    HAMTShard = 'HAMTShard'\n  }\n\n  enum __DataTypeValues {\n    Raw = 0,\n    Directory = 1,\n    File = 2,\n    Metadata = 3,\n    Symlink = 4,\n    HAMTShard = 5\n  }\n\n  export namespace DataType {\n    export const codec = (): Codec<DataType> => {\n      return enumeration<DataType>(__DataTypeValues)\n    }\n  }\n\n  let _codec: Codec<Data>\n\n  export const codec = (): Codec<Data> => {\n    if (_codec == null) {\n      _codec = message<Data>((obj, w, opts = {}) => {\n        if (opts.lengthDelimited !== false) {\n          w.fork()\n        }\n\n        if (obj.Type != null) {\n          w.uint32(8)\n          Data.DataType.codec().encode(obj.Type, w)\n        }\n\n        if (obj.Data != null) {\n          w.uint32(18)\n          w.bytes(obj.Data)\n        }\n\n        if (obj.filesize != null) {\n          w.uint32(24)\n          w.uint64(obj.filesize)\n        }\n\n        if (obj.blocksizes != null) {\n          for (const value of obj.blocksizes) {\n            w.uint32(32)\n            w.uint64(value)\n          }\n        }\n\n        if (obj.hashType != null) {\n          w.uint32(40)\n          w.uint64(obj.hashType)\n        }\n\n        if (obj.fanout != null) {\n          w.uint32(48)\n          w.uint64(obj.fanout)\n        }\n\n        if (obj.mode != null) {\n          w.uint32(56)\n          w.uint32(obj.mode)\n        }\n\n        if (obj.mtime != null) {\n          w.uint32(66)\n          UnixTime.codec().encode(obj.mtime, w)\n        }\n\n        if (opts.lengthDelimited !== false) {\n          w.ldelim()\n        }\n      }, (reader, length) => {\n        const obj: any = {\n          blocksizes: []\n        }\n\n        const end = length == null ? reader.len : reader.pos + length\n\n        while (reader.pos < end) {\n          const tag = reader.uint32()\n\n          switch (tag >>> 3) {\n            case 1:\n              obj.Type = Data.DataType.codec().decode(reader)\n              break\n            case 2:\n              obj.Data = reader.bytes()\n              break\n            case 3:\n              obj.filesize = reader.uint64()\n              break\n            case 4:\n              obj.blocksizes.push(reader.uint64())\n              break\n            case 5:\n              obj.hashType = reader.uint64()\n              break\n            case 6:\n              obj.fanout = reader.uint64()\n              break\n            case 7:\n              obj.mode = reader.uint32()\n              break\n            case 8:\n              obj.mtime = UnixTime.codec().decode(reader, reader.uint32())\n              break\n            default:\n              reader.skipType(tag & 7)\n              break\n          }\n        }\n\n        return obj\n      })\n    }\n\n    return _codec\n  }\n\n  export const encode = (obj: Partial<Data>): Uint8Array => {\n    return encodeMessage(obj, Data.codec())\n  }\n\n  export const decode = (buf: Uint8Array | Uint8ArrayList): Data => {\n    return decodeMessage(buf, Data.codec())\n  }\n}\n\nexport interface UnixTime {\n  Seconds?: bigint\n  FractionalNanoseconds?: number\n}\n\nexport namespace UnixTime {\n  let _codec: Codec<UnixTime>\n\n  export const codec = (): Codec<UnixTime> => {\n    if (_codec == null) {\n      _codec = message<UnixTime>((obj, w, opts = {}) => {\n        if (opts.lengthDelimited !== false) {\n          w.fork()\n        }\n\n        if (obj.Seconds != null) {\n          w.uint32(8)\n          w.int64(obj.Seconds)\n        }\n\n        if (obj.FractionalNanoseconds != null) {\n          w.uint32(21)\n          w.fixed32(obj.FractionalNanoseconds)\n        }\n\n        if (opts.lengthDelimited !== false) {\n          w.ldelim()\n        }\n      }, (reader, length) => {\n        const obj: any = {}\n\n        const end = length == null ? reader.len : reader.pos + length\n\n        while (reader.pos < end) {\n          const tag = reader.uint32()\n\n          switch (tag >>> 3) {\n            case 1:\n              obj.Seconds = reader.int64()\n              break\n            case 2:\n              obj.FractionalNanoseconds = reader.fixed32()\n              break\n            default:\n              reader.skipType(tag & 7)\n              break\n          }\n        }\n\n        return obj\n      })\n    }\n\n    return _codec\n  }\n\n  export const encode = (obj: Partial<UnixTime>): Uint8Array => {\n    return encodeMessage(obj, UnixTime.codec())\n  }\n\n  export const decode = (buf: Uint8Array | Uint8ArrayList): UnixTime => {\n    return decodeMessage(buf, UnixTime.codec())\n  }\n}\n\nexport interface Metadata {\n  MimeType?: string\n}\n\nexport namespace Metadata {\n  let _codec: Codec<Metadata>\n\n  export const codec = (): Codec<Metadata> => {\n    if (_codec == null) {\n      _codec = message<Metadata>((obj, w, opts = {}) => {\n        if (opts.lengthDelimited !== false) {\n          w.fork()\n        }\n\n        if (obj.MimeType != null) {\n          w.uint32(10)\n          w.string(obj.MimeType)\n        }\n\n        if (opts.lengthDelimited !== false) {\n          w.ldelim()\n        }\n      }, (reader, length) => {\n        const obj: any = {}\n\n        const end = length == null ? reader.len : reader.pos + length\n\n        while (reader.pos < end) {\n          const tag = reader.uint32()\n\n          switch (tag >>> 3) {\n            case 1:\n              obj.MimeType = reader.string()\n              break\n            default:\n              reader.skipType(tag & 7)\n              break\n          }\n        }\n\n        return obj\n      })\n    }\n\n    return _codec\n  }\n\n  export const encode = (obj: Partial<Metadata>): Uint8Array => {\n    return encodeMessage(obj, Metadata.codec())\n  }\n\n  export const decode = (buf: Uint8Array | Uint8ArrayList): Metadata => {\n    return decodeMessage(buf, Metadata.codec())\n  }\n}\n", "/**\n * @packageDocumentation\n *\n * This module contains the protobuf definition of the UnixFS data structure found at the root of all UnixFS DAGs.\n *\n * The UnixFS spec can be found in the [ipfs/specs repository](http://github.com/ipfs/specs)\n *\n * @example Create a file composed of several blocks\n *\n * ```TypeScript\n * import { UnixFS } from 'ipfs-unixfs'\n *\n * const data = new UnixFS({ type: 'file' })\n * data.addBlockSize(256n) // add the size of each block\n * data.addBlockSize(256n)\n * // ...\n * ```\n *\n * @example Create a directory that contains several files\n *\n * Creating a directory that contains several files is achieve by creating a unixfs element that identifies a MerkleDAG node as a directory. The links of that MerkleDAG node are the files that are contained in this directory.\n *\n * ```TypeScript\n * import { UnixFS } from 'ipfs-unixfs'\n *\n * const data = new UnixFS({ type: 'directory' })\n * ```\n *\n * @example Create an unixfs Data element\n *\n * ```TypeScript\n * import { UnixFS } from 'ipfs-unixfs'\n *\n * const data = new UnixFS({\n *   // ...options\n * })\n * ```\n *\n * `options` is an optional object argument that might include the following keys:\n *\n * - type (string, default `file`): The type of UnixFS entry.  Can be:\n *   - `raw`\n *   - `directory`\n *   - `file`\n *   - `metadata`\n *   - `symlink`\n *   - `hamt-sharded-directory`\n * - data (Uint8Array): The optional data field for this node\n * - blockSizes (Array, default: `[]`): If this is a `file` node that is made up of multiple blocks, `blockSizes` is a list numbers that represent the size of the file chunks stored in each child node. It is used to calculate the total file size.\n * - mode (Number, default `0644` for files, `0755` for directories/hamt-sharded-directories) file mode\n * - mtime (`Date`, `{ secs, nsecs }`, `{ Seconds, FractionalNanoseconds }`, `[ secs, nsecs ]`): The modification time of this node\n *\n * @example Add and remove a block size to the block size list\n *\n * ```TypeScript\n * import { UnixFS } from 'ipfs-unixfs'\n *\n * const data = new UnixFS({ type: 'file' })\n * const sizeInBytes = 100n\n * data.addBlockSize(sizeInBytes)\n * ```\n *\n * ```TypeScript\n * import { UnixFS } from 'ipfs-unixfs'\n *\n * const data = new UnixFS({ type: 'file' })\n *\n * const index = 0\n * data.removeBlockSize(index)\n * ```\n *\n * @example Get total fileSize\n *\n * ```TypeScript\n * import { UnixFS } from 'ipfs-unixfs'\n *\n * const data = new UnixFS({ type: 'file' })\n * data.fileSize() // => size in bytes\n * ```\n *\n * @example Marshal and unmarshal\n *\n * ```TypeScript\n * import { UnixFS } from 'ipfs-unixfs'\n *\n * const data = new UnixFS({ type: 'file' })\n * const marshaled = data.marshal()\n * const unmarshaled = UnixFS.unmarshal(marshaled)\n * ```\n *\n * @example Is this UnixFS entry a directory?\n *\n * ```TypeScript\n * import { UnixFS } from 'ipfs-unixfs'\n *\n * const dir = new UnixFS({ type: 'directory' })\n * dir.isDirectory() // true\n *\n * const file = new UnixFS({ type: 'file' })\n * file.isDirectory() // false\n * ```\n *\n * @example Has an mtime been set?\n *\n * If no modification time has been set, no `mtime` property will be present on the `Data` instance:\n *\n * ```TypeScript\n * import { UnixFS } from 'ipfs-unixfs'\n *\n * const file = new UnixFS({ type: 'file' })\n * file.mtime // undefined\n *\n * Object.prototype.hasOwnProperty.call(file, 'mtime') // false\n *\n * const dir = new UnixFS({ type: 'directory', mtime: { secs: 5n } })\n * dir.mtime // { secs: Number, nsecs: Number }\n * ```\n */\n\nimport { InvalidTypeError, InvalidUnixFSMessageError } from './errors.js'\nimport { Data as PBData } from './unixfs.js'\n\nexport interface Mtime {\n  secs: bigint\n  nsecs?: number\n}\n\nexport type MtimeLike = Mtime | { Seconds: number, FractionalNanoseconds?: number } | [number, number] | Date\n\nexport type UnixFSType = 'raw' | 'directory' | 'file' | 'metadata' | 'symlink' | 'hamt-sharded-directory'\n\nconst types: Record<string, UnixFSType> = {\n  Raw: 'raw',\n  Directory: 'directory',\n  File: 'file',\n  Metadata: 'metadata',\n  Symlink: 'symlink',\n  HAMTShard: 'hamt-sharded-directory'\n}\n\nconst dirTypes = [\n  'directory',\n  'hamt-sharded-directory'\n]\n\nconst DEFAULT_FILE_MODE = parseInt('0644', 8)\nconst DEFAULT_DIRECTORY_MODE = parseInt('0755', 8)\n\n// https://github.com/ipfs/boxo/blob/364c5040ec91ec8e2a61446e9921e9225704c34d/ipld/unixfs/hamt/hamt.go#L778\nconst MAX_FANOUT = BigInt(1 << 10)\n\nexport interface UnixFSOptions {\n  type?: UnixFSType\n  data?: Uint8Array\n  blockSizes?: bigint[]\n  hashType?: bigint\n  fanout?: bigint\n  mtime?: Mtime\n  mode?: number\n}\n\nclass UnixFS {\n  /**\n   * Decode from protobuf https://github.com/ipfs/specs/blob/master/UNIXFS.md\n   */\n  static unmarshal (marshaled: Uint8Array): UnixFS {\n    const message = PBData.decode(marshaled)\n\n    if (message.fanout != null && message.fanout > MAX_FANOUT) {\n      throw new InvalidUnixFSMessageError(`Fanout size was too large - ${message.fanout} > ${MAX_FANOUT}`)\n    }\n\n    const data = new UnixFS({\n      type: types[message.Type != null ? message.Type.toString() : 'File'],\n      data: message.Data,\n      blockSizes: message.blocksizes,\n      mode: message.mode,\n      mtime: message.mtime != null\n        ? {\n            secs: message.mtime.Seconds ?? 0n,\n            nsecs: message.mtime.FractionalNanoseconds\n          }\n        : undefined,\n      fanout: message.fanout\n    })\n\n    // make sure we honour the original mode\n    data._originalMode = message.mode ?? 0\n\n    return data\n  }\n\n  public type: string\n  public data?: Uint8Array\n  public blockSizes: bigint[]\n  public hashType?: bigint\n  public fanout?: bigint\n  public mtime?: Mtime\n\n  private _mode?: number\n  private _originalMode: number\n\n  constructor (options: UnixFSOptions = {\n    type: 'file'\n  }) {\n    const {\n      type,\n      data,\n      blockSizes,\n      hashType,\n      fanout,\n      mtime,\n      mode\n    } = options\n\n    if (type != null && !Object.values(types).includes(type)) {\n      throw new InvalidTypeError('Type: ' + type + ' is not valid')\n    }\n\n    this.type = type ?? 'file'\n    this.data = data\n    this.hashType = hashType\n    this.fanout = fanout\n    this.blockSizes = blockSizes ?? []\n    this._originalMode = 0\n    this.mode = mode\n    this.mtime = mtime\n  }\n\n  set mode (mode: number | undefined) {\n    if (mode == null) {\n      this._mode = this.isDirectory() ? DEFAULT_DIRECTORY_MODE : DEFAULT_FILE_MODE\n    } else {\n      this._mode = (mode & 0xFFF)\n    }\n  }\n\n  get mode (): number | undefined {\n    return this._mode\n  }\n\n  isDirectory (): boolean {\n    return dirTypes.includes(this.type)\n  }\n\n  addBlockSize (size: bigint): void {\n    this.blockSizes.push(size)\n  }\n\n  removeBlockSize (index: number): void {\n    this.blockSizes.splice(index, 1)\n  }\n\n  /**\n   * Returns `0n` for directories or `data.length + sum(blockSizes)` for everything else\n   */\n  fileSize (): bigint {\n    if (this.isDirectory()) {\n      // dirs don't have file size\n      return 0n\n    }\n\n    let sum = 0n\n    this.blockSizes.forEach((size) => {\n      sum += size\n    })\n\n    if (this.data != null) {\n      sum += BigInt(this.data.length)\n    }\n\n    return sum\n  }\n\n  /**\n   * encode to protobuf Uint8Array\n   */\n  marshal (): Uint8Array {\n    let type\n\n    switch (this.type) {\n      case 'raw': type = PBData.DataType.Raw; break\n      case 'directory': type = PBData.DataType.Directory; break\n      case 'file': type = PBData.DataType.File; break\n      case 'metadata': type = PBData.DataType.Metadata; break\n      case 'symlink': type = PBData.DataType.Symlink; break\n      case 'hamt-sharded-directory': type = PBData.DataType.HAMTShard; break\n      default:\n        throw new InvalidTypeError(`Type: ${type} is not valid`)\n    }\n\n    let data = this.data\n\n    if (this.data == null || this.data.length === 0) {\n      data = undefined\n    }\n\n    let mode\n\n    if (this.mode != null) {\n      mode = (this._originalMode & 0xFFFFF000) | (this.mode ?? 0)\n\n      if (mode === DEFAULT_FILE_MODE && !this.isDirectory()) {\n        mode = undefined\n      }\n\n      if (mode === DEFAULT_DIRECTORY_MODE && this.isDirectory()) {\n        mode = undefined\n      }\n    }\n\n    let mtime\n\n    if (this.mtime != null) {\n      mtime = {\n        Seconds: this.mtime.secs,\n        FractionalNanoseconds: this.mtime.nsecs\n      }\n    }\n\n    return PBData.encode({\n      Type: type,\n      Data: data,\n      filesize: this.isDirectory() ? undefined : this.fileSize(),\n      blocksizes: this.blockSizes,\n      hashType: this.hashType,\n      fanout: this.fanout,\n      mode,\n      mtime\n    })\n  }\n}\n\nexport { UnixFS }\nexport * from './errors.js'\n", "import { bytes } from 'multiformats'\nimport { from } from 'multiformats/hashes/hasher'\n// @ts-expect-error no types\nimport mur from 'murmurhash3js-revisited'\n\n/**\n * @param {number} number\n * @returns {Uint8Array}\n */\nfunction fromNumberTo32BitBuf (number) {\n  const bytes = new Array(4)\n  for (let i = 0; i < 4; i++) {\n    bytes[i] = number & 0xff\n    number = number >> 8\n  }\n  return new Uint8Array(bytes)\n}\n\nexport const murmur332 = from({\n  name: 'murmur3-32',\n  code: 0x23,\n  encode: (input) => fromNumberTo32BitBuf(mur.x86.hash32(input))\n})\n\nexport const murmur3128 = from({\n  name: 'murmur3-128',\n  code: 0x22,\n  encode: (input) => bytes.fromHex(mur.x64.hash128(input))\n})\n\n// A special-use 0x22 that truncates 64 bits, specifically for use in the UnixFS HAMT\nexport const murmur364 = from({\n  name: 'murmur3-x64-64',\n  code: 0x22,\n  encode: (input) => bytes.fromHex(mur.x64.hash128(input)).subarray(0, 8)\n})\n", "// @ts-expect-error no types\nimport SparseArray from 'sparse-array'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport type { InfiniteHash } from './consumable-hash.js'\n\nexport interface BucketChild<V> {\n  key: string\n  value: V\n  hash: InfiniteHash\n}\n\ninterface SA<B> {\n  length: number\n  compactArray(): B[]\n  get(i: number): B\n  set(i: number, value: B): void\n  reduce <A> (fn: (acc: A, curr: B, index: number) => A, initial: A): B\n  find(fn: (item: B) => boolean): B | undefined\n  bitField(): number[]\n  unset(i: number): void\n}\n\nexport interface BucketPosition<T> {\n  bucket: Bucket<T>\n  pos: number\n  hash: InfiniteHash\n  existingChild?: BucketChild<T>\n}\n\nexport interface BucketOptions {\n  bits: number\n  hash(value: Uint8Array | InfiniteHash): InfiniteHash\n}\n\nexport class Bucket<T> {\n  _options: BucketOptions\n  _popCount: number\n  _parent?: Bucket<T>\n  _posAtParent: number\n  _children: SA<Bucket<T> | BucketChild<T>>\n\n  key: string | null\n\n  constructor (options: BucketOptions, parent?: Bucket<T>, posAtParent = 0) {\n    this._options = options\n    this._popCount = 0\n    this._parent = parent\n    this._posAtParent = posAtParent\n    this._children = new SparseArray()\n    this.key = null\n  }\n\n  async put (key: string, value: T): Promise<void> {\n    const place = await this._findNewBucketAndPos(key)\n\n    place.bucket._putAt(place, key, value)\n  }\n\n  async get (key: string): Promise<T | undefined> {\n    const child = await this._findChild(key)\n\n    if (child != null) {\n      return child.value\n    }\n  }\n\n  async del (key: string): Promise<void> {\n    const place = await this._findPlace(key)\n    const child = place.bucket._at(place.pos)\n\n    if (child != null && child.key === key) {\n      place.bucket._delAt(place.pos)\n    }\n  }\n\n  leafCount (): number {\n    const children = this._children.compactArray()\n\n    return children.reduce((acc, child) => {\n      if (child instanceof Bucket) {\n        return acc + child.leafCount()\n      }\n\n      return acc + 1\n    }, 0)\n  }\n\n  childrenCount (): number {\n    return this._children.length\n  }\n\n  onlyChild (): Bucket<T> | BucketChild<T> {\n    return this._children.get(0)\n  }\n\n  * eachLeafSeries (): Iterable<BucketChild<T>> {\n    const children = this._children.compactArray()\n\n    for (const child of children) {\n      if (child instanceof Bucket) {\n        yield * child.eachLeafSeries()\n      } else {\n        yield child\n      }\n    }\n  }\n\n  serialize <M> (map: (value: BucketChild<T>, index: number) => M, reduce: (reduced: Bucket<T> | BucketChild<T>) => M): M {\n    const acc: M[] = []\n    // serialize to a custom non-sparse representation\n    return reduce(this._children.reduce((acc, child, index) => {\n      if (child != null) {\n        if (child instanceof Bucket) {\n          acc.push(child.serialize(map, reduce))\n        } else {\n          acc.push(map(child, index))\n        }\n      }\n      return acc\n    }, acc))\n  }\n\n  async asyncTransform <R = T> (asyncMap: (value: BucketChild<T>) => Promise<T[]>, asyncReduce: (reduced: any) => Promise<R>): Promise<R> {\n    return asyncTransformBucket(this, asyncMap, asyncReduce)\n  }\n\n  toJSON (): Record<string, any> {\n    return this.serialize(mapNode, reduceNodes)\n  }\n\n  prettyPrint (): string {\n    return JSON.stringify(this.toJSON(), null, '  ')\n  }\n\n  tableSize (): number {\n    return Math.pow(2, this._options.bits)\n  }\n\n  async _findChild (key: string): Promise<BucketChild<T> | undefined> {\n    const result = await this._findPlace(key)\n    const child = result.bucket._at(result.pos)\n\n    if (child instanceof Bucket) {\n      // should not be possible, this._findPlace should always\n      // return a location for a child, not a bucket\n      return undefined\n    }\n\n    if (child != null && child.key === key) {\n      return child\n    }\n  }\n\n  async _findPlace (key: string | InfiniteHash): Promise<BucketPosition<T>> {\n    const hashValue = this._options.hash(typeof key === 'string' ? uint8ArrayFromString(key) : key)\n    const index = await hashValue.take(this._options.bits)\n\n    const child = this._children.get(index)\n\n    if (child instanceof Bucket) {\n      return child._findPlace(hashValue)\n    }\n\n    return {\n      bucket: this,\n      pos: index,\n      hash: hashValue,\n      existingChild: child\n    }\n  }\n\n  async _findNewBucketAndPos (key: string | InfiniteHash): Promise<BucketPosition<T>> {\n    const place = await this._findPlace(key)\n\n    if ((place.existingChild != null) && place.existingChild.key !== key) {\n      // conflict\n      const bucket = new Bucket(this._options, place.bucket, place.pos)\n      place.bucket._putObjectAt(place.pos, bucket)\n\n      // put the previous value\n      const newPlace = await bucket._findPlace(place.existingChild.hash)\n      newPlace.bucket._putAt(newPlace, place.existingChild.key, place.existingChild.value)\n\n      return bucket._findNewBucketAndPos(place.hash)\n    }\n\n    // no conflict, we found the place\n    return place\n  }\n\n  _putAt (place: BucketPosition<T>, key: string, value: T): void {\n    this._putObjectAt(place.pos, {\n      key,\n      value,\n      hash: place.hash\n    })\n  }\n\n  _putObjectAt (pos: number, object: Bucket<T> | BucketChild<T>): void {\n    if (this._children.get(pos) == null) {\n      this._popCount++\n    }\n    this._children.set(pos, object)\n  }\n\n  _delAt (pos: number): void {\n    if (pos === -1) {\n      throw new Error('Invalid position')\n    }\n\n    if (this._children.get(pos) != null) {\n      this._popCount--\n    }\n    this._children.unset(pos)\n    this._level()\n  }\n\n  _level (): void {\n    if (this._parent != null && this._popCount <= 1) {\n      if (this._popCount === 1) {\n        // remove myself from parent, replacing me with my only child\n        const onlyChild = this._children.find(exists)\n\n        if ((onlyChild != null) && !(onlyChild instanceof Bucket)) {\n          const hash = onlyChild.hash\n          hash.untake(this._options.bits)\n          const place = {\n            pos: this._posAtParent,\n            hash,\n            bucket: this._parent\n          }\n          this._parent._putAt(place, onlyChild.key, onlyChild.value)\n        }\n      } else {\n        this._parent._delAt(this._posAtParent)\n      }\n    }\n  }\n\n  _at (index: number): Bucket<T> | BucketChild<T> {\n    return this._children.get(index)\n  }\n}\n\nfunction exists (o: any): boolean {\n  return Boolean(o)\n}\n\nfunction mapNode (node: { key: string }, _: number): string {\n  return node.key\n}\n\nfunction reduceNodes <T> (nodes: T): any {\n  return nodes\n}\n\nasync function asyncTransformBucket <T, R = T> (bucket: Bucket<T>, asyncMap: (value: BucketChild<T>) => Promise<T[]>, asyncReduce: (reduced: any) => Promise<R>): Promise<R> {\n  const output = []\n\n  for (const child of bucket._children.compactArray()) {\n    if (child instanceof Bucket) {\n      await asyncTransformBucket(child, asyncMap, asyncReduce)\n    } else {\n      const mappedChildren = await asyncMap(child)\n\n      output.push({\n        bitField: bucket._children.bitField(),\n        children: mappedChildren\n      })\n    }\n  }\n\n  return asyncReduce(output)\n}\n", "import { allocUnsafe } from '#alloc'\nimport { asUint8Array } from '#util/as-uint8array'\n\n/**\n * Returns a new Uint8Array created by concatenating the passed Uint8Arrays\n */\nexport function concat (arrays: Uint8Array[], length?: number): Uint8Array {\n  if (length == null) {\n    length = arrays.reduce((acc, curr) => acc + curr.length, 0)\n  }\n\n  const output = allocUnsafe(length)\n  let offset = 0\n\n  for (const arr of arrays) {\n    output.set(arr, offset)\n    offset += arr.length\n  }\n\n  return asUint8Array(output)\n}\n", "const START_MASKS = [\n  0b11111111,\n  0b11111110,\n  0b11111100,\n  0b11111000,\n  0b11110000,\n  0b11100000,\n  0b11000000,\n  0b10000000\n]\n\nconst STOP_MASKS = [\n  0b00000001,\n  0b00000011,\n  0b00000111,\n  0b00001111,\n  0b00011111,\n  0b00111111,\n  0b01111111,\n  0b11111111\n]\n\nexport class ConsumableBuffer {\n  _value: Uint8Array\n  _currentBytePos: number\n  _currentBitPos: number\n\n  constructor (value: Uint8Array) {\n    this._value = value\n    this._currentBytePos = value.length - 1\n    this._currentBitPos = 7\n  }\n\n  availableBits (): number {\n    return this._currentBitPos + 1 + this._currentBytePos * 8\n  }\n\n  totalBits (): number {\n    return this._value.length * 8\n  }\n\n  take (bits: number): number {\n    let pendingBits = bits\n    let result = 0\n    while (pendingBits > 0 && this._haveBits()) {\n      const byte = this._value[this._currentBytePos]\n      const availableBits = this._currentBitPos + 1\n      const taking = Math.min(availableBits, pendingBits)\n      const value = byteBitsToInt(byte, availableBits - taking, taking)\n      result = (result << taking) + value\n\n      pendingBits -= taking\n\n      this._currentBitPos -= taking\n      if (this._currentBitPos < 0) {\n        this._currentBitPos = 7\n        this._currentBytePos--\n      }\n    }\n\n    return result\n  }\n\n  untake (bits: number): void {\n    this._currentBitPos += bits\n    while (this._currentBitPos > 7) {\n      this._currentBitPos -= 8\n      this._currentBytePos += 1\n    }\n  }\n\n  _haveBits (): boolean {\n    return this._currentBytePos >= 0\n  }\n}\n\nfunction byteBitsToInt (byte: number, start: number, length: number): number {\n  const mask = maskFor(start, length)\n  return (byte & mask) >>> start\n}\n\nfunction maskFor (start: number, length: number): number {\n  return START_MASKS[start] & STOP_MASKS[Math.min(length + start - 1, 7)]\n}\n", "import { concat as uint8ArrayConcat } from 'uint8arrays/concat'\nimport { ConsumableBuffer } from './consumable-buffer.js'\n\nexport function wrapHash (hashFn: (value: Uint8Array) => Promise<Uint8Array>): (value: InfiniteHash | Uint8Array) => InfiniteHash {\n  function hashing (value: InfiniteHash | Uint8Array): InfiniteHash {\n    if (value instanceof InfiniteHash) {\n      // already a hash. return it\n      return value\n    } else {\n      return new InfiniteHash(value, hashFn)\n    }\n  }\n\n  return hashing\n}\n\nexport class InfiniteHash {\n  _value: Uint8Array\n  _hashFn: (value: Uint8Array) => Promise<Uint8Array>\n  _depth: number\n  _availableBits: number\n  _currentBufferIndex: number\n  _buffers: ConsumableBuffer[]\n\n  constructor (value: Uint8Array, hashFn: (value: Uint8Array) => Promise<Uint8Array>) {\n    if (!(value instanceof Uint8Array)) {\n      throw new Error('can only hash Uint8Arrays')\n    }\n\n    this._value = value\n    this._hashFn = hashFn\n    this._depth = -1\n    this._availableBits = 0\n    this._currentBufferIndex = 0\n    this._buffers = []\n  }\n\n  async take (bits: number): Promise<number> {\n    let pendingBits = bits\n\n    while (this._availableBits < pendingBits) {\n      await this._produceMoreBits()\n    }\n\n    let result = 0\n\n    while (pendingBits > 0) {\n      const hash = this._buffers[this._currentBufferIndex]\n      const available = Math.min(hash.availableBits(), pendingBits)\n      const took = hash.take(available)\n      result = (result << available) + took\n      pendingBits -= available\n      this._availableBits -= available\n\n      if (hash.availableBits() === 0) {\n        this._currentBufferIndex++\n      }\n    }\n\n    return result\n  }\n\n  untake (bits: number): void {\n    let pendingBits = bits\n\n    while (pendingBits > 0) {\n      const hash = this._buffers[this._currentBufferIndex]\n      const availableForUntake = Math.min(hash.totalBits() - hash.availableBits(), pendingBits)\n      hash.untake(availableForUntake)\n      pendingBits -= availableForUntake\n      this._availableBits += availableForUntake\n\n      if (this._currentBufferIndex > 0 && hash.totalBits() === hash.availableBits()) {\n        this._depth--\n        this._currentBufferIndex--\n      }\n    }\n  }\n\n  async _produceMoreBits (): Promise<void> {\n    this._depth++\n\n    const value = this._depth > 0 ? uint8ArrayConcat([this._value, Uint8Array.from([this._depth])]) : this._value\n    const hashValue = await this._hashFn(value)\n    const buffer = new ConsumableBuffer(hashValue)\n\n    this._buffers.push(buffer)\n    this._availableBits += buffer.availableBits()\n  }\n}\n", "/**\n * @packageDocumentation\n *\n * A [Hash Mapped Trie](https://en.wikipedia.org/wiki/Hash_array_mapped_trie) implementation for JavaScript.\n *\n * This is used by [@helia/unixfs](https://www.npmjs.com/package/@helia/unixfs) for it's HAMT-sharded directory implementation.\n *\n * @example\n *\n * ```TypeScript\n * import { createHAMT } from 'hamt-sharding'\n * import crypto from 'crypto-promise'\n *\n * // decide how to hash buffers made from keys, can return a Promise\n * const hashFn = async (buf) => {\n *   return crypto\n *     .createHash('sha256')\n *     .update(buf)\n *     .digest()\n * }\n *\n * const bucket = createHAMT({\n *   hashFn: hashFn\n * })\n *\n * await bucket.put('key', 'value')\n *\n * const output = await bucket.get('key')\n * // output === 'value'\n * ```\n */\n\nimport { Bucket } from './bucket.js'\nimport { wrapHash } from './consumable-hash.js'\nimport type { BucketOptions, BucketPosition, BucketChild } from './bucket.js'\n\ninterface UserBucketOptions {\n  hashFn(value: Uint8Array): Promise<Uint8Array>\n  bits?: number\n}\n\nexport function createHAMT<T> (options: UserBucketOptions): Bucket<T> {\n  if (options == null || options.hashFn == null) {\n    throw new Error('please define an options.hashFn')\n  }\n\n  const bucketOptions = {\n    bits: options.bits ?? 8,\n    hash: wrapHash(options.hashFn)\n  }\n\n  return new Bucket<T>(bucketOptions)\n}\n\nexport { Bucket }\nexport type { BucketOptions, BucketPosition, BucketChild }\n", "import { decode } from '@ipld/dag-pb'\nimport { murmur3128 } from '@multiformats/murmur3'\nimport { Bucket, createHAMT } from 'hamt-sharding'\nimport { UnixFS } from 'ipfs-unixfs'\nimport { NotUnixFSError } from '../errors.js'\nimport type { ExporterOptions, ShardTraversalContext, ReadableStorage } from '../index.js'\nimport type { PBLink, PBNode } from '@ipld/dag-pb'\nimport type { BucketPosition } from 'hamt-sharding'\nimport type { CID } from 'multiformats/cid'\n\n// FIXME: this is copy/pasted from ipfs-unixfs-importer/src/options.js\nconst hashFn = async function (buf: Uint8Array): Promise<Uint8Array> {\n  return (await murmur3128.encode(buf))\n    // Murmur3 outputs 128 bit but, accidentally, IPFS Go's\n    // implementation only uses the first 64, so we must do the same\n    // for parity..\n    .slice(0, 8)\n    // Invert buffer because that's how Go impl does it\n    .reverse()\n}\n\nconst addLinksToHamtBucket = async (links: PBLink[], bucket: Bucket<boolean>, rootBucket: Bucket<boolean>): Promise<void> => {\n  const padLength = (bucket.tableSize() - 1).toString(16).length\n  await Promise.all(\n    links.map(async link => {\n      if (link.Name == null) {\n        // TODO(@rvagg): what do? this is technically possible\n        throw new Error('Unexpected Link without a Name')\n      }\n      if (link.Name.length === padLength) {\n        const pos = parseInt(link.Name, 16)\n\n        bucket._putObjectAt(pos, new Bucket({\n          hash: rootBucket._options.hash,\n          bits: rootBucket._options.bits\n        }, bucket, pos))\n        return\n      }\n\n      await rootBucket.put(link.Name.substring(2), true)\n    })\n  )\n}\n\nconst toPrefix = (position: number, padLength: number): string => {\n  return position\n    .toString(16)\n    .toUpperCase()\n    .padStart(padLength, '0')\n    .substring(0, padLength)\n}\n\nconst toBucketPath = (position: BucketPosition<boolean>): Array<Bucket<boolean>> => {\n  let bucket = position.bucket\n  const path = []\n\n  while (bucket._parent != null) {\n    path.push(bucket)\n\n    bucket = bucket._parent\n  }\n\n  path.push(bucket)\n\n  return path.reverse()\n}\n\nconst findShardCid = async (node: PBNode, name: string, blockstore: ReadableStorage, context?: ShardTraversalContext, options?: ExporterOptions): Promise<CID | undefined> => {\n  if (context == null) {\n    if (node.Data == null) {\n      throw new NotUnixFSError('no data in PBNode')\n    }\n\n    let dir: UnixFS\n    try {\n      dir = UnixFS.unmarshal(node.Data)\n    } catch (err: any) {\n      throw new NotUnixFSError(err.message)\n    }\n\n    if (dir.type !== 'hamt-sharded-directory') {\n      throw new NotUnixFSError('not a HAMT')\n    }\n    if (dir.fanout == null) {\n      throw new NotUnixFSError('missing fanout')\n    }\n\n    const rootBucket = createHAMT<boolean>({\n      hashFn,\n      bits: Math.log2(Number(dir.fanout))\n    })\n\n    context = {\n      rootBucket,\n      hamtDepth: 1,\n      lastBucket: rootBucket\n    }\n  }\n\n  const padLength = (context.lastBucket.tableSize() - 1).toString(16).length\n\n  await addLinksToHamtBucket(node.Links, context.lastBucket, context.rootBucket)\n\n  const position = await context.rootBucket._findNewBucketAndPos(name)\n  let prefix = toPrefix(position.pos, padLength)\n  const bucketPath = toBucketPath(position)\n\n  if (bucketPath.length > context.hamtDepth) {\n    context.lastBucket = bucketPath[context.hamtDepth]\n\n    prefix = toPrefix(context.lastBucket._posAtParent, padLength)\n  }\n\n  const link = node.Links.find(link => {\n    if (link.Name == null) {\n      return false\n    }\n\n    const entryPrefix = link.Name.substring(0, padLength)\n    const entryName = link.Name.substring(padLength)\n\n    if (entryPrefix !== prefix) {\n      // not the entry or subshard we're looking for\n      return false\n    }\n\n    if (entryName !== '' && entryName !== name) {\n      // not the entry we're looking for\n      return false\n    }\n\n    return true\n  })\n\n  if (link == null) {\n    return\n  }\n\n  if (link.Name != null && link.Name.substring(padLength) === name) {\n    return link.Hash\n  }\n\n  context.hamtDepth++\n\n  const block = await blockstore.get(link.Hash, options)\n  node = decode(block)\n\n  return findShardCid(node, name, blockstore, context, options)\n}\n\nexport default findShardCid\n", "/**\n * @packageDocumentation\n *\n * Lets you look at the contents of an async iterator and decide what to do\n *\n * @example\n *\n * ```javascript\n * import peekable from 'it-peekable'\n *\n * // This can also be an iterator, generator, etc\n * const values = [0, 1, 2, 3, 4]\n *\n * const it = peekable(value)\n *\n * const first = it.peek()\n *\n * console.info(first) // 0\n *\n * it.push(first)\n *\n * console.info([...it])\n * // [ 0, 1, 2, 3, 4 ]\n * ```\n *\n * Async sources must be awaited:\n *\n * ```javascript\n * import peekable from 'it-peekable'\n *\n * const values = async function * () {\n *   yield * [0, 1, 2, 3, 4]\n * }\n *\n * const it = peekable(values())\n *\n * const first = await it.peek()\n *\n * console.info(first) // 0\n *\n * it.push(first)\n *\n * console.info(await all(it))\n * // [ 0, 1, 2, 3, 4 ]\n * ```\n */\n\nexport interface Peek <T> {\n  peek(): IteratorResult<T, undefined>\n}\n\nexport interface AsyncPeek <T> {\n  peek(): Promise<IteratorResult<T, undefined>>\n}\n\nexport interface Push <T> {\n  push(value: T): void\n}\n\nexport type Peekable <T> = Iterable<T> & Peek<T> & Push<T> & Iterator<T>\n\nexport type AsyncPeekable <T> = AsyncIterable<T> & AsyncPeek<T> & Push<T> & AsyncIterator<T>\n\nfunction peekable <T> (iterable: Iterable<T>): Peekable<T>\nfunction peekable <T> (iterable: AsyncIterable<T>): AsyncPeekable<T>\nfunction peekable <T> (iterable: Iterable<T> | AsyncIterable<T>): Peekable<T> | AsyncPeekable<T> {\n  // @ts-expect-error can't use Symbol.asyncIterator to index iterable since it might be Iterable\n  const [iterator, symbol] = iterable[Symbol.asyncIterator] != null\n    // @ts-expect-error can't use Symbol.asyncIterator to index iterable since it might be Iterable\n    ? [iterable[Symbol.asyncIterator](), Symbol.asyncIterator]\n    // @ts-expect-error can't use Symbol.iterator to index iterable since it might be AsyncIterable\n    : [iterable[Symbol.iterator](), Symbol.iterator]\n\n  const queue: any[] = []\n\n  // @ts-expect-error can't use symbol to index peekable\n  return {\n    peek: () => {\n      return iterator.next()\n    },\n    push: (value: any) => {\n      queue.push(value)\n    },\n    next: () => {\n      if (queue.length > 0) {\n        return {\n          done: false,\n          value: queue.shift()\n        }\n      }\n\n      return iterator.next()\n    },\n    [symbol] () {\n      return this\n    }\n  }\n}\n\nexport default peekable\n", "/**\n * @packageDocumentation\n *\n * Filter values out of an (async)iterable\n *\n * @example\n *\n * ```javascript\n * import all from 'it-all'\n * import filter from 'it-filter'\n *\n * // This can also be an iterator, generator, etc\n * const values = [0, 1, 2, 3, 4]\n *\n * const fn = (val, index) => val > 2 // Return boolean to keep item\n *\n * const arr = all(filter(values, fn))\n *\n * console.info(arr) // 3, 4\n * ```\n *\n * Async sources and filter functions must be awaited:\n *\n * ```javascript\n * import all from 'it-all'\n * import filter from 'it-filter'\n *\n * const values = async function * () {\n *   yield * [0, 1, 2, 3, 4]\n * }\n *\n * const fn = async val => (val, index) > 2 // Return boolean or promise of boolean to keep item\n *\n * const arr = await all(filter(values, fn))\n *\n * console.info(arr) // 3, 4\n * ```\n */\n\nimport peek from 'it-peekable'\n\nfunction isAsyncIterable <T> (thing: any): thing is AsyncIterable<T> {\n  return thing[Symbol.asyncIterator] != null\n}\n\n/**\n * Filters the passed (async) iterable by using the filter function\n */\nfunction filter <T> (source: Iterable<T>, fn: (val: T, index: number) => Promise<boolean>): AsyncGenerator<T, void, undefined>\nfunction filter <T> (source: Iterable<T>, fn: (val: T, index: number) => boolean): Generator<T, void, undefined>\nfunction filter <T> (source: Iterable<T> | AsyncIterable<T>, fn: (val: T, index: number) => boolean | Promise<boolean>): AsyncGenerator<T, void, undefined>\nfunction filter <T> (source: Iterable<T> | AsyncIterable<T>, fn: (val: T, index: number) => boolean | Promise<boolean>): Generator<T, void, undefined> | AsyncGenerator<T, void, undefined> {\n  let index = 0\n\n  if (isAsyncIterable(source)) {\n    return (async function * () {\n      for await (const entry of source) {\n        if (await fn(entry, index++)) {\n          yield entry\n        }\n      }\n    })()\n  }\n\n  // if mapping function returns a promise we have to return an async generator\n  const peekable = peek(source)\n  const { value, done } = peekable.next()\n\n  if (done === true) {\n    return (function * () {}())\n  }\n\n  const res = fn(value, index++)\n\n  // @ts-expect-error .then is not present on O\n  if (typeof res.then === 'function') {\n    return (async function * () {\n      if (await res) {\n        yield value\n      }\n\n      for (const entry of peekable) {\n        if (await fn(entry, index++)) {\n          yield entry\n        }\n      }\n    })()\n  }\n\n  const func = fn as (val: T, index: number) => boolean\n\n  return (function * () {\n    if (res === true) {\n      yield value\n    }\n\n    for (const entry of peekable) {\n      if (func(entry, index++)) {\n        yield entry\n      }\n    }\n  })()\n}\n\nexport default filter\n", "/**\n * @packageDocumentation\n *\n * Convert one value from an (async)iterator into another.\n *\n * @example\n *\n * ```javascript\n * import map from 'it-map'\n *\n * // This can also be an iterator, generator, etc\n * const values = [0, 1, 2, 3, 4]\n *\n * const result = map(values, (val, index) => val++)\n *\n * console.info(result) // [1, 2, 3, 4, 5]\n * ```\n *\n * Async sources and transforms must be awaited:\n *\n * ```javascript\n * import map from 'it-map'\n *\n * const values = async function * () {\n *   yield * [0, 1, 2, 3, 4]\n * }\n *\n * const result = await map(values(), async (val, index) => val++)\n *\n * console.info(result) // [1, 2, 3, 4, 5]\n * ```\n */\n\nimport peek from 'it-peekable'\n\nfunction isAsyncIterable <T> (thing: any): thing is AsyncIterable<T> {\n  return thing[Symbol.asyncIterator] != null\n}\n\n/**\n * Takes an (async) iterable and returns one with each item mapped by the passed\n * function\n */\nfunction map <I, O> (source: Iterable<I>, func: (val: I, index: number) => Promise<O>): AsyncGenerator<O, void, undefined>\nfunction map <I, O> (source: Iterable<I>, func: (val: I, index: number) => O): Generator<O, void, undefined>\nfunction map <I, O> (source: AsyncIterable<I> | Iterable<I>, func: (val: I, index: number) => O | Promise<O>): AsyncGenerator<O, void, undefined>\nfunction map <I, O> (source: AsyncIterable<I> | Iterable<I>, func: (val: I, index: number) => O | Promise<O>): AsyncGenerator<O, void, undefined> | Generator<O, void, undefined> {\n  let index = 0\n\n  if (isAsyncIterable(source)) {\n    return (async function * () {\n      for await (const val of source) {\n        yield func(val, index++)\n      }\n    })()\n  }\n\n  // if mapping function returns a promise we have to return an async generator\n  const peekable = peek(source)\n  const { value, done } = peekable.next()\n\n  if (done === true) {\n    return (function * () {}())\n  }\n\n  const res = func(value, index++)\n\n  // @ts-expect-error .then is not present on O\n  if (typeof res.then === 'function') {\n    return (async function * () {\n      yield await res\n\n      for (const val of peekable) {\n        yield func(val, index++)\n      }\n    })()\n  }\n\n  const fn = func as (val: I, index: number) => O\n\n  return (function * () {\n    yield res as O\n\n    for (const val of peekable) {\n      yield fn(val, index++)\n    }\n  })()\n}\n\nexport default map\n", "export default function pDefer() {\n\tconst deferred = {};\n\n\tdeferred.promise = new Promise((resolve, reject) => {\n\t\tdeferred.resolve = resolve;\n\t\tdeferred.reject = reject;\n\t});\n\n\treturn deferred;\n}\n", "/**\n * @packageDocumentation\n *\n * Takes an (async) iterable that emits promise-returning functions, invokes them in parallel up to the concurrency limit and emits the results as they become available, optionally in the same order as the input\n *\n * @example\n *\n * ```javascript\n * import parallel from 'it-parallel'\n * import all from 'it-all'\n * import delay from 'delay'\n *\n * // This can also be an iterator, async iterator, generator, etc\n * const input = [\n *   async () => {\n *     console.info('start 1')\n *     await delay(500)\n *\n *     console.info('end 1')\n *     return 1\n *   },\n *   async () => {\n *     console.info('start 2')\n *     await delay(200)\n *\n *     console.info('end 2')\n *     return 2\n *   },\n *   async () => {\n *     console.info('start 3')\n *     await delay(100)\n *\n *     console.info('end 3')\n *     return 3\n *   }\n * ]\n *\n * const result = await all(parallel(input, {\n *   concurrency: 2\n * }))\n *\n * // output:\n * // start 1\n * // start 2\n * // end 2\n * // start 3\n * // end 3\n * // end 1\n *\n * console.info(result) // [2, 3, 1]\n * ```\n *\n * If order is important, pass `ordered: true` as an option:\n *\n * ```javascript\n * const result = await all(parallel(input, {\n *   concurrency: 2,\n *   ordered: true\n * }))\n *\n * // output:\n * // start 1\n * // start 2\n * // end 2\n * // start 3\n * // end 3\n * // end 1\n *\n * console.info(result) // [1, 2, 3]\n * ```\n */\n\nimport defer from 'p-defer'\n\ninterface Operation<T> {\n  done: boolean\n  ok: boolean\n  err: Error\n  value: T\n}\n\nconst CustomEvent = globalThis.CustomEvent ?? Event\n\nexport interface ParallelOptions {\n  /**\n   * How many jobs to execute in parallel (default: )\n   */\n  concurrency?: number\n  ordered?: boolean\n}\n\n/**\n * Takes an (async) iterator that emits promise-returning functions,\n * invokes them in parallel and emits the results as they become available but\n * in the same order as the input\n */\nexport default async function * parallel <T> (source: Iterable<() => Promise<T>> | AsyncIterable<() => Promise<T>>, options: ParallelOptions = {}): AsyncGenerator<T, void, undefined> {\n  let concurrency = options.concurrency ?? Infinity\n\n  if (concurrency < 1) {\n    concurrency = Infinity\n  }\n\n  const ordered = options.ordered ?? false\n  const emitter = new EventTarget()\n\n  const ops: Array<Operation<T>> = []\n  let slotAvailable = defer()\n  let resultAvailable = defer()\n  let sourceFinished = false\n  let sourceErr: Error | undefined\n  let opErred = false\n\n  emitter.addEventListener('task-complete', () => {\n    resultAvailable.resolve()\n  })\n\n  void Promise.resolve().then(async () => {\n    try {\n      for await (const task of source) {\n        if (ops.length === concurrency) {\n          slotAvailable = defer()\n          await slotAvailable.promise\n        }\n\n        if (opErred) {\n          break\n        }\n\n        const op: any = {\n          done: false\n        }\n        ops.push(op)\n\n        task()\n          .then(result => {\n            op.done = true\n            op.ok = true\n            op.value = result\n            emitter.dispatchEvent(new CustomEvent('task-complete'))\n          }, err => {\n            op.done = true\n            op.err = err\n            emitter.dispatchEvent(new CustomEvent('task-complete'))\n          })\n      }\n\n      sourceFinished = true\n      emitter.dispatchEvent(new CustomEvent('task-complete'))\n    } catch (err: any) {\n      sourceErr = err\n      emitter.dispatchEvent(new CustomEvent('task-complete'))\n    }\n  })\n\n  function valuesAvailable (): boolean {\n    if (ordered) {\n      return ops[0]?.done\n    }\n\n    return Boolean(ops.find(op => op.done))\n  }\n\n  function * yieldOrderedValues (): Generator<T, void, unknown> {\n    while ((ops.length > 0) && ops[0].done) {\n      const op = ops[0]\n      ops.shift()\n\n      if (op.ok) {\n        yield op.value\n      } else {\n        // allow the source to exit\n        opErred = true\n        slotAvailable.resolve()\n\n        throw op.err\n      }\n\n      slotAvailable.resolve()\n    }\n  }\n\n  function * yieldUnOrderedValues (): Generator<T, void, unknown> {\n    // more values can become available while we wait for `yield`\n    // to return control to this function\n    while (valuesAvailable()) {\n      for (let i = 0; i < ops.length; i++) {\n        if (ops[i].done) {\n          const op = ops[i]\n          ops.splice(i, 1)\n          i--\n\n          if (op.ok) {\n            yield op.value\n          } else {\n            opErred = true\n            slotAvailable.resolve()\n\n            throw op.err\n          }\n\n          slotAvailable.resolve()\n        }\n      }\n    }\n  }\n\n  while (true) {\n    if (!valuesAvailable()) {\n      resultAvailable = defer()\n      await resultAvailable.promise\n    }\n\n    if (sourceErr != null) {\n      // the source threw an error, propagate it\n      throw sourceErr\n    }\n\n    if (ordered) {\n      yield * yieldOrderedValues()\n    } else {\n      yield * yieldUnOrderedValues()\n    }\n\n    if (sourceErr != null) {\n      // if the source yields an array that is `yield *`, it can throw while the\n      // onward consumer is processing the array contents - make sure we\n      // propagate the error\n      // eslint-disable-next-line @typescript-eslint/only-throw-error\n      throw sourceErr\n    }\n\n    if (sourceFinished && ops.length === 0) {\n      // not waiting for any results and no more tasks so we are done\n      break\n    }\n  }\n}\n", "// ported from https://www.npmjs.com/package/fast-fifo\n\nexport interface Next<T> {\n  done?: boolean\n  error?: Error\n  value?: T\n}\n\nclass FixedFIFO<T> {\n  public buffer: Array<Next<T> | undefined>\n  private readonly mask: number\n  private top: number\n  private btm: number\n  public next: FixedFIFO<T> | null\n\n  constructor (hwm: number) {\n    if (!(hwm > 0) || ((hwm - 1) & hwm) !== 0) {\n      throw new Error('Max size for a FixedFIFO should be a power of two')\n    }\n\n    this.buffer = new Array(hwm)\n    this.mask = hwm - 1\n    this.top = 0\n    this.btm = 0\n    this.next = null\n  }\n\n  push (data: Next<T>): boolean {\n    if (this.buffer[this.top] !== undefined) {\n      return false\n    }\n\n    this.buffer[this.top] = data\n    this.top = (this.top + 1) & this.mask\n\n    return true\n  }\n\n  shift (): Next<T> | undefined {\n    const last = this.buffer[this.btm]\n\n    if (last === undefined) {\n      return undefined\n    }\n\n    this.buffer[this.btm] = undefined\n    this.btm = (this.btm + 1) & this.mask\n    return last\n  }\n\n  isEmpty (): boolean {\n    return this.buffer[this.btm] === undefined\n  }\n}\n\nexport interface FIFOOptions {\n  /**\n   * When the queue reaches this size, it will be split into head/tail parts\n   */\n  splitLimit?: number\n}\n\nexport class FIFO<T> {\n  public size: number\n  private readonly hwm: number\n  private head: FixedFIFO<T>\n  private tail: FixedFIFO<T>\n\n  constructor (options: FIFOOptions = {}) {\n    this.hwm = options.splitLimit ?? 16\n    this.head = new FixedFIFO<T>(this.hwm)\n    this.tail = this.head\n    this.size = 0\n  }\n\n  calculateSize (obj: any): number {\n    if (obj?.byteLength != null) {\n      return obj.byteLength\n    }\n\n    return 1\n  }\n\n  push (val: Next<T>): void {\n    if (val?.value != null) {\n      this.size += this.calculateSize(val.value)\n    }\n\n    if (!this.head.push(val)) {\n      const prev = this.head\n      this.head = prev.next = new FixedFIFO<T>(2 * this.head.buffer.length)\n      this.head.push(val)\n    }\n  }\n\n  shift (): Next<T> | undefined {\n    let val = this.tail.shift()\n\n    if (val === undefined && (this.tail.next != null)) {\n      const next = this.tail.next\n      this.tail.next = null\n      this.tail = next\n      val = this.tail.shift()\n    }\n\n    if (val?.value != null) {\n      this.size -= this.calculateSize(val.value)\n    }\n\n    return val\n  }\n\n  isEmpty (): boolean {\n    return this.head.isEmpty()\n  }\n}\n", "/**\n * @packageDocumentation\n *\n * An iterable that you can push values into.\n *\n * @example\n *\n * ```js\n * import { pushable } from 'it-pushable'\n *\n * const source = pushable()\n *\n * setTimeout(() => source.push('hello'), 100)\n * setTimeout(() => source.push('world'), 200)\n * setTimeout(() => source.end(), 300)\n *\n * const start = Date.now()\n *\n * for await (const value of source) {\n *   console.log(`got \"${value}\" after ${Date.now() - start}ms`)\n * }\n * console.log(`done after ${Date.now() - start}ms`)\n *\n * // Output:\n * // got \"hello\" after 105ms\n * // got \"world\" after 207ms\n * // done after 309ms\n * ```\n *\n * @example\n *\n * ```js\n * import { pushableV } from 'it-pushable'\n * import all from 'it-all'\n *\n * const source = pushableV()\n *\n * source.push(1)\n * source.push(2)\n * source.push(3)\n * source.end()\n *\n * console.info(await all(source))\n *\n * // Output:\n * // [ [1, 2, 3] ]\n * ```\n */\n\nimport deferred from 'p-defer'\nimport { FIFO, type Next } from './fifo.js'\n\nexport class AbortError extends Error {\n  type: string\n  code: string\n\n  constructor (message?: string, code?: string) {\n    super(message ?? 'The operation was aborted')\n    this.type = 'aborted'\n    this.code = code ?? 'ABORT_ERR'\n  }\n}\n\nexport interface AbortOptions {\n  signal?: AbortSignal\n}\n\ninterface BasePushable<T> {\n  /**\n   * End the iterable after all values in the buffer (if any) have been yielded. If an\n   * error is passed the buffer is cleared immediately and the next iteration will\n   * throw the passed error\n   */\n  end(err?: Error): this\n\n  /**\n   * Push a value into the iterable. Values are yielded from the iterable in the order\n   * they are pushed. Values not yet consumed from the iterable are buffered.\n   */\n  push(value: T): this\n\n  /**\n   * Returns a promise that resolves when the underlying queue becomes empty (e.g.\n   * this.readableLength === 0).\n   *\n   * If an AbortSignal is passed as an option and that signal aborts, it only\n   * causes the returned promise to reject - it does not end the pushable.\n   */\n  onEmpty(options?: AbortOptions): Promise<void>\n\n  /**\n   * This property contains the number of bytes (or objects) in the queue ready to be read.\n   *\n   * If `objectMode` is true, this is the number of objects in the queue, if false it's the\n   * total number of bytes in the queue.\n   */\n  readableLength: number\n}\n\n/**\n * An iterable that you can push values into.\n */\nexport interface Pushable<T, R = void, N = unknown> extends AsyncGenerator<T, R, N>, BasePushable<T> {}\n\n/**\n * Similar to `pushable`, except it yields multiple buffered chunks at a time. All values yielded from the iterable will be arrays.\n */\nexport interface PushableV<T, R = void, N = unknown> extends AsyncGenerator<T[], R, N>, BasePushable<T> {}\n\nexport interface Options {\n  /**\n   * A boolean value that means non-`Uint8Array`s will be passed to `.push`, default: `false`\n   */\n  objectMode?: boolean\n\n  /**\n   * A function called after *all* values have been yielded from the iterator (including\n   * buffered values). In the case when the iterator is ended with an error it will be\n   * passed the error as a parameter.\n   */\n  onEnd?(err?: Error): void\n}\n\nexport interface DoneResult { done: true }\nexport interface ValueResult<T> { done: false, value: T }\nexport type NextResult<T> = ValueResult<T> | DoneResult\n\ninterface getNext<T, V = T> { (buffer: FIFO<T>): NextResult<V> }\n\nexport interface ObjectPushableOptions extends Options {\n  objectMode: true\n}\n\nexport interface BytePushableOptions extends Options {\n  objectMode?: false\n}\n\n/**\n * Create a new async iterable. The values yielded from calls to `.next()`\n * or when used in a `for await of`loop are \"pushed\" into the iterable.\n * Returns an async iterable object with additional methods.\n */\nexport function pushable<T extends { byteLength: number } = Uint8Array> (options?: BytePushableOptions): Pushable<T>\nexport function pushable<T> (options: ObjectPushableOptions): Pushable<T>\nexport function pushable<T> (options: Options = {}): Pushable<T> {\n  const getNext = (buffer: FIFO<T>): NextResult<T> => {\n    const next: Next<T> | undefined = buffer.shift()\n\n    if (next == null) {\n      return { done: true }\n    }\n\n    if (next.error != null) {\n      throw next.error\n    }\n\n    return {\n      done: next.done === true,\n      // @ts-expect-error if done is false, value will be present\n      value: next.value\n    }\n  }\n\n  return _pushable<T, T, Pushable<T>>(getNext, options)\n}\n\nexport function pushableV<T extends { byteLength: number } = Uint8Array> (options?: BytePushableOptions): PushableV<T>\nexport function pushableV<T> (options: ObjectPushableOptions): PushableV<T>\nexport function pushableV<T> (options: Options = {}): PushableV<T> {\n  const getNext = (buffer: FIFO<T>): NextResult<T[]> => {\n    let next: Next<T> | undefined\n    const values: T[] = []\n\n    while (!buffer.isEmpty()) {\n      next = buffer.shift()\n\n      if (next == null) {\n        break\n      }\n\n      if (next.error != null) {\n        throw next.error\n      }\n\n      if (next.done === false) {\n        // @ts-expect-error if done is false value should be pushed\n        values.push(next.value)\n      }\n    }\n\n    if (next == null) {\n      return { done: true }\n    }\n\n    return {\n      done: next.done === true,\n      value: values\n    }\n  }\n\n  return _pushable<T, T[], PushableV<T>>(getNext, options)\n}\n\nfunction _pushable<PushType, ValueType, ReturnType> (getNext: getNext<PushType, ValueType>, options?: Options): ReturnType {\n  options = options ?? {}\n  let onEnd = options.onEnd\n  let buffer = new FIFO<PushType>()\n  let pushable: any\n  let onNext: ((next: Next<PushType>) => ReturnType) | null\n  let ended: boolean\n  let drain = deferred()\n\n  const waitNext = async (): Promise<NextResult<ValueType>> => {\n    try {\n      if (!buffer.isEmpty()) {\n        return getNext(buffer)\n      }\n\n      if (ended) {\n        return { done: true }\n      }\n\n      return await new Promise<NextResult<ValueType>>((resolve, reject) => {\n        onNext = (next: Next<PushType>) => {\n          onNext = null\n          buffer.push(next)\n\n          try {\n            resolve(getNext(buffer))\n          } catch (err) {\n            reject(err)\n          }\n\n          return pushable\n        }\n      })\n    } finally {\n      if (buffer.isEmpty()) {\n        // settle promise in the microtask queue to give consumers a chance to\n        // await after calling .push\n        queueMicrotask(() => {\n          drain.resolve()\n          drain = deferred()\n        })\n      }\n    }\n  }\n\n  const bufferNext = (next: Next<PushType>): ReturnType => {\n    if (onNext != null) {\n      return onNext(next)\n    }\n\n    buffer.push(next)\n    return pushable\n  }\n\n  const bufferError = (err: Error): ReturnType => {\n    buffer = new FIFO()\n\n    if (onNext != null) {\n      return onNext({ error: err })\n    }\n\n    buffer.push({ error: err })\n    return pushable\n  }\n\n  const push = (value: PushType): ReturnType => {\n    if (ended) {\n      return pushable\n    }\n\n    // @ts-expect-error `byteLength` is not declared on PushType\n    if (options?.objectMode !== true && value?.byteLength == null) {\n      throw new Error('objectMode was not true but tried to push non-Uint8Array value')\n    }\n\n    return bufferNext({ done: false, value })\n  }\n  const end = (err?: Error): ReturnType => {\n    if (ended) return pushable\n    ended = true\n\n    return (err != null) ? bufferError(err) : bufferNext({ done: true })\n  }\n  const _return = (): DoneResult => {\n    buffer = new FIFO()\n    end()\n\n    return { done: true }\n  }\n  const _throw = (err: Error): DoneResult => {\n    end(err)\n\n    return { done: true }\n  }\n\n  pushable = {\n    [Symbol.asyncIterator] () { return this },\n    next: waitNext,\n    return: _return,\n    throw: _throw,\n    push,\n    end,\n    get readableLength (): number {\n      return buffer.size\n    },\n    onEmpty: async (options?: AbortOptions) => {\n      const signal = options?.signal\n      signal?.throwIfAborted()\n\n      if (buffer.isEmpty()) {\n        return\n      }\n\n      let cancel: Promise<void> | undefined\n      let listener: (() => void) | undefined\n\n      if (signal != null) {\n        cancel = new Promise((resolve, reject) => {\n          listener = () => {\n            reject(new AbortError())\n          }\n\n          signal.addEventListener('abort', listener)\n        })\n      }\n\n      try {\n        await Promise.race([\n          drain.promise,\n          cancel\n        ])\n      } finally {\n        if (listener != null && signal != null) {\n          signal?.removeEventListener('abort', listener)\n        }\n      }\n    }\n  }\n\n  if (onEnd == null) {\n    return pushable\n  }\n\n  const _pushable = pushable\n\n  pushable = {\n    [Symbol.asyncIterator] () { return this },\n    next () {\n      return _pushable.next()\n    },\n    throw (err: Error) {\n      _pushable.throw(err)\n\n      if (onEnd != null) {\n        onEnd(err)\n        onEnd = undefined\n      }\n\n      return { done: true }\n    },\n    return () {\n      _pushable.return()\n\n      if (onEnd != null) {\n        onEnd()\n        onEnd = undefined\n      }\n\n      return { done: true }\n    },\n    push,\n    end (err: Error) {\n      _pushable.end(err)\n\n      if (onEnd != null) {\n        onEnd(err)\n        onEnd = undefined\n      }\n\n      return pushable\n    },\n    get readableLength () {\n      return _pushable.readableLength\n    },\n    onEmpty: (opts?: AbortOptions) => {\n      return _pushable.onEmpty(opts)\n    }\n  }\n\n  return pushable\n}\n", "/**\n * An abort error class that extends error\n */\nexport class AbortError extends Error {\n  public type: string\n  public code: string | string\n\n  constructor (message?: string, code?: string, name?: string) {\n    super(message ?? 'The operation was aborted')\n    this.type = 'aborted'\n    this.name = name ?? 'AbortError'\n    this.code = code ?? 'ABORT_ERR'\n  }\n}\n\nexport interface RaceSignalOptions {\n  /**\n   * The message for the error thrown if the signal aborts\n   */\n  errorMessage?: string\n\n  /**\n   * The code for the error thrown if the signal aborts\n   */\n  errorCode?: string\n\n  /**\n   * The name for the error thrown if the signal aborts\n   */\n  errorName?: string\n}\n\n/**\n * Race a promise against an abort signal\n */\nexport async function raceSignal <T> (promise: Promise<T>, signal?: AbortSignal, opts?: RaceSignalOptions): Promise<T> {\n  if (signal == null) {\n    return promise\n  }\n\n  if (signal.aborted) {\n    // the passed promise may yet resolve or reject but the use has signalled\n    // they are no longer interested so smother the error\n    promise.catch(() => {})\n    return Promise.reject(new AbortError(opts?.errorMessage, opts?.errorCode, opts?.errorName))\n  }\n\n  let listener\n\n  // create the error here so we have more context in the stack trace\n  const error = new AbortError(opts?.errorMessage, opts?.errorCode, opts?.errorName)\n\n  try {\n    return await Promise.race([\n      promise,\n      new Promise<T>((resolve, reject) => {\n        listener = () => {\n          reject(error)\n        }\n        signal.addEventListener('abort', listener)\n      })\n    ])\n  } finally {\n    if (listener != null) {\n      signal.removeEventListener('abort', listener)\n    }\n  }\n}\n", "/**\n * @packageDocumentation\n *\n * A pushable async generator that waits until the current value is consumed\n * before allowing a new value to be pushed.\n *\n * Useful for when you don't want to keep memory usage under control and/or\n * allow a downstream consumer to dictate how fast data flows through a pipe,\n * but you want to be able to apply a transform to that data.\n *\n * @example\n *\n * ```typescript\n * import { queuelessPushable } from 'it-queueless-pushable'\n *\n * const pushable = queuelessPushable<string>()\n *\n * // run asynchronously\n * Promise.resolve().then(async () => {\n *   // push a value - the returned promise will not resolve until the value is\n *   // read from the pushable\n *   await pushable.push('hello')\n * })\n *\n * // read a value\n * const result = await pushable.next()\n * console.info(result) // { done: false, value: 'hello' }\n * ```\n */\n\nimport deferred from 'p-defer'\nimport { raceSignal } from 'race-signal'\nimport type { AbortOptions } from 'abort-error'\nimport type { RaceSignalOptions } from 'race-signal'\n\nexport interface Pushable<T> extends AsyncGenerator<T, void, unknown> {\n  /**\n   * End the iterable after all values in the buffer (if any) have been yielded. If an\n   * error is passed the buffer is cleared immediately and the next iteration will\n   * throw the passed error\n   */\n  end(err?: Error, options?: AbortOptions & RaceSignalOptions): Promise<void>\n\n  /**\n   * Push a value into the iterable. Values are yielded from the iterable in the order\n   * they are pushed. Values not yet consumed from the iterable are buffered.\n   */\n  push(value: T, options?: AbortOptions & RaceSignalOptions): Promise<void>\n}\n\nclass QueuelessPushable <T> implements Pushable<T> {\n  private readNext: PromiseWithResolvers<void>\n  private haveNext: PromiseWithResolvers<void>\n  private ended: boolean\n  private nextResult: IteratorResult<T> | undefined\n  private error?: Error\n\n  constructor () {\n    this.ended = false\n\n    this.readNext = deferred()\n    this.haveNext = deferred()\n  }\n\n  [Symbol.asyncIterator] (): AsyncGenerator<T, void, unknown> {\n    return this\n  }\n\n  async next (): Promise<IteratorResult<T, void>> {\n    if (this.nextResult == null) {\n      // wait for the supplier to push a value\n      await this.haveNext.promise\n    }\n\n    if (this.nextResult == null) {\n      throw new Error('HaveNext promise resolved but nextResult was undefined')\n    }\n\n    const nextResult = this.nextResult\n    this.nextResult = undefined\n\n    // signal to the supplier that we read the value\n    this.readNext.resolve()\n    this.readNext = deferred()\n\n    return nextResult\n  }\n\n  async throw (err?: Error): Promise<IteratorReturnResult<undefined>> {\n    this.ended = true\n    this.error = err\n\n    if (err != null) {\n      // this can cause unhandled promise rejections if nothing is awaiting the\n      // next value so attach a dummy catch listener to the promise\n      this.haveNext.promise.catch(() => {})\n      this.haveNext.reject(err)\n    }\n\n    const result: IteratorReturnResult<undefined> = {\n      done: true,\n      value: undefined\n    }\n\n    return result\n  }\n\n  async return (): Promise<IteratorResult<T>> {\n    const result: IteratorReturnResult<undefined> = {\n      done: true,\n      value: undefined\n    }\n\n    this.ended = true\n    this.nextResult = result\n\n    // let the consumer know we have a new value\n    this.haveNext.resolve()\n\n    return result\n  }\n\n  async push (value: T, options?: AbortOptions & RaceSignalOptions): Promise<void> {\n    await this._push(value, options)\n  }\n\n  async end (err?: Error, options?: AbortOptions & RaceSignalOptions): Promise<void> {\n    if (err != null) {\n      await this.throw(err)\n    } else {\n      // abortable return\n      await this._push(undefined, options)\n    }\n  }\n\n  private async _push (value?: T, options?: AbortOptions & RaceSignalOptions): Promise<void> {\n    if (value != null && this.ended) {\n      throw this.error ?? new Error('Cannot push value onto an ended pushable')\n    }\n\n    // wait for all values to be read\n    while (this.nextResult != null) {\n      await this.readNext.promise\n    }\n\n    if (value != null) {\n      this.nextResult = { done: false, value }\n    } else {\n      this.ended = true\n      this.nextResult = { done: true, value: undefined }\n    }\n\n    // let the consumer know we have a new value\n    this.haveNext.resolve()\n    this.haveNext = deferred()\n\n    // wait for the consumer to have finished processing the value and requested\n    // the next one or for the passed signal to abort the waiting\n    await raceSignal(\n      this.readNext.promise,\n      options?.signal,\n      options\n    )\n  }\n}\n\nexport function queuelessPushable <T> (): Pushable<T> {\n  return new QueuelessPushable<T>()\n}\n", "/**\n * @packageDocumentation\n *\n * Merge several (async)iterables into one, yield values as they arrive.\n *\n * Nb. sources are iterated over in parallel so the order of emitted items is not guaranteed.\n *\n * @example\n *\n * ```javascript\n * import merge from 'it-merge'\n * import all from 'it-all'\n *\n * // This can also be an iterator, generator, etc\n * const values1 = [0, 1, 2, 3, 4]\n * const values2 = [5, 6, 7, 8, 9]\n *\n * const arr = all(merge(values1, values2))\n *\n * console.info(arr) // 0, 1, 2, 3, 4, 5, 6, 7, 8, 9\n * ```\n *\n * Async sources must be awaited:\n *\n * ```javascript\n * import merge from 'it-merge'\n * import all from 'it-all'\n *\n * // This can also be an iterator, async iterator, generator, etc\n * const values1 = async function * () {\n *   yield * [0, 1, 2, 3, 4]\n * }\n * const values2 = async function * () {\n *   yield * [5, 6, 7, 8, 9]\n * }\n *\n * const arr = await all(merge(values1(), values2()))\n *\n * console.info(arr) // 0, 1, 5, 6, 2, 3, 4, 7, 8, 9  <- nb. order is not guaranteed\n * ```\n */\n\nimport { queuelessPushable } from 'it-queueless-pushable'\nimport type { Pushable } from 'it-queueless-pushable'\n\nfunction isAsyncIterable <T> (thing: any): thing is AsyncIterable<T> {\n  return thing[Symbol.asyncIterator] != null\n}\n\nasync function addAllToPushable <T> (sources: Array<AsyncIterable<T> | Iterable<T>>, output: Pushable<T>, signal: AbortSignal): Promise<void> {\n  try {\n    await Promise.all(\n      sources.map(async (source) => {\n        for await (const item of source) {\n          await output.push(item, {\n            signal\n          })\n          signal.throwIfAborted()\n        }\n      })\n    )\n\n    await output.end(undefined, {\n      signal\n    })\n  } catch (err: any) {\n    await output.end(err, {\n      signal\n    })\n      .catch(() => {})\n  }\n}\n\nasync function * mergeSources <T> (sources: Array<AsyncIterable<T> | Iterable<T>>): AsyncGenerator<T, void, undefined> {\n  const controller = new AbortController()\n  const output = queuelessPushable<T>()\n\n  addAllToPushable(sources, output, controller.signal)\n    .catch(() => {})\n\n  try {\n    yield * output\n  } finally {\n    controller.abort()\n  }\n}\n\nfunction * mergeSyncSources <T> (syncSources: Array<Iterable<T>>): Generator<T, void, undefined> {\n  for (const source of syncSources) {\n    yield * source\n  }\n}\n\n/**\n * Treat one or more iterables as a single iterable.\n *\n * Nb. sources are iterated over in parallel so the\n * order of emitted items is not guaranteed.\n */\nfunction merge <T> (...sources: Array<Iterable<T>>): Generator<T, void, undefined>\nfunction merge <T> (...sources: Array<AsyncIterable<T> | Iterable<T>>): AsyncGenerator<T, void, undefined>\nfunction merge <T> (...sources: Array<AsyncIterable<T> | Iterable<T>>): AsyncGenerator<T, void, undefined> | Generator<T, void, undefined> {\n  const syncSources: Array<Iterable<T>> = []\n\n  for (const source of sources) {\n    if (!isAsyncIterable(source)) {\n      syncSources.push(source)\n    }\n  }\n\n  if (syncSources.length === sources.length) {\n    // all sources are synchronous\n    return mergeSyncSources(syncSources)\n  }\n\n  return mergeSources(sources)\n}\n\nexport default merge\n", "import { pushable } from 'it-pushable'\nimport merge from 'it-merge'\nimport type { Duplex, Transform, Sink } from 'it-stream-types'\n\ninterface SourceFn<A = any> { (): A }\n\ntype PipeSource<A = any> =\n  Iterable<A> |\n  AsyncIterable<A> |\n  SourceFn<A> |\n  Duplex<A, any, any>\n\ntype PipeTransform<A = any, B = any> =\n  Transform<A, B> |\n  Duplex<B, A>\n\ntype PipeSink<A = any, B = any> =\n  Sink<A, B> |\n  Duplex<any, A, B>\n\ntype PipeOutput<A> =\n  A extends Sink<any> ? ReturnType<A> :\n    A extends Duplex<any, any, any> ? ReturnType<A['sink']> :\n      never\n\n// single item pipe output includes pipe source types\ntype SingleItemPipeOutput<A> =\n  A extends Iterable<any> ? A :\n    A extends AsyncIterable<any> ? A :\n      A extends SourceFn ? ReturnType<A> :\n        A extends Duplex<any, any, any> ? A['source'] :\n          PipeOutput<A>\n\ntype PipeFnInput<A> =\n  A extends Iterable<any> ? A :\n    A extends AsyncIterable<any> ? A :\n      A extends SourceFn ? ReturnType<A> :\n        A extends Transform<any, any> ? ReturnType<A> :\n          A extends Duplex<any, any, any> ? A['source'] :\n            never\n\n// one item, just a pass-through\nexport function pipe<\n  A extends PipeSource\n> (\n  source: A\n): SingleItemPipeOutput<A>\n\n// two items, source to sink\nexport function pipe<\n  A extends PipeSource,\n  B extends PipeSink<PipeFnInput<A>>\n> (\n  source: A,\n  sink: B\n): PipeOutput<B>\n\n// three items, source to sink with transform(s) in between\nexport function pipe<\n  A extends PipeSource,\n  B extends PipeTransform<PipeFnInput<A>>,\n  C extends PipeSink<PipeFnInput<B>>\n> (\n  source: A,\n  transform1: B,\n  sink: C\n): PipeOutput<C>\n\n// many items, source to sink with transform(s) in between\nexport function pipe<\n  A extends PipeSource,\n  B extends PipeTransform<PipeFnInput<A>>,\n  C extends PipeTransform<PipeFnInput<B>>,\n  D extends PipeSink<PipeFnInput<C>>\n> (\n  source: A,\n  transform1: B,\n  transform2: C,\n  sink: D\n): PipeOutput<D>\n\n// lots of items, source to sink with transform(s) in between\nexport function pipe<\n  A extends PipeSource,\n  B extends PipeTransform<PipeFnInput<A>>,\n  C extends PipeTransform<PipeFnInput<B>>,\n  D extends PipeTransform<PipeFnInput<C>>,\n  E extends PipeSink<PipeFnInput<D>>\n> (\n  source: A,\n  transform1: B,\n  transform2: C,\n  transform3: D,\n  sink: E\n): PipeOutput<E>\n\n// lots of items, source to sink with transform(s) in between\nexport function pipe<\n  A extends PipeSource,\n  B extends PipeTransform<PipeFnInput<A>>,\n  C extends PipeTransform<PipeFnInput<B>>,\n  D extends PipeTransform<PipeFnInput<C>>,\n  E extends PipeTransform<PipeFnInput<D>>,\n  F extends PipeSink<PipeFnInput<E>>\n> (\n  source: A,\n  transform1: B,\n  transform2: C,\n  transform3: D,\n  transform4: E,\n  sink: F\n): PipeOutput<F>\n\n// lots of items, source to sink with transform(s) in between\nexport function pipe<\n  A extends PipeSource,\n  B extends PipeTransform<PipeFnInput<A>>,\n  C extends PipeTransform<PipeFnInput<B>>,\n  D extends PipeTransform<PipeFnInput<C>>,\n  E extends PipeTransform<PipeFnInput<D>>,\n  F extends PipeTransform<PipeFnInput<E>>,\n  G extends PipeSink<PipeFnInput<F>>\n> (\n  source: A,\n  transform1: B,\n  transform2: C,\n  transform3: D,\n  transform4: E,\n  transform5: F,\n  sink: G\n): PipeOutput<G>\n\n// lots of items, source to sink with transform(s) in between\nexport function pipe<\n  A extends PipeSource,\n  B extends PipeTransform<PipeFnInput<A>>,\n  C extends PipeTransform<PipeFnInput<B>>,\n  D extends PipeTransform<PipeFnInput<C>>,\n  E extends PipeTransform<PipeFnInput<D>>,\n  F extends PipeTransform<PipeFnInput<E>>,\n  G extends PipeTransform<PipeFnInput<F>>,\n  H extends PipeSink<PipeFnInput<G>>\n> (\n  source: A,\n  transform1: B,\n  transform2: C,\n  transform3: D,\n  transform4: E,\n  transform5: F,\n  transform6: G,\n  sink: H\n): PipeOutput<H>\n\n// lots of items, source to sink with transform(s) in between\nexport function pipe<\n  A extends PipeSource,\n  B extends PipeTransform<PipeFnInput<A>>,\n  C extends PipeTransform<PipeFnInput<B>>,\n  D extends PipeTransform<PipeFnInput<C>>,\n  E extends PipeTransform<PipeFnInput<D>>,\n  F extends PipeTransform<PipeFnInput<E>>,\n  G extends PipeTransform<PipeFnInput<F>>,\n  H extends PipeTransform<PipeFnInput<G>>,\n  I extends PipeSink<PipeFnInput<H>>\n> (\n  source: A,\n  transform1: B,\n  transform2: C,\n  transform3: D,\n  transform4: E,\n  transform5: F,\n  transform6: G,\n  transform7: H,\n  sink: I\n): PipeOutput<I>\n\n// lots of items, source to sink with transform(s) in between\nexport function pipe<\n  A extends PipeSource,\n  B extends PipeTransform<PipeFnInput<A>>,\n  C extends PipeTransform<PipeFnInput<B>>,\n  D extends PipeTransform<PipeFnInput<C>>,\n  E extends PipeTransform<PipeFnInput<D>>,\n  F extends PipeTransform<PipeFnInput<E>>,\n  G extends PipeTransform<PipeFnInput<F>>,\n  H extends PipeTransform<PipeFnInput<G>>,\n  I extends PipeTransform<PipeFnInput<H>>,\n  J extends PipeSink<PipeFnInput<I>>\n> (\n  source: A,\n  transform1: B,\n  transform2: C,\n  transform3: D,\n  transform4: E,\n  transform5: F,\n  transform6: G,\n  transform7: H,\n  transform8: I,\n  sink: J\n): PipeOutput<J>\n\n// lots of items, source to sink with transform(s) in between\nexport function pipe<\n  A extends PipeSource,\n  B extends PipeTransform<PipeFnInput<A>>,\n  C extends PipeTransform<PipeFnInput<B>>,\n  D extends PipeTransform<PipeFnInput<C>>,\n  E extends PipeTransform<PipeFnInput<D>>,\n  F extends PipeTransform<PipeFnInput<E>>,\n  G extends PipeTransform<PipeFnInput<F>>,\n  H extends PipeTransform<PipeFnInput<G>>,\n  I extends PipeTransform<PipeFnInput<H>>,\n  J extends PipeTransform<PipeFnInput<I>>,\n  K extends PipeSink<PipeFnInput<J>>\n> (\n  source: A,\n  transform1: B,\n  transform2: C,\n  transform3: D,\n  transform4: E,\n  transform5: F,\n  transform6: G,\n  transform7: H,\n  transform8: I,\n  transform9: J,\n  sink: K\n): PipeOutput<K>\n\n// lots of items, source to sink with transform(s) in between\nexport function pipe<\n  A extends PipeSource,\n  B extends PipeTransform<PipeFnInput<A>>,\n  C extends PipeTransform<PipeFnInput<B>>,\n  D extends PipeTransform<PipeFnInput<C>>,\n  E extends PipeTransform<PipeFnInput<D>>,\n  F extends PipeTransform<PipeFnInput<E>>,\n  G extends PipeTransform<PipeFnInput<F>>,\n  H extends PipeTransform<PipeFnInput<G>>,\n  I extends PipeTransform<PipeFnInput<H>>,\n  J extends PipeTransform<PipeFnInput<I>>,\n  K extends PipeTransform<PipeFnInput<J>>,\n  L extends PipeSink<PipeFnInput<K>>\n> (\n  source: A,\n  transform1: B,\n  transform2: C,\n  transform3: D,\n  transform4: E,\n  transform5: F,\n  transform6: G,\n  transform7: H,\n  transform8: I,\n  transform9: J,\n  transform10: K,\n  sink: L\n): PipeOutput<L>\n\nexport function pipe (first: any, ...rest: any[]): any {\n  if (first == null) {\n    throw new Error('Empty pipeline')\n  }\n\n  // Duplex at start: wrap in function and return duplex source\n  if (isDuplex(first)) {\n    const duplex = first\n    first = () => duplex.source\n  // Iterable at start: wrap in function\n  } else if (isIterable(first) || isAsyncIterable(first)) {\n    const source = first\n    first = () => source\n  }\n\n  const fns = [first, ...rest]\n\n  if (fns.length > 1) {\n    // Duplex at end: use duplex sink\n    if (isDuplex(fns[fns.length - 1])) {\n      fns[fns.length - 1] = fns[fns.length - 1].sink\n    }\n  }\n\n  if (fns.length > 2) {\n    // Duplex in the middle, consume source with duplex sink and return duplex source\n    for (let i = 1; i < fns.length - 1; i++) {\n      if (isDuplex(fns[i])) {\n        fns[i] = duplexPipelineFn(fns[i])\n      }\n    }\n  }\n\n  return rawPipe(...fns)\n}\n\nexport const rawPipe = (...fns: any): any => {\n  let res\n  while (fns.length > 0) {\n    res = fns.shift()(res)\n  }\n  return res\n}\n\nconst isAsyncIterable = (obj: any): obj is AsyncIterable<unknown> => {\n  return obj?.[Symbol.asyncIterator] != null\n}\n\nconst isIterable = (obj: any): obj is Iterable<unknown> => {\n  return obj?.[Symbol.iterator] != null\n}\n\nconst isDuplex = (obj: any): obj is Duplex => {\n  if (obj == null) {\n    return false\n  }\n\n  return obj.sink != null && obj.source != null\n}\n\nconst duplexPipelineFn = (duplex: Duplex<any, any, any>) => {\n  return (source: any) => {\n    const p = duplex.sink(source)\n\n    if (p?.then != null) {\n      const stream = pushable<any>({\n        objectMode: true\n      })\n      p.then(() => {\n        stream.end()\n      }, (err: Error) => {\n        stream.end(err)\n      })\n\n      let sourceWrap: () => Iterable<any> | AsyncIterable<any>\n      const source = duplex.source\n\n      if (isAsyncIterable(source)) {\n        sourceWrap = async function * () {\n          yield * source\n          stream.end()\n        }\n      } else if (isIterable(source)) {\n        sourceWrap = function * () {\n          yield * source\n          stream.end()\n        }\n      } else {\n        throw new Error('Unknown duplex source type - must be Iterable or AsyncIterable')\n      }\n\n      return merge(stream, sourceWrap())\n    }\n\n    return duplex.source\n  }\n}\n", "import filter from 'it-filter'\nimport map from 'it-map'\nimport parallel from 'it-parallel'\nimport { pipe } from 'it-pipe'\nimport { CustomProgressEvent } from 'progress-events'\nimport type { ExporterOptions, ExportWalk, UnixfsV1DirectoryContent, UnixfsV1Resolver } from '../../../index.js'\n\nconst directoryContent: UnixfsV1Resolver = (cid, node, unixfs, path, resolve, depth, blockstore) => {\n  async function * yieldDirectoryContent (options: ExporterOptions = {}): UnixfsV1DirectoryContent {\n    const offset = options.offset ?? 0\n    const length = options.length ?? node.Links.length\n    const links = node.Links.slice(offset, length)\n\n    options.onProgress?.(new CustomProgressEvent<ExportWalk>('unixfs:exporter:walk:directory', {\n      cid\n    }))\n\n    yield * pipe(\n      links,\n      source => map(source, link => {\n        return async () => {\n          const linkName = link.Name ?? ''\n          const linkPath = `${path}/${linkName}`\n          const result = await resolve(link.Hash, linkName, linkPath, [], depth + 1, blockstore, options)\n          return result.entry\n        }\n      }),\n      source => parallel(source, {\n        ordered: true,\n        concurrency: options.blockReadConcurrency\n      }),\n      source => filter(source, entry => entry != null)\n    )\n  }\n\n  return yieldDirectoryContent\n}\n\nexport default directoryContent\n", "import EventEmitter from './index.js'\n\nexport { EventEmitter }\nexport default EventEmitter\n", "export class TimeoutError extends Error {\n\tconstructor(message) {\n\t\tsuper(message);\n\t\tthis.name = 'TimeoutError';\n\t}\n}\n\n/**\nAn error to be thrown when the request is aborted by AbortController.\nDOMException is thrown instead of this Error when DOMException is available.\n*/\nexport class AbortError extends Error {\n\tconstructor(message) {\n\t\tsuper();\n\t\tthis.name = 'AbortError';\n\t\tthis.message = message;\n\t}\n}\n\n/**\nTODO: Remove AbortError and just throw DOMException when targeting Node 18.\n*/\nconst getDOMException = errorMessage => globalThis.DOMException === undefined\n\t? new AbortError(errorMessage)\n\t: new DOMException(errorMessage);\n\n/**\nTODO: Remove below function and just 'reject(signal.reason)' when targeting Node 18.\n*/\nconst getAbortedReason = signal => {\n\tconst reason = signal.reason === undefined\n\t\t? getDOMException('This operation was aborted.')\n\t\t: signal.reason;\n\n\treturn reason instanceof Error ? reason : getDOMException(reason);\n};\n\nexport default function pTimeout(promise, options) {\n\tconst {\n\t\tmilliseconds,\n\t\tfallback,\n\t\tmessage,\n\t\tcustomTimers = {setTimeout, clearTimeout},\n\t} = options;\n\n\tlet timer;\n\tlet abortHandler;\n\n\tconst wrappedPromise = new Promise((resolve, reject) => {\n\t\tif (typeof milliseconds !== 'number' || Math.sign(milliseconds) !== 1) {\n\t\t\tthrow new TypeError(`Expected \\`milliseconds\\` to be a positive number, got \\`${milliseconds}\\``);\n\t\t}\n\n\t\tif (options.signal) {\n\t\t\tconst {signal} = options;\n\t\t\tif (signal.aborted) {\n\t\t\t\treject(getAbortedReason(signal));\n\t\t\t}\n\n\t\t\tabortHandler = () => {\n\t\t\t\treject(getAbortedReason(signal));\n\t\t\t};\n\n\t\t\tsignal.addEventListener('abort', abortHandler, {once: true});\n\t\t}\n\n\t\tif (milliseconds === Number.POSITIVE_INFINITY) {\n\t\t\tpromise.then(resolve, reject);\n\t\t\treturn;\n\t\t}\n\n\t\t// We create the error outside of `setTimeout` to preserve the stack trace.\n\t\tconst timeoutError = new TimeoutError();\n\n\t\ttimer = customTimers.setTimeout.call(undefined, () => {\n\t\t\tif (fallback) {\n\t\t\t\ttry {\n\t\t\t\t\tresolve(fallback());\n\t\t\t\t} catch (error) {\n\t\t\t\t\treject(error);\n\t\t\t\t}\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (typeof promise.cancel === 'function') {\n\t\t\t\tpromise.cancel();\n\t\t\t}\n\n\t\t\tif (message === false) {\n\t\t\t\tresolve();\n\t\t\t} else if (message instanceof Error) {\n\t\t\t\treject(message);\n\t\t\t} else {\n\t\t\t\ttimeoutError.message = message ?? `Promise timed out after ${milliseconds} milliseconds`;\n\t\t\t\treject(timeoutError);\n\t\t\t}\n\t\t}, milliseconds);\n\n\t\t(async () => {\n\t\t\ttry {\n\t\t\t\tresolve(await promise);\n\t\t\t} catch (error) {\n\t\t\t\treject(error);\n\t\t\t}\n\t\t})();\n\t});\n\n\tconst cancelablePromise = wrappedPromise.finally(() => {\n\t\tcancelablePromise.clear();\n\t\tif (abortHandler && options.signal) {\n\t\t\toptions.signal.removeEventListener('abort', abortHandler);\n\t\t}\n\t});\n\n\tcancelablePromise.clear = () => {\n\t\tcustomTimers.clearTimeout.call(undefined, timer);\n\t\ttimer = undefined;\n\t};\n\n\treturn cancelablePromise;\n}\n", "// Port of lower_bound from https://en.cppreference.com/w/cpp/algorithm/lower_bound\n// Used to compute insertion index to keep queue sorted after insertion\nexport default function lowerBound(array, value, comparator) {\n    let first = 0;\n    let count = array.length;\n    while (count > 0) {\n        const step = Math.trunc(count / 2);\n        let it = first + step;\n        if (comparator(array[it], value) <= 0) {\n            first = ++it;\n            count -= step + 1;\n        }\n        else {\n            count = step;\n        }\n    }\n    return first;\n}\n", "import lowerBound from './lower-bound.js';\nexport default class PriorityQueue {\n    #queue = [];\n    enqueue(run, options) {\n        options = {\n            priority: 0,\n            ...options,\n        };\n        const element = {\n            priority: options.priority,\n            id: options.id,\n            run,\n        };\n        if (this.size === 0 || this.#queue[this.size - 1].priority >= options.priority) {\n            this.#queue.push(element);\n            return;\n        }\n        const index = lowerBound(this.#queue, element, (a, b) => b.priority - a.priority);\n        this.#queue.splice(index, 0, element);\n    }\n    setPriority(id, priority) {\n        const index = this.#queue.findIndex((element) => element.id === id);\n        if (index === -1) {\n            throw new ReferenceError(`No promise function with the id \"${id}\" exists in the queue.`);\n        }\n        const [item] = this.#queue.splice(index, 1);\n        this.enqueue(item.run, { priority, id });\n    }\n    dequeue() {\n        const item = this.#queue.shift();\n        return item?.run;\n    }\n    filter(options) {\n        return this.#queue.filter((element) => element.priority === options.priority).map((element) => element.run);\n    }\n    get size() {\n        return this.#queue.length;\n    }\n}\n", "import { EventEmitter } from 'eventemitter3';\nimport pTimeout, { TimeoutError } from 'p-timeout';\nimport PriorityQueue from './priority-queue.js';\n/**\nPromise queue with concurrency control.\n*/\nexport default class PQueue extends EventEmitter {\n    #carryoverConcurrencyCount;\n    #isIntervalIgnored;\n    #intervalCount = 0;\n    #intervalCap;\n    #interval;\n    #intervalEnd = 0;\n    #intervalId;\n    #timeoutId;\n    #queue;\n    #queueClass;\n    #pending = 0;\n    // The `!` is needed because of https://github.com/microsoft/TypeScript/issues/32194\n    #concurrency;\n    #isPaused;\n    #throwOnTimeout;\n    // Use to assign a unique identifier to a promise function, if not explicitly specified\n    #idAssigner = 1n;\n    /**\n    Per-operation timeout in milliseconds. Operations fulfill once `timeout` elapses if they haven't already.\n\n    Applies to each future operation.\n    */\n    timeout;\n    // TODO: The `throwOnTimeout` option should affect the return types of `add()` and `addAll()`\n    constructor(options) {\n        super();\n        // eslint-disable-next-line @typescript-eslint/consistent-type-assertions\n        options = {\n            carryoverConcurrencyCount: false,\n            intervalCap: Number.POSITIVE_INFINITY,\n            interval: 0,\n            concurrency: Number.POSITIVE_INFINITY,\n            autoStart: true,\n            queueClass: PriorityQueue,\n            ...options,\n        };\n        if (!(typeof options.intervalCap === 'number' && options.intervalCap >= 1)) {\n            throw new TypeError(`Expected \\`intervalCap\\` to be a number from 1 and up, got \\`${options.intervalCap?.toString() ?? ''}\\` (${typeof options.intervalCap})`);\n        }\n        if (options.interval === undefined || !(Number.isFinite(options.interval) && options.interval >= 0)) {\n            throw new TypeError(`Expected \\`interval\\` to be a finite number >= 0, got \\`${options.interval?.toString() ?? ''}\\` (${typeof options.interval})`);\n        }\n        this.#carryoverConcurrencyCount = options.carryoverConcurrencyCount;\n        this.#isIntervalIgnored = options.intervalCap === Number.POSITIVE_INFINITY || options.interval === 0;\n        this.#intervalCap = options.intervalCap;\n        this.#interval = options.interval;\n        this.#queue = new options.queueClass();\n        this.#queueClass = options.queueClass;\n        this.concurrency = options.concurrency;\n        this.timeout = options.timeout;\n        this.#throwOnTimeout = options.throwOnTimeout === true;\n        this.#isPaused = options.autoStart === false;\n    }\n    get #doesIntervalAllowAnother() {\n        return this.#isIntervalIgnored || this.#intervalCount < this.#intervalCap;\n    }\n    get #doesConcurrentAllowAnother() {\n        return this.#pending < this.#concurrency;\n    }\n    #next() {\n        this.#pending--;\n        this.#tryToStartAnother();\n        this.emit('next');\n    }\n    #onResumeInterval() {\n        this.#onInterval();\n        this.#initializeIntervalIfNeeded();\n        this.#timeoutId = undefined;\n    }\n    get #isIntervalPaused() {\n        const now = Date.now();\n        if (this.#intervalId === undefined) {\n            const delay = this.#intervalEnd - now;\n            if (delay < 0) {\n                // Act as the interval was done\n                // We don't need to resume it here because it will be resumed on line 160\n                this.#intervalCount = (this.#carryoverConcurrencyCount) ? this.#pending : 0;\n            }\n            else {\n                // Act as the interval is pending\n                if (this.#timeoutId === undefined) {\n                    this.#timeoutId = setTimeout(() => {\n                        this.#onResumeInterval();\n                    }, delay);\n                }\n                return true;\n            }\n        }\n        return false;\n    }\n    #tryToStartAnother() {\n        if (this.#queue.size === 0) {\n            // We can clear the interval (\"pause\")\n            // Because we can redo it later (\"resume\")\n            if (this.#intervalId) {\n                clearInterval(this.#intervalId);\n            }\n            this.#intervalId = undefined;\n            this.emit('empty');\n            if (this.#pending === 0) {\n                this.emit('idle');\n            }\n            return false;\n        }\n        if (!this.#isPaused) {\n            const canInitializeInterval = !this.#isIntervalPaused;\n            if (this.#doesIntervalAllowAnother && this.#doesConcurrentAllowAnother) {\n                const job = this.#queue.dequeue();\n                if (!job) {\n                    return false;\n                }\n                this.emit('active');\n                job();\n                if (canInitializeInterval) {\n                    this.#initializeIntervalIfNeeded();\n                }\n                return true;\n            }\n        }\n        return false;\n    }\n    #initializeIntervalIfNeeded() {\n        if (this.#isIntervalIgnored || this.#intervalId !== undefined) {\n            return;\n        }\n        this.#intervalId = setInterval(() => {\n            this.#onInterval();\n        }, this.#interval);\n        this.#intervalEnd = Date.now() + this.#interval;\n    }\n    #onInterval() {\n        if (this.#intervalCount === 0 && this.#pending === 0 && this.#intervalId) {\n            clearInterval(this.#intervalId);\n            this.#intervalId = undefined;\n        }\n        this.#intervalCount = this.#carryoverConcurrencyCount ? this.#pending : 0;\n        this.#processQueue();\n    }\n    /**\n    Executes all queued functions until it reaches the limit.\n    */\n    #processQueue() {\n        // eslint-disable-next-line no-empty\n        while (this.#tryToStartAnother()) { }\n    }\n    get concurrency() {\n        return this.#concurrency;\n    }\n    set concurrency(newConcurrency) {\n        if (!(typeof newConcurrency === 'number' && newConcurrency >= 1)) {\n            throw new TypeError(`Expected \\`concurrency\\` to be a number from 1 and up, got \\`${newConcurrency}\\` (${typeof newConcurrency})`);\n        }\n        this.#concurrency = newConcurrency;\n        this.#processQueue();\n    }\n    async #throwOnAbort(signal) {\n        return new Promise((_resolve, reject) => {\n            signal.addEventListener('abort', () => {\n                reject(signal.reason);\n            }, { once: true });\n        });\n    }\n    /**\n    Updates the priority of a promise function by its id, affecting its execution order. Requires a defined concurrency limit to take effect.\n\n    For example, this can be used to prioritize a promise function to run earlier.\n\n    ```js\n    import PQueue from 'p-queue';\n\n    const queue = new PQueue({concurrency: 1});\n\n    queue.add(async () => '\uD83E\uDD84', {priority: 1});\n    queue.add(async () => '\uD83E\uDD80', {priority: 0, id: '\uD83E\uDD80'});\n    queue.add(async () => '\uD83E\uDD84', {priority: 1});\n    queue.add(async () => '\uD83E\uDD84', {priority: 1});\n\n    queue.setPriority('\uD83E\uDD80', 2);\n    ```\n\n    In this case, the promise function with `id: '\uD83E\uDD80'` runs second.\n\n    You can also deprioritize a promise function to delay its execution:\n\n    ```js\n    import PQueue from 'p-queue';\n\n    const queue = new PQueue({concurrency: 1});\n\n    queue.add(async () => '\uD83E\uDD84', {priority: 1});\n    queue.add(async () => '\uD83E\uDD80', {priority: 1, id: '\uD83E\uDD80'});\n    queue.add(async () => '\uD83E\uDD84');\n    queue.add(async () => '\uD83E\uDD84', {priority: 0});\n\n    queue.setPriority('\uD83E\uDD80', -1);\n    ```\n    Here, the promise function with `id: '\uD83E\uDD80'` executes last.\n    */\n    setPriority(id, priority) {\n        this.#queue.setPriority(id, priority);\n    }\n    async add(function_, options = {}) {\n        // In case `id` is not defined.\n        options.id ??= (this.#idAssigner++).toString();\n        options = {\n            timeout: this.timeout,\n            throwOnTimeout: this.#throwOnTimeout,\n            ...options,\n        };\n        return new Promise((resolve, reject) => {\n            this.#queue.enqueue(async () => {\n                this.#pending++;\n                this.#intervalCount++;\n                try {\n                    options.signal?.throwIfAborted();\n                    let operation = function_({ signal: options.signal });\n                    if (options.timeout) {\n                        operation = pTimeout(Promise.resolve(operation), { milliseconds: options.timeout });\n                    }\n                    if (options.signal) {\n                        operation = Promise.race([operation, this.#throwOnAbort(options.signal)]);\n                    }\n                    const result = await operation;\n                    resolve(result);\n                    this.emit('completed', result);\n                }\n                catch (error) {\n                    if (error instanceof TimeoutError && !options.throwOnTimeout) {\n                        resolve();\n                        return;\n                    }\n                    reject(error);\n                    this.emit('error', error);\n                }\n                finally {\n                    this.#next();\n                }\n            }, options);\n            this.emit('add');\n            this.#tryToStartAnother();\n        });\n    }\n    async addAll(functions, options) {\n        return Promise.all(functions.map(async (function_) => this.add(function_, options)));\n    }\n    /**\n    Start (or resume) executing enqueued tasks within concurrency limit. No need to call this if queue is not paused (via `options.autoStart = false` or by `.pause()` method.)\n    */\n    start() {\n        if (!this.#isPaused) {\n            return this;\n        }\n        this.#isPaused = false;\n        this.#processQueue();\n        return this;\n    }\n    /**\n    Put queue execution on hold.\n    */\n    pause() {\n        this.#isPaused = true;\n    }\n    /**\n    Clear the queue.\n    */\n    clear() {\n        this.#queue = new this.#queueClass();\n    }\n    /**\n    Can be called multiple times. Useful if you for example add additional items at a later time.\n\n    @returns A promise that settles when the queue becomes empty.\n    */\n    async onEmpty() {\n        // Instantly resolve if the queue is empty\n        if (this.#queue.size === 0) {\n            return;\n        }\n        await this.#onEvent('empty');\n    }\n    /**\n    @returns A promise that settles when the queue size is less than the given limit: `queue.size < limit`.\n\n    If you want to avoid having the queue grow beyond a certain size you can `await queue.onSizeLessThan()` before adding a new item.\n\n    Note that this only limits the number of items waiting to start. There could still be up to `concurrency` jobs already running that this call does not include in its calculation.\n    */\n    async onSizeLessThan(limit) {\n        // Instantly resolve if the queue is empty.\n        if (this.#queue.size < limit) {\n            return;\n        }\n        await this.#onEvent('next', () => this.#queue.size < limit);\n    }\n    /**\n    The difference with `.onEmpty` is that `.onIdle` guarantees that all work from the queue has finished. `.onEmpty` merely signals that the queue is empty, but it could mean that some promises haven't completed yet.\n\n    @returns A promise that settles when the queue becomes empty, and all promises have completed; `queue.size === 0 && queue.pending === 0`.\n    */\n    async onIdle() {\n        // Instantly resolve if none pending and if nothing else is queued\n        if (this.#pending === 0 && this.#queue.size === 0) {\n            return;\n        }\n        await this.#onEvent('idle');\n    }\n    async #onEvent(event, filter) {\n        return new Promise(resolve => {\n            const listener = () => {\n                if (filter && !filter()) {\n                    return;\n                }\n                this.off(event, listener);\n                resolve();\n            };\n            this.on(event, listener);\n        });\n    }\n    /**\n    Size of the queue, the number of queued items waiting to run.\n    */\n    get size() {\n        return this.#queue.size;\n    }\n    /**\n    Size of the queue, filtered by the given options.\n\n    For example, this can be used to find the number of items remaining in the queue with a specific priority level.\n    */\n    sizeBy(options) {\n        // eslint-disable-next-line unicorn/no-array-callback-reference\n        return this.#queue.filter(options).length;\n    }\n    /**\n    Number of running items (no longer in the queue).\n    */\n    get pending() {\n        return this.#pending;\n    }\n    /**\n    Whether the queue is currently paused.\n    */\n    get isPaused() {\n        return this.#isPaused;\n    }\n}\n", "import * as dagPb from '@ipld/dag-pb'\nimport { UnixFS } from 'ipfs-unixfs'\nimport map from 'it-map'\nimport parallel from 'it-parallel'\nimport { pipe } from 'it-pipe'\nimport { pushable } from 'it-pushable'\nimport * as raw from 'multiformats/codecs/raw'\nimport PQueue from 'p-queue'\nimport { CustomProgressEvent } from 'progress-events'\nimport { NotUnixFSError, OverReadError, UnderReadError } from '../../../errors.js'\nimport extractDataFromBlock from '../../../utils/extract-data-from-block.js'\nimport validateOffsetAndLength from '../../../utils/validate-offset-and-length.js'\nimport type { ExporterOptions, UnixfsV1FileContent, UnixfsV1Resolver, ReadableStorage, ExportProgress, ExportWalk } from '../../../index.js'\nimport type { Pushable } from 'it-pushable'\n\nasync function walkDAG (blockstore: ReadableStorage, node: dagPb.PBNode | Uint8Array, queue: Pushable<Uint8Array>, streamPosition: bigint, start: bigint, end: bigint, options: ExporterOptions): Promise<void> {\n  // a `raw` node\n  if (node instanceof Uint8Array) {\n    const buf = extractDataFromBlock(node, streamPosition, start, end)\n\n    queue.push(buf)\n\n    return\n  }\n\n  if (node.Data == null) {\n    throw new NotUnixFSError('no data in PBNode')\n  }\n\n  let file: UnixFS\n\n  try {\n    file = UnixFS.unmarshal(node.Data)\n  } catch (err: any) {\n    throw new NotUnixFSError(err.message)\n  }\n\n  // might be a unixfs `raw` node or have data on intermediate nodes\n  if (file.data != null) {\n    const data = file.data\n    const buf = extractDataFromBlock(data, streamPosition, start, end)\n\n    queue.push(buf)\n\n    streamPosition += BigInt(buf.byteLength)\n  }\n\n  const childOps: Array<{ link: dagPb.PBLink, blockStart: bigint }> = []\n\n  if (node.Links.length !== file.blockSizes.length) {\n    throw new NotUnixFSError('Inconsistent block sizes and dag links')\n  }\n\n  for (let i = 0; i < node.Links.length; i++) {\n    const childLink = node.Links[i]\n    const childStart = streamPosition // inclusive\n    const childEnd = childStart + file.blockSizes[i] // exclusive\n\n    if ((start >= childStart && start < childEnd) || // child has offset byte\n        (end >= childStart && end <= childEnd) || // child has end byte\n        (start < childStart && end > childEnd)) { // child is between offset and end bytes\n      childOps.push({\n        link: childLink,\n        blockStart: streamPosition\n      })\n    }\n\n    streamPosition = childEnd\n\n    if (streamPosition > end) {\n      break\n    }\n  }\n\n  await pipe(\n    childOps,\n    (source) => map(source, (op) => {\n      return async () => {\n        const block = await blockstore.get(op.link.Hash, options)\n\n        return {\n          ...op,\n          block\n        }\n      }\n    }),\n    (source) => parallel(source, {\n      ordered: true,\n      concurrency: options.blockReadConcurrency\n    }),\n    async (source) => {\n      for await (const { link, block, blockStart } of source) {\n        let child: dagPb.PBNode | Uint8Array\n        switch (link.Hash.code) {\n          case dagPb.code:\n            child = dagPb.decode(block)\n            break\n          case raw.code:\n            child = block\n            break\n          default:\n            queue.end(new NotUnixFSError(`Unsupported codec: ${link.Hash.code}`))\n            return\n        }\n\n        // create a queue for this child - we use a queue instead of recursion\n        // to avoid overflowing the stack\n        const childQueue = new PQueue({\n          concurrency: 1\n        })\n        // if any of the child jobs error, end the read queue with the error\n        childQueue.on('error', error => {\n          queue.end(error)\n        })\n\n        // if the job rejects the 'error' event will be emitted on the child queue\n        void childQueue.add(async () => {\n          options.onProgress?.(new CustomProgressEvent<ExportWalk>('unixfs:exporter:walk:file', {\n            cid: link.Hash\n          }))\n\n          await walkDAG(blockstore, child, queue, blockStart, start, end, options)\n        })\n\n        // wait for this child to complete before moving on to the next\n        await childQueue.onIdle()\n      }\n    }\n  )\n\n  if (streamPosition >= end) {\n    queue.end()\n  }\n}\n\nconst fileContent: UnixfsV1Resolver = (cid, node, unixfs, path, resolve, depth, blockstore) => {\n  async function * yieldFileContent (options: ExporterOptions = {}): UnixfsV1FileContent {\n    const fileSize = unixfs.fileSize()\n\n    if (fileSize === undefined) {\n      throw new Error('File was a directory')\n    }\n\n    const {\n      start,\n      end\n    } = validateOffsetAndLength(fileSize, options.offset, options.length)\n\n    if (end === 0n) {\n      return\n    }\n\n    let read = 0n\n    const wanted = end - start\n    const queue = pushable()\n\n    options.onProgress?.(new CustomProgressEvent<ExportWalk>('unixfs:exporter:walk:file', {\n      cid\n    }))\n\n    void walkDAG(blockstore, node, queue, 0n, start, end, options)\n      .catch(err => {\n        queue.end(err)\n      })\n\n    for await (const buf of queue) {\n      if (buf == null) {\n        continue\n      }\n\n      read += BigInt(buf.byteLength)\n\n      if (read > wanted) {\n        queue.end()\n        throw new OverReadError('Read too many bytes - the file size reported by the UnixFS data in the root node may be incorrect')\n      }\n\n      if (read === wanted) {\n        queue.end()\n      }\n\n      options.onProgress?.(new CustomProgressEvent<ExportProgress>('unixfs:exporter:progress:unixfs:file', {\n        bytesRead: read,\n        totalBytes: wanted,\n        fileSize\n      }))\n\n      yield buf\n    }\n\n    if (read < wanted) {\n      throw new UnderReadError('Traversed entire DAG but did not read enough bytes')\n    }\n  }\n\n  return yieldFileContent\n}\n\nexport default fileContent\n", "import { decode } from '@ipld/dag-pb'\nimport { UnixFS } from 'ipfs-unixfs'\nimport map from 'it-map'\nimport parallel from 'it-parallel'\nimport { pipe } from 'it-pipe'\nimport { CustomProgressEvent } from 'progress-events'\nimport { NotUnixFSError } from '../../../errors.js'\nimport type { ExporterOptions, Resolve, UnixfsV1DirectoryContent, UnixfsV1Resolver, ReadableStorage, ExportWalk } from '../../../index.js'\nimport type { PBNode } from '@ipld/dag-pb'\n\nconst hamtShardedDirectoryContent: UnixfsV1Resolver = (cid, node, unixfs, path, resolve, depth, blockstore) => {\n  function yieldHamtDirectoryContent (options: ExporterOptions = {}): UnixfsV1DirectoryContent {\n    options.onProgress?.(new CustomProgressEvent<ExportWalk>('unixfs:exporter:walk:hamt-sharded-directory', {\n      cid\n    }))\n\n    return listDirectory(node, path, resolve, depth, blockstore, options)\n  }\n\n  return yieldHamtDirectoryContent\n}\n\nasync function * listDirectory (node: PBNode, path: string, resolve: Resolve, depth: number, blockstore: ReadableStorage, options: ExporterOptions): UnixfsV1DirectoryContent {\n  const links = node.Links\n\n  if (node.Data == null) {\n    throw new NotUnixFSError('no data in PBNode')\n  }\n\n  let dir: UnixFS\n  try {\n    dir = UnixFS.unmarshal(node.Data)\n  } catch (err: any) {\n    throw new NotUnixFSError(err.message)\n  }\n\n  if (dir.fanout == null) {\n    throw new NotUnixFSError('missing fanout')\n  }\n\n  const padLength = (dir.fanout - 1n).toString(16).length\n\n  const results = pipe(\n    links,\n    source => map(source, link => {\n      return async () => {\n        const name = link.Name != null ? link.Name.substring(padLength) : null\n\n        if (name != null && name !== '') {\n          const result = await resolve(link.Hash, name, `${path}/${name}`, [], depth + 1, blockstore, options)\n\n          return { entries: result.entry == null ? [] : [result.entry] }\n        } else {\n          // descend into subshard\n          const block = await blockstore.get(link.Hash, options)\n          node = decode(block)\n\n          options.onProgress?.(new CustomProgressEvent<ExportWalk>('unixfs:exporter:walk:hamt-sharded-directory', {\n            cid: link.Hash\n          }))\n\n          return { entries: listDirectory(node, path, resolve, depth, blockstore, options) }\n        }\n      }\n    }),\n    source => parallel(source, {\n      ordered: true,\n      concurrency: options.blockReadConcurrency\n    })\n  )\n\n  for await (const { entries } of results) {\n    yield * entries\n  }\n}\n\nexport default hamtShardedDirectoryContent\n", "import { decode } from '@ipld/dag-pb'\nimport { UnixFS } from 'ipfs-unixfs'\nimport { NotFoundError, NotUnixFSError } from '../../errors.js'\nimport findShardCid from '../../utils/find-cid-in-shard.js'\nimport contentDirectory from './content/directory.js'\nimport contentFile from './content/file.js'\nimport contentHamtShardedDirectory from './content/hamt-sharded-directory.js'\nimport type { Resolver, UnixfsV1Resolver } from '../../index.js'\nimport type { PBNode } from '@ipld/dag-pb'\nimport type { CID } from 'multiformats/cid'\n\nconst findLinkCid = (node: PBNode, name: string): CID | undefined => {\n  const link = node.Links.find(link => link.Name === name)\n\n  return link?.Hash\n}\n\nconst contentExporters: Record<string, UnixfsV1Resolver> = {\n  raw: contentFile,\n  file: contentFile,\n  directory: contentDirectory,\n  'hamt-sharded-directory': contentHamtShardedDirectory,\n  metadata: (cid, node, unixfs, path, resolve, depth, blockstore) => {\n    return () => []\n  },\n  symlink: (cid, node, unixfs, path, resolve, depth, blockstore) => {\n    return () => []\n  }\n}\n\n// @ts-expect-error types are wrong\nconst unixFsResolver: Resolver = async (cid, name, path, toResolve, resolve, depth, blockstore, options) => {\n  const block = await blockstore.get(cid, options)\n  const node = decode(block)\n  let unixfs\n  let next\n\n  if (name == null) {\n    name = cid.toString()\n  }\n\n  if (node.Data == null) {\n    throw new NotUnixFSError('no data in PBNode')\n  }\n\n  try {\n    unixfs = UnixFS.unmarshal(node.Data)\n  } catch (err: any) {\n    // non-UnixFS dag-pb node? It could happen.\n    throw new NotUnixFSError(err.message)\n  }\n\n  if (path == null) {\n    path = name\n  }\n\n  if (toResolve.length > 0) {\n    let linkCid\n\n    if (unixfs?.type === 'hamt-sharded-directory') {\n      // special case - unixfs v1 hamt shards\n      linkCid = await findShardCid(node, toResolve[0], blockstore)\n    } else {\n      linkCid = findLinkCid(node, toResolve[0])\n    }\n\n    if (linkCid == null) {\n      throw new NotFoundError('file does not exist')\n    }\n\n    // remove the path component we have resolved\n    const nextName = toResolve.shift()\n    const nextPath = `${path}/${nextName}`\n\n    next = {\n      cid: linkCid,\n      toResolve,\n      name: nextName ?? '',\n      path: nextPath\n    }\n  }\n\n  const content = contentExporters[unixfs.type](cid, node, unixfs, path, resolve, depth, blockstore)\n\n  if (content == null) {\n    throw new NotFoundError('could not find content exporter')\n  }\n\n  if (unixfs.isDirectory()) {\n    return {\n      entry: {\n        type: 'directory',\n        name,\n        path,\n        cid,\n        content,\n        unixfs,\n        depth,\n        node,\n        size: unixfs.fileSize()\n      },\n      next\n    }\n  }\n\n  return {\n    entry: {\n      type: 'file',\n      name,\n      path,\n      cid,\n      content,\n      unixfs,\n      depth,\n      node,\n      size: unixfs.fileSize()\n    },\n    next\n  }\n}\n\nexport default unixFsResolver\n", "import * as dagCbor from '@ipld/dag-cbor'\nimport * as dagJson from '@ipld/dag-json'\nimport * as dagPb from '@ipld/dag-pb'\nimport * as json from 'multiformats/codecs/json'\nimport * as raw from 'multiformats/codecs/raw'\nimport { identity } from 'multiformats/hashes/identity'\nimport { NoResolverError } from '../errors.js'\nimport dagCborResolver from './dag-cbor.js'\nimport dagJsonResolver from './dag-json.js'\nimport identifyResolver from './identity.js'\nimport jsonResolver from './json.js'\nimport rawResolver from './raw.js'\nimport dagPbResolver from './unixfs-v1/index.js'\nimport type { Resolve, Resolver } from '../index.js'\n\nconst resolvers: Record<number, Resolver> = {\n  [dagPb.code]: dagPbResolver,\n  [raw.code]: rawResolver,\n  [dagCbor.code]: dagCborResolver,\n  [dagJson.code]: dagJsonResolver,\n  [identity.code]: identifyResolver,\n  [json.code]: jsonResolver\n}\n\nconst resolve: Resolve = async (cid, name, path, toResolve, depth, blockstore, options) => {\n  const resolver = resolvers[cid.code]\n\n  if (resolver == null) {\n    throw new NoResolverError(`No resolver for code ${cid.code}`)\n  }\n\n  return resolver(cid, name, path, toResolve, resolve, depth, blockstore, options)\n}\n\nexport default resolve\n"],
  "mappings": "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",
  "names": ["require_murmurHash3js", "__commonJSMin", "exports", "module", "root", "undefined", "library", "_validBytes", "bytes", "i", "_x86Multiply", "m", "n", "_x86Rotl", "_x86Fmix", "h", "_x64Add", "o", "_x64Multiply", "_x64Rotl", "_x64LeftShift", "_x64Xor", "_x64Fmix", "seed", "remainder", "blocks", "h1", "k1", "c1", "c2", "h2", "h3", "h4", "k2", "k3", "k4", "c3", "c4", "require_murmurhash3js_revisited", "__commonJSMin", "exports", "module", "require_sparse_array", "__commonJSMin", "exports", "module", "index", "value", "pos", "needsSort", "last", "iterator", "i", "mapped", "reducer", "initialValue", "acc", "finder", "found", "noCreate", "bytePos", "byte", "bitPos", "previousPopCount", "popCountReduce", "mask", "bytePopCount", "popCount", "targetLength", "data", "elem", "randomIndex", "sortInternal", "bytes", "pendingBitsForResultingByte", "pendingBitsForNewByte", "resultingByte", "newByte", "pending", "usingBits", "masked", "valueOnly", "count", "_v", "v", "a", "b", "require_eventemitter3", "__commonJSMin", "exports", "module", "has", "prefix", "Events", "EE", "fn", "context", "once", "addListener", "emitter", "event", "listener", "evt", "clearEvent", "EventEmitter", "names", "events", "name", "handlers", "l", "ee", "listeners", "a1", "a2", "a3", "a4", "a5", "len", "args", "i", "length", "j", "index_exports", "__export", "BadPathError", "InvalidParametersError", "NoPropError", "NoResolverError", "NotFoundError", "NotUnixFSError", "OverReadError", "UnderReadError", "exporter", "recursive", "walkPath", "isAsyncIterable", "thing", "last", "source", "res", "entry", "src_default", "base32_exports", "__export", "base32", "base32hex", "base32hexpad", "base32hexpadupper", "base32hexupper", "base32pad", "base32padupper", "base32upper", "base32z", "bytes_exports", "__export", "coerce", "empty", "equals", "fromHex", "fromString", "isBinary", "toHex", "toString", "d", "hex", "byte", "hexes", "b", "aa", "bb", "ii", "o", "str", "base", "ALPHABET", "name", "BASE_MAP", "j", "x", "xc", "BASE", "LEADER", "FACTOR", "iFACTOR", "encode", "source", "zeroes", "length", "pbegin", "pend", "size", "b58", "carry", "i", "it1", "it2", "str", "decodeUnsafe", "psz", "b256", "it3", "it4", "vch", "decode", "string", "buffer", "src", "_brrp__multiformats_scope_baseX", "base_x_default", "Encoder", "name", "prefix", "baseEncode", "bytes", "Decoder", "baseDecode", "prefixCodePoint", "text", "decoder", "or", "ComposedDecoder", "decoders", "input", "left", "right", "Codec", "from", "encode", "decode", "baseX", "alphabet", "base_x_default", "coerce", "string", "alphabetIdx", "bitsPerChar", "end", "out", "bits", "buffer", "written", "i", "value", "data", "pad", "mask", "createAlphabetIdx", "rfc4648", "base32", "rfc4648", "base32upper", "base32pad", "base32padupper", "base32hex", "base32hexupper", "base32hexpad", "base32hexpadupper", "base32z", "base36_exports", "__export", "base36", "base36upper", "base36", "baseX", "base36upper", "base58_exports", "__export", "base58btc", "base58flickr", "base58btc", "baseX", "base58flickr", "encode_1", "encode", "MSB", "REST", "MSBALL", "INT", "num", "out", "offset", "oldOffset", "decode", "read", "MSB$1", "REST$1", "buf", "res", "shift", "counter", "b", "l", "N1", "N2", "N3", "N4", "N5", "N6", "N7", "N8", "N9", "length", "value", "varint", "_brrp_varint", "varint_default", "decode", "data", "offset", "varint_default", "encodeTo", "int", "target", "encodingLength", "create", "code", "digest", "size", "sizeOffset", "encodingLength", "digestOffset", "bytes", "encodeTo", "Digest", "decode", "multihash", "coerce", "equals", "a", "b", "data", "format", "link", "base", "bytes", "version", "toStringV0", "baseCache", "base58btc", "toStringV1", "base32", "cache", "baseCache", "cid", "CID", "_CID", "version", "code", "multihash", "bytes", "DAG_PB_CODE", "SHA_256_CODE", "digest", "create", "other", "self", "unknown", "equals", "base", "format", "input", "value", "encodeCID", "cidSymbol", "decode", "remainder", "specs", "prefixSize", "multihashBytes", "coerce", "digestBytes", "Digest", "initialBytes", "offset", "next", "i", "length", "codec", "multihashCode", "digestSize", "size", "multihashSize", "source", "prefix", "parseCIDtoBytes", "decoder", "base58btc", "base32", "base36", "toStringV0", "toStringV1", "codeOffset", "encodingLength", "hashOffset", "encodeTo", "BadPathError", "_BadPathError", "message", "NotFoundError", "_NotFoundError", "NoResolverError", "_NoResolverError", "NotUnixFSError", "_NotUnixFSError", "OverReadError", "_OverReadError", "UnderReadError", "_UnderReadError", "NoPropError", "_NoPropError", "InvalidParametersError", "_InvalidParametersError", "typeofs", "objectTypeNames", "is", "value", "typeOf", "isBuffer", "objectType", "getObjectType", "objectTypeName", "Type", "major", "name", "terminal", "typ", "Token", "type", "value", "encodedLength", "useBuffer", "textDecoder", "textEncoder", "isBuffer", "buf", "asU8A", "toString", "bytes", "start", "end", "utf8Slice", "fromString", "string", "utf8ToBytes", "slice", "useBuffer", "bytes", "start", "end", "isBuffer", "concat", "chunks", "length", "c", "asU8A", "out", "off", "b", "alloc", "size", "compare", "b1", "b2", "isBuffer", "i", "utf8ToBytes", "str", "out", "p", "c", "utf8Slice", "buf", "offset", "end", "res", "firstByte", "codePoint", "bytesPerSequence", "secondByte", "thirdByte", "fourthByte", "tempCodePoint", "decodeCodePointsArray", "MAX_ARGUMENTS_LENGTH", "codePoints", "len", "defaultChunkSize", "Bl", "chunkSize", "bytes", "topChunk", "chunkPos", "alloc", "reset", "byts", "chunk", "slice", "concat", "decodeErrPrefix", "encodeErrPrefix", "uintMinorPrefixBytes", "assertEnoughData", "data", "pos", "need", "uintBoundaries", "readUint8", "data", "offset", "options", "assertEnoughData", "value", "decodeErrPrefix", "readUint16", "readUint32", "readUint64", "hi", "lo", "decodeUint8", "pos", "_minor", "Token", "Type", "decodeUint16", "decodeUint32", "decodeUint64", "encodeUint", "buf", "token", "encodeUintValue", "major", "uint", "nuint", "buint", "set", "tok1", "tok2", "decodeNegint8", "data", "pos", "_minor", "options", "Token", "Type", "readUint8", "decodeNegint16", "readUint16", "decodeNegint32", "readUint32", "neg1b", "pos1b", "decodeNegint64", "int", "readUint64", "value", "decodeErrPrefix", "encodeNegint", "buf", "token", "negint", "unsigned", "encodeUintValue", "uintBoundaries", "tok1", "tok2", "toToken", "data", "pos", "prefix", "length", "assertEnoughData", "buf", "slice", "Token", "Type", "decodeBytesCompact", "minor", "_options", "decodeBytes8", "_minor", "options", "readUint8", "decodeBytes16", "readUint16", "decodeBytes32", "readUint32", "decodeBytes64", "l", "readUint64", "decodeErrPrefix", "tokenBytes", "token", "fromString", "encodeBytes", "bytes", "encodeUintValue", "tok1", "tok2", "compareBytes", "b1", "b2", "compare", "toToken", "data", "pos", "prefix", "length", "options", "totLength", "assertEnoughData", "tok", "Token", "Type", "toString", "slice", "decodeStringCompact", "minor", "decodeString8", "_minor", "readUint8", "decodeString16", "readUint16", "decodeString32", "readUint32", "decodeString64", "l", "readUint64", "decodeErrPrefix", "encodeString", "encodeBytes", "toToken", "_data", "_pos", "prefix", "length", "Token", "Type", "decodeArrayCompact", "data", "pos", "minor", "_options", "decodeArray8", "_minor", "options", "readUint8", "decodeArray16", "readUint16", "decodeArray32", "readUint32", "decodeArray64", "l", "readUint64", "decodeErrPrefix", "decodeArrayIndefinite", "encodeArray", "buf", "token", "encodeUintValue", "encodeUint", "toToken", "_data", "_pos", "prefix", "length", "Token", "Type", "decodeMapCompact", "data", "pos", "minor", "_options", "decodeMap8", "_minor", "options", "readUint8", "decodeMap16", "readUint16", "decodeMap32", "readUint32", "decodeMap64", "l", "readUint64", "decodeErrPrefix", "decodeMapIndefinite", "encodeMap", "buf", "token", "encodeUintValue", "encodeUint", "decodeTagCompact", "_data", "_pos", "minor", "_options", "Token", "Type", "decodeTag8", "data", "pos", "_minor", "options", "readUint8", "decodeTag16", "readUint16", "decodeTag32", "readUint32", "decodeTag64", "readUint64", "encodeTag", "buf", "token", "encodeUintValue", "encodeUint", "MINOR_FALSE", "MINOR_TRUE", "MINOR_NULL", "MINOR_UNDEFINED", "decodeUndefined", "_data", "_pos", "_minor", "options", "decodeErrPrefix", "Token", "Type", "decodeBreak", "createToken", "value", "bytes", "decodeFloat16", "data", "pos", "readFloat16", "decodeFloat32", "readFloat32", "decodeFloat64", "readFloat64", "encodeFloat", "buf", "token", "float", "decoded", "success", "encodeFloat16", "ui8a", "encodeFloat32", "encodeFloat64", "buffer", "dataView", "inp", "valu32", "exponent", "mantissa", "logicalExponent", "half", "exp", "mant", "val", "offset", "encodeUint", "invalidMinor", "data", "pos", "minor", "decodeErrPrefix", "errorer", "msg", "jump", "i", "decodeUint8", "decodeUint16", "decodeUint32", "decodeUint64", "decodeNegint8", "decodeNegint16", "decodeNegint32", "decodeNegint64", "decodeBytesCompact", "decodeBytes8", "decodeBytes16", "decodeBytes32", "decodeBytes64", "decodeStringCompact", "decodeString8", "decodeString16", "decodeString32", "decodeString64", "decodeArrayCompact", "decodeArray8", "decodeArray16", "decodeArray32", "decodeArray64", "decodeArrayIndefinite", "decodeMapCompact", "decodeMap8", "decodeMap16", "decodeMap32", "decodeMap64", "decodeMapIndefinite", "decodeTagCompact", "decodeTag8", "decodeTag16", "decodeTag32", "decodeTag64", "decodeUndefined", "decodeFloat16", "decodeFloat32", "decodeFloat64", "decodeBreak", "quick", "Token", "Type", "makeCborEncoders", "encoders", "Type", "encodeUint", "encodeNegint", "encodeBytes", "encodeString", "encodeArray", "encodeMap", "encodeTag", "encodeFloat", "cborEncoders", "buf", "Bl", "Ref", "_Ref", "obj", "parent", "p", "stack", "encodeErrPrefix", "simpleTokens", "Token", "typeEncoders", "_typ", "_options", "_refStack", "_obj", "options", "refStack", "entries", "i", "e", "objectToTokens", "typ", "isMap", "keys", "length", "key", "sortMapEntries", "is", "customTypeEncoder", "tokens", "typeEncoder", "defaultDecodeOptions", "Tokeniser", "data", "options", "byt", "token", "quick", "decoder", "jump", "decodeErrPrefix", "minor", "DONE", "BREAK", "tokenToArray", "tokeniser", "arr", "value", "tokensToObject", "tokenToMap", "useMaps", "obj", "m", "i", "key", "Type", "tagged", "decodeFirst", "decoded", "decode", "remainder", "CID_CBOR_TAG", "toByteView", "buf", "cidEncoder", "obj", "cid", "CID", "bytes", "Token", "Type", "undefinedEncoder", "numberEncoder", "num", "_encodeOptions", "encodeOptions", "cidDecoder", "_decodeOptions", "decodeOptions", "code", "decode", "data", "toByteView", "_decodeOptions", "JSONEncoder", "buf", "recurs", "Type", "token", "is", "isa", "i", "_buf", "_token", "encodeErrPrefix", "byts", "fromString", "asU8A", "dp", "Tokenizer", "data", "options", "c", "str", "decodeErrPrefix", "i", "startPos", "negative", "float", "swallow", "chars", "ch", "Token", "Type", "numStr", "num", "l", "readu4", "u4", "readUtf8Char", "firstByte", "codePoint", "bytesPerSequence", "secondByte", "thirdByte", "fourthByte", "tempCodePoint", "ch1", "decodeCodePointsArray", "token", "decode", "from", "name", "code", "encode", "Hasher", "input", "result", "create", "digest", "base64_exports", "__export", "base64", "base64pad", "base64url", "base64urlpad", "base64", "rfc4648", "base64pad", "base64url", "base64urlpad", "toByteView", "buf", "DagJsonTokenizer", "Tokenizer", "data", "options", "token", "Type", "keyToken", "valueToken", "Token", "innerKeyToken", "innerValueToken", "i", "bytes", "base64", "decodeOptions", "CID", "code", "decode", "data", "buf", "toByteView", "options", "decodeOptions", "DagJsonTokenizer", "utf8Decoder", "utf8Encoder", "textDecoder", "decodeVarint", "bytes", "offset", "v", "shift", "b", "decodeBytes", "byteLen", "postOffset", "decodeKey", "index", "wire", "decodeLink", "link", "l", "wireType", "fieldNum", "byts", "decodeNode", "links", "linksBeforeData", "data", "node", "textEncoder", "maxInt32", "maxUInt32", "textEncoder", "toByteView", "buf", "code", "decode", "bytes", "buf", "toByteView", "pbn", "decodeNode", "node", "l", "link", "CID", "textEncoder", "textDecoder", "code", "decode", "data", "textDecoder", "code", "identity_exports", "__export", "identity", "code", "name", "encode", "coerce", "digest", "input", "create", "identity", "resolveObjectPath", "object", "block", "cid", "name", "path", "toResolve", "depth", "subObject", "subPath", "prop", "subObjectCid", "CID", "NoPropError", "resolve", "cid", "name", "path", "toResolve", "depth", "blockstore", "options", "block", "object", "decode", "resolveObjectPath", "dag_cbor_default", "resolve", "cid", "name", "path", "toResolve", "depth", "blockstore", "options", "block", "object", "decode", "resolveObjectPath", "dag_json_default", "CustomProgressEvent", "type", "detail", "extractDataFromBlock", "block", "blockStart", "requestedStart", "requestedEnd", "blockLength", "blockEnd", "extract_data_from_block_default", "validateOffsetAndLength", "size", "offset", "length", "fileSize", "start", "end", "InvalidParametersError", "validate_offset_and_length_default", "rawContent", "node", "contentGenerator", "options", "start", "end", "validate_offset_and_length_default", "buf", "extract_data_from_block_default", "CustomProgressEvent", "resolve", "cid", "name", "path", "toResolve", "depth", "blockstore", "NotFoundError", "decode", "identity_default", "resolve", "cid", "name", "path", "toResolve", "depth", "blockstore", "options", "block", "object", "decode", "resolveObjectPath", "json_default", "rawContent", "node", "contentGenerator", "options", "start", "end", "validate_offset_and_length_default", "buf", "extract_data_from_block_default", "CustomProgressEvent", "resolve", "cid", "name", "path", "toResolve", "depth", "blockstore", "NotFoundError", "block", "raw_default", "InvalidTypeError", "_InvalidTypeError", "message", "InvalidUnixFSMessageError", "_InvalidUnixFSMessageError", "allocUnsafe", "size", "N1", "N2", "N3", "N4", "N5", "N6", "N7", "MSB", "REST", "encodingLength", "value", "encodeUint8Array", "buf", "offset", "decodeUint8Array", "buf", "offset", "b", "res", "REST", "MSB", "N4", "N5", "N6", "N7", "f32", "f8b", "writeFloatLE", "val", "buf", "pos", "readFloatLE", "buf", "pos", "f8b", "f32", "f64", "d8b", "writeDoubleLE", "val", "buf", "pos", "readDoubleLE", "buf", "pos", "d8b", "f64", "MAX_SAFE_NUMBER_INTEGER", "MIN_SAFE_NUMBER_INTEGER", "LongBits", "_LongBits", "lo", "hi", "unsigned", "mask", "part0", "part1", "part2", "value", "zero", "negative", "TWO_32", "sign", "length", "string", "len", "c", "i", "read", "buffer", "start", "end", "parts", "chunk", "t", "write", "offset", "c1", "c2", "indexOutOfRange", "reader", "writeLength", "readFixed32End", "buf", "end", "Uint8ArrayReader", "buffer", "value", "readFloatLE", "readDoubleLE", "length", "start", "bytes", "read", "wireType", "bits", "LongBits", "i", "lo", "hi", "decodeUint8Array", "encodingLength", "createReader", "decodeMessage", "buf", "codec", "opts", "reader", "createReader", "base10_exports", "__export", "base10", "base10", "baseX", "base16_exports", "__export", "base16", "base16upper", "base16", "rfc4648", "base16upper", "base2_exports", "__export", "base2", "base2", "rfc4648", "base256emoji_exports", "__export", "base256emoji", "alphabet", "alphabetBytesToChars", "p", "c", "i", "alphabetCharsToBytes", "codePoint", "encode", "data", "decode", "str", "byts", "char", "byt", "base256emoji", "from", "base8_exports", "__export", "base8", "base8", "rfc4648", "identity_exports", "__export", "identity", "identity", "from", "buf", "toString", "str", "fromString", "sha2_browser_exports", "__export", "sha256", "sha512", "sha", "name", "data", "sha256", "from", "sha512", "bases", "identity_exports", "base2_exports", "base8_exports", "base10_exports", "base16_exports", "base32_exports", "base36_exports", "base58_exports", "base64_exports", "base256emoji_exports", "hashes", "sha2_browser_exports", "createCodec", "name", "prefix", "encode", "decode", "string", "buf", "str", "ascii", "i", "allocUnsafe", "BASES", "bases", "bases_default", "fromString", "string", "encoding", "base", "bases_default", "pool", "size", "SIZE", "MAX", "slab", "offset", "allocUnsafe", "buf", "Op", "fn", "len", "val", "noop", "State", "writer", "bufferPool", "pool", "alloc", "size", "allocUnsafe", "Uint8ArrayWriter", "value", "VarintOp", "writeVarint64", "LongBits", "bits", "encodeUint8Array", "encodingLength", "writeByte", "writeFixed32", "writeFloatLE", "writeDoubleLE", "writeBytes", "length", "write", "head", "tail", "buf", "pos", "writeVarint32", "writeBytesBuffer", "writeStringBuffer", "fromString", "createWriter", "encodeMessage", "message", "codec", "w", "createWriter", "CODEC_TYPES", "createCodec", "name", "type", "encode", "decode", "enumeration", "v", "findValue", "val", "encode", "writer", "enumValue", "decode", "reader", "createCodec", "CODEC_TYPES", "message", "encode", "decode", "createCodec", "CODEC_TYPES", "Data", "DataType", "__DataTypeValues", "enumeration", "_codec", "message", "obj", "w", "opts", "value", "UnixTime", "reader", "length", "end", "tag", "encodeMessage", "buf", "decodeMessage", "Metadata", "types", "dirTypes", "DEFAULT_FILE_MODE", "DEFAULT_DIRECTORY_MODE", "MAX_FANOUT", "UnixFS", "_UnixFS", "marshaled", "message", "Data", "InvalidUnixFSMessageError", "data", "options", "type", "blockSizes", "hashType", "fanout", "mtime", "mode", "InvalidTypeError", "size", "index", "sum", "import_murmurhash3js_revisited", "fromNumberTo32BitBuf", "number", "bytes", "i", "murmur332", "from", "input", "mur", "murmur3128", "bytes_exports", "murmur364", "import_sparse_array", "Bucket", "_Bucket", "options", "parent", "posAtParent", "SparseArray", "key", "value", "place", "child", "acc", "children", "map", "reduce", "index", "asyncMap", "asyncReduce", "asyncTransformBucket", "mapNode", "reduceNodes", "result", "hashValue", "fromString", "bucket", "newPlace", "pos", "object", "onlyChild", "exists", "hash", "o", "node", "_", "nodes", "output", "mappedChildren", "concat", "arrays", "length", "acc", "curr", "output", "allocUnsafe", "offset", "arr", "START_MASKS", "STOP_MASKS", "ConsumableBuffer", "value", "bits", "pendingBits", "result", "byte", "availableBits", "taking", "byteBitsToInt", "start", "length", "mask", "maskFor", "wrapHash", "hashFn", "hashing", "value", "InfiniteHash", "bits", "pendingBits", "result", "hash", "available", "took", "availableForUntake", "concat", "hashValue", "buffer", "ConsumableBuffer", "createHAMT", "options", "bucketOptions", "wrapHash", "Bucket", "hashFn", "buf", "murmur3128", "addLinksToHamtBucket", "links", "bucket", "rootBucket", "padLength", "link", "pos", "Bucket", "toPrefix", "position", "toBucketPath", "path", "findShardCid", "node", "name", "blockstore", "context", "options", "NotUnixFSError", "dir", "UnixFS", "err", "createHAMT", "prefix", "bucketPath", "entryPrefix", "entryName", "block", "decode", "find_cid_in_shard_default", "peekable", "iterable", "iterator", "symbol", "queue", "value", "src_default", "isAsyncIterable", "thing", "filter", "source", "fn", "index", "entry", "peekable", "src_default", "value", "done", "res", "func", "isAsyncIterable", "thing", "map", "source", "func", "index", "val", "peekable", "src_default", "value", "done", "res", "fn", "pDefer", "deferred", "resolve", "reject", "CustomEvent", "parallel", "source", "options", "concurrency", "ordered", "emitter", "ops", "slotAvailable", "pDefer", "resultAvailable", "sourceFinished", "sourceErr", "opErred", "task", "op", "result", "err", "valuesAvailable", "yieldOrderedValues", "yieldUnOrderedValues", "i", "FixedFIFO", "hwm", "data", "last", "FIFO", "options", "obj", "val", "prev", "next", "AbortError", "message", "code", "pushable", "options", "_pushable", "buffer", "next", "_pushable", "getNext", "options", "onEnd", "buffer", "FIFO", "pushable", "onNext", "ended", "drain", "pDefer", "waitNext", "resolve", "reject", "next", "err", "bufferNext", "bufferError", "push", "value", "end", "_return", "_throw", "signal", "cancel", "listener", "AbortError", "opts", "AbortError", "message", "code", "name", "raceSignal", "promise", "signal", "opts", "listener", "error", "resolve", "reject", "QueuelessPushable", "pDefer", "nextResult", "err", "result", "value", "options", "raceSignal", "queuelessPushable", "isAsyncIterable", "thing", "addAllToPushable", "sources", "output", "signal", "source", "item", "err", "mergeSources", "controller", "queuelessPushable", "mergeSyncSources", "syncSources", "merge", "src_default", "pipe", "first", "rest", "isDuplex", "duplex", "isIterable", "isAsyncIterable", "source", "fns", "i", "duplexPipelineFn", "rawPipe", "res", "obj", "p", "stream", "pushable", "err", "sourceWrap", "src_default", "directoryContent", "cid", "node", "unixfs", "path", "resolve", "depth", "blockstore", "yieldDirectoryContent", "options", "offset", "length", "links", "CustomProgressEvent", "pipe", "source", "src_default", "link", "linkName", "linkPath", "parallel", "entry", "directory_default", "import_index", "TimeoutError", "message", "AbortError", "getDOMException", "errorMessage", "getAbortedReason", "signal", "reason", "pTimeout", "promise", "options", "milliseconds", "fallback", "customTimers", "timer", "abortHandler", "cancelablePromise", "resolve", "reject", "timeoutError", "error", "lowerBound", "array", "value", "comparator", "first", "count", "step", "it", "PriorityQueue", "#queue", "run", "options", "element", "index", "lowerBound", "a", "b", "id", "priority", "item", "PQueue", "EventEmitter", "#carryoverConcurrencyCount", "#isIntervalIgnored", "#intervalCount", "#intervalCap", "#interval", "#intervalEnd", "#intervalId", "#timeoutId", "#queue", "#queueClass", "#pending", "#concurrency", "#isPaused", "#throwOnTimeout", "#idAssigner", "options", "PriorityQueue", "#doesIntervalAllowAnother", "#doesConcurrentAllowAnother", "#next", "#tryToStartAnother", "#onResumeInterval", "#onInterval", "#initializeIntervalIfNeeded", "#isIntervalPaused", "now", "delay", "canInitializeInterval", "job", "#processQueue", "newConcurrency", "#throwOnAbort", "signal", "_resolve", "reject", "id", "priority", "function_", "resolve", "operation", "pTimeout", "result", "error", "TimeoutError", "functions", "#onEvent", "limit", "event", "filter", "listener", "walkDAG", "blockstore", "node", "queue", "streamPosition", "start", "end", "options", "buf", "extract_data_from_block_default", "NotUnixFSError", "file", "UnixFS", "err", "data", "childOps", "i", "childLink", "childStart", "childEnd", "pipe", "source", "src_default", "op", "block", "parallel", "link", "blockStart", "child", "code", "decode", "childQueue", "PQueue", "error", "CustomProgressEvent", "fileContent", "cid", "unixfs", "path", "resolve", "depth", "yieldFileContent", "fileSize", "validate_offset_and_length_default", "read", "wanted", "pushable", "OverReadError", "UnderReadError", "file_default", "hamtShardedDirectoryContent", "cid", "node", "unixfs", "path", "resolve", "depth", "blockstore", "yieldHamtDirectoryContent", "options", "CustomProgressEvent", "listDirectory", "links", "NotUnixFSError", "dir", "UnixFS", "err", "padLength", "results", "pipe", "source", "src_default", "link", "name", "result", "block", "decode", "parallel", "entries", "hamt_sharded_directory_default", "findLinkCid", "node", "name", "link", "contentExporters", "file_default", "directory_default", "hamt_sharded_directory_default", "cid", "unixfs", "path", "resolve", "depth", "blockstore", "unixFsResolver", "toResolve", "options", "block", "decode", "next", "NotUnixFSError", "UnixFS", "err", "linkCid", "find_cid_in_shard_default", "NotFoundError", "nextName", "nextPath", "content", "unixfs_v1_default", "resolvers", "code", "unixfs_v1_default", "raw_default", "dag_cbor_default", "dag_json_default", "identity", "identity_default", "json_default", "resolve", "cid", "name", "path", "toResolve", "depth", "blockstore", "options", "resolver", "NoResolverError", "resolvers_default", "toPathComponents", "path", "cidAndRest", "CID", "cid", "output", "BadPathError", "walkPath", "blockstore", "options", "toResolve", "name", "entryPath", "startingDepth", "result", "resolvers_default", "NotFoundError", "exporter", "src_default", "recursive", "node", "child", "recurse", "file"]
}
