/**
 * @packageDocumentation
 *
 * The UnixFS Exporter provides a means to read DAGs from a blockstore given a CID.
 *
 * @example
 *
 * ```TypeScript
 * // import a file and export it again
 * import { importer } from 'ipfs-unixfs-importer'
 * import { exporter } from 'ipfs-unixfs-exporter'
 * import { MemoryBlockstore } from 'blockstore-core/memory'
 *
 * // Should contain the blocks we are trying to export
 * const blockstore = new MemoryBlockstore()
 * const files = []
 *
 * for await (const file of importer([{
 *   path: '/foo/bar.txt',
 *   content: new Uint8Array([0, 1, 2, 3])
 * }], blockstore)) {
 *   files.push(file)
 * }
 *
 * console.info(files[0].cid) // Qmbaz
 *
 * const entry = await exporter(files[0].cid, blockstore)
 *
 * if (entry.type !== 'file') {
 *   throw new Error('Unexpected entry type')
 * }
 *
 * console.info(entry.cid) // Qmqux
 * console.info(entry.path) // Qmbaz/foo/bar.txt
 * console.info(entry.name) // bar.txt
 * console.info(entry.unixfs.fileSize()) // 4
 *
 * // stream content from unixfs node
 * const size = entry.unixfs.fileSize()
 * const bytes = new Uint8Array(Number(size))
 * let offset = 0
 *
 * for await (const buf of entry.content()) {
 *   bytes.set(buf, offset)
 *   offset += buf.byteLength
 * }
 *
 * console.info(bytes) // 0, 1, 2, 3
 * ```
 */
import last from 'it-last';
import { CID } from 'multiformats/cid';
import { BadPathError, NotFoundError } from './errors.js';
import resolve from './resolvers/index.js';
export * from './errors.js';
const toPathComponents = (path = '') => {
    // split on / unless escaped with \
    return (path
        .trim()
        .match(/([^\\^/]|\\\/)+/g) ?? [])
        .filter(Boolean);
};
const cidAndRest = (path) => {
    if (path instanceof Uint8Array) {
        return {
            cid: CID.decode(path),
            toResolve: []
        };
    }
    const cid = CID.asCID(path);
    if (cid != null) {
        return {
            cid,
            toResolve: []
        };
    }
    if (typeof path === 'string') {
        if (path.indexOf('/ipfs/') === 0) {
            path = path.substring(6);
        }
        const output = toPathComponents(path);
        return {
            cid: CID.parse(output[0]),
            toResolve: output.slice(1)
        };
    }
    throw new BadPathError(`Unknown path type ${path}`);
};
/**
 * Returns an async iterator that yields entries for all segments in a path
 *
 * @example
 *
 * ```TypeScript
 * import { walkPath } from 'ipfs-unixfs-exporter'
 *
 * const entries = []
 *
 * for await (const entry of walkPath('Qmfoo/foo/bar/baz.txt', blockstore)) {
 *   entries.push(entry)
 * }
 *
 * // entries contains 4x `entry` objects
 * ```
 */
export async function* walkPath(path, blockstore, options = {}) {
    let { cid, toResolve } = cidAndRest(path);
    let name = cid.toString();
    let entryPath = name;
    const startingDepth = toResolve.length;
    while (true) {
        const result = await resolve(cid, name, entryPath, toResolve, startingDepth, blockstore, options);
        if (result.entry == null && result.next == null) {
            throw new NotFoundError(`Could not resolve ${path}`);
        }
        if (result.entry != null) {
            yield result.entry;
        }
        if (result.next == null) {
            return;
        }
        // resolve further parts
        toResolve = result.next.toResolve;
        cid = result.next.cid;
        name = result.next.name;
        entryPath = result.next.path;
    }
}
/**
 * Uses the given blockstore instance to fetch an IPFS node by a CID or path.
 *
 * Returns a {@link Promise} which resolves to a {@link UnixFSEntry}.
 *
 * @example
 *
 * ```typescript
 * import { exporter } from 'ipfs-unixfs-exporter'
 * import { CID } from 'multiformats/cid'
 *
 * const cid = CID.parse('QmFoo')
 *
 * const entry = await exporter(cid, blockstore, {
 *   signal: AbortSignal.timeout(50000)
 * })
 *
 * if (entry.type === 'file') {
 *   for await (const chunk of entry.content()) {
 *     // chunk is a Uint8Array
 *   }
 * }
 * ```
 */
export async function exporter(path, blockstore, options = {}) {
    const result = await last(walkPath(path, blockstore, options));
    if (result == null) {
        throw new NotFoundError(`Could not resolve ${path}`);
    }
    return result;
}
/**
 * Returns an async iterator that yields all entries beneath a given CID or IPFS
 * path, as well as the containing directory.
 *
 * @example
 *
 * ```typescript
 * import { recursive } from 'ipfs-unixfs-exporter'
 *
 * const entries = []
 *
 * for await (const child of recursive('Qmfoo/foo/bar', blockstore)) {
 *   entries.push(entry)
 * }
 *
 * // entries contains all children of the `Qmfoo/foo/bar` directory and it's children
 * ```
 */
export async function* recursive(path, blockstore, options = {}) {
    const node = await exporter(path, blockstore, options);
    if (node == null) {
        return;
    }
    yield node;
    if (node.type === 'directory') {
        for await (const child of recurse(node, options)) {
            yield child;
        }
    }
    async function* recurse(node, options) {
        for await (const file of node.content(options)) {
            yield file;
            if (file instanceof Uint8Array) {
                continue;
            }
            if (file.type === 'directory') {
                yield* recurse(file, options);
            }
        }
    }
}
//# sourceMappingURL=index.js.map