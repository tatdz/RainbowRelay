import { NotFoundError } from '@libp2p/interface';
import { marshalIPNSRecord, multihashFromIPNSRoutingKey, unmarshalIPNSRecord } from 'ipns';
import first from 'it-first';
import map from 'it-map';
import { CID } from 'multiformats/cid';
import { equals as uint8ArrayEquals } from 'uint8arrays/equals';
import { fromString as uint8ArrayFromString } from 'uint8arrays/from-string';
const IPNS_PREFIX = uint8ArrayFromString('/ipns/');
function isIPNSKey(key) {
    return uint8ArrayEquals(key.subarray(0, IPNS_PREFIX.byteLength), IPNS_PREFIX);
}
/**
 * Wrapper class to convert [http-routing-v1 content events](https://specs.ipfs.tech/routing/http-routing-v1/#response-body) into returned values
 */
export class DelegatedRoutingV1HttpApiClientContentRouting {
    client;
    constructor(client) {
        this.client = client;
    }
    async *findProviders(cid, options = {}) {
        yield* map(this.client.getProviders(cid, options), (record) => {
            return {
                id: record.ID,
                multiaddrs: record.Addrs ?? []
            };
        });
    }
    async provide() {
        // noop
    }
    async cancelReprovide() {
        // noop
    }
    async put(key, value, options) {
        if (!isIPNSKey(key)) {
            return;
        }
        const digest = multihashFromIPNSRoutingKey(key);
        const cid = CID.createV1(0x72, digest);
        const record = unmarshalIPNSRecord(value);
        await this.client.putIPNS(cid, record, options);
    }
    async get(key, options) {
        if (!isIPNSKey(key)) {
            throw new NotFoundError('Not found');
        }
        const digest = multihashFromIPNSRoutingKey(key);
        const cid = CID.createV1(0x72, digest);
        try {
            const record = await this.client.getIPNS(cid, options);
            return marshalIPNSRecord(record);
        }
        catch (err) {
            // BadResponseError is thrown when the response had no body, which means
            // the record couldn't be found
            if (err.name === 'BadResponseError') {
                throw new NotFoundError('Not found');
            }
            throw err;
        }
    }
}
/**
 * Wrapper class to convert [http-routing-v1](https://specs.ipfs.tech/routing/http-routing-v1/#response-body-0) events into expected libp2p values
 */
export class DelegatedRoutingV1HttpApiClientPeerRouting {
    client;
    constructor(client) {
        this.client = client;
    }
    async findPeer(peerId, options = {}) {
        const peer = await first(this.client.getPeers(peerId, options));
        if (peer != null) {
            return {
                id: peer.ID,
                multiaddrs: peer.Addrs ?? []
            };
        }
        throw new NotFoundError('Not found');
    }
    async *getClosestPeers(key, options = {}) {
        // noop
    }
}
//# sourceMappingURL=routings.js.map