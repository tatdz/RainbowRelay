import { AbstractSession } from '@helia/utils';
import { isPeerId } from '@libp2p/interface';
class BitswapSession extends AbstractSession {
    wantList;
    network;
    libp2p;
    constructor(components, init) {
        super(components, {
            ...init,
            name: 'helia:bitswap:session'
        });
        this.wantList = components.wantList;
        this.network = components.network;
        this.libp2p = components.libp2p;
    }
    async queryProvider(cid, provider, options) {
        this.log('sending WANT-BLOCK for %c to %p', cid, provider);
        const result = await this.wantList.wantSessionBlock(cid, provider, options);
        this.log('%p %s %c', provider, result.has ? 'has' : 'does not have', cid);
        if (result.has && result.block != null) {
            return result.block;
        }
        throw new Error('Provider did not have block');
    }
    async *findNewProviders(cid, options = {}) {
        for await (const provider of this.network.findProviders(cid, options)) {
            yield provider.id;
        }
    }
    toEvictionKey(provider) {
        return provider.toMultihash().bytes;
    }
    equals(providerA, providerB) {
        return providerA.equals(providerB);
    }
    async convertToProvider(provider, options) {
        if (isPeerId(provider)) {
            return provider;
        }
        const connection = await this.libp2p.dial(provider, options);
        return connection.remotePeer;
    }
}
export function createBitswapSession(components, init) {
    return new BitswapSession(components, init);
}
//# sourceMappingURL=session.js.map