{
  "version": 3,
  "sources": ["../../../node_modules/murmurhash3js-revisited/lib/murmurHash3js.js", "../../../node_modules/murmurhash3js-revisited/index.js", "../../../node_modules/sparse-array/index.js", "../../../node_modules/eventemitter3/index.js", "../src/index.ts", "../../../node_modules/it-first/src/index.ts", "../../../node_modules/it-batch/src/index.ts", "../../../node_modules/it-parallel-batch/src/index.ts", "../../../node_modules/uint8arrays/src/alloc.ts", "../../../node_modules/uint8arrays/src/concat.ts", "../../../node_modules/uint8arrays/src/equals.ts", "../../../node_modules/uint8arraylist/src/index.ts", "../../../node_modules/ipfs-unixfs-importer/src/chunker/fixed-size.ts", "../../../node_modules/@ipld/dag-pb/src/index.js", "../../../node_modules/multiformats/src/bases/base32.ts", "../../../node_modules/multiformats/src/bytes.ts", "../../../node_modules/multiformats/src/vendor/base-x.js", "../../../node_modules/multiformats/src/bases/base.ts", "../../../node_modules/multiformats/src/bases/base36.ts", "../../../node_modules/multiformats/src/bases/base58.ts", "../../../node_modules/multiformats/src/vendor/varint.js", "../../../node_modules/multiformats/src/varint.ts", "../../../node_modules/multiformats/src/hashes/digest.ts", "../../../node_modules/multiformats/src/cid.ts", "../../../node_modules/@ipld/dag-pb/src/pb-decode.js", "../../../node_modules/@ipld/dag-pb/src/pb-encode.js", "../../../node_modules/@ipld/dag-pb/src/util.js", "../../../node_modules/ipfs-unixfs/src/errors.ts", "../../../node_modules/uint8-varint/src/index.ts", "../../../node_modules/protons-runtime/src/utils/float.ts", "../../../node_modules/protons-runtime/src/utils/longbits.ts", "../../../node_modules/protons-runtime/src/utils/utf8.ts", "../../../node_modules/protons-runtime/src/utils/reader.ts", "../../../node_modules/protons-runtime/src/decode.ts", "../../../node_modules/multiformats/src/bases/base10.ts", "../../../node_modules/multiformats/src/bases/base16.ts", "../../../node_modules/multiformats/src/bases/base2.ts", "../../../node_modules/multiformats/src/bases/base256emoji.ts", "../../../node_modules/multiformats/src/bases/base64.ts", "../../../node_modules/multiformats/src/bases/base8.ts", "../../../node_modules/multiformats/src/bases/identity.ts", "../../../node_modules/multiformats/src/codecs/json.ts", "../../../node_modules/multiformats/src/codecs/raw.ts", "../../../node_modules/multiformats/src/hashes/identity.ts", "../../../node_modules/multiformats/src/hashes/sha2-browser.ts", "../../../node_modules/multiformats/src/hashes/hasher.ts", "../../../node_modules/multiformats/src/basics.ts", "../../../node_modules/uint8arrays/src/util/bases.ts", "../../../node_modules/uint8arrays/src/from-string.ts", "../../../node_modules/protons-runtime/src/utils/pool.ts", "../../../node_modules/protons-runtime/src/utils/writer.ts", "../../../node_modules/protons-runtime/src/encode.ts", "../../../node_modules/protons-runtime/src/codec.ts", "../../../node_modules/protons-runtime/src/codecs/enum.ts", "../../../node_modules/protons-runtime/src/codecs/message.ts", "../../../node_modules/ipfs-unixfs/src/unixfs.ts", "../../../node_modules/ipfs-unixfs/src/index.ts", "../../../node_modules/progress-events/src/index.ts", "../../../node_modules/ipfs-unixfs-importer/src/utils/persist.ts", "../../../node_modules/ipfs-unixfs-importer/src/dag-builder/buffer-importer.ts", "../../../node_modules/ipfs-unixfs-importer/src/errors.ts", "../../../node_modules/ipfs-unixfs-importer/src/dag-builder/dir.ts", "../../../node_modules/ipfs-unixfs-importer/src/dag-builder/file.ts", "../../../node_modules/ipfs-unixfs-importer/src/dag-builder/index.ts", "../../../node_modules/ipfs-unixfs-importer/src/dag-builder/validate-chunks.ts", "../../../node_modules/ipfs-unixfs-importer/src/layout/balanced.ts", "../../../node_modules/it-all/src/index.ts", "../../../node_modules/ipfs-unixfs-importer/src/dir.ts", "../../../node_modules/ipfs-unixfs-importer/src/dir-flat.ts", "../../../node_modules/@multiformats/murmur3/src/index.js", "../../../node_modules/hamt-sharding/src/bucket.ts", "../../../node_modules/hamt-sharding/src/consumable-buffer.ts", "../../../node_modules/hamt-sharding/src/consumable-hash.ts", "../../../node_modules/hamt-sharding/src/index.ts", "../../../node_modules/ipfs-unixfs-importer/src/dir-sharded.ts", "../../../node_modules/ipfs-unixfs-importer/src/flat-to-shard.ts", "../../../node_modules/ipfs-unixfs-importer/src/utils/to-path-components.ts", "../../../node_modules/ipfs-unixfs-importer/src/tree-builder.ts", "../../../node_modules/ipfs-unixfs-importer/src/index.ts", "../../../node_modules/it-last/src/index.ts", "../src/errors.ts", "../src/commands/add.ts", "../../../node_modules/is-plain-obj/index.js", "../../../node_modules/@libp2p/utils/src/merge-options.ts", "../../../node_modules/ipfs-unixfs-exporter/src/errors.ts", "../../../node_modules/cborg/lib/is.js", "../../../node_modules/cborg/lib/token.js", "../../../node_modules/cborg/lib/byte-utils.js", "../../../node_modules/cborg/lib/bl.js", "../../../node_modules/cborg/lib/common.js", "../../../node_modules/cborg/lib/0uint.js", "../../../node_modules/cborg/lib/1negint.js", "../../../node_modules/cborg/lib/2bytes.js", "../../../node_modules/cborg/lib/3string.js", "../../../node_modules/cborg/lib/4array.js", "../../../node_modules/cborg/lib/5map.js", "../../../node_modules/cborg/lib/6tag.js", "../../../node_modules/cborg/lib/7float.js", "../../../node_modules/cborg/lib/jump.js", "../../../node_modules/cborg/lib/encode.js", "../../../node_modules/cborg/lib/decode.js", "../../../node_modules/@ipld/dag-cbor/src/index.js", "../../../node_modules/cborg/lib/json/encode.js", "../../../node_modules/cborg/lib/json/decode.js", "../../../node_modules/@ipld/dag-json/src/index.js", "../../../node_modules/ipfs-unixfs-exporter/src/utils/resolve-object-path.ts", "../../../node_modules/ipfs-unixfs-exporter/src/resolvers/dag-cbor.ts", "../../../node_modules/ipfs-unixfs-exporter/src/resolvers/dag-json.ts", "../../../node_modules/ipfs-unixfs-exporter/src/utils/extract-data-from-block.ts", "../../../node_modules/ipfs-unixfs-exporter/src/utils/validate-offset-and-length.ts", "../../../node_modules/ipfs-unixfs-exporter/src/resolvers/identity.ts", "../../../node_modules/ipfs-unixfs-exporter/src/resolvers/json.ts", "../../../node_modules/ipfs-unixfs-exporter/src/resolvers/raw.ts", "../../../node_modules/ipfs-unixfs-exporter/src/utils/find-cid-in-shard.ts", "../../../node_modules/it-peekable/src/index.ts", "../../../node_modules/it-filter/src/index.ts", "../../../node_modules/it-map/src/index.ts", "../../../node_modules/p-defer/index.js", "../../../node_modules/it-parallel/src/index.ts", "../../../node_modules/it-pushable/src/fifo.ts", "../../../node_modules/it-pushable/src/index.ts", "../../../node_modules/race-signal/src/index.ts", "../../../node_modules/it-queueless-pushable/src/index.ts", "../../../node_modules/it-merge/src/index.ts", "../../../node_modules/it-pipe/src/index.ts", "../../../node_modules/ipfs-unixfs-exporter/src/resolvers/unixfs-v1/content/directory.ts", "../../../node_modules/eventemitter3/index.mjs", "../../../node_modules/p-timeout/index.js", "../../../node_modules/p-queue/dist/lower-bound.js", "../../../node_modules/p-queue/dist/priority-queue.js", "../../../node_modules/p-queue/dist/index.js", "../../../node_modules/ipfs-unixfs-exporter/src/resolvers/unixfs-v1/content/file.ts", "../../../node_modules/ipfs-unixfs-exporter/src/resolvers/unixfs-v1/content/hamt-sharded-directory.ts", "../../../node_modules/ipfs-unixfs-exporter/src/resolvers/unixfs-v1/index.ts", "../../../node_modules/ipfs-unixfs-exporter/src/resolvers/index.ts", "../../../node_modules/ipfs-unixfs-exporter/src/index.ts", "../../../node_modules/weald/node_modules/ms/dist/index.mjs", "../../../node_modules/weald/src/common.ts", "../../../node_modules/weald/src/browser.ts", "../../../node_modules/weald/src/index.ts", "../../../node_modules/@libp2p/logger/src/index.ts", "../src/commands/utils/add-link.ts", "../src/commands/utils/consumable-hash.ts", "../src/commands/utils/hamt-constants.ts", "../src/commands/utils/hamt-utils.ts", "../src/commands/utils/persist.ts", "../src/commands/utils/dir-sharded.ts", "../src/commands/utils/is-over-shard-threshold.ts", "../src/commands/utils/cid-to-directory.ts", "../src/commands/utils/cid-to-pblink.ts", "../src/commands/utils/resolve.ts", "../src/commands/cat.ts", "../src/commands/chmod.ts", "../src/commands/cp.ts", "../src/commands/ls.ts", "../src/commands/mkdir.ts", "../src/commands/utils/remove-link.ts", "../src/commands/rm.ts", "../../../node_modules/@sindresorhus/fnv1a/index.js", "../../../node_modules/@libp2p/utils/src/filters/hashes.ts", "../../../node_modules/@libp2p/utils/src/filters/fingerprint.ts", "../../../node_modules/@libp2p/utils/src/filters/utils.ts", "../../../node_modules/@libp2p/utils/src/filters/bucket.ts", "../../../node_modules/@libp2p/utils/src/filters/cuckoo-filter.ts", "../../../node_modules/@libp2p/utils/src/filters/scalable-cuckoo-filter.ts", "../src/commands/stat.ts", "../src/commands/touch.ts", "../src/unixfs.ts", "../src/utils/glob-source.browser.ts", "../src/utils/url-source.ts"],
  "sourcesContent": ["/* jshint -W086: true */\n// +----------------------------------------------------------------------+\n// | murmurHash3js.js v3.0.1 // https://github.com/pid/murmurHash3js\n// | A javascript implementation of MurmurHash3's x86 hashing algorithms. |\n// |----------------------------------------------------------------------|\n// | Copyright (c) 2012-2015 Karan Lyons                                       |\n// | https://github.com/karanlyons/murmurHash3.js/blob/c1778f75792abef7bdd74bc85d2d4e1a3d25cfe9/murmurHash3.js |\n// | Freely distributable under the MIT license.                          |\n// +----------------------------------------------------------------------+\n\n;(function (root, undefined) {\n    'use strict';\n\n    // Create a local object that'll be exported or referenced globally.\n    var library = {\n        'version': '3.0.0',\n        'x86': {},\n        'x64': {},\n        'inputValidation': true\n    };\n\n    // PRIVATE FUNCTIONS\n    // -----------------\n\n    function _validBytes(bytes) {\n        // check the input is an array or a typed array\n        if (!Array.isArray(bytes) && !ArrayBuffer.isView(bytes)) {\n            return false;\n        }\n\n        // check all bytes are actually bytes\n        for (var i = 0; i < bytes.length; i++) {\n            if (!Number.isInteger(bytes[i]) || bytes[i] < 0 || bytes[i] > 255) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    function _x86Multiply(m, n) {\n        //\n        // Given two 32bit ints, returns the two multiplied together as a\n        // 32bit int.\n        //\n\n        return ((m & 0xffff) * n) + ((((m >>> 16) * n) & 0xffff) << 16);\n    }\n\n    function _x86Rotl(m, n) {\n        //\n        // Given a 32bit int and an int representing a number of bit positions,\n        // returns the 32bit int rotated left by that number of positions.\n        //\n\n        return (m << n) | (m >>> (32 - n));\n    }\n\n    function _x86Fmix(h) {\n        //\n        // Given a block, returns murmurHash3's final x86 mix of that block.\n        //\n\n        h ^= h >>> 16;\n        h = _x86Multiply(h, 0x85ebca6b);\n        h ^= h >>> 13;\n        h = _x86Multiply(h, 0xc2b2ae35);\n        h ^= h >>> 16;\n\n        return h;\n    }\n\n    function _x64Add(m, n) {\n        //\n        // Given two 64bit ints (as an array of two 32bit ints) returns the two\n        // added together as a 64bit int (as an array of two 32bit ints).\n        //\n\n        m = [m[0] >>> 16, m[0] & 0xffff, m[1] >>> 16, m[1] & 0xffff];\n        n = [n[0] >>> 16, n[0] & 0xffff, n[1] >>> 16, n[1] & 0xffff];\n        var o = [0, 0, 0, 0];\n\n        o[3] += m[3] + n[3];\n        o[2] += o[3] >>> 16;\n        o[3] &= 0xffff;\n\n        o[2] += m[2] + n[2];\n        o[1] += o[2] >>> 16;\n        o[2] &= 0xffff;\n\n        o[1] += m[1] + n[1];\n        o[0] += o[1] >>> 16;\n        o[1] &= 0xffff;\n\n        o[0] += m[0] + n[0];\n        o[0] &= 0xffff;\n\n        return [(o[0] << 16) | o[1], (o[2] << 16) | o[3]];\n    }\n\n    function _x64Multiply(m, n) {\n        //\n        // Given two 64bit ints (as an array of two 32bit ints) returns the two\n        // multiplied together as a 64bit int (as an array of two 32bit ints).\n        //\n\n        m = [m[0] >>> 16, m[0] & 0xffff, m[1] >>> 16, m[1] & 0xffff];\n        n = [n[0] >>> 16, n[0] & 0xffff, n[1] >>> 16, n[1] & 0xffff];\n        var o = [0, 0, 0, 0];\n\n        o[3] += m[3] * n[3];\n        o[2] += o[3] >>> 16;\n        o[3] &= 0xffff;\n\n        o[2] += m[2] * n[3];\n        o[1] += o[2] >>> 16;\n        o[2] &= 0xffff;\n\n        o[2] += m[3] * n[2];\n        o[1] += o[2] >>> 16;\n        o[2] &= 0xffff;\n\n        o[1] += m[1] * n[3];\n        o[0] += o[1] >>> 16;\n        o[1] &= 0xffff;\n\n        o[1] += m[2] * n[2];\n        o[0] += o[1] >>> 16;\n        o[1] &= 0xffff;\n\n        o[1] += m[3] * n[1];\n        o[0] += o[1] >>> 16;\n        o[1] &= 0xffff;\n\n        o[0] += (m[0] * n[3]) + (m[1] * n[2]) + (m[2] * n[1]) + (m[3] * n[0]);\n        o[0] &= 0xffff;\n\n        return [(o[0] << 16) | o[1], (o[2] << 16) | o[3]];\n    }\n\n    function _x64Rotl(m, n) {\n        //\n        // Given a 64bit int (as an array of two 32bit ints) and an int\n        // representing a number of bit positions, returns the 64bit int (as an\n        // array of two 32bit ints) rotated left by that number of positions.\n        //\n\n        n %= 64;\n\n        if (n === 32) {\n            return [m[1], m[0]];\n        } else if (n < 32) {\n            return [(m[0] << n) | (m[1] >>> (32 - n)), (m[1] << n) | (m[0] >>> (32 - n))];\n        } else {\n            n -= 32;\n            return [(m[1] << n) | (m[0] >>> (32 - n)), (m[0] << n) | (m[1] >>> (32 - n))];\n        }\n    }\n\n    function _x64LeftShift(m, n) {\n        //\n        // Given a 64bit int (as an array of two 32bit ints) and an int\n        // representing a number of bit positions, returns the 64bit int (as an\n        // array of two 32bit ints) shifted left by that number of positions.\n        //\n\n        n %= 64;\n\n        if (n === 0) {\n            return m;\n        } else if (n < 32) {\n            return [(m[0] << n) | (m[1] >>> (32 - n)), m[1] << n];\n        } else {\n            return [m[1] << (n - 32), 0];\n        }\n    }\n\n    function _x64Xor(m, n) {\n        //\n        // Given two 64bit ints (as an array of two 32bit ints) returns the two\n        // xored together as a 64bit int (as an array of two 32bit ints).\n        //\n\n        return [m[0] ^ n[0], m[1] ^ n[1]];\n    }\n\n    function _x64Fmix(h) {\n        //\n        // Given a block, returns murmurHash3's final x64 mix of that block.\n        // (`[0, h[0] >>> 1]` is a 33 bit unsigned right shift. This is the\n        // only place where we need to right shift 64bit ints.)\n        //\n\n        h = _x64Xor(h, [0, h[0] >>> 1]);\n        h = _x64Multiply(h, [0xff51afd7, 0xed558ccd]);\n        h = _x64Xor(h, [0, h[0] >>> 1]);\n        h = _x64Multiply(h, [0xc4ceb9fe, 0x1a85ec53]);\n        h = _x64Xor(h, [0, h[0] >>> 1]);\n\n        return h;\n    }\n\n    // PUBLIC FUNCTIONS\n    // ----------------\n\n    library.x86.hash32 = function (bytes, seed) {\n        //\n        // Given a string and an optional seed as an int, returns a 32 bit hash\n        // using the x86 flavor of MurmurHash3, as an unsigned int.\n        //\n        if (library.inputValidation && !_validBytes(bytes)) {\n            return undefined;\n        }\n        seed = seed || 0;\n\n        var remainder = bytes.length % 4;\n        var blocks = bytes.length - remainder;\n\n        var h1 = seed;\n\n        var k1 = 0;\n\n        var c1 = 0xcc9e2d51;\n        var c2 = 0x1b873593;\n\n        for (var i = 0; i < blocks; i = i + 4) {\n            k1 = (bytes[i]) | (bytes[i + 1] << 8) | (bytes[i + 2] << 16) | (bytes[i + 3] << 24);\n\n            k1 = _x86Multiply(k1, c1);\n            k1 = _x86Rotl(k1, 15);\n            k1 = _x86Multiply(k1, c2);\n\n            h1 ^= k1;\n            h1 = _x86Rotl(h1, 13);\n            h1 = _x86Multiply(h1, 5) + 0xe6546b64;\n        }\n\n        k1 = 0;\n\n        switch (remainder) {\n            case 3:\n                k1 ^= bytes[i + 2] << 16;\n\n            case 2:\n                k1 ^= bytes[i + 1] << 8;\n\n            case 1:\n                k1 ^= bytes[i];\n                k1 = _x86Multiply(k1, c1);\n                k1 = _x86Rotl(k1, 15);\n                k1 = _x86Multiply(k1, c2);\n                h1 ^= k1;\n        }\n\n        h1 ^= bytes.length;\n        h1 = _x86Fmix(h1);\n\n        return h1 >>> 0;\n    };\n\n    library.x86.hash128 = function (bytes, seed) {\n        //\n        // Given a string and an optional seed as an int, returns a 128 bit\n        // hash using the x86 flavor of MurmurHash3, as an unsigned hex.\n        //\n        if (library.inputValidation && !_validBytes(bytes)) {\n            return undefined;\n        }\n\n        seed = seed || 0;\n        var remainder = bytes.length % 16;\n        var blocks = bytes.length - remainder;\n\n        var h1 = seed;\n        var h2 = seed;\n        var h3 = seed;\n        var h4 = seed;\n\n        var k1 = 0;\n        var k2 = 0;\n        var k3 = 0;\n        var k4 = 0;\n\n        var c1 = 0x239b961b;\n        var c2 = 0xab0e9789;\n        var c3 = 0x38b34ae5;\n        var c4 = 0xa1e38b93;\n\n        for (var i = 0; i < blocks; i = i + 16) {\n            k1 = (bytes[i]) | (bytes[i + 1] << 8) | (bytes[i + 2] << 16) | (bytes[i + 3] << 24);\n            k2 = (bytes[i + 4]) | (bytes[i + 5] << 8) | (bytes[i + 6] << 16) | (bytes[i + 7] << 24);\n            k3 = (bytes[i + 8]) | (bytes[i + 9] << 8) | (bytes[i + 10] << 16) | (bytes[i + 11] << 24);\n            k4 = (bytes[i + 12]) | (bytes[i + 13] << 8) | (bytes[i + 14] << 16) | (bytes[i + 15] << 24);\n\n            k1 = _x86Multiply(k1, c1);\n            k1 = _x86Rotl(k1, 15);\n            k1 = _x86Multiply(k1, c2);\n            h1 ^= k1;\n\n            h1 = _x86Rotl(h1, 19);\n            h1 += h2;\n            h1 = _x86Multiply(h1, 5) + 0x561ccd1b;\n\n            k2 = _x86Multiply(k2, c2);\n            k2 = _x86Rotl(k2, 16);\n            k2 = _x86Multiply(k2, c3);\n            h2 ^= k2;\n\n            h2 = _x86Rotl(h2, 17);\n            h2 += h3;\n            h2 = _x86Multiply(h2, 5) + 0x0bcaa747;\n\n            k3 = _x86Multiply(k3, c3);\n            k3 = _x86Rotl(k3, 17);\n            k3 = _x86Multiply(k3, c4);\n            h3 ^= k3;\n\n            h3 = _x86Rotl(h3, 15);\n            h3 += h4;\n            h3 = _x86Multiply(h3, 5) + 0x96cd1c35;\n\n            k4 = _x86Multiply(k4, c4);\n            k4 = _x86Rotl(k4, 18);\n            k4 = _x86Multiply(k4, c1);\n            h4 ^= k4;\n\n            h4 = _x86Rotl(h4, 13);\n            h4 += h1;\n            h4 = _x86Multiply(h4, 5) + 0x32ac3b17;\n        }\n\n        k1 = 0;\n        k2 = 0;\n        k3 = 0;\n        k4 = 0;\n\n        switch (remainder) {\n            case 15:\n                k4 ^= bytes[i + 14] << 16;\n\n            case 14:\n                k4 ^= bytes[i + 13] << 8;\n\n            case 13:\n                k4 ^= bytes[i + 12];\n                k4 = _x86Multiply(k4, c4);\n                k4 = _x86Rotl(k4, 18);\n                k4 = _x86Multiply(k4, c1);\n                h4 ^= k4;\n\n            case 12:\n                k3 ^= bytes[i + 11] << 24;\n\n            case 11:\n                k3 ^= bytes[i + 10] << 16;\n\n            case 10:\n                k3 ^= bytes[i + 9] << 8;\n\n            case 9:\n                k3 ^= bytes[i + 8];\n                k3 = _x86Multiply(k3, c3);\n                k3 = _x86Rotl(k3, 17);\n                k3 = _x86Multiply(k3, c4);\n                h3 ^= k3;\n\n            case 8:\n                k2 ^= bytes[i + 7] << 24;\n\n            case 7:\n                k2 ^= bytes[i + 6] << 16;\n\n            case 6:\n                k2 ^= bytes[i + 5] << 8;\n\n            case 5:\n                k2 ^= bytes[i + 4];\n                k2 = _x86Multiply(k2, c2);\n                k2 = _x86Rotl(k2, 16);\n                k2 = _x86Multiply(k2, c3);\n                h2 ^= k2;\n\n            case 4:\n                k1 ^= bytes[i + 3] << 24;\n\n            case 3:\n                k1 ^= bytes[i + 2] << 16;\n\n            case 2:\n                k1 ^= bytes[i + 1] << 8;\n\n            case 1:\n                k1 ^= bytes[i];\n                k1 = _x86Multiply(k1, c1);\n                k1 = _x86Rotl(k1, 15);\n                k1 = _x86Multiply(k1, c2);\n                h1 ^= k1;\n        }\n\n        h1 ^= bytes.length;\n        h2 ^= bytes.length;\n        h3 ^= bytes.length;\n        h4 ^= bytes.length;\n\n        h1 += h2;\n        h1 += h3;\n        h1 += h4;\n        h2 += h1;\n        h3 += h1;\n        h4 += h1;\n\n        h1 = _x86Fmix(h1);\n        h2 = _x86Fmix(h2);\n        h3 = _x86Fmix(h3);\n        h4 = _x86Fmix(h4);\n\n        h1 += h2;\n        h1 += h3;\n        h1 += h4;\n        h2 += h1;\n        h3 += h1;\n        h4 += h1;\n\n        return (\"00000000\" + (h1 >>> 0).toString(16)).slice(-8) + (\"00000000\" + (h2 >>> 0).toString(16)).slice(-8) + (\"00000000\" + (h3 >>> 0).toString(16)).slice(-8) + (\"00000000\" + (h4 >>> 0).toString(16)).slice(-8);\n    };\n\n    library.x64.hash128 = function (bytes, seed) {\n        //\n        // Given a string and an optional seed as an int, returns a 128 bit\n        // hash using the x64 flavor of MurmurHash3, as an unsigned hex.\n        //\n        if (library.inputValidation && !_validBytes(bytes)) {\n            return undefined;\n        }\n        seed = seed || 0;\n\n        var remainder = bytes.length % 16;\n        var blocks = bytes.length - remainder;\n\n        var h1 = [0, seed];\n        var h2 = [0, seed];\n\n        var k1 = [0, 0];\n        var k2 = [0, 0];\n\n        var c1 = [0x87c37b91, 0x114253d5];\n        var c2 = [0x4cf5ad43, 0x2745937f];\n\n        for (var i = 0; i < blocks; i = i + 16) {\n            k1 = [(bytes[i + 4]) | (bytes[i + 5] << 8) | (bytes[i + 6] << 16) | (bytes[i + 7] << 24), (bytes[i]) |\n                (bytes[i + 1] << 8) | (bytes[i + 2] << 16) | (bytes[i + 3] << 24)];\n            k2 = [(bytes[i + 12]) | (bytes[i + 13] << 8) | (bytes[i + 14] << 16) | (bytes[i + 15] << 24), (bytes[i + 8]) |\n                (bytes[i + 9] << 8) | (bytes[i + 10] << 16) | (bytes[i + 11] << 24)];\n\n            k1 = _x64Multiply(k1, c1);\n            k1 = _x64Rotl(k1, 31);\n            k1 = _x64Multiply(k1, c2);\n            h1 = _x64Xor(h1, k1);\n\n            h1 = _x64Rotl(h1, 27);\n            h1 = _x64Add(h1, h2);\n            h1 = _x64Add(_x64Multiply(h1, [0, 5]), [0, 0x52dce729]);\n\n            k2 = _x64Multiply(k2, c2);\n            k2 = _x64Rotl(k2, 33);\n            k2 = _x64Multiply(k2, c1);\n            h2 = _x64Xor(h2, k2);\n\n            h2 = _x64Rotl(h2, 31);\n            h2 = _x64Add(h2, h1);\n            h2 = _x64Add(_x64Multiply(h2, [0, 5]), [0, 0x38495ab5]);\n        }\n\n        k1 = [0, 0];\n        k2 = [0, 0];\n\n        switch (remainder) {\n            case 15:\n                k2 = _x64Xor(k2, _x64LeftShift([0, bytes[i + 14]], 48));\n\n            case 14:\n                k2 = _x64Xor(k2, _x64LeftShift([0, bytes[i + 13]], 40));\n\n            case 13:\n                k2 = _x64Xor(k2, _x64LeftShift([0, bytes[i + 12]], 32));\n\n            case 12:\n                k2 = _x64Xor(k2, _x64LeftShift([0, bytes[i + 11]], 24));\n\n            case 11:\n                k2 = _x64Xor(k2, _x64LeftShift([0, bytes[i + 10]], 16));\n\n            case 10:\n                k2 = _x64Xor(k2, _x64LeftShift([0, bytes[i + 9]], 8));\n\n            case 9:\n                k2 = _x64Xor(k2, [0, bytes[i + 8]]);\n                k2 = _x64Multiply(k2, c2);\n                k2 = _x64Rotl(k2, 33);\n                k2 = _x64Multiply(k2, c1);\n                h2 = _x64Xor(h2, k2);\n\n            case 8:\n                k1 = _x64Xor(k1, _x64LeftShift([0, bytes[i + 7]], 56));\n\n            case 7:\n                k1 = _x64Xor(k1, _x64LeftShift([0, bytes[i + 6]], 48));\n\n            case 6:\n                k1 = _x64Xor(k1, _x64LeftShift([0, bytes[i + 5]], 40));\n\n            case 5:\n                k1 = _x64Xor(k1, _x64LeftShift([0, bytes[i + 4]], 32));\n\n            case 4:\n                k1 = _x64Xor(k1, _x64LeftShift([0, bytes[i + 3]], 24));\n\n            case 3:\n                k1 = _x64Xor(k1, _x64LeftShift([0, bytes[i + 2]], 16));\n\n            case 2:\n                k1 = _x64Xor(k1, _x64LeftShift([0, bytes[i + 1]], 8));\n\n            case 1:\n                k1 = _x64Xor(k1, [0, bytes[i]]);\n                k1 = _x64Multiply(k1, c1);\n                k1 = _x64Rotl(k1, 31);\n                k1 = _x64Multiply(k1, c2);\n                h1 = _x64Xor(h1, k1);\n        }\n\n        h1 = _x64Xor(h1, [0, bytes.length]);\n        h2 = _x64Xor(h2, [0, bytes.length]);\n\n        h1 = _x64Add(h1, h2);\n        h2 = _x64Add(h2, h1);\n\n        h1 = _x64Fmix(h1);\n        h2 = _x64Fmix(h2);\n\n        h1 = _x64Add(h1, h2);\n        h2 = _x64Add(h2, h1);\n\n        return (\"00000000\" + (h1[0] >>> 0).toString(16)).slice(-8) + (\"00000000\" + (h1[1] >>> 0).toString(16)).slice(-8) + (\"00000000\" + (h2[0] >>> 0).toString(16)).slice(-8) + (\"00000000\" + (h2[1] >>> 0).toString(16)).slice(-8);\n    };\n\n    // INITIALIZATION\n    // --------------\n\n    // Export murmurHash3 for CommonJS, either as an AMD module or just as part\n    // of the global object.\n    if (typeof exports !== 'undefined') {\n\n        if (typeof module !== 'undefined' && module.exports) {\n            exports = module.exports = library;\n        }\n\n        exports.murmurHash3 = library;\n\n    } else if (typeof define === 'function' && define.amd) {\n\n        define([], function () {\n            return library;\n        });\n    } else {\n\n        // Use murmurHash3.noConflict to restore `murmurHash3` back to its\n        // original value. Returns a reference to the library object, to allow\n        // it to be used under a different name.\n        library._murmurHash3 = root.murmurHash3;\n\n        library.noConflict = function () {\n            root.murmurHash3 = library._murmurHash3;\n            library._murmurHash3 = undefined;\n            library.noConflict = undefined;\n\n            return library;\n        };\n\n        root.murmurHash3 = library;\n    }\n})(this);\n", "module.exports = require('./lib/murmurHash3js');\n", "'use strict'\n\n// JS treats subjects of bitwise operators as SIGNED 32 bit numbers,\n// which means the maximum amount of bits we can store inside each byte\n// is 7..\nconst BITS_PER_BYTE = 7\n\nmodule.exports = class SparseArray {\n  constructor () {\n    this._bitArrays = []\n    this._data = []\n    this._length = 0\n    this._changedLength = false\n    this._changedData = false\n  }\n\n  set (index, value) {\n    let pos = this._internalPositionFor(index, false)\n    if (value === undefined) {\n      // unsetting\n      if (pos !== -1) {\n        // remove item from bit array and array itself\n        this._unsetInternalPos(pos)\n        this._unsetBit(index)\n        this._changedLength = true\n        this._changedData = true\n      }\n    } else {\n      let needsSort = false\n      if (pos === -1) {\n        pos = this._data.length\n        this._setBit(index)\n        this._changedData = true\n      } else {\n        needsSort = true\n      }\n      this._setInternalPos(pos, index, value, needsSort)\n      this._changedLength = true\n    }\n  }\n\n  unset (index) {\n    this.set(index, undefined)\n  }\n\n  get (index) {\n    this._sortData()\n    const pos = this._internalPositionFor(index, true)\n    if (pos === -1) {\n      return undefined\n    }\n    return this._data[pos][1]\n  }\n\n  push (value) {\n    this.set(this.length, value)\n    return this.length\n  }\n\n  get length () {\n    this._sortData()\n    if (this._changedLength) {\n      const last = this._data[this._data.length - 1]\n      this._length = last ? last[0] + 1 : 0\n      this._changedLength = false\n    }\n    return this._length\n  }\n\n  forEach (iterator) {\n    let i = 0\n    while(i < this.length) {\n      iterator(this.get(i), i, this)\n      i++\n    }\n  }\n\n  map (iterator) {\n    let i = 0\n    let mapped = new Array(this.length)\n    while(i < this.length) {\n      mapped[i] = iterator(this.get(i), i, this)\n      i++\n    }\n    return mapped\n  }\n\n  reduce (reducer, initialValue) {\n    let i = 0\n    let acc = initialValue\n    while(i < this.length) {\n      const value = this.get(i)\n      acc = reducer(acc, value, i)\n      i++\n    }\n    return acc\n  }\n\n  find (finder) {\n    let i = 0, found, last\n    while ((i < this.length) && !found) {\n      last = this.get(i)\n      found = finder(last)\n      i++\n    }\n    return found ? last : undefined\n  }\n\n  _internalPositionFor (index, noCreate) {\n    const bytePos = this._bytePosFor(index, noCreate)\n    if (bytePos >= this._bitArrays.length) {\n      return -1\n    }\n    const byte = this._bitArrays[bytePos]\n    const bitPos = index - bytePos * BITS_PER_BYTE\n    const exists = (byte & (1 << bitPos)) > 0\n    if (!exists) {\n      return -1\n    }\n    const previousPopCount = this._bitArrays.slice(0, bytePos).reduce(popCountReduce, 0)\n\n    const mask = ~(0xffffffff << (bitPos + 1))\n    const bytePopCount = popCount(byte & mask)\n    const arrayPos = previousPopCount + bytePopCount - 1\n    return arrayPos\n  }\n\n  _bytePosFor (index, noCreate) {\n    const bytePos = Math.floor(index / BITS_PER_BYTE)\n    const targetLength = bytePos + 1\n    while (!noCreate && this._bitArrays.length < targetLength) {\n      this._bitArrays.push(0)\n    }\n    return bytePos\n  }\n\n  _setBit (index) {\n    const bytePos = this._bytePosFor(index, false)\n    this._bitArrays[bytePos] |= (1 << (index - (bytePos * BITS_PER_BYTE)))\n  }\n\n  _unsetBit(index) {\n    const bytePos = this._bytePosFor(index, false)\n    this._bitArrays[bytePos] &= ~(1 << (index - (bytePos * BITS_PER_BYTE)))\n  }\n\n  _setInternalPos(pos, index, value, needsSort) {\n    const data =this._data\n    const elem = [index, value]\n    if (needsSort) {\n      this._sortData()\n      data[pos] = elem\n    } else {\n      // new element. just shove it into the array\n      // but be nice about where we shove it\n      // in order to make sorting it later easier\n      if (data.length) {\n        if (data[data.length - 1][0] >= index) {\n          data.push(elem)\n        } else if (data[0][0] <= index) {\n          data.unshift(elem)\n        } else {\n          const randomIndex = Math.round(data.length / 2)\n          this._data = data.slice(0, randomIndex).concat(elem).concat(data.slice(randomIndex))\n        }\n      } else {\n        this._data.push(elem)\n      }\n      this._changedData = true\n      this._changedLength = true\n    }\n  }\n\n  _unsetInternalPos (pos) {\n    this._data.splice(pos, 1)\n  }\n\n  _sortData () {\n    if (this._changedData) {\n      this._data.sort(sortInternal)\n    }\n\n    this._changedData = false\n  }\n\n  bitField () {\n    const bytes = []\n    let pendingBitsForResultingByte = 8\n    let pendingBitsForNewByte = 0\n    let resultingByte = 0\n    let newByte\n    const pending = this._bitArrays.slice()\n    while (pending.length || pendingBitsForNewByte) {\n      if (pendingBitsForNewByte === 0) {\n        newByte = pending.shift()\n        pendingBitsForNewByte = 7\n      }\n\n      const usingBits = Math.min(pendingBitsForNewByte, pendingBitsForResultingByte)\n      const mask = ~(0b11111111 << usingBits)\n      const masked = newByte & mask\n      resultingByte |= masked << (8 - pendingBitsForResultingByte)\n      newByte = newByte >>> usingBits\n      pendingBitsForNewByte -= usingBits\n      pendingBitsForResultingByte -= usingBits\n\n      if (!pendingBitsForResultingByte || (!pendingBitsForNewByte && !pending.length)) {\n        bytes.push(resultingByte)\n        resultingByte = 0\n        pendingBitsForResultingByte = 8\n      }\n    }\n\n    // remove trailing zeroes\n    for(var i = bytes.length - 1; i > 0; i--) {\n      const value = bytes[i]\n      if (value === 0) {\n        bytes.pop()\n      } else {\n        break\n      }\n    }\n\n    return bytes\n  }\n\n  compactArray () {\n    this._sortData()\n    return this._data.map(valueOnly)\n  }\n}\n\nfunction popCountReduce (count, byte) {\n  return count + popCount(byte)\n}\n\nfunction popCount(_v) {\n  let v = _v\n  v = v - ((v >> 1) & 0x55555555)                    // reuse input as temporary\n  v = (v & 0x33333333) + ((v >> 2) & 0x33333333)     // temp\n  return ((v + (v >> 4) & 0xF0F0F0F) * 0x1010101) >> 24\n}\n\nfunction sortInternal (a, b) {\n  return a[0] - b[0]\n}\n\nfunction valueOnly (elem) {\n  return elem[1]\n}", "'use strict';\n\nvar has = Object.prototype.hasOwnProperty\n  , prefix = '~';\n\n/**\n * Constructor to create a storage for our `EE` objects.\n * An `Events` instance is a plain object whose properties are event names.\n *\n * @constructor\n * @private\n */\nfunction Events() {}\n\n//\n// We try to not inherit from `Object.prototype`. In some engines creating an\n// instance in this way is faster than calling `Object.create(null)` directly.\n// If `Object.create(null)` is not supported we prefix the event names with a\n// character to make sure that the built-in object properties are not\n// overridden or used as an attack vector.\n//\nif (Object.create) {\n  Events.prototype = Object.create(null);\n\n  //\n  // This hack is needed because the `__proto__` property is still inherited in\n  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.\n  //\n  if (!new Events().__proto__) prefix = false;\n}\n\n/**\n * Representation of a single event listener.\n *\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} [once=false] Specify if the listener is a one-time listener.\n * @constructor\n * @private\n */\nfunction EE(fn, context, once) {\n  this.fn = fn;\n  this.context = context;\n  this.once = once || false;\n}\n\n/**\n * Add a listener for a given event.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} once Specify if the listener is a one-time listener.\n * @returns {EventEmitter}\n * @private\n */\nfunction addListener(emitter, event, fn, context, once) {\n  if (typeof fn !== 'function') {\n    throw new TypeError('The listener must be a function');\n  }\n\n  var listener = new EE(fn, context || emitter, once)\n    , evt = prefix ? prefix + event : event;\n\n  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;\n  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);\n  else emitter._events[evt] = [emitter._events[evt], listener];\n\n  return emitter;\n}\n\n/**\n * Clear event by name.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} evt The Event name.\n * @private\n */\nfunction clearEvent(emitter, evt) {\n  if (--emitter._eventsCount === 0) emitter._events = new Events();\n  else delete emitter._events[evt];\n}\n\n/**\n * Minimal `EventEmitter` interface that is molded against the Node.js\n * `EventEmitter` interface.\n *\n * @constructor\n * @public\n */\nfunction EventEmitter() {\n  this._events = new Events();\n  this._eventsCount = 0;\n}\n\n/**\n * Return an array listing the events for which the emitter has registered\n * listeners.\n *\n * @returns {Array}\n * @public\n */\nEventEmitter.prototype.eventNames = function eventNames() {\n  var names = []\n    , events\n    , name;\n\n  if (this._eventsCount === 0) return names;\n\n  for (name in (events = this._events)) {\n    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);\n  }\n\n  if (Object.getOwnPropertySymbols) {\n    return names.concat(Object.getOwnPropertySymbols(events));\n  }\n\n  return names;\n};\n\n/**\n * Return the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Array} The registered listeners.\n * @public\n */\nEventEmitter.prototype.listeners = function listeners(event) {\n  var evt = prefix ? prefix + event : event\n    , handlers = this._events[evt];\n\n  if (!handlers) return [];\n  if (handlers.fn) return [handlers.fn];\n\n  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {\n    ee[i] = handlers[i].fn;\n  }\n\n  return ee;\n};\n\n/**\n * Return the number of listeners listening to a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Number} The number of listeners.\n * @public\n */\nEventEmitter.prototype.listenerCount = function listenerCount(event) {\n  var evt = prefix ? prefix + event : event\n    , listeners = this._events[evt];\n\n  if (!listeners) return 0;\n  if (listeners.fn) return 1;\n  return listeners.length;\n};\n\n/**\n * Calls each of the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Boolean} `true` if the event had listeners, else `false`.\n * @public\n */\nEventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return false;\n\n  var listeners = this._events[evt]\n    , len = arguments.length\n    , args\n    , i;\n\n  if (listeners.fn) {\n    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);\n\n    switch (len) {\n      case 1: return listeners.fn.call(listeners.context), true;\n      case 2: return listeners.fn.call(listeners.context, a1), true;\n      case 3: return listeners.fn.call(listeners.context, a1, a2), true;\n      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;\n      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n    }\n\n    for (i = 1, args = new Array(len -1); i < len; i++) {\n      args[i - 1] = arguments[i];\n    }\n\n    listeners.fn.apply(listeners.context, args);\n  } else {\n    var length = listeners.length\n      , j;\n\n    for (i = 0; i < length; i++) {\n      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);\n\n      switch (len) {\n        case 1: listeners[i].fn.call(listeners[i].context); break;\n        case 2: listeners[i].fn.call(listeners[i].context, a1); break;\n        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;\n        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;\n        default:\n          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {\n            args[j - 1] = arguments[j];\n          }\n\n          listeners[i].fn.apply(listeners[i].context, args);\n      }\n    }\n  }\n\n  return true;\n};\n\n/**\n * Add a listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.on = function on(event, fn, context) {\n  return addListener(this, event, fn, context, false);\n};\n\n/**\n * Add a one-time listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.once = function once(event, fn, context) {\n  return addListener(this, event, fn, context, true);\n};\n\n/**\n * Remove the listeners of a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn Only remove the listeners that match this function.\n * @param {*} context Only remove the listeners that have this context.\n * @param {Boolean} once Only remove one-time listeners.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return this;\n  if (!fn) {\n    clearEvent(this, evt);\n    return this;\n  }\n\n  var listeners = this._events[evt];\n\n  if (listeners.fn) {\n    if (\n      listeners.fn === fn &&\n      (!once || listeners.once) &&\n      (!context || listeners.context === context)\n    ) {\n      clearEvent(this, evt);\n    }\n  } else {\n    for (var i = 0, events = [], length = listeners.length; i < length; i++) {\n      if (\n        listeners[i].fn !== fn ||\n        (once && !listeners[i].once) ||\n        (context && listeners[i].context !== context)\n      ) {\n        events.push(listeners[i]);\n      }\n    }\n\n    //\n    // Reset the array, or remove it completely if we have no more listeners.\n    //\n    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;\n    else clearEvent(this, evt);\n  }\n\n  return this;\n};\n\n/**\n * Remove all listeners, or those of the specified event.\n *\n * @param {(String|Symbol)} [event] The event name.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n  var evt;\n\n  if (event) {\n    evt = prefix ? prefix + event : event;\n    if (this._events[evt]) clearEvent(this, evt);\n  } else {\n    this._events = new Events();\n    this._eventsCount = 0;\n  }\n\n  return this;\n};\n\n//\n// Alias methods names because people roll like that.\n//\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\nEventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n//\n// Expose the prefix.\n//\nEventEmitter.prefixed = prefix;\n\n//\n// Allow `EventEmitter` to be imported as module namespace.\n//\nEventEmitter.EventEmitter = EventEmitter;\n\n//\n// Expose the module.\n//\nif ('undefined' !== typeof module) {\n  module.exports = EventEmitter;\n}\n", "/**\n * @packageDocumentation\n *\n * `@helia/unixfs` is an implementation of a {@link https://github.com/ipfs/specs/blob/main/UNIXFS.md UnixFS filesystem} compatible with {@link https://github.com/ipfs/helia Helia}.\n *\n * See the [API docs](https://ipfs.github.io/helia/modules/_helia_unixfs.html) for all available operations.\n *\n * @example Creating files and directories\n *\n * ```typescript\n * import { createHelia } from 'helia'\n * import { unixfs } from '@helia/unixfs'\n *\n * const helia = await createHelia()\n * const fs = unixfs(helia)\n *\n * // create an empty dir and a file, then add the file to the dir\n * const emptyDirCid = await fs.addDirectory()\n * const fileCid = await fs.addBytes(Uint8Array.from([0, 1, 2, 3]))\n * const updateDirCid = await fs.cp(fileCid, emptyDirCid, 'foo.txt')\n *\n * // or doing the same thing as a stream\n * for await (const entry of fs.addAll([{\n *   path: 'foo.txt',\n *   content: Uint8Array.from([0, 1, 2, 3])\n * }])) {\n *   console.info(entry)\n * }\n * ```\n *\n * @example Recursively adding a directory\n *\n * Node.js-compatibly environments only:\n *\n * ```typescript\n * import { createHelia } from 'helia'\n * import { unixfs } from '@helia/unixfs'\n * import { globSource } from '@helia/unixfs'\n *\n * const helia = await createHelia()\n * const fs = unixfs(helia)\n *\n * for await (const entry of fs.addAll(globSource('path/to/containing/dir', 'glob-pattern'))) {\n *   console.info(entry)\n * }\n * ```\n *\n * @example Adding files and directories in the browser\n *\n * Uses [@cypsela/browser-source](https://github.com/cypsela/browser-source) to read [FileSystemEntry](https://developer.mozilla.org/en-US/docs/Web/API/FileSystemEntry) and [FileSystemHandle](https://developer.mozilla.org/en-US/docs/Web/API/FileSystemHandle) files and directories.\n *\n * Instances of these data types are available from drag and drop events and window methods like [showOpenFilePicker](https://developer.mozilla.org/en-US/docs/Web/API/Window/showOpenFilePicker).\n *\n * ```typescript\n * import { createHelia } from 'helia'\n * import { unixfs } from '@helia/unixfs'\n * import { fsEntrySource, fsHandleSource } from '@cypsela/browser-source'\n *\n * const helia = await createHelia()\n * const fs = unixfs(helia)\n *\n * // get FileSystemEntry from drag and drop events\n * const fileEntry = {} as FileSystemEntry\n *\n * for await (const entry of fs.addAll(fsEntrySource(fileEntry))) {\n *   console.info(entry)\n * }\n *\n * // get FileSystemHandle from drag and drop events or window methods\n * const fileHandle = {} as FileSystemHandle\n *\n * for await (const entry of fs.addAll(fsHandleSource(fileHandle))) {\n *   console.info(entry)\n * }\n * ```\n */\n\nimport { UnixFS as UnixFSClass } from './unixfs.js'\nimport type { GetBlockProgressEvents, PutBlockProgressEvents } from '@helia/interface/blocks'\nimport type { AbortOptions } from '@libp2p/interface'\nimport type { Filter } from '@libp2p/utils/filters'\nimport type { Blockstore } from 'interface-blockstore'\nimport type { Mtime, UnixFS as IPFSUnixFS } from 'ipfs-unixfs'\nimport type { ExporterProgressEvents, UnixFSEntry } from 'ipfs-unixfs-exporter'\nimport type { ByteStream, DirectoryCandidate, ImportCandidateStream, ImporterOptions, ImporterProgressEvents, ImportResult, ImportContent } from 'ipfs-unixfs-importer'\nimport type { CID, Version } from 'multiformats/cid'\nimport type { ProgressOptions } from 'progress-events'\n\nexport interface UnixFSComponents {\n  blockstore: Pick<Blockstore, 'get' | 'put' | 'has'>\n}\n\nexport interface FileCandidate<T extends ImportContent = ImportContent> {\n  path: string\n  content: T\n  mtime?: Mtime\n  mode?: number\n}\n\nexport type AddEvents = PutBlockProgressEvents\n| ImporterProgressEvents\n\nexport interface AddOptions extends AbortOptions, Omit<ImporterOptions, 'onProgress'>, ProgressOptions<AddEvents> {\n\n}\n\nexport type AddFileOptions = Omit<AddOptions, 'wrapWithDirectory'>\n\nexport type GetEvents = GetBlockProgressEvents\n| ExporterProgressEvents\n\n/**\n * Options to pass to the cat command\n */\nexport interface CatOptions extends AbortOptions, ProgressOptions<GetEvents> {\n  /**\n   * Start reading the file at this offset\n   */\n  offset?: number\n\n  /**\n   * Stop reading the file after this many bytes\n   */\n  length?: number\n\n  /**\n   * An optional path to allow reading files inside directories\n   */\n  path?: string\n\n  /**\n   * If true, do not perform any network operations and throw if blocks are\n   * missing from the local store. (default: false)\n   */\n  offline?: boolean\n}\n\n/**\n * Options to pass to the chmod command\n */\nexport interface ChmodOptions extends AbortOptions, ProgressOptions<GetEvents | PutBlockProgressEvents> {\n  /**\n   * If the target of the operation is a directory and this is true,\n   * apply the new mode to all directory contents\n   */\n  recursive: boolean\n\n  /**\n   * Optional path to set the mode on directory contents\n   */\n  path?: string\n\n  /**\n   * DAGs with a root block larger than this value will be sharded. Blocks\n   * smaller than this value will be regular UnixFS directories.\n   */\n  shardSplitThresholdBytes: number\n\n  /**\n   * If true, do not perform any network operations and throw if blocks are\n   * missing from the local store. (default: false)\n   */\n  offline?: boolean\n}\n\n/**\n * Options to pass to the cp command\n */\nexport interface CpOptions extends AbortOptions, ProgressOptions<GetEvents | PutBlockProgressEvents> {\n  /**\n   * If true, allow overwriting existing directory entries (default: false)\n   */\n  force: boolean\n\n  /**\n   * DAGs with a root block larger than this value will be sharded. Blocks\n   * smaller than this value will be regular UnixFS directories.\n   */\n  shardSplitThresholdBytes: number\n\n  /**\n   * If true, do not perform any network operations and throw if blocks are\n   * missing from the local store. (default: false)\n   */\n  offline?: boolean\n}\n\n/**\n * Options to pass to the ls command\n */\nexport interface LsOptions extends AbortOptions, ProgressOptions<GetEvents> {\n  /**\n   * Optional path to list subdirectory contents if the target CID resolves to\n   * a directory\n   */\n  path?: string\n\n  /**\n   * Start reading the directory entries at this offset\n   */\n  offset?: number\n\n  /**\n   * Stop reading the directory contents after this many directory entries\n   */\n  length?: number\n\n  /**\n   * If true, do not perform any network operations and throw if blocks are\n   * missing from the local store. (default: false)\n   */\n  offline?: boolean\n}\n\n/**\n * Options to pass to the mkdir command\n */\nexport interface MkdirOptions extends AbortOptions, ProgressOptions<GetEvents | PutBlockProgressEvents> {\n  /**\n   * The CID version to create the new directory with - defaults to the same\n   * version as the containing directory\n   */\n  cidVersion: Version\n\n  /**\n   * If true, allow overwriting existing directory entries (default: false)\n   */\n  force: boolean\n\n  /**\n   * An optional mode to set on the new directory\n   */\n  mode?: number\n\n  /**\n   * An optional mtime to set on the new directory\n   */\n  mtime?: Mtime\n\n  /**\n   * DAGs with a root block larger than this value will be sharded. Blocks\n   * smaller than this value will be regular UnixFS directories.\n   */\n  shardSplitThresholdBytes: number\n\n  /**\n   * If true, do not perform any network operations and throw if blocks are\n   * missing from the local store. (default: false)\n   */\n  offline?: boolean\n}\n\n/**\n * Options to pass to the rm command\n */\nexport interface RmOptions extends AbortOptions, ProgressOptions<GetEvents | PutBlockProgressEvents> {\n  /**\n   * DAGs with a root block larger than this value will be sharded. Blocks\n   * smaller than this value will be regular UnixFS directories.\n   */\n  shardSplitThresholdBytes: number\n\n  /**\n   * If true, do not perform any network operations and throw if blocks are\n   * missing from the local store. (default: false)\n   */\n  offline?: boolean\n}\n\n/**\n * Options to pass to the stat command\n */\nexport interface StatOptions extends AbortOptions, ProgressOptions<GetEvents> {\n  /**\n   * An optional path to allow getting stats of paths inside directories\n   */\n  path?: string\n\n  /**\n   * If true, do not perform any network operations and throw if blocks are\n   * missing from the local store.\n   *\n   * @default false\n   */\n  offline?: boolean\n}\n\nexport interface ExtendedStatOptions extends StatOptions {\n  /**\n   * If true, traverse the whole DAG to return additional stats. If all data is\n   * not in the local blockstore, this may involve fetching them from the\n   * network.\n   */\n  extended: true\n\n  /**\n   * By default CIDs are deduplicated using a `ScalableCuckooFilter` - if you\n   * wish to use a different filter, pass it here.\n   */\n  filter?: Filter\n}\n\n/**\n * Statistics relating to a UnixFS DAG\n */\nexport interface Stats {\n  /**\n   * The file or directory CID\n   */\n  cid: CID\n\n  /**\n   * The file or directory mode\n   */\n  mode: number\n\n  /**\n   * The file or directory mtime\n   */\n  mtime?: Mtime\n\n  /**\n   * The type of UnixFS node - 'file' or 'directory'\n   */\n  type: 'file' | 'directory' | 'raw'\n\n  /**\n   * UnixFS metadata about this file or directory\n   */\n  unixfs?: IPFSUnixFS\n\n  /**\n   * The size in bytes of the file as reported by the UnixFS metadata stored in\n   * the root DAG node, or if the CID resolves to a raw node, the size of the\n   * block that holds it.\n   *\n   * For directories this will return `0` as no size information is available in\n   * the root block - instead please stat with the `extended` option to traverse\n   * the DAG and calculate the size.\n   */\n  size: bigint\n}\n\nexport interface FileStats extends Stats {\n  type: 'file'\n  unixfs: IPFSUnixFS\n}\n\nexport interface DirectoryStats extends Stats {\n  type: 'directory'\n  unixfs: IPFSUnixFS\n}\n\nexport interface RawStats extends Stats {\n  type: 'raw'\n  unixfs: undefined\n}\n\n/**\n * More detailed statistics relating to a UnixFS DAG. These can involve\n * traversing the DAG behind the CID so can involve network operations and/or\n * more disk activity.\n */\nexport interface ExtendedStats extends Stats {\n  /**\n   * How many blocks make up the DAG.\n   *\n   * nb. this will only be accurate if either all blocks are present in the\n   * local blockstore or the `offline` option was not `true`\n   */\n  blocks: bigint\n\n  /**\n   * How many unique blocks make up the DAG - this count does not include any\n   * blocks that appear in the DAG more than once.\n   *\n   * nb. this will only be accurate if either all blocks are present in the\n   * local blockstore or the `offline` option was not `true`\n   */\n  uniqueBlocks: bigint\n\n  /**\n   * The size of the DAG that holds the file or directory in bytes - this is\n   * the sum of all block sizes so includes any protobuf overhead, etc.\n   *\n   * Duplicate blocks are included in this measurement.\n   *\n   * nb. this will only be accurate if either all blocks are present in the\n   * local blockstore or the `offline` option was not `true`\n   */\n  dagSize: bigint\n\n  /**\n   * Similar to `dagSize` except duplicate blocks are not included in the\n   * reported amount.\n   *\n   * nb. this will only be accurate if either all blocks are present in the\n   * local blockstore or the `offline` option was not `true`\n   */\n  deduplicatedDagSize: bigint\n\n  /**\n   * How much of the file or directory is in the local block store. If this is a\n   * directory it will include the `localSize` of all child files and\n   * directories.\n   *\n   * It does not include protobuf overhead, for that see `dagSize`.\n   *\n   * nb. if the `offline` option is `true`, and not all blocks for the\n   * file/directory are in the blockstore, this number may be smaller than\n   * `size`.\n   */\n  localSize: bigint\n}\n\nexport interface ExtendedFileStats extends ExtendedStats {\n  type: 'file'\n  unixfs: IPFSUnixFS\n}\n\nexport interface ExtendedDirectoryStats extends ExtendedStats {\n  type: 'directory'\n  unixfs: IPFSUnixFS\n}\n\nexport interface ExtendedRawStats extends ExtendedStats {\n  type: 'raw'\n  unixfs: undefined\n}\n\n/**\n * Options to pass to the touch command\n */\nexport interface TouchOptions extends AbortOptions, ProgressOptions<GetEvents | PutBlockProgressEvents> {\n  /**\n   * Optional mtime to set on the DAG root, defaults to the current time\n   */\n  mtime?: Mtime\n\n  /**\n   * Optional path to set mtime on directory contents\n   */\n  path?: string\n\n  /**\n   * If the DAG is a directory and this is true, update the mtime on all contents\n   */\n  recursive: boolean\n\n  /**\n   * DAGs with a root block larger than this value will be sharded. Blocks\n   * smaller than this value will be regular UnixFS directories.\n   */\n  shardSplitThresholdBytes: number\n\n  /**\n   * If true, do not perform any network operations and throw if blocks are\n   * missing from the local store. (default: false)\n   */\n  offline?: boolean\n}\n\n/**\n * The UnixFS interface provides familiar filesystem operations to make working with\n * UnixFS DAGs simple and intuitive.\n */\nexport interface UnixFS {\n  /**\n   * Add all files and directories from the passed stream. This method wraps the\n   * `importer` export from the `ipfs-unixfs-importer` module - please see the docs\n   * for input/output types.\n   *\n   * @example\n   *\n   * ```typescript\n   * const source = [{\n   *   path: './foo.txt',\n   *   content: Uint8Array.from([0, 1, 2, 3])\n   * }, {\n   *   path: './bar.txt',\n   *   content: Uint8Array.from([4, 5, 6, 7])\n   * }]\n   *\n   * for await (const entry of fs.import(source)) {\n   *   console.info(entry)\n   * }\n   * ```\n   */\n  addAll(source: ImportCandidateStream, options?: Partial<AddOptions>): AsyncIterable<ImportResult>\n\n  /**\n   * Add a single `Uint8Array` to your Helia node and receive a CID that will\n   * resolve to it.\n   *\n   * If you want to preserve a file name or other metadata such as modification\n   * time or mode, use `addFile` instead.\n   *\n   * @example\n   *\n   * ```typescript\n   * const cid = await fs.addBytes(Uint8Array.from([0, 1, 2, 3]))\n   *\n   * console.info(cid)\n   * ```\n   */\n  addBytes(bytes: Uint8Array, options?: Partial<AddFileOptions>): Promise<CID>\n\n  /**\n   * Add a stream of `Uint8Array`s to your Helia node and receive a CID that\n   * will resolve to them.\n   *\n   * If you want to preserve a file name or other metadata such as modification\n   * time or mode, use `addFile` instead.\n   *\n   * @example\n   *\n   * ```typescript\n   * import fs from 'fs'\n   *\n   * const stream = fs.createReadStream('./foo.txt')\n   * const cid = await fs.addByteStream(stream)\n   *\n   * console.info(cid)\n   * ```\n   */\n  addByteStream(bytes: ByteStream, options?: Partial<AddFileOptions>): Promise<CID>\n\n  /**\n   * Add a file to your Helia node with metadata. The returned CID will resolve\n   * to a directory with one file entry.\n   *\n   * If you don't care about file names and just want a CID that will resolve to\n   * the contents of the file, use `addBytes` or `addByeStream` instead.\n   *\n   * @example\n   *\n   * ```typescript\n   * const cid = await fs.addFile({\n   *   path: './foo.txt',\n   *   content: Uint8Array.from([0, 1, 2, 3]),\n   *   mode: 0x755,\n   *   mtime: {\n   *     secs: 10n,\n   *     nsecs: 0\n   *   }\n   * })\n   *\n   * console.info(cid)\n   * ```\n   */\n  addFile(file: FileCandidate, options?: Partial<AddFileOptions>): Promise<CID>\n\n  /**\n   * Add a directory to your Helia node.\n   *\n   * @example\n   *\n   * If no path is specified, the returned CID will resolve to an empty\n   * directory.\n   *\n   * ```typescript\n   * const cid = await fs.addDirectory()\n   *\n   * console.info(cid) // empty directory CID\n   * ```\n   *\n   * @example\n   *\n   * If a path is specified, the CID will resolve to a directory that contains\n   * an empty directory with the specified name.\n   *\n   * ```typescript\n   * const cid = await fs.addDirectory({\n   *   path: 'my-dir'\n   * })\n   *\n   * console.info(cid) // containing directory CID\n   *\n   * const stat = await fs.stat(cid, {\n   *   path: 'my-dir'\n   * })\n   *\n   * console.info(stat.cid) // empty directory CID\n   * ```\n   */\n  addDirectory(dir?: Partial<DirectoryCandidate>, options?: Partial<AddFileOptions>): Promise<CID>\n\n  /**\n   * Retrieve the contents of a file from your Helia node.\n   *\n   * @example\n   *\n   * ```typescript\n   * for await (const buf of fs.cat(cid)) {\n   *   console.info(buf)\n   * }\n   * ```\n   */\n  cat(cid: CID, options?: Partial<CatOptions>): AsyncIterable<Uint8Array>\n\n  /**\n   * Change the permissions on a file or directory in a DAG\n   *\n   * @example\n   *\n   * ```typescript\n   * const beforeCid = await fs.addBytes(Uint8Array.from([0, 1, 2, 3]))\n   * const beforeStats = await fs.stat(beforeCid)\n   *\n   * const afterCid = await fs.chmod(cid, 0x755)\n   * const afterStats = await fs.stat(afterCid)\n   *\n   * console.info(beforeCid, beforeStats)\n   * console.info(afterCid, afterStats)\n   * ```\n   */\n  chmod(cid: CID, mode: number, options?: Partial<ChmodOptions>): Promise<CID>\n\n  /**\n   * Add a file or directory to a target directory.\n   *\n   * @example\n   *\n   * ```typescript\n   * const fileCid = await fs.addBytes(Uint8Array.from([0, 1, 2, 3]))\n   * const directoryCid = await fs.addDirectory()\n   *\n   * const updatedCid = await fs.cp(fileCid, directoryCid, 'foo.txt')\n   *\n   * console.info(updatedCid)\n   * ```\n   */\n  cp(source: CID, target: CID, name: string, options?: Partial<CpOptions>): Promise<CID>\n\n  /**\n   * List directory contents.\n   *\n   * @example\n   *\n   * ```typescript\n   * for await (const entry of fs.ls(directoryCid)) {\n   *   console.info(entry)\n   * }\n   * ```\n   */\n  ls(cid: CID, options?: Partial<LsOptions>): AsyncIterable<UnixFSEntry>\n\n  /**\n   * Make a new directory under an existing directory.\n   *\n   * @example\n   *\n   * ```typescript\n   * const directoryCid = await fs.addDirectory()\n   *\n   * const updatedCid = await fs.mkdir(directoryCid, 'new-dir')\n   *\n   * console.info(updatedCid)\n   * ```\n   */\n  mkdir(cid: CID, dirname: string, options?: Partial<MkdirOptions>): Promise<CID>\n\n  /**\n   * Remove a file or directory from an existing directory.\n   *\n   * @example\n   *\n   * ```typescript\n   * const directoryCid = await fs.addDirectory()\n   * const updatedCid = await fs.mkdir(directoryCid, 'new-dir')\n   *\n   * const finalCid = await fs.rm(updatedCid, 'new-dir')\n   *\n   * console.info(finalCid)\n   * ```\n   */\n  rm(cid: CID, path: string, options?: Partial<RmOptions>): Promise<CID>\n\n  /**\n   * Return statistics about a UnixFS DAG.\n   *\n   * @example\n   *\n   * ```typescript\n   * const fileCid = await fs.addBytes(Uint8Array.from([0, 1, 2, 3]))\n   *\n   * const stats = await fs.stat(fileCid)\n   *\n   * console.info(stats)\n   * ```\n   */\n  stat(cid: CID, options?: StatOptions): Promise<FileStats | DirectoryStats | RawStats>\n  stat(cid: CID, options?: ExtendedStatOptions): Promise<ExtendedFileStats | ExtendedDirectoryStats | ExtendedRawStats>\n\n  /**\n   * Update the mtime of a UnixFS DAG\n   *\n   * @example\n   *\n   * ```typescript\n   * const beforeCid = await fs.addBytes(Uint8Array.from([0, 1, 2, 3]))\n   * const beforeStats = await fs.stat(beforeCid)\n   *\n   * const afterCid = await fs.touch(beforeCid)\n   * const afterStats = await fs.stat(afterCid)\n   *\n   * console.info(beforeCid, beforeStats)\n   * console.info(afterCid, afterStats)\n   * ```\n   */\n  touch(cid: CID, options?: Partial<TouchOptions>): Promise<CID>\n}\n\n/**\n * Create a {@link UnixFS} instance for use with {@link https://github.com/ipfs/helia Helia}\n */\nexport function unixfs (helia: { blockstore: Pick<Blockstore, 'get' | 'put' | 'has'> }): UnixFS {\n  return new UnixFSClass(helia)\n}\n\nexport { globSource } from './utils/glob-source.js'\nexport type { GlobSourceResult, GlobSourceOptions } from './utils/glob-source.js'\nexport { urlSource } from './utils/url-source.js'\n", "/**\n * @packageDocumentation\n *\n * Return the first value in an (async)iterable\n *\n * @example\n *\n * ```javascript\n * import first from 'it-first'\n *\n * // This can also be an iterator, generator, etc\n * const values = [0, 1, 2, 3, 4]\n *\n * const res = first(values)\n *\n * console.info(res) // 0\n * ```\n *\n * Async sources must be awaited:\n *\n * ```javascript\n * import first from 'it-first'\n *\n * const values = async function * () {\n *   yield * [0, 1, 2, 3, 4]\n * }\n *\n * const res = await first(values())\n *\n * console.info(res) // 0\n * ```\n */\n\nfunction isAsyncIterable <T> (thing: any): thing is AsyncIterable<T> {\n  return thing[Symbol.asyncIterator] != null\n}\n\n/**\n * Returns the first result from an (async) iterable, unless empty, in which\n * case returns `undefined`\n */\nfunction first <T> (source: Iterable<T>): T | undefined\nfunction first <T> (source: Iterable<T> | AsyncIterable<T>): Promise<T | undefined>\nfunction first <T> (source: Iterable<T> | AsyncIterable<T>): Promise<T | undefined> | T | undefined {\n  if (isAsyncIterable(source)) {\n    return (async () => {\n      for await (const entry of source) { // eslint-disable-line no-unreachable-loop\n        return entry\n      }\n\n      return undefined\n    })()\n  }\n\n  for (const entry of source) { // eslint-disable-line no-unreachable-loop\n    return entry\n  }\n\n  return undefined\n}\n\nexport default first\n", "/**\n * @packageDocumentation\n *\n * The final batch may be smaller than the max.\n *\n * @example\n *\n * ```javascript\n * import batch from 'it-batch'\n * import all from 'it-all'\n *\n * // This can also be an iterator, generator, etc\n * const values = [0, 1, 2, 3, 4]\n * const batchSize = 2\n *\n * const result = all(batch(values, batchSize))\n *\n * console.info(result) // [0, 1], [2, 3], [4]\n * ```\n *\n * Async sources must be awaited:\n *\n * ```javascript\n * import batch from 'it-batch'\n * import all from 'it-all'\n *\n * const values = async function * () {\n *   yield * [0, 1, 2, 3, 4]\n * }\n *\n * const batchSize = 2\n * const result = await all(batch(values(), batchSize))\n *\n * console.info(result) // [0, 1], [2, 3], [4]\n * ```\n */\n\nfunction isAsyncIterable <T> (thing: any): thing is AsyncIterable<T> {\n  return thing[Symbol.asyncIterator] != null\n}\n\n/**\n * Takes an (async) iterable that emits things and returns an async iterable that\n * emits those things in fixed-sized batches\n */\nfunction batch <T> (source: Iterable<T>, size?: number): Generator<T[], void, undefined>\nfunction batch <T> (source: Iterable<T> | AsyncIterable<T>, size?: number): AsyncGenerator<T[], void, undefined>\nfunction batch <T> (source: Iterable<T> | AsyncIterable<T>, size: number = 1): Generator<T[], void, undefined> | AsyncGenerator<T[], void, undefined> {\n  size = Number(size)\n\n  if (isAsyncIterable(source)) {\n    return (async function * () {\n      let things: T[] = []\n\n      if (size < 1) {\n        size = 1\n      }\n\n      if (size !== Math.round(size)) {\n        throw new Error('Batch size must be an integer')\n      }\n\n      for await (const thing of source) {\n        things.push(thing)\n\n        while (things.length >= size) {\n          yield things.slice(0, size)\n\n          things = things.slice(size)\n        }\n      }\n\n      while (things.length > 0) {\n        yield things.slice(0, size)\n\n        things = things.slice(size)\n      }\n    }())\n  }\n\n  return (function * () {\n    let things: T[] = []\n\n    if (size < 1) {\n      size = 1\n    }\n\n    if (size !== Math.round(size)) {\n      throw new Error('Batch size must be an integer')\n    }\n\n    for (const thing of source) {\n      things.push(thing)\n\n      while (things.length >= size) {\n        yield things.slice(0, size)\n\n        things = things.slice(size)\n      }\n    }\n\n    while (things.length > 0) {\n      yield things.slice(0, size)\n\n      things = things.slice(size)\n    }\n  }())\n}\n\nexport default batch\n", "/**\n * @packageDocumentation\n *\n * Takes an async iterator that emits promise-returning functions, invokes them in parallel and emits the results in the same order as the input.\n *\n * The final batch may be smaller than the batch size.\n *\n * @example\n *\n * ```javascript\n * import parallelBatch from 'it-parallel-batch'\n * import all from 'it-all'\n * import delay from 'delay'\n *\n * // This can also be an iterator, async iterator, generator, etc\n * const input = [\n *   async () => {\n *     await delay(500)\n *\n *     return 1\n *   },\n *   async () => {\n *     await delay(200)\n *\n *     return 2\n *   },\n *   async () => {\n *     await delay(100)\n *\n *     return 3\n *   }\n * ]\n *\n * const batchSize = 2\n *\n * const result = await all(parallelBatch(input, batchSize))\n *\n * console.info(result) // [1, 2, 3]\n * ```\n */\n\nimport batch from 'it-batch'\n\ninterface Success<T> {\n  ok: true\n  value: T\n}\n\ninterface Failure {\n  ok: false\n  err: Error\n}\n\n/**\n * Takes an (async) iterator that emits promise-returning functions,\n * invokes them in parallel and emits the results as they become available but\n * in the same order as the input\n */\nexport default async function * parallelBatch <T> (source: AsyncIterable<() => Promise<T>> | Iterable<() => Promise<T>>, size: number = 1): AsyncGenerator<T, void, undefined> {\n  for await (const tasks of batch(source, size)) {\n    const things: Array<Promise<Success<T> | Failure>> = tasks.map(\n      async (p: () => Promise<T>) => {\n        return p().then(value => ({ ok: true, value }), err => ({ ok: false, err }))\n      })\n\n    for (let i = 0; i < things.length; i++) {\n      const result = await things[i]\n\n      if (result.ok) {\n        yield result.value\n      } else {\n        throw result.err\n      }\n    }\n  }\n}\n", "/**\n * Returns a `Uint8Array` of the requested size. Referenced memory will\n * be initialized to 0.\n */\nexport function alloc (size: number = 0): Uint8Array {\n  return new Uint8Array(size)\n}\n\n/**\n * Where possible returns a Uint8Array of the requested size that references\n * uninitialized memory. Only use if you are certain you will immediately\n * overwrite every value in the returned `Uint8Array`.\n */\nexport function allocUnsafe (size: number = 0): Uint8Array {\n  return new Uint8Array(size)\n}\n", "import { allocUnsafe } from '#alloc'\nimport { asUint8Array } from '#util/as-uint8array'\n\n/**\n * Returns a new Uint8Array created by concatenating the passed Uint8Arrays\n */\nexport function concat (arrays: Uint8Array[], length?: number): Uint8Array {\n  if (length == null) {\n    length = arrays.reduce((acc, curr) => acc + curr.length, 0)\n  }\n\n  const output = allocUnsafe(length)\n  let offset = 0\n\n  for (const arr of arrays) {\n    output.set(arr, offset)\n    offset += arr.length\n  }\n\n  return asUint8Array(output)\n}\n", "/**\n * Returns true if the two passed Uint8Arrays have the same content\n */\nexport function equals (a: Uint8Array, b: Uint8Array): boolean {\n  if (a === b) {\n    return true\n  }\n\n  if (a.byteLength !== b.byteLength) {\n    return false\n  }\n\n  for (let i = 0; i < a.byteLength; i++) {\n    if (a[i] !== b[i]) {\n      return false\n    }\n  }\n\n  return true\n}\n", "/**\n * @packageDocumentation\n *\n * A class that lets you do operations over a list of Uint8Arrays without\n * copying them.\n *\n * ```js\n * import { Uint8ArrayList } from 'uint8arraylist'\n *\n * const list = new Uint8ArrayList()\n * list.append(Uint8Array.from([0, 1, 2]))\n * list.append(Uint8Array.from([3, 4, 5]))\n *\n * list.subarray()\n * // -> Uint8Array([0, 1, 2, 3, 4, 5])\n *\n * list.consume(3)\n * list.subarray()\n * // -> Uint8Array([3, 4, 5])\n *\n * // you can also iterate over the list\n * for (const buf of list) {\n *   // ..do something with `buf`\n * }\n *\n * list.subarray(0, 1)\n * // -> Uint8Array([0])\n * ```\n *\n * ## Converting Uint8ArrayLists to Uint8Arrays\n *\n * There are two ways to turn a `Uint8ArrayList` into a `Uint8Array` - `.slice` and `.subarray` and one way to turn a `Uint8ArrayList` into a `Uint8ArrayList` with different contents - `.sublist`.\n *\n * ### slice\n *\n * Slice follows the same semantics as [Uint8Array.slice](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/slice) in that it creates a new `Uint8Array` and copies bytes into it using an optional offset & length.\n *\n * ```js\n * const list = new Uint8ArrayList()\n * list.append(Uint8Array.from([0, 1, 2]))\n * list.append(Uint8Array.from([3, 4, 5]))\n *\n * list.slice(0, 1)\n * // -> Uint8Array([0])\n * ```\n *\n * ### subarray\n *\n * Subarray attempts to follow the same semantics as [Uint8Array.subarray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/subarray) with one important different - this is a no-copy operation, unless the requested bytes span two internal buffers in which case it is a copy operation.\n *\n * ```js\n * const list = new Uint8ArrayList()\n * list.append(Uint8Array.from([0, 1, 2]))\n * list.append(Uint8Array.from([3, 4, 5]))\n *\n * list.subarray(0, 1)\n * // -> Uint8Array([0]) - no-copy\n *\n * list.subarray(2, 5)\n * // -> Uint8Array([2, 3, 4]) - copy\n * ```\n *\n * ### sublist\n *\n * Sublist creates and returns a new `Uint8ArrayList` that shares the underlying buffers with the original so is always a no-copy operation.\n *\n * ```js\n * const list = new Uint8ArrayList()\n * list.append(Uint8Array.from([0, 1, 2]))\n * list.append(Uint8Array.from([3, 4, 5]))\n *\n * list.sublist(0, 1)\n * // -> Uint8ArrayList([0]) - no-copy\n *\n * list.sublist(2, 5)\n * // -> Uint8ArrayList([2], [3, 4]) - no-copy\n * ```\n *\n * ## Inspiration\n *\n * Borrows liberally from [bl](https://www.npmjs.com/package/bl) but only uses native JS types.\n */\nimport { allocUnsafe, alloc } from 'uint8arrays/alloc'\nimport { concat } from 'uint8arrays/concat'\nimport { equals } from 'uint8arrays/equals'\n\nconst symbol = Symbol.for('@achingbrain/uint8arraylist')\n\nexport type Appendable = Uint8ArrayList | Uint8Array\n\nfunction findBufAndOffset (bufs: Uint8Array[], index: number): { buf: Uint8Array, index: number } {\n  if (index == null || index < 0) {\n    throw new RangeError('index is out of bounds')\n  }\n\n  let offset = 0\n\n  for (const buf of bufs) {\n    const bufEnd = offset + buf.byteLength\n\n    if (index < bufEnd) {\n      return {\n        buf,\n        index: index - offset\n      }\n    }\n\n    offset = bufEnd\n  }\n\n  throw new RangeError('index is out of bounds')\n}\n\n/**\n * Check if object is a CID instance\n *\n * @example\n *\n * ```js\n * import { isUint8ArrayList, Uint8ArrayList } from 'uint8arraylist'\n *\n * isUint8ArrayList(true) // false\n * isUint8ArrayList([]) // false\n * isUint8ArrayList(new Uint8ArrayList()) // true\n * ```\n */\nexport function isUint8ArrayList (value: any): value is Uint8ArrayList {\n  return Boolean(value?.[symbol])\n}\n\nexport class Uint8ArrayList implements Iterable<Uint8Array> {\n  private bufs: Uint8Array[]\n  public length: number\n  public readonly [symbol] = true\n\n  constructor (...data: Appendable[]) {\n    this.bufs = []\n    this.length = 0\n\n    if (data.length > 0) {\n      this.appendAll(data)\n    }\n  }\n\n  * [Symbol.iterator] (): Iterator<Uint8Array> {\n    yield * this.bufs\n  }\n\n  get byteLength (): number {\n    return this.length\n  }\n\n  /**\n   * Add one or more `bufs` to the end of this Uint8ArrayList\n   */\n  append (...bufs: Appendable[]): void {\n    this.appendAll(bufs)\n  }\n\n  /**\n   * Add all `bufs` to the end of this Uint8ArrayList\n   */\n  appendAll (bufs: Appendable[]): void {\n    let length = 0\n\n    for (const buf of bufs) {\n      if (buf instanceof Uint8Array) {\n        length += buf.byteLength\n        this.bufs.push(buf)\n      } else if (isUint8ArrayList(buf)) {\n        length += buf.byteLength\n        this.bufs.push(...buf.bufs)\n      } else {\n        throw new Error('Could not append value, must be an Uint8Array or a Uint8ArrayList')\n      }\n    }\n\n    this.length += length\n  }\n\n  /**\n   * Add one or more `bufs` to the start of this Uint8ArrayList\n   */\n  prepend (...bufs: Appendable[]): void {\n    this.prependAll(bufs)\n  }\n\n  /**\n   * Add all `bufs` to the start of this Uint8ArrayList\n   */\n  prependAll (bufs: Appendable[]): void {\n    let length = 0\n\n    for (const buf of bufs.reverse()) {\n      if (buf instanceof Uint8Array) {\n        length += buf.byteLength\n        this.bufs.unshift(buf)\n      } else if (isUint8ArrayList(buf)) {\n        length += buf.byteLength\n        this.bufs.unshift(...buf.bufs)\n      } else {\n        throw new Error('Could not prepend value, must be an Uint8Array or a Uint8ArrayList')\n      }\n    }\n\n    this.length += length\n  }\n\n  /**\n   * Read the value at `index`\n   */\n  get (index: number): number {\n    const res = findBufAndOffset(this.bufs, index)\n\n    return res.buf[res.index]\n  }\n\n  /**\n   * Set the value at `index` to `value`\n   */\n  set (index: number, value: number): void {\n    const res = findBufAndOffset(this.bufs, index)\n\n    res.buf[res.index] = value\n  }\n\n  /**\n   * Copy bytes from `buf` to the index specified by `offset`\n   */\n  write (buf: Appendable, offset: number = 0): void {\n    if (buf instanceof Uint8Array) {\n      for (let i = 0; i < buf.length; i++) {\n        this.set(offset + i, buf[i])\n      }\n    } else if (isUint8ArrayList(buf)) {\n      for (let i = 0; i < buf.length; i++) {\n        this.set(offset + i, buf.get(i))\n      }\n    } else {\n      throw new Error('Could not write value, must be an Uint8Array or a Uint8ArrayList')\n    }\n  }\n\n  /**\n   * Remove bytes from the front of the pool\n   */\n  consume (bytes: number): void {\n    // first, normalize the argument, in accordance with how Buffer does it\n    bytes = Math.trunc(bytes)\n\n    // do nothing if not a positive number\n    if (Number.isNaN(bytes) || bytes <= 0) {\n      return\n    }\n\n    // if consuming all bytes, skip iterating\n    if (bytes === this.byteLength) {\n      this.bufs = []\n      this.length = 0\n      return\n    }\n\n    while (this.bufs.length > 0) {\n      if (bytes >= this.bufs[0].byteLength) {\n        bytes -= this.bufs[0].byteLength\n        this.length -= this.bufs[0].byteLength\n        this.bufs.shift()\n      } else {\n        this.bufs[0] = this.bufs[0].subarray(bytes)\n        this.length -= bytes\n        break\n      }\n    }\n  }\n\n  /**\n   * Extracts a section of an array and returns a new array.\n   *\n   * This is a copy operation as it is with Uint8Arrays and Arrays\n   * - note this is different to the behaviour of Node Buffers.\n   */\n  slice (beginInclusive?: number, endExclusive?: number): Uint8Array {\n    const { bufs, length } = this._subList(beginInclusive, endExclusive)\n\n    return concat(bufs, length)\n  }\n\n  /**\n   * Returns a alloc from the given start and end element index.\n   *\n   * In the best case where the data extracted comes from a single Uint8Array\n   * internally this is a no-copy operation otherwise it is a copy operation.\n   */\n  subarray (beginInclusive?: number, endExclusive?: number): Uint8Array {\n    const { bufs, length } = this._subList(beginInclusive, endExclusive)\n\n    if (bufs.length === 1) {\n      return bufs[0]\n    }\n\n    return concat(bufs, length)\n  }\n\n  /**\n   * Returns a allocList from the given start and end element index.\n   *\n   * This is a no-copy operation.\n   */\n  sublist (beginInclusive?: number, endExclusive?: number): Uint8ArrayList {\n    const { bufs, length } = this._subList(beginInclusive, endExclusive)\n\n    const list = new Uint8ArrayList()\n    list.length = length\n    // don't loop, just set the bufs\n    list.bufs = [...bufs]\n\n    return list\n  }\n\n  private _subList (beginInclusive?: number, endExclusive?: number): { bufs: Uint8Array[], length: number } {\n    beginInclusive = beginInclusive ?? 0\n    endExclusive = endExclusive ?? this.length\n\n    if (beginInclusive < 0) {\n      beginInclusive = this.length + beginInclusive\n    }\n\n    if (endExclusive < 0) {\n      endExclusive = this.length + endExclusive\n    }\n\n    if (beginInclusive < 0 || endExclusive > this.length) {\n      throw new RangeError('index is out of bounds')\n    }\n\n    if (beginInclusive === endExclusive) {\n      return { bufs: [], length: 0 }\n    }\n\n    if (beginInclusive === 0 && endExclusive === this.length) {\n      return { bufs: this.bufs, length: this.length }\n    }\n\n    const bufs: Uint8Array[] = []\n    let offset = 0\n\n    for (let i = 0; i < this.bufs.length; i++) {\n      const buf = this.bufs[i]\n      const bufStart = offset\n      const bufEnd = bufStart + buf.byteLength\n\n      // for next loop\n      offset = bufEnd\n\n      if (beginInclusive >= bufEnd) {\n        // start after this buf\n        continue\n      }\n\n      const sliceStartInBuf = beginInclusive >= bufStart && beginInclusive < bufEnd\n      const sliceEndsInBuf = endExclusive > bufStart && endExclusive <= bufEnd\n\n      if (sliceStartInBuf && sliceEndsInBuf) {\n        // slice is wholly contained within this buffer\n        if (beginInclusive === bufStart && endExclusive === bufEnd) {\n          // requested whole buffer\n          bufs.push(buf)\n          break\n        }\n\n        // requested part of buffer\n        const start = beginInclusive - bufStart\n        bufs.push(buf.subarray(start, start + (endExclusive - beginInclusive)))\n        break\n      }\n\n      if (sliceStartInBuf) {\n        // slice starts in this buffer\n        if (beginInclusive === 0) {\n          // requested whole buffer\n          bufs.push(buf)\n          continue\n        }\n\n        // requested part of buffer\n        bufs.push(buf.subarray(beginInclusive - bufStart))\n        continue\n      }\n\n      if (sliceEndsInBuf) {\n        if (endExclusive === bufEnd) {\n          // requested whole buffer\n          bufs.push(buf)\n          break\n        }\n\n        // requested part of buffer\n        bufs.push(buf.subarray(0, endExclusive - bufStart))\n        break\n      }\n\n      // slice started before this buffer and ends after it\n      bufs.push(buf)\n    }\n\n    return { bufs, length: endExclusive - beginInclusive }\n  }\n\n  indexOf (search: Uint8ArrayList | Uint8Array, offset: number = 0): number {\n    if (!isUint8ArrayList(search) && !(search instanceof Uint8Array)) {\n      throw new TypeError('The \"value\" argument must be a Uint8ArrayList or Uint8Array')\n    }\n\n    const needle = search instanceof Uint8Array ? search : search.subarray()\n\n    offset = Number(offset ?? 0)\n\n    if (isNaN(offset)) {\n      offset = 0\n    }\n\n    if (offset < 0) {\n      offset = this.length + offset\n    }\n\n    if (offset < 0) {\n      offset = 0\n    }\n\n    if (search.length === 0) {\n      return offset > this.length ? this.length : offset\n    }\n\n    // https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_string-search_algorithm\n    const M: number = needle.byteLength\n\n    if (M === 0) {\n      throw new TypeError('search must be at least 1 byte long')\n    }\n\n    // radix\n    const radix: number = 256\n    const rightmostPositions: Int32Array = new Int32Array(radix)\n\n    // position of the rightmost occurrence of the byte c in the pattern\n    for (let c: number = 0; c < radix; c++) {\n      // -1 for bytes not in pattern\n      rightmostPositions[c] = -1\n    }\n\n    for (let j = 0; j < M; j++) {\n      // rightmost position for bytes in pattern\n      rightmostPositions[needle[j]] = j\n    }\n\n    // Return offset of first match, -1 if no match\n    const right = rightmostPositions\n    const lastIndex = this.byteLength - needle.byteLength\n    const lastPatIndex = needle.byteLength - 1\n    let skip: number\n\n    for (let i = offset; i <= lastIndex; i += skip) {\n      skip = 0\n\n      for (let j = lastPatIndex; j >= 0; j--) {\n        const char: number = this.get(i + j)\n\n        if (needle[j] !== char) {\n          skip = Math.max(1, j - right[char])\n          break\n        }\n      }\n\n      if (skip === 0) {\n        return i\n      }\n    }\n\n    return -1\n  }\n\n  getInt8 (byteOffset: number): number {\n    const buf = this.subarray(byteOffset, byteOffset + 1)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n\n    return view.getInt8(0)\n  }\n\n  setInt8 (byteOffset: number, value: number): void {\n    const buf = allocUnsafe(1)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n    view.setInt8(0, value)\n\n    this.write(buf, byteOffset)\n  }\n\n  getInt16 (byteOffset: number, littleEndian?: boolean): number {\n    const buf = this.subarray(byteOffset, byteOffset + 2)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n\n    return view.getInt16(0, littleEndian)\n  }\n\n  setInt16 (byteOffset: number, value: number, littleEndian?: boolean): void {\n    const buf = alloc(2)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n    view.setInt16(0, value, littleEndian)\n\n    this.write(buf, byteOffset)\n  }\n\n  getInt32 (byteOffset: number, littleEndian?: boolean): number {\n    const buf = this.subarray(byteOffset, byteOffset + 4)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n\n    return view.getInt32(0, littleEndian)\n  }\n\n  setInt32 (byteOffset: number, value: number, littleEndian?: boolean): void {\n    const buf = alloc(4)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n    view.setInt32(0, value, littleEndian)\n\n    this.write(buf, byteOffset)\n  }\n\n  getBigInt64 (byteOffset: number, littleEndian?: boolean): bigint {\n    const buf = this.subarray(byteOffset, byteOffset + 8)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n\n    return view.getBigInt64(0, littleEndian)\n  }\n\n  setBigInt64 (byteOffset: number, value: bigint, littleEndian?: boolean): void {\n    const buf = alloc(8)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n    view.setBigInt64(0, value, littleEndian)\n\n    this.write(buf, byteOffset)\n  }\n\n  getUint8 (byteOffset: number): number {\n    const buf = this.subarray(byteOffset, byteOffset + 1)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n\n    return view.getUint8(0)\n  }\n\n  setUint8 (byteOffset: number, value: number): void {\n    const buf = allocUnsafe(1)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n    view.setUint8(0, value)\n\n    this.write(buf, byteOffset)\n  }\n\n  getUint16 (byteOffset: number, littleEndian?: boolean): number {\n    const buf = this.subarray(byteOffset, byteOffset + 2)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n\n    return view.getUint16(0, littleEndian)\n  }\n\n  setUint16 (byteOffset: number, value: number, littleEndian?: boolean): void {\n    const buf = alloc(2)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n    view.setUint16(0, value, littleEndian)\n\n    this.write(buf, byteOffset)\n  }\n\n  getUint32 (byteOffset: number, littleEndian?: boolean): number {\n    const buf = this.subarray(byteOffset, byteOffset + 4)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n\n    return view.getUint32(0, littleEndian)\n  }\n\n  setUint32 (byteOffset: number, value: number, littleEndian?: boolean): void {\n    const buf = alloc(4)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n    view.setUint32(0, value, littleEndian)\n\n    this.write(buf, byteOffset)\n  }\n\n  getBigUint64 (byteOffset: number, littleEndian?: boolean): bigint {\n    const buf = this.subarray(byteOffset, byteOffset + 8)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n\n    return view.getBigUint64(0, littleEndian)\n  }\n\n  setBigUint64 (byteOffset: number, value: bigint, littleEndian?: boolean): void {\n    const buf = alloc(8)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n    view.setBigUint64(0, value, littleEndian)\n\n    this.write(buf, byteOffset)\n  }\n\n  getFloat32 (byteOffset: number, littleEndian?: boolean): number {\n    const buf = this.subarray(byteOffset, byteOffset + 4)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n\n    return view.getFloat32(0, littleEndian)\n  }\n\n  setFloat32 (byteOffset: number, value: number, littleEndian?: boolean): void {\n    const buf = alloc(4)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n    view.setFloat32(0, value, littleEndian)\n\n    this.write(buf, byteOffset)\n  }\n\n  getFloat64 (byteOffset: number, littleEndian?: boolean): number {\n    const buf = this.subarray(byteOffset, byteOffset + 8)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n\n    return view.getFloat64(0, littleEndian)\n  }\n\n  setFloat64 (byteOffset: number, value: number, littleEndian?: boolean): void {\n    const buf = alloc(8)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n    view.setFloat64(0, value, littleEndian)\n\n    this.write(buf, byteOffset)\n  }\n\n  equals (other: any): other is Uint8ArrayList {\n    if (other == null) {\n      return false\n    }\n\n    if (!(other instanceof Uint8ArrayList)) {\n      return false\n    }\n\n    if (other.bufs.length !== this.bufs.length) {\n      return false\n    }\n\n    for (let i = 0; i < this.bufs.length; i++) {\n      if (!equals(this.bufs[i], other.bufs[i])) {\n        return false\n      }\n    }\n\n    return true\n  }\n\n  /**\n   * Create a Uint8ArrayList from a pre-existing list of Uint8Arrays.  Use this\n   * method if you know the total size of all the Uint8Arrays ahead of time.\n   */\n  static fromUint8Arrays (bufs: Uint8Array[], length?: number): Uint8ArrayList {\n    const list = new Uint8ArrayList()\n    list.bufs = bufs\n\n    if (length == null) {\n      length = bufs.reduce((acc, curr) => acc + curr.byteLength, 0)\n    }\n\n    list.length = length\n\n    return list\n  }\n}\n\n/*\nfunction indexOf (needle: Uint8Array, haystack: Uint8Array, offset = 0) {\n  for (let i = offset; i < haystack.byteLength; i++) {\n    for (let j = 0; j < needle.length; j++) {\n      if (haystack[i + j] !== needle[j]) {\n        break\n      }\n\n      if (j === needle.byteLength -1) {\n        return i\n      }\n    }\n\n    if (haystack.byteLength - i < needle.byteLength) {\n      break\n    }\n  }\n\n  return -1\n}\n*/\n", "import { Uint8ArrayList } from 'uint8arraylist'\nimport type { Chunker } from './index.js'\n\nexport interface FixedSizeOptions {\n  chunkSize?: number\n}\n\nconst DEFAULT_CHUNK_SIZE = 262144\n\nexport const fixedSize = (options: FixedSizeOptions = {}): Chunker => {\n  const chunkSize = options.chunkSize ?? DEFAULT_CHUNK_SIZE\n\n  return async function * fixedSizeChunker (source) {\n    let list = new Uint8ArrayList()\n    let currentLength = 0\n    let emitted = false\n\n    for await (const buffer of source) {\n      list.append(buffer)\n\n      currentLength += buffer.length\n\n      while (currentLength >= chunkSize) {\n        yield list.slice(0, chunkSize)\n        emitted = true\n\n        // throw away consumed bytes\n        if (chunkSize === list.length) {\n          list = new Uint8ArrayList()\n          currentLength = 0\n        } else {\n          const newBl = new Uint8ArrayList()\n          newBl.append(list.sublist(chunkSize))\n          list = newBl\n\n          // update our offset\n          currentLength -= chunkSize\n        }\n      }\n    }\n\n    if (!emitted || currentLength > 0) {\n      // return any remaining bytes\n      yield list.subarray(0, currentLength)\n    }\n  }\n}\n", "import { CID } from 'multiformats/cid'\nimport { decodeNode } from './pb-decode.js'\nimport { encodeNode } from './pb-encode.js'\nimport { prepare, validate, createNode, createLink, toByteView } from './util.js'\n\n/**\n * @template T\n * @typedef {import('multiformats/codecs/interface').ByteView<T>} ByteView\n */\n\n/**\n * @template T\n * @typedef {import('multiformats/codecs/interface').ArrayBufferView<T>} ArrayBufferView\n */\n\n/**\n * @typedef {import('./interface.js').PBLink} PBLink\n * @typedef {import('./interface.js').PBNode} PBNode\n */\n\nexport const name = 'dag-pb'\nexport const code = 0x70\n\n/**\n * @param {PBNode} node\n * @returns {ByteView<PBNode>}\n */\nexport function encode (node) {\n  validate(node)\n\n  const pbn = {}\n  if (node.Links) {\n    pbn.Links = node.Links.map((l) => {\n      const link = {}\n      if (l.Hash) {\n        link.Hash = l.Hash.bytes // cid -> bytes\n      }\n      if (l.Name !== undefined) {\n        link.Name = l.Name\n      }\n      if (l.Tsize !== undefined) {\n        link.Tsize = l.Tsize\n      }\n      return link\n    })\n  }\n  if (node.Data) {\n    pbn.Data = node.Data\n  }\n\n  return encodeNode(pbn)\n}\n\n/**\n * @param {ByteView<PBNode> | ArrayBufferView<PBNode>} bytes\n * @returns {PBNode}\n */\nexport function decode (bytes) {\n  const buf = toByteView(bytes)\n  const pbn = decodeNode(buf)\n\n  const node = {}\n\n  if (pbn.Data) {\n    node.Data = pbn.Data\n  }\n\n  if (pbn.Links) {\n    node.Links = pbn.Links.map((l) => {\n      const link = {}\n      try {\n        link.Hash = CID.decode(l.Hash)\n      } catch {\n        // ignore parse fail\n      }\n      if (!link.Hash) {\n        throw new Error('Invalid Hash field found in link, expected CID')\n      }\n      if (l.Name !== undefined) {\n        link.Name = l.Name\n      }\n      if (l.Tsize !== undefined) {\n        link.Tsize = l.Tsize\n      }\n      return link\n    })\n  }\n\n  return node\n}\n\nexport { prepare, validate, createNode, createLink }\n", "import { rfc4648 } from './base.js'\n\nexport const base32 = rfc4648({\n  prefix: 'b',\n  name: 'base32',\n  alphabet: 'abcdefghijklmnopqrstuvwxyz234567',\n  bitsPerChar: 5\n})\n\nexport const base32upper = rfc4648({\n  prefix: 'B',\n  name: 'base32upper',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567',\n  bitsPerChar: 5\n})\n\nexport const base32pad = rfc4648({\n  prefix: 'c',\n  name: 'base32pad',\n  alphabet: 'abcdefghijklmnopqrstuvwxyz234567=',\n  bitsPerChar: 5\n})\n\nexport const base32padupper = rfc4648({\n  prefix: 'C',\n  name: 'base32padupper',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=',\n  bitsPerChar: 5\n})\n\nexport const base32hex = rfc4648({\n  prefix: 'v',\n  name: 'base32hex',\n  alphabet: '0123456789abcdefghijklmnopqrstuv',\n  bitsPerChar: 5\n})\n\nexport const base32hexupper = rfc4648({\n  prefix: 'V',\n  name: 'base32hexupper',\n  alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV',\n  bitsPerChar: 5\n})\n\nexport const base32hexpad = rfc4648({\n  prefix: 't',\n  name: 'base32hexpad',\n  alphabet: '0123456789abcdefghijklmnopqrstuv=',\n  bitsPerChar: 5\n})\n\nexport const base32hexpadupper = rfc4648({\n  prefix: 'T',\n  name: 'base32hexpadupper',\n  alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV=',\n  bitsPerChar: 5\n})\n\nexport const base32z = rfc4648({\n  prefix: 'h',\n  name: 'base32z',\n  alphabet: 'ybndrfg8ejkmcpqxot1uwisza345h769',\n  bitsPerChar: 5\n})\n", "export const empty = new Uint8Array(0)\n\nexport function toHex (d: Uint8Array): string {\n  return d.reduce((hex, byte) => hex + byte.toString(16).padStart(2, '0'), '')\n}\n\nexport function fromHex (hex: string): Uint8Array {\n  const hexes = hex.match(/../g)\n  return hexes != null ? new Uint8Array(hexes.map(b => parseInt(b, 16))) : empty\n}\n\nexport function equals (aa: Uint8Array, bb: Uint8Array): boolean {\n  if (aa === bb) { return true }\n  if (aa.byteLength !== bb.byteLength) {\n    return false\n  }\n\n  for (let ii = 0; ii < aa.byteLength; ii++) {\n    if (aa[ii] !== bb[ii]) {\n      return false\n    }\n  }\n\n  return true\n}\n\nexport function coerce (o: ArrayBufferView | ArrayBuffer | Uint8Array): Uint8Array {\n  if (o instanceof Uint8Array && o.constructor.name === 'Uint8Array') { return o }\n  if (o instanceof ArrayBuffer) { return new Uint8Array(o) }\n  if (ArrayBuffer.isView(o)) {\n    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength)\n  }\n  throw new Error('Unknown type, must be binary type')\n}\n\nexport function isBinary (o: unknown): o is ArrayBuffer | ArrayBufferView {\n  return o instanceof ArrayBuffer || ArrayBuffer.isView(o)\n}\n\nexport function fromString (str: string): Uint8Array {\n  return new TextEncoder().encode(str)\n}\n\nexport function toString (b: Uint8Array): string {\n  return new TextDecoder().decode(b)\n}\n", "/* eslint-disable */\n// base-x encoding / decoding\n// Copyright (c) 2018 base-x contributors\n// Copyright (c) 2014-2018 The Bitcoin Core developers (base58.cpp)\n// Distributed under the MIT software license, see the accompanying\n// file LICENSE or http://www.opensource.org/licenses/mit-license.php.\n/**\n * @param {string} ALPHABET\n * @param {any} name\n */\nfunction base (ALPHABET, name) {\n  if (ALPHABET.length >= 255) { throw new TypeError('Alphabet too long') }\n  var BASE_MAP = new Uint8Array(256);\n  for (var j = 0; j < BASE_MAP.length; j++) {\n    BASE_MAP[j] = 255;\n  }\n  for (var i = 0; i < ALPHABET.length; i++) {\n    var x = ALPHABET.charAt(i);\n    var xc = x.charCodeAt(0);\n    if (BASE_MAP[xc] !== 255) { throw new TypeError(x + ' is ambiguous') }\n    BASE_MAP[xc] = i;\n  }\n  var BASE = ALPHABET.length;\n  var LEADER = ALPHABET.charAt(0);\n  var FACTOR = Math.log(BASE) / Math.log(256); // log(BASE) / log(256), rounded up\n  var iFACTOR = Math.log(256) / Math.log(BASE); // log(256) / log(BASE), rounded up\n  /**\n   * @param {any[] | Iterable<number>} source\n   */\n  function encode (source) {\n    // @ts-ignore\n    if (source instanceof Uint8Array) ; else if (ArrayBuffer.isView(source)) {\n      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);\n    } else if (Array.isArray(source)) {\n      source = Uint8Array.from(source);\n    }\n    if (!(source instanceof Uint8Array)) { throw new TypeError('Expected Uint8Array') }\n    if (source.length === 0) { return '' }\n        // Skip & count leading zeroes.\n    var zeroes = 0;\n    var length = 0;\n    var pbegin = 0;\n    var pend = source.length;\n    while (pbegin !== pend && source[pbegin] === 0) {\n      pbegin++;\n      zeroes++;\n    }\n        // Allocate enough space in big-endian base58 representation.\n    var size = ((pend - pbegin) * iFACTOR + 1) >>> 0;\n    var b58 = new Uint8Array(size);\n        // Process the bytes.\n    while (pbegin !== pend) {\n      var carry = source[pbegin];\n            // Apply \"b58 = b58 * 256 + ch\".\n      var i = 0;\n      for (var it1 = size - 1; (carry !== 0 || i < length) && (it1 !== -1); it1--, i++) {\n        carry += (256 * b58[it1]) >>> 0;\n        b58[it1] = (carry % BASE) >>> 0;\n        carry = (carry / BASE) >>> 0;\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i;\n      pbegin++;\n    }\n        // Skip leading zeroes in base58 result.\n    var it2 = size - length;\n    while (it2 !== size && b58[it2] === 0) {\n      it2++;\n    }\n        // Translate the result into a string.\n    var str = LEADER.repeat(zeroes);\n    for (; it2 < size; ++it2) { str += ALPHABET.charAt(b58[it2]); }\n    return str\n  }\n  /**\n   * @param {string | string[]} source\n   */\n  function decodeUnsafe (source) {\n    if (typeof source !== 'string') { throw new TypeError('Expected String') }\n    if (source.length === 0) { return new Uint8Array() }\n    var psz = 0;\n        // Skip leading spaces.\n    if (source[psz] === ' ') { return }\n        // Skip and count leading '1's.\n    var zeroes = 0;\n    var length = 0;\n    while (source[psz] === LEADER) {\n      zeroes++;\n      psz++;\n    }\n        // Allocate enough space in big-endian base256 representation.\n    var size = (((source.length - psz) * FACTOR) + 1) >>> 0; // log(58) / log(256), rounded up.\n    var b256 = new Uint8Array(size);\n        // Process the characters.\n    while (source[psz]) {\n            // Decode character\n      var carry = BASE_MAP[source.charCodeAt(psz)];\n            // Invalid character\n      if (carry === 255) { return }\n      var i = 0;\n      for (var it3 = size - 1; (carry !== 0 || i < length) && (it3 !== -1); it3--, i++) {\n        carry += (BASE * b256[it3]) >>> 0;\n        b256[it3] = (carry % 256) >>> 0;\n        carry = (carry / 256) >>> 0;\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i;\n      psz++;\n    }\n        // Skip trailing spaces.\n    if (source[psz] === ' ') { return }\n        // Skip leading zeroes in b256.\n    var it4 = size - length;\n    while (it4 !== size && b256[it4] === 0) {\n      it4++;\n    }\n    var vch = new Uint8Array(zeroes + (size - it4));\n    var j = zeroes;\n    while (it4 !== size) {\n      vch[j++] = b256[it4++];\n    }\n    return vch\n  }\n  /**\n   * @param {string | string[]} string\n   */\n  function decode (string) {\n    var buffer = decodeUnsafe(string);\n    if (buffer) { return buffer }\n    throw new Error(`Non-${name} character`)\n  }\n  return {\n    encode: encode,\n    decodeUnsafe: decodeUnsafe,\n    decode: decode\n  }\n}\nvar src = base;\n\nvar _brrp__multiformats_scope_baseX = src;\n\nexport default _brrp__multiformats_scope_baseX;\n", "import { coerce } from '../bytes.js'\nimport basex from '../vendor/base-x.js'\nimport type { BaseCodec, BaseDecoder, BaseEncoder, CombobaseDecoder, Multibase, MultibaseCodec, MultibaseDecoder, MultibaseEncoder, UnibaseDecoder } from './interface.js'\n\ninterface EncodeFn { (bytes: Uint8Array): string }\ninterface DecodeFn { (text: string): Uint8Array }\n\n/**\n * Class represents both BaseEncoder and MultibaseEncoder meaning it\n * can be used to encode to multibase or base encode without multibase\n * prefix.\n */\nclass Encoder<Base extends string, Prefix extends string> implements MultibaseEncoder<Prefix>, BaseEncoder {\n  readonly name: Base\n  readonly prefix: Prefix\n  readonly baseEncode: EncodeFn\n\n  constructor (name: Base, prefix: Prefix, baseEncode: EncodeFn) {\n    this.name = name\n    this.prefix = prefix\n    this.baseEncode = baseEncode\n  }\n\n  encode (bytes: Uint8Array): Multibase<Prefix> {\n    if (bytes instanceof Uint8Array) {\n      return `${this.prefix}${this.baseEncode(bytes)}`\n    } else {\n      throw Error('Unknown type, must be binary type')\n    }\n  }\n}\n\n/**\n * Class represents both BaseDecoder and MultibaseDecoder so it could be used\n * to decode multibases (with matching prefix) or just base decode strings\n * with corresponding base encoding.\n */\nclass Decoder<Base extends string, Prefix extends string> implements MultibaseDecoder<Prefix>, UnibaseDecoder<Prefix>, BaseDecoder {\n  readonly name: Base\n  readonly prefix: Prefix\n  readonly baseDecode: DecodeFn\n  private readonly prefixCodePoint: number\n\n  constructor (name: Base, prefix: Prefix, baseDecode: DecodeFn) {\n    this.name = name\n    this.prefix = prefix\n    const prefixCodePoint = prefix.codePointAt(0)\n    /* c8 ignore next 3 */\n    if (prefixCodePoint === undefined) {\n      throw new Error('Invalid prefix character')\n    }\n    this.prefixCodePoint = prefixCodePoint\n    this.baseDecode = baseDecode\n  }\n\n  decode (text: string): Uint8Array {\n    if (typeof text === 'string') {\n      if (text.codePointAt(0) !== this.prefixCodePoint) {\n        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`)\n      }\n      return this.baseDecode(text.slice(this.prefix.length))\n    } else {\n      throw Error('Can only multibase decode strings')\n    }\n  }\n\n  or<OtherPrefix extends string> (decoder: UnibaseDecoder<OtherPrefix> | ComposedDecoder<OtherPrefix>): ComposedDecoder<Prefix | OtherPrefix> {\n    return or(this, decoder)\n  }\n}\n\ntype Decoders<Prefix extends string> = Record<Prefix, UnibaseDecoder<Prefix>>\n\nclass ComposedDecoder<Prefix extends string> implements MultibaseDecoder<Prefix>, CombobaseDecoder<Prefix> {\n  readonly decoders: Decoders<Prefix>\n\n  constructor (decoders: Decoders<Prefix>) {\n    this.decoders = decoders\n  }\n\n  or <OtherPrefix extends string> (decoder: UnibaseDecoder<OtherPrefix> | ComposedDecoder<OtherPrefix>): ComposedDecoder<Prefix | OtherPrefix> {\n    return or(this, decoder)\n  }\n\n  decode (input: string): Uint8Array {\n    const prefix = input[0] as Prefix\n    const decoder = this.decoders[prefix]\n    if (decoder != null) {\n      return decoder.decode(input)\n    } else {\n      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)\n    }\n  }\n}\n\nexport function or <L extends string, R extends string> (left: UnibaseDecoder<L> | CombobaseDecoder<L>, right: UnibaseDecoder<R> | CombobaseDecoder<R>): ComposedDecoder<L | R> {\n  return new ComposedDecoder({\n    ...(left.decoders ?? { [(left as UnibaseDecoder<L>).prefix]: left }),\n    ...(right.decoders ?? { [(right as UnibaseDecoder<R>).prefix]: right })\n  } as Decoders<L | R>)\n}\n\nexport class Codec<Base extends string, Prefix extends string> implements MultibaseCodec<Prefix>, MultibaseEncoder<Prefix>, MultibaseDecoder<Prefix>, BaseCodec, BaseEncoder, BaseDecoder {\n  readonly name: Base\n  readonly prefix: Prefix\n  readonly baseEncode: EncodeFn\n  readonly baseDecode: DecodeFn\n  readonly encoder: Encoder<Base, Prefix>\n  readonly decoder: Decoder<Base, Prefix>\n\n  constructor (name: Base, prefix: Prefix, baseEncode: EncodeFn, baseDecode: DecodeFn) {\n    this.name = name\n    this.prefix = prefix\n    this.baseEncode = baseEncode\n    this.baseDecode = baseDecode\n    this.encoder = new Encoder(name, prefix, baseEncode)\n    this.decoder = new Decoder(name, prefix, baseDecode)\n  }\n\n  encode (input: Uint8Array): string {\n    return this.encoder.encode(input)\n  }\n\n  decode (input: string): Uint8Array {\n    return this.decoder.decode(input)\n  }\n}\n\nexport function from <Base extends string, Prefix extends string> ({ name, prefix, encode, decode }: { name: Base, prefix: Prefix, encode: EncodeFn, decode: DecodeFn }): Codec<Base, Prefix> {\n  return new Codec(name, prefix, encode, decode)\n}\n\nexport function baseX <Base extends string, Prefix extends string> ({ name, prefix, alphabet }: { name: Base, prefix: Prefix, alphabet: string }): Codec<Base, Prefix> {\n  const { encode, decode } = basex(alphabet, name)\n  return from({\n    prefix,\n    name,\n    encode,\n    decode: (text: string): Uint8Array => coerce(decode(text))\n  })\n}\n\nfunction decode (string: string, alphabetIdx: Record<string, number>, bitsPerChar: number, name: string): Uint8Array {\n  // Count the padding bytes:\n  let end = string.length\n  while (string[end - 1] === '=') {\n    --end\n  }\n\n  // Allocate the output:\n  const out = new Uint8Array((end * bitsPerChar / 8) | 0)\n\n  // Parse the data:\n  let bits = 0 // Number of bits currently in the buffer\n  let buffer = 0 // Bits waiting to be written out, MSB first\n  let written = 0 // Next byte to write\n  for (let i = 0; i < end; ++i) {\n    // Read one character from the string:\n    const value = alphabetIdx[string[i]]\n    if (value === undefined) {\n      throw new SyntaxError(`Non-${name} character`)\n    }\n\n    // Append the bits to the buffer:\n    buffer = (buffer << bitsPerChar) | value\n    bits += bitsPerChar\n\n    // Write out some bits if the buffer has a byte's worth:\n    if (bits >= 8) {\n      bits -= 8\n      out[written++] = 0xff & (buffer >> bits)\n    }\n  }\n\n  // Verify that we have received just enough bits:\n  if (bits >= bitsPerChar || (0xff & (buffer << (8 - bits))) !== 0) {\n    throw new SyntaxError('Unexpected end of data')\n  }\n\n  return out\n}\n\nfunction encode (data: Uint8Array, alphabet: string, bitsPerChar: number): string {\n  const pad = alphabet[alphabet.length - 1] === '='\n  const mask = (1 << bitsPerChar) - 1\n  let out = ''\n\n  let bits = 0 // Number of bits currently in the buffer\n  let buffer = 0 // Bits waiting to be written out, MSB first\n  for (let i = 0; i < data.length; ++i) {\n    // Slurp data into the buffer:\n    buffer = (buffer << 8) | data[i]\n    bits += 8\n\n    // Write out as much as we can:\n    while (bits > bitsPerChar) {\n      bits -= bitsPerChar\n      out += alphabet[mask & (buffer >> bits)]\n    }\n  }\n\n  // Partial character:\n  if (bits !== 0) {\n    out += alphabet[mask & (buffer << (bitsPerChar - bits))]\n  }\n\n  // Add padding characters until we hit a byte boundary:\n  if (pad) {\n    while (((out.length * bitsPerChar) & 7) !== 0) {\n      out += '='\n    }\n  }\n\n  return out\n}\n\nfunction createAlphabetIdx (alphabet: string): Record<string, number> {\n  // Build the character lookup table:\n  const alphabetIdx: Record<string, number> = {}\n  for (let i = 0; i < alphabet.length; ++i) {\n    alphabetIdx[alphabet[i]] = i\n  }\n  return alphabetIdx\n}\n\n/**\n * RFC4648 Factory\n */\nexport function rfc4648 <Base extends string, Prefix extends string> ({ name, prefix, bitsPerChar, alphabet }: { name: Base, prefix: Prefix, bitsPerChar: number, alphabet: string }): Codec<Base, Prefix> {\n  const alphabetIdx = createAlphabetIdx(alphabet)\n  return from({\n    prefix,\n    name,\n    encode (input: Uint8Array): string {\n      return encode(input, alphabet, bitsPerChar)\n    },\n    decode (input: string): Uint8Array {\n      return decode(input, alphabetIdx, bitsPerChar, name)\n    }\n  })\n}\n", "import { baseX } from './base.js'\n\nexport const base36 = baseX({\n  prefix: 'k',\n  name: 'base36',\n  alphabet: '0123456789abcdefghijklmnopqrstuvwxyz'\n})\n\nexport const base36upper = baseX({\n  prefix: 'K',\n  name: 'base36upper',\n  alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n})\n", "import { baseX } from './base.js'\n\nexport const base58btc = baseX({\n  name: 'base58btc',\n  prefix: 'z',\n  alphabet: '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'\n})\n\nexport const base58flickr = baseX({\n  name: 'base58flickr',\n  prefix: 'Z',\n  alphabet: '123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ'\n})\n", "/* eslint-disable */\nvar encode_1 = encode;\n\nvar MSB = 0x80\n  , REST = 0x7F\n  , MSBALL = ~REST\n  , INT = Math.pow(2, 31);\n\n/**\n * @param {number} num\n * @param {number[]} out\n * @param {number} offset\n */\nfunction encode(num, out, offset) {\n  out = out || [];\n  offset = offset || 0;\n  var oldOffset = offset;\n\n  while(num >= INT) {\n    out[offset++] = (num & 0xFF) | MSB;\n    num /= 128;\n  }\n  while(num & MSBALL) {\n    out[offset++] = (num & 0xFF) | MSB;\n    num >>>= 7;\n  }\n  out[offset] = num | 0;\n  \n  // @ts-ignore\n  encode.bytes = offset - oldOffset + 1;\n  \n  return out\n}\n\nvar decode = read;\n\nvar MSB$1 = 0x80\n  , REST$1 = 0x7F;\n\n/**\n * @param {string | any[]} buf\n * @param {number} offset\n */\nfunction read(buf, offset) {\n  var res    = 0\n    , offset = offset || 0\n    , shift  = 0\n    , counter = offset\n    , b\n    , l = buf.length;\n\n  do {\n    if (counter >= l) {\n      // @ts-ignore\n      read.bytes = 0;\n      throw new RangeError('Could not decode varint')\n    }\n    b = buf[counter++];\n    res += shift < 28\n      ? (b & REST$1) << shift\n      : (b & REST$1) * Math.pow(2, shift);\n    shift += 7;\n  } while (b >= MSB$1)\n\n  // @ts-ignore\n  read.bytes = counter - offset;\n\n  return res\n}\n\nvar N1 = Math.pow(2,  7);\nvar N2 = Math.pow(2, 14);\nvar N3 = Math.pow(2, 21);\nvar N4 = Math.pow(2, 28);\nvar N5 = Math.pow(2, 35);\nvar N6 = Math.pow(2, 42);\nvar N7 = Math.pow(2, 49);\nvar N8 = Math.pow(2, 56);\nvar N9 = Math.pow(2, 63);\n\nvar length = function (/** @type {number} */ value) {\n  return (\n    value < N1 ? 1\n  : value < N2 ? 2\n  : value < N3 ? 3\n  : value < N4 ? 4\n  : value < N5 ? 5\n  : value < N6 ? 6\n  : value < N7 ? 7\n  : value < N8 ? 8\n  : value < N9 ? 9\n  :              10\n  )\n};\n\nvar varint = {\n    encode: encode_1\n  , decode: decode\n  , encodingLength: length\n};\n\nvar _brrp_varint = varint;\n\nexport default _brrp_varint;\n", "import varint from './vendor/varint.js'\n\nexport function decode (data: Uint8Array, offset = 0): [number, number] {\n  const code = varint.decode(data, offset)\n  return [code, varint.decode.bytes]\n}\n\nexport function encodeTo (int: number, target: Uint8Array, offset = 0): Uint8Array {\n  varint.encode(int, target, offset)\n  return target\n}\n\nexport function encodingLength (int: number): number {\n  return varint.encodingLength(int)\n}\n", "import { coerce, equals as equalBytes } from '../bytes.js'\nimport * as varint from '../varint.js'\nimport type { MultihashDigest } from './interface.js'\n\n/**\n * Creates a multihash digest.\n */\nexport function create <Code extends number> (code: Code, digest: Uint8Array): Digest<Code, number> {\n  const size = digest.byteLength\n  const sizeOffset = varint.encodingLength(code)\n  const digestOffset = sizeOffset + varint.encodingLength(size)\n\n  const bytes = new Uint8Array(digestOffset + size)\n  varint.encodeTo(code, bytes, 0)\n  varint.encodeTo(size, bytes, sizeOffset)\n  bytes.set(digest, digestOffset)\n\n  return new Digest(code, size, digest, bytes)\n}\n\n/**\n * Turns bytes representation of multihash digest into an instance.\n */\nexport function decode (multihash: Uint8Array): MultihashDigest {\n  const bytes = coerce(multihash)\n  const [code, sizeOffset] = varint.decode(bytes)\n  const [size, digestOffset] = varint.decode(bytes.subarray(sizeOffset))\n  const digest = bytes.subarray(sizeOffset + digestOffset)\n\n  if (digest.byteLength !== size) {\n    throw new Error('Incorrect length')\n  }\n\n  return new Digest(code, size, digest, bytes)\n}\n\nexport function equals (a: MultihashDigest, b: unknown): b is MultihashDigest {\n  if (a === b) {\n    return true\n  } else {\n    const data = b as { code?: unknown, size?: unknown, bytes?: unknown }\n\n    return (\n      a.code === data.code &&\n      a.size === data.size &&\n      data.bytes instanceof Uint8Array &&\n      equalBytes(a.bytes, data.bytes)\n    )\n  }\n}\n\n/**\n * Represents a multihash digest which carries information about the\n * hashing algorithm and an actual hash digest.\n */\nexport class Digest<Code extends number, Size extends number> implements MultihashDigest {\n  readonly code: Code\n  readonly size: Size\n  readonly digest: Uint8Array\n  readonly bytes: Uint8Array\n\n  /**\n   * Creates a multihash digest.\n   */\n  constructor (code: Code, size: Size, digest: Uint8Array, bytes: Uint8Array) {\n    this.code = code\n    this.size = size\n    this.digest = digest\n    this.bytes = bytes\n  }\n}\n\n/**\n * Used to check that the passed multihash has the passed code\n */\nexport function hasCode <T extends number> (digest: MultihashDigest, code: T): digest is MultihashDigest<T> {\n  return digest.code === code\n}\n", "import { base32 } from './bases/base32.js'\nimport { base36 } from './bases/base36.js'\nimport { base58btc } from './bases/base58.js'\nimport { coerce } from './bytes.js'\nimport * as Digest from './hashes/digest.js'\nimport * as varint from './varint.js'\nimport type * as API from './link/interface.js'\n\n// This way TS will also expose all the types from module\nexport * from './link/interface.js'\n\nexport function format <T extends API.Link<unknown, number, number, API.Version>, Prefix extends string> (link: T, base?: API.MultibaseEncoder<Prefix>): API.ToString<T, Prefix> {\n  const { bytes, version } = link\n  switch (version) {\n    case 0:\n      return toStringV0(\n        bytes,\n        baseCache(link),\n        base as API.MultibaseEncoder<'z'> ?? base58btc.encoder\n      )\n    default:\n      return toStringV1(\n        bytes,\n        baseCache(link),\n        (base ?? base32.encoder) as API.MultibaseEncoder<Prefix>\n      )\n  }\n}\n\nexport function toJSON <Link extends API.UnknownLink> (link: Link): API.LinkJSON<Link> {\n  return {\n    '/': format(link)\n  }\n}\n\nexport function fromJSON <Link extends API.UnknownLink> (json: API.LinkJSON<Link>): CID<unknown, number, number, API.Version> {\n  return CID.parse(json['/'])\n}\n\nconst cache = new WeakMap<API.UnknownLink, Map<string, string>>()\n\nfunction baseCache (cid: API.UnknownLink): Map<string, string> {\n  const baseCache = cache.get(cid)\n  if (baseCache == null) {\n    const baseCache = new Map()\n    cache.set(cid, baseCache)\n    return baseCache\n  }\n  return baseCache\n}\n\nexport class CID<Data = unknown, Format extends number = number, Alg extends number = number, Version extends API.Version = API.Version> implements API.Link<Data, Format, Alg, Version> {\n  readonly code: Format\n  readonly version: Version\n  readonly multihash: API.MultihashDigest<Alg>\n  readonly bytes: Uint8Array\n  readonly '/': Uint8Array\n\n  /**\n   * @param version - Version of the CID\n   * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv\n   * @param multihash - (Multi)hash of the of the content.\n   */\n  constructor (version: Version, code: Format, multihash: API.MultihashDigest<Alg>, bytes: Uint8Array) {\n    this.code = code\n    this.version = version\n    this.multihash = multihash\n    this.bytes = bytes\n\n    // flag to serializers that this is a CID and\n    // should be treated specially\n    this['/'] = bytes\n  }\n\n  /**\n   * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`\n   * please either use `CID.asCID(cid)` or switch to new signalling mechanism\n   *\n   * @deprecated\n   */\n  get asCID (): this {\n    return this\n  }\n\n  // ArrayBufferView\n  get byteOffset (): number {\n    return this.bytes.byteOffset\n  }\n\n  // ArrayBufferView\n  get byteLength (): number {\n    return this.bytes.byteLength\n  }\n\n  toV0 (): CID<Data, API.DAG_PB, API.SHA_256, 0> {\n    switch (this.version) {\n      case 0: {\n        return this as CID<Data, API.DAG_PB, API.SHA_256, 0>\n      }\n      case 1: {\n        const { code, multihash } = this\n\n        if (code !== DAG_PB_CODE) {\n          throw new Error('Cannot convert a non dag-pb CID to CIDv0')\n        }\n\n        // sha2-256\n        if (multihash.code !== SHA_256_CODE) {\n          throw new Error('Cannot convert non sha2-256 multihash CID to CIDv0')\n        }\n\n        return (\n          CID.createV0(\n            multihash as API.MultihashDigest<API.SHA_256>\n          )\n        )\n      }\n      default: {\n        throw Error(\n          `Can not convert CID version ${this.version} to version 0. This is a bug please report`\n        )\n      }\n    }\n  }\n\n  toV1 (): CID<Data, Format, Alg, 1> {\n    switch (this.version) {\n      case 0: {\n        const { code, digest } = this.multihash\n        const multihash = Digest.create(code, digest)\n        return (\n          CID.createV1(this.code, multihash)\n        )\n      }\n      case 1: {\n        return this as CID<Data, Format, Alg, 1>\n      }\n      default: {\n        throw Error(\n          `Can not convert CID version ${this.version} to version 1. This is a bug please report`\n        )\n      }\n    }\n  }\n\n  equals (other: unknown): other is CID<Data, Format, Alg, Version> {\n    return CID.equals(this, other)\n  }\n\n  static equals <Data, Format extends number, Alg extends number, Version extends API.Version>(self: API.Link<Data, Format, Alg, Version>, other: unknown): other is CID {\n    const unknown = other as { code?: unknown, version?: unknown, multihash?: unknown }\n    return (\n      unknown != null &&\n      self.code === unknown.code &&\n      self.version === unknown.version &&\n      Digest.equals(self.multihash, unknown.multihash)\n    )\n  }\n\n  toString (base?: API.MultibaseEncoder<string>): string {\n    return format(this, base)\n  }\n\n  toJSON (): API.LinkJSON<this> {\n    return { '/': format(this) }\n  }\n\n  link (): this {\n    return this\n  }\n\n  readonly [Symbol.toStringTag] = 'CID';\n\n  // Legacy\n\n  [Symbol.for('nodejs.util.inspect.custom')] (): string {\n    return `CID(${this.toString()})`\n  }\n\n  /**\n   * Takes any input `value` and returns a `CID` instance if it was\n   * a `CID` otherwise returns `null`. If `value` is instanceof `CID`\n   * it will return value back. If `value` is not instance of this CID\n   * class, but is compatible CID it will return new instance of this\n   * `CID` class. Otherwise returns null.\n   *\n   * This allows two different incompatible versions of CID library to\n   * co-exist and interop as long as binary interface is compatible.\n   */\n  static asCID <Data, Format extends number, Alg extends number, Version extends API.Version, U>(input: API.Link<Data, Format, Alg, Version> | U): CID<Data, Format, Alg, Version> | null {\n    if (input == null) {\n      return null\n    }\n\n    const value = input as any\n    if (value instanceof CID) {\n      // If value is instance of CID then we're all set.\n      return value\n    } else if ((value['/'] != null && value['/'] === value.bytes) || value.asCID === value) {\n      // If value isn't instance of this CID class but `this.asCID === this` or\n      // `value['/'] === value.bytes` is true it is CID instance coming from a\n      // different implementation (diff version or duplicate). In that case we\n      // rebase it to this `CID` implementation so caller is guaranteed to get\n      // instance with expected API.\n      const { version, code, multihash, bytes } = value\n      return new CID(\n        version,\n        code,\n        multihash as API.MultihashDigest<Alg>,\n        bytes ?? encodeCID(version, code, multihash.bytes)\n      )\n    } else if (value[cidSymbol] === true) {\n      // If value is a CID from older implementation that used to be tagged via\n      // symbol we still rebase it to the this `CID` implementation by\n      // delegating that to a constructor.\n      const { version, multihash, code } = value\n      const digest = Digest.decode(multihash) as API.MultihashDigest<Alg>\n      return CID.create(version, code, digest)\n    } else {\n      // Otherwise value is not a CID (or an incompatible version of it) in\n      // which case we return `null`.\n      return null\n    }\n  }\n\n  /**\n   * @param version - Version of the CID\n   * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv\n   * @param digest - (Multi)hash of the of the content.\n   */\n  static create <Data, Format extends number, Alg extends number, Version extends API.Version>(version: Version, code: Format, digest: API.MultihashDigest<Alg>): CID<Data, Format, Alg, Version> {\n    if (typeof code !== 'number') {\n      throw new Error('String codecs are no longer supported')\n    }\n\n    if (!(digest.bytes instanceof Uint8Array)) {\n      throw new Error('Invalid digest')\n    }\n\n    switch (version) {\n      case 0: {\n        if (code !== DAG_PB_CODE) {\n          throw new Error(\n            `Version 0 CID must use dag-pb (code: ${DAG_PB_CODE}) block encoding`\n          )\n        } else {\n          return new CID(version, code, digest, digest.bytes)\n        }\n      }\n      case 1: {\n        const bytes = encodeCID(version, code, digest.bytes)\n        return new CID(version, code, digest, bytes)\n      }\n      default: {\n        throw new Error('Invalid version')\n      }\n    }\n  }\n\n  /**\n   * Simplified version of `create` for CIDv0.\n   */\n  static createV0 <T = unknown>(digest: API.MultihashDigest<typeof SHA_256_CODE>): CID<T, typeof DAG_PB_CODE, typeof SHA_256_CODE, 0> {\n    return CID.create(0, DAG_PB_CODE, digest)\n  }\n\n  /**\n   * Simplified version of `create` for CIDv1.\n   *\n   * @param code - Content encoding format code.\n   * @param digest - Multihash of the content.\n   */\n  static createV1 <Data, Code extends number, Alg extends number>(code: Code, digest: API.MultihashDigest<Alg>): CID<Data, Code, Alg, 1> {\n    return CID.create(1, code, digest)\n  }\n\n  /**\n   * Decoded a CID from its binary representation. The byte array must contain\n   * only the CID with no additional bytes.\n   *\n   * An error will be thrown if the bytes provided do not contain a valid\n   * binary representation of a CID.\n   */\n  static decode <Data, Code extends number, Alg extends number, Version extends API.Version>(bytes: API.ByteView<API.Link<Data, Code, Alg, Version>>): CID<Data, Code, Alg, Version> {\n    const [cid, remainder] = CID.decodeFirst(bytes)\n    if (remainder.length !== 0) {\n      throw new Error('Incorrect length')\n    }\n    return cid\n  }\n\n  /**\n   * Decoded a CID from its binary representation at the beginning of a byte\n   * array.\n   *\n   * Returns an array with the first element containing the CID and the second\n   * element containing the remainder of the original byte array. The remainder\n   * will be a zero-length byte array if the provided bytes only contained a\n   * binary CID representation.\n   */\n  static decodeFirst <T, C extends number, A extends number, V extends API.Version>(bytes: API.ByteView<API.Link<T, C, A, V>>): [CID<T, C, A, V>, Uint8Array] {\n    const specs = CID.inspectBytes(bytes)\n    const prefixSize = specs.size - specs.multihashSize\n    const multihashBytes = coerce(\n      bytes.subarray(prefixSize, prefixSize + specs.multihashSize)\n    )\n    if (multihashBytes.byteLength !== specs.multihashSize) {\n      throw new Error('Incorrect length')\n    }\n    const digestBytes = multihashBytes.subarray(\n      specs.multihashSize - specs.digestSize\n    )\n    const digest = new Digest.Digest(\n      specs.multihashCode,\n      specs.digestSize,\n      digestBytes,\n      multihashBytes\n    )\n    const cid =\n      specs.version === 0\n        ? CID.createV0(digest as API.MultihashDigest<API.SHA_256>)\n        : CID.createV1(specs.codec, digest)\n    return [cid as CID<T, C, A, V>, bytes.subarray(specs.size)]\n  }\n\n  /**\n   * Inspect the initial bytes of a CID to determine its properties.\n   *\n   * Involves decoding up to 4 varints. Typically this will require only 4 to 6\n   * bytes but for larger multicodec code values and larger multihash digest\n   * lengths these varints can be quite large. It is recommended that at least\n   * 10 bytes be made available in the `initialBytes` argument for a complete\n   * inspection.\n   */\n  static inspectBytes <T, C extends number, A extends number, V extends API.Version>(initialBytes: API.ByteView<API.Link<T, C, A, V>>): { version: V, codec: C, multihashCode: A, digestSize: number, multihashSize: number, size: number } {\n    let offset = 0\n    const next = (): number => {\n      const [i, length] = varint.decode(initialBytes.subarray(offset))\n      offset += length\n      return i\n    }\n\n    let version = next() as V\n    let codec = DAG_PB_CODE as C\n    if (version as number === 18) {\n      // CIDv0\n      version = 0 as V\n      offset = 0\n    } else {\n      codec = next() as C\n    }\n\n    if (version !== 0 && version !== 1) {\n      throw new RangeError(`Invalid CID version ${version}`)\n    }\n\n    const prefixSize = offset\n    const multihashCode = next() as A // multihash code\n    const digestSize = next() // multihash length\n    const size = offset + digestSize\n    const multihashSize = size - prefixSize\n\n    return { version, codec, multihashCode, digestSize, multihashSize, size }\n  }\n\n  /**\n   * Takes cid in a string representation and creates an instance. If `base`\n   * decoder is not provided will use a default from the configuration. It will\n   * throw an error if encoding of the CID is not compatible with supplied (or\n   * a default decoder).\n   */\n  static parse <Prefix extends string, Data, Code extends number, Alg extends number, Version extends API.Version>(source: API.ToString<API.Link<Data, Code, Alg, Version>, Prefix>, base?: API.MultibaseDecoder<Prefix>): CID<Data, Code, Alg, Version> {\n    const [prefix, bytes] = parseCIDtoBytes(source, base)\n\n    const cid = CID.decode(bytes)\n\n    if (cid.version === 0 && source[0] !== 'Q') {\n      throw Error('Version 0 CID string must not include multibase prefix')\n    }\n\n    // Cache string representation to avoid computing it on `this.toString()`\n    baseCache(cid).set(prefix, source)\n\n    return cid\n  }\n}\n\nfunction parseCIDtoBytes <Prefix extends string, Data, Code extends number, Alg extends number, Version extends API.Version> (source: API.ToString<API.Link<Data, Code, Alg, Version>, Prefix>, base?: API.MultibaseDecoder<Prefix>): [Prefix, API.ByteView<API.Link<Data, Code, Alg, Version>>] {\n  switch (source[0]) {\n    // CIDv0 is parsed differently\n    case 'Q': {\n      const decoder = base ?? base58btc\n      return [\n        base58btc.prefix as Prefix,\n        decoder.decode(`${base58btc.prefix}${source}`)\n      ]\n    }\n    case base58btc.prefix: {\n      const decoder = base ?? base58btc\n      return [base58btc.prefix as Prefix, decoder.decode(source)]\n    }\n    case base32.prefix: {\n      const decoder = base ?? base32\n      return [base32.prefix as Prefix, decoder.decode(source)]\n    }\n    case base36.prefix: {\n      const decoder = base ?? base36\n      return [base36.prefix as Prefix, decoder.decode(source)]\n    }\n    default: {\n      if (base == null) {\n        throw Error(\n          'To parse non base32, base36 or base58btc encoded CID multibase decoder must be provided'\n        )\n      }\n      return [source[0] as Prefix, base.decode(source)]\n    }\n  }\n}\n\nfunction toStringV0 (bytes: Uint8Array, cache: Map<string, string>, base: API.MultibaseEncoder<'z'>): string {\n  const { prefix } = base\n  if (prefix !== base58btc.prefix) {\n    throw Error(`Cannot string encode V0 in ${base.name} encoding`)\n  }\n\n  const cid = cache.get(prefix)\n  if (cid == null) {\n    const cid = base.encode(bytes).slice(1)\n    cache.set(prefix, cid)\n    return cid\n  } else {\n    return cid\n  }\n}\n\nfunction toStringV1 <Prefix extends string> (bytes: Uint8Array, cache: Map<string, string>, base: API.MultibaseEncoder<Prefix>): string {\n  const { prefix } = base\n  const cid = cache.get(prefix)\n  if (cid == null) {\n    const cid = base.encode(bytes)\n    cache.set(prefix, cid)\n    return cid\n  } else {\n    return cid\n  }\n}\n\nconst DAG_PB_CODE = 0x70\nconst SHA_256_CODE = 0x12\n\nfunction encodeCID (version: API.Version, code: number, multihash: Uint8Array): Uint8Array {\n  const codeOffset = varint.encodingLength(version)\n  const hashOffset = codeOffset + varint.encodingLength(code)\n  const bytes = new Uint8Array(hashOffset + multihash.byteLength)\n  varint.encodeTo(version, bytes, 0)\n  varint.encodeTo(code, bytes, codeOffset)\n  bytes.set(multihash, hashOffset)\n  return bytes\n}\n\nconst cidSymbol = Symbol.for('@ipld/js-cid/CID')\n", "const textDecoder = new TextDecoder()\n\n/**\n * @typedef {import('./interface.js').RawPBLink} RawPBLink\n */\n\n/**\n * @typedef {import('./interface.js').RawPBNode} RawPBNode\n */\n\n/**\n * @param {Uint8Array} bytes\n * @param {number} offset\n * @returns {[number, number]}\n */\nfunction decodeVarint (bytes, offset) {\n  let v = 0\n\n  for (let shift = 0; ; shift += 7) {\n    /* c8 ignore next 3 */\n    if (shift >= 64) {\n      throw new Error('protobuf: varint overflow')\n    }\n    /* c8 ignore next 3 */\n    if (offset >= bytes.length) {\n      throw new Error('protobuf: unexpected end of data')\n    }\n\n    const b = bytes[offset++]\n    v += shift < 28 ? (b & 0x7f) << shift : (b & 0x7f) * (2 ** shift)\n    if (b < 0x80) {\n      break\n    }\n  }\n  return [v, offset]\n}\n\n/**\n * @param {Uint8Array} bytes\n * @param {number} offset\n * @returns {[Uint8Array, number]}\n */\nfunction decodeBytes (bytes, offset) {\n  let byteLen\n  ;[byteLen, offset] = decodeVarint(bytes, offset)\n  const postOffset = offset + byteLen\n\n  /* c8 ignore next 3 */\n  if (byteLen < 0 || postOffset < 0) {\n    throw new Error('protobuf: invalid length')\n  }\n  /* c8 ignore next 3 */\n  if (postOffset > bytes.length) {\n    throw new Error('protobuf: unexpected end of data')\n  }\n\n  return [bytes.subarray(offset, postOffset), postOffset]\n}\n\n/**\n * @param {Uint8Array} bytes\n * @param {number} index\n * @returns {[number, number, number]}\n */\nfunction decodeKey (bytes, index) {\n  let wire\n  ;[wire, index] = decodeVarint(bytes, index)\n  // [wireType, fieldNum, newIndex]\n  return [wire & 0x7, wire >> 3, index]\n}\n\n/**\n * @param {Uint8Array} bytes\n * @returns {RawPBLink}\n */\nfunction decodeLink (bytes) {\n  /** @type {RawPBLink} */\n  const link = {}\n  const l = bytes.length\n  let index = 0\n\n  while (index < l) {\n    let wireType, fieldNum\n    ;[wireType, fieldNum, index] = decodeKey(bytes, index)\n\n    if (fieldNum === 1) {\n      if (link.Hash) {\n        throw new Error('protobuf: (PBLink) duplicate Hash section')\n      }\n      if (wireType !== 2) {\n        throw new Error(`protobuf: (PBLink) wrong wireType (${wireType}) for Hash`)\n      }\n      if (link.Name !== undefined) {\n        throw new Error('protobuf: (PBLink) invalid order, found Name before Hash')\n      }\n      if (link.Tsize !== undefined) {\n        throw new Error('protobuf: (PBLink) invalid order, found Tsize before Hash')\n      }\n\n      [link.Hash, index] = decodeBytes(bytes, index)\n    } else if (fieldNum === 2) {\n      if (link.Name !== undefined) {\n        throw new Error('protobuf: (PBLink) duplicate Name section')\n      }\n      if (wireType !== 2) {\n        throw new Error(`protobuf: (PBLink) wrong wireType (${wireType}) for Name`)\n      }\n      if (link.Tsize !== undefined) {\n        throw new Error('protobuf: (PBLink) invalid order, found Tsize before Name')\n      }\n\n      let byts\n      ;[byts, index] = decodeBytes(bytes, index)\n      link.Name = textDecoder.decode(byts)\n    } else if (fieldNum === 3) {\n      if (link.Tsize !== undefined) {\n        throw new Error('protobuf: (PBLink) duplicate Tsize section')\n      }\n      if (wireType !== 0) {\n        throw new Error(`protobuf: (PBLink) wrong wireType (${wireType}) for Tsize`)\n      }\n\n      [link.Tsize, index] = decodeVarint(bytes, index)\n    } else {\n      throw new Error(`protobuf: (PBLink) invalid fieldNumber, expected 1, 2 or 3, got ${fieldNum}`)\n    }\n  }\n\n  /* c8 ignore next 3 */\n  if (index > l) {\n    throw new Error('protobuf: (PBLink) unexpected end of data')\n  }\n\n  return link\n}\n\n/**\n * @param {Uint8Array} bytes\n * @returns {RawPBNode}\n */\nexport function decodeNode (bytes) {\n  const l = bytes.length\n  let index = 0\n  /** @type {RawPBLink[]|void} */\n  let links = undefined // eslint-disable-line no-undef-init\n  let linksBeforeData = false\n  /** @type {Uint8Array|void} */\n  let data = undefined // eslint-disable-line no-undef-init\n\n  while (index < l) {\n    let wireType, fieldNum\n    ;[wireType, fieldNum, index] = decodeKey(bytes, index)\n\n    if (wireType !== 2) {\n      throw new Error(`protobuf: (PBNode) invalid wireType, expected 2, got ${wireType}`)\n    }\n\n    if (fieldNum === 1) {\n      if (data) {\n        throw new Error('protobuf: (PBNode) duplicate Data section')\n      }\n\n      [data, index] = decodeBytes(bytes, index)\n      if (links) {\n        linksBeforeData = true\n      }\n    } else if (fieldNum === 2) {\n      if (linksBeforeData) { // interleaved Links/Data/Links\n        throw new Error('protobuf: (PBNode) duplicate Links section')\n      } else if (!links) {\n        links = []\n      }\n      let byts\n      ;[byts, index] = decodeBytes(bytes, index)\n      links.push(decodeLink(byts))\n    } else {\n      throw new Error(`protobuf: (PBNode) invalid fieldNumber, expected 1 or 2, got ${fieldNum}`)\n    }\n  }\n\n  /* c8 ignore next 3 */\n  if (index > l) {\n    throw new Error('protobuf: (PBNode) unexpected end of data')\n  }\n\n  /** @type {RawPBNode} */\n  const node = {}\n  if (data) {\n    node.Data = data\n  }\n  node.Links = links || []\n  return node\n}\n", "const textEncoder = new TextEncoder()\nconst maxInt32 = 2 ** 32\nconst maxUInt32 = 2 ** 31\n\n/**\n * @typedef {import('./interface.js').RawPBLink} RawPBLink\n */\n\n/**\n * @typedef {import('./interface.js').RawPBNode} RawPBNode\n */\n\n// the encoders work backward from the end of the bytes array\n\n/**\n * encodeLink() is passed a slice of the parent byte array that ends where this\n * link needs to end, so it packs to the right-most part of the passed `bytes`\n *\n * @param {RawPBLink} link\n * @param {Uint8Array} bytes\n * @returns {number}\n */\nfunction encodeLink (link, bytes) {\n  let i = bytes.length\n\n  if (typeof link.Tsize === 'number') {\n    if (link.Tsize < 0) {\n      throw new Error('Tsize cannot be negative')\n    }\n    if (!Number.isSafeInteger(link.Tsize)) {\n      throw new Error('Tsize too large for encoding')\n    }\n    i = encodeVarint(bytes, i, link.Tsize) - 1\n    bytes[i] = 0x18\n  }\n\n  if (typeof link.Name === 'string') {\n    const nameBytes = textEncoder.encode(link.Name)\n    i -= nameBytes.length\n    bytes.set(nameBytes, i)\n    i = encodeVarint(bytes, i, nameBytes.length) - 1\n    bytes[i] = 0x12\n  }\n\n  if (link.Hash) {\n    i -= link.Hash.length\n    bytes.set(link.Hash, i)\n    i = encodeVarint(bytes, i, link.Hash.length) - 1\n    bytes[i] = 0xa\n  }\n\n  return bytes.length - i\n}\n\n/**\n * Encodes a PBNode into a new byte array of precisely the correct size\n *\n * @param {RawPBNode} node\n * @returns {Uint8Array}\n */\nexport function encodeNode (node) {\n  const size = sizeNode(node)\n  const bytes = new Uint8Array(size)\n  let i = size\n\n  if (node.Data) {\n    i -= node.Data.length\n    bytes.set(node.Data, i)\n    i = encodeVarint(bytes, i, node.Data.length) - 1\n    bytes[i] = 0xa\n  }\n\n  if (node.Links) {\n    for (let index = node.Links.length - 1; index >= 0; index--) {\n      const size = encodeLink(node.Links[index], bytes.subarray(0, i))\n      i -= size\n      i = encodeVarint(bytes, i, size) - 1\n      bytes[i] = 0x12\n    }\n  }\n\n  return bytes\n}\n\n/**\n * work out exactly how many bytes this link takes up\n *\n * @param {RawPBLink} link\n * @returns\n */\nfunction sizeLink (link) {\n  let n = 0\n\n  if (link.Hash) {\n    const l = link.Hash.length\n    n += 1 + l + sov(l)\n  }\n\n  if (typeof link.Name === 'string') {\n    const l = textEncoder.encode(link.Name).length\n    n += 1 + l + sov(l)\n  }\n\n  if (typeof link.Tsize === 'number') {\n    n += 1 + sov(link.Tsize)\n  }\n\n  return n\n}\n\n/**\n * Work out exactly how many bytes this node takes up\n *\n * @param {RawPBNode} node\n * @returns {number}\n */\nfunction sizeNode (node) {\n  let n = 0\n\n  if (node.Data) {\n    const l = node.Data.length\n    n += 1 + l + sov(l)\n  }\n\n  if (node.Links) {\n    for (const link of node.Links) {\n      const l = sizeLink(link)\n      n += 1 + l + sov(l)\n    }\n  }\n\n  return n\n}\n\n/**\n * @param {Uint8Array} bytes\n * @param {number} offset\n * @param {number} v\n * @returns {number}\n */\nfunction encodeVarint (bytes, offset, v) {\n  offset -= sov(v)\n  const base = offset\n\n  while (v >= maxUInt32) {\n    bytes[offset++] = (v & 0x7f) | 0x80\n    v /= 128\n  }\n\n  while (v >= 128) {\n    bytes[offset++] = (v & 0x7f) | 0x80\n    v >>>= 7\n  }\n\n  bytes[offset] = v\n\n  return base\n}\n\n/**\n * size of varint\n *\n * @param {number} x\n * @returns {number}\n */\nfunction sov (x) {\n  if (x % 2 === 0) {\n    x++\n  }\n  return Math.floor((len64(x) + 6) / 7)\n}\n\n/**\n * golang math/bits, how many bits does it take to represent this integer?\n *\n * @param {number} x\n * @returns {number}\n */\nfunction len64 (x) {\n  let n = 0\n  if (x >= maxInt32) {\n    x = Math.floor(x / maxInt32)\n    n = 32\n  }\n  if (x >= (1 << 16)) {\n    x >>>= 16\n    n += 16\n  }\n  if (x >= (1 << 8)) {\n    x >>>= 8\n    n += 8\n  }\n  return n + len8tab[x]\n}\n\n// golang math/bits\nconst len8tab = [\n  0, 1, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4,\n  5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\n  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\n  7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,\n  7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,\n  7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,\n  7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,\n  8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,\n  8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,\n  8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,\n  8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,\n  8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,\n  8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,\n  8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,\n  8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8\n]\n", "import { CID } from 'multiformats/cid'\n\n/* eslint-disable complexity, no-nested-ternary */\n\n/**\n * @typedef {import('./interface.js').PBLink} PBLink\n * @typedef {import('./interface.js').PBNode} PBNode\n */\n\n/**\n * @template T\n * @typedef {import('multiformats/codecs/interface').ByteView<T>} ByteView\n */\n\n/**\n * @template T\n * @typedef {import('multiformats/codecs/interface').ArrayBufferView<T>} ArrayBufferView\n */\n\nconst pbNodeProperties = ['Data', 'Links']\nconst pbLinkProperties = ['Hash', 'Name', 'Tsize']\n\nconst textEncoder = new TextEncoder()\n\n/**\n * @param {PBLink} a\n * @param {PBLink} b\n * @returns {number}\n */\nfunction linkComparator (a, b) {\n  if (a === b) {\n    return 0\n  }\n\n  const abuf = a.Name ? textEncoder.encode(a.Name) : []\n  const bbuf = b.Name ? textEncoder.encode(b.Name) : []\n\n  let x = abuf.length\n  let y = bbuf.length\n\n  for (let i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (abuf[i] !== bbuf[i]) {\n      x = abuf[i]\n      y = bbuf[i]\n      break\n    }\n  }\n\n  return x < y ? -1 : y < x ? 1 : 0\n}\n\n/**\n * @param {any} node\n * @param {string[]} properties\n * @returns {boolean}\n */\nfunction hasOnlyProperties (node, properties) {\n  return !Object.keys(node).some((p) => !properties.includes(p))\n}\n\n/**\n * Converts a CID, or a PBLink-like object to a PBLink\n *\n * @param {any} link\n * @returns {PBLink}\n */\nfunction asLink (link) {\n  if (typeof link.asCID === 'object') {\n    const Hash = CID.asCID(link)\n    if (!Hash) {\n      throw new TypeError('Invalid DAG-PB form')\n    }\n    return { Hash }\n  }\n\n  if (typeof link !== 'object' || Array.isArray(link)) {\n    throw new TypeError('Invalid DAG-PB form')\n  }\n\n  const pbl = {}\n\n  if (link.Hash) {\n    let cid = CID.asCID(link.Hash)\n    try {\n      if (!cid) {\n        if (typeof link.Hash === 'string') {\n          cid = CID.parse(link.Hash)\n        } else if (link.Hash instanceof Uint8Array) {\n          cid = CID.decode(link.Hash)\n        }\n      }\n    } catch (/** @type {any} */ e) {\n      throw new TypeError(`Invalid DAG-PB form: ${e.message}`)\n    }\n\n    if (cid) {\n      pbl.Hash = cid\n    }\n  }\n\n  if (!pbl.Hash) {\n    throw new TypeError('Invalid DAG-PB form')\n  }\n\n  if (typeof link.Name === 'string') {\n    pbl.Name = link.Name\n  }\n\n  if (typeof link.Tsize === 'number') {\n    pbl.Tsize = link.Tsize\n  }\n\n  return pbl\n}\n\n/**\n * @param {any} node\n * @returns {PBNode}\n */\nexport function prepare (node) {\n  if (node instanceof Uint8Array || typeof node === 'string') {\n    node = { Data: node }\n  }\n\n  if (typeof node !== 'object' || Array.isArray(node)) {\n    throw new TypeError('Invalid DAG-PB form')\n  }\n\n  /** @type {PBNode} */\n  const pbn = {}\n\n  if (node.Data !== undefined) {\n    if (typeof node.Data === 'string') {\n      pbn.Data = textEncoder.encode(node.Data)\n    } else if (node.Data instanceof Uint8Array) {\n      pbn.Data = node.Data\n    } else {\n      throw new TypeError('Invalid DAG-PB form')\n    }\n  }\n\n  if (node.Links !== undefined) {\n    if (Array.isArray(node.Links)) {\n      pbn.Links = node.Links.map(asLink)\n      pbn.Links.sort(linkComparator)\n    } else {\n      throw new TypeError('Invalid DAG-PB form')\n    }\n  } else {\n    pbn.Links = []\n  }\n\n  return pbn\n}\n\n/**\n * @param {PBNode} node\n */\nexport function validate (node) {\n  /*\n  type PBLink struct {\n    Hash optional Link\n    Name optional String\n    Tsize optional Int\n  }\n\n  type PBNode struct {\n    Links [PBLink]\n    Data optional Bytes\n  }\n  */\n  // @ts-ignore private property for TS\n  if (!node || typeof node !== 'object' || Array.isArray(node) || node instanceof Uint8Array || (node['/'] && node['/'] === node.bytes)) {\n    throw new TypeError('Invalid DAG-PB form')\n  }\n\n  if (!hasOnlyProperties(node, pbNodeProperties)) {\n    throw new TypeError('Invalid DAG-PB form (extraneous properties)')\n  }\n\n  if (node.Data !== undefined && !(node.Data instanceof Uint8Array)) {\n    throw new TypeError('Invalid DAG-PB form (Data must be bytes)')\n  }\n\n  if (!Array.isArray(node.Links)) {\n    throw new TypeError('Invalid DAG-PB form (Links must be a list)')\n  }\n\n  for (let i = 0; i < node.Links.length; i++) {\n    const link = node.Links[i]\n    // @ts-ignore private property for TS\n    if (!link || typeof link !== 'object' || Array.isArray(link) || link instanceof Uint8Array || (link['/'] && link['/'] === link.bytes)) {\n      throw new TypeError('Invalid DAG-PB form (bad link)')\n    }\n\n    if (!hasOnlyProperties(link, pbLinkProperties)) {\n      throw new TypeError('Invalid DAG-PB form (extraneous properties on link)')\n    }\n\n    if (link.Hash === undefined) {\n      throw new TypeError('Invalid DAG-PB form (link must have a Hash)')\n    }\n\n    // @ts-ignore private property for TS\n    if (link.Hash == null || !link.Hash['/'] || link.Hash['/'] !== link.Hash.bytes) {\n      throw new TypeError('Invalid DAG-PB form (link Hash must be a CID)')\n    }\n\n    if (link.Name !== undefined && typeof link.Name !== 'string') {\n      throw new TypeError('Invalid DAG-PB form (link Name must be a string)')\n    }\n\n    if (link.Tsize !== undefined) {\n      if (typeof link.Tsize !== 'number' || link.Tsize % 1 !== 0) {\n        throw new TypeError('Invalid DAG-PB form (link Tsize must be an integer)')\n      }\n      if (link.Tsize < 0) {\n        throw new TypeError('Invalid DAG-PB form (link Tsize cannot be negative)')\n      }\n    }\n\n    if (i > 0 && linkComparator(link, node.Links[i - 1]) === -1) {\n      throw new TypeError('Invalid DAG-PB form (links must be sorted by Name bytes)')\n    }\n  }\n}\n\n/**\n * @param {Uint8Array} data\n * @param {PBLink[]} [links]\n * @returns {PBNode}\n */\nexport function createNode (data, links = []) {\n  return prepare({ Data: data, Links: links })\n}\n\n/**\n * @param {string} name\n * @param {number} size\n * @param {CID} cid\n * @returns {PBLink}\n */\nexport function createLink (name, size, cid) {\n  return asLink({ Hash: cid, Name: name, Tsize: size })\n}\n\n/**\n * @template T\n * @param {ByteView<T> | ArrayBufferView<T>} buf\n * @returns {ByteView<T>}\n */\nexport function toByteView (buf) {\n  if (buf instanceof ArrayBuffer) {\n    return new Uint8Array(buf, 0, buf.byteLength)\n  }\n\n  return buf\n}\n", "export class InvalidTypeError extends Error {\n  static name = 'InvalidTypeError'\n  static code = 'ERR_INVALID_TYPE'\n  name = InvalidTypeError.name\n  code = InvalidTypeError.code\n\n  constructor (message = 'Invalid type') {\n    super(message)\n  }\n}\n\nexport class InvalidUnixFSMessageError extends Error {\n  static name = 'InvalidUnixFSMessageError'\n  static code = 'ERR_INVALID_MESSAGE'\n  name = InvalidUnixFSMessageError.name\n  code = InvalidUnixFSMessageError.code\n\n  constructor (message = 'Invalid message') {\n    super(message)\n  }\n}\n", "/* eslint-disable no-fallthrough */\nimport { allocUnsafe } from 'uint8arrays/alloc'\nimport type { Uint8ArrayList } from 'uint8arraylist'\n\nconst N1 = Math.pow(2, 7)\nconst N2 = Math.pow(2, 14)\nconst N3 = Math.pow(2, 21)\nconst N4 = Math.pow(2, 28)\nconst N5 = Math.pow(2, 35)\nconst N6 = Math.pow(2, 42)\nconst N7 = Math.pow(2, 49)\n\n/** Most significant bit of a byte */\nconst MSB = 0x80\n/** Rest of the bits in a byte */\nconst REST = 0x7f\n\nexport function encodingLength (value: number): number {\n  if (value < N1) {\n    return 1\n  }\n\n  if (value < N2) {\n    return 2\n  }\n\n  if (value < N3) {\n    return 3\n  }\n\n  if (value < N4) {\n    return 4\n  }\n\n  if (value < N5) {\n    return 5\n  }\n\n  if (value < N6) {\n    return 6\n  }\n\n  if (value < N7) {\n    return 7\n  }\n\n  if (Number.MAX_SAFE_INTEGER != null && value > Number.MAX_SAFE_INTEGER) {\n    throw new RangeError('Could not encode varint')\n  }\n\n  return 8\n}\n\nexport function encodeUint8Array (value: number, buf: Uint8Array, offset: number = 0): Uint8Array {\n  switch (encodingLength(value)) {\n    case 8: {\n      buf[offset++] = (value & 0xFF) | MSB\n      value /= 128\n    }\n    case 7: {\n      buf[offset++] = (value & 0xFF) | MSB\n      value /= 128\n    }\n    case 6: {\n      buf[offset++] = (value & 0xFF) | MSB\n      value /= 128\n    }\n    case 5: {\n      buf[offset++] = (value & 0xFF) | MSB\n      value /= 128\n    }\n    case 4: {\n      buf[offset++] = (value & 0xFF) | MSB\n      value >>>= 7\n    }\n    case 3: {\n      buf[offset++] = (value & 0xFF) | MSB\n      value >>>= 7\n    }\n    case 2: {\n      buf[offset++] = (value & 0xFF) | MSB\n      value >>>= 7\n    }\n    case 1: {\n      buf[offset++] = (value & 0xFF)\n      value >>>= 7\n      break\n    }\n    default: throw new Error('unreachable')\n  }\n  return buf\n}\n\nexport function encodeUint8ArrayList (value: number, buf: Uint8ArrayList, offset: number = 0): Uint8ArrayList {\n  switch (encodingLength(value)) {\n    case 8: {\n      buf.set(offset++, (value & 0xFF) | MSB)\n      value /= 128\n    }\n    case 7: {\n      buf.set(offset++, (value & 0xFF) | MSB)\n      value /= 128\n    }\n    case 6: {\n      buf.set(offset++, (value & 0xFF) | MSB)\n      value /= 128\n    }\n    case 5: {\n      buf.set(offset++, (value & 0xFF) | MSB)\n      value /= 128\n    }\n    case 4: {\n      buf.set(offset++, (value & 0xFF) | MSB)\n      value >>>= 7\n    }\n    case 3: {\n      buf.set(offset++, (value & 0xFF) | MSB)\n      value >>>= 7\n    }\n    case 2: {\n      buf.set(offset++, (value & 0xFF) | MSB)\n      value >>>= 7\n    }\n    case 1: {\n      buf.set(offset++, (value & 0xFF))\n      value >>>= 7\n      break\n    }\n    default: throw new Error('unreachable')\n  }\n  return buf\n}\n\nexport function decodeUint8Array (buf: Uint8Array, offset: number): number {\n  let b = buf[offset]\n  let res = 0\n\n  res += b & REST\n  if (b < MSB) {\n    return res\n  }\n\n  b = buf[offset + 1]\n  res += (b & REST) << 7\n  if (b < MSB) {\n    return res\n  }\n\n  b = buf[offset + 2]\n  res += (b & REST) << 14\n  if (b < MSB) {\n    return res\n  }\n\n  b = buf[offset + 3]\n  res += (b & REST) << 21\n  if (b < MSB) {\n    return res\n  }\n\n  b = buf[offset + 4]\n  res += (b & REST) * N4\n  if (b < MSB) {\n    return res\n  }\n\n  b = buf[offset + 5]\n  res += (b & REST) * N5\n  if (b < MSB) {\n    return res\n  }\n\n  b = buf[offset + 6]\n  res += (b & REST) * N6\n  if (b < MSB) {\n    return res\n  }\n\n  b = buf[offset + 7]\n  res += (b & REST) * N7\n  if (b < MSB) {\n    return res\n  }\n\n  throw new RangeError('Could not decode varint')\n}\n\nexport function decodeUint8ArrayList (buf: Uint8ArrayList, offset: number): number {\n  let b = buf.get(offset)\n  let res = 0\n\n  res += b & REST\n  if (b < MSB) {\n    return res\n  }\n\n  b = buf.get(offset + 1)\n  res += (b & REST) << 7\n  if (b < MSB) {\n    return res\n  }\n\n  b = buf.get(offset + 2)\n  res += (b & REST) << 14\n  if (b < MSB) {\n    return res\n  }\n\n  b = buf.get(offset + 3)\n  res += (b & REST) << 21\n  if (b < MSB) {\n    return res\n  }\n\n  b = buf.get(offset + 4)\n  res += (b & REST) * N4\n  if (b < MSB) {\n    return res\n  }\n\n  b = buf.get(offset + 5)\n  res += (b & REST) * N5\n  if (b < MSB) {\n    return res\n  }\n\n  b = buf.get(offset + 6)\n  res += (b & REST) * N6\n  if (b < MSB) {\n    return res\n  }\n\n  b = buf.get(offset + 7)\n  res += (b & REST) * N7\n  if (b < MSB) {\n    return res\n  }\n\n  throw new RangeError('Could not decode varint')\n}\n\nexport function encode (value: number): Uint8Array\nexport function encode (value: number, buf: Uint8Array, offset?: number): Uint8Array\nexport function encode (value: number, buf: Uint8ArrayList, offset?: number): Uint8ArrayList\nexport function encode <T extends Uint8Array | Uint8ArrayList = Uint8Array> (value: number, buf?: T, offset: number = 0): T {\n  if (buf == null) {\n    buf = allocUnsafe(encodingLength(value)) as T\n  }\n  if (buf instanceof Uint8Array) {\n    return encodeUint8Array(value, buf, offset) as T\n  } else {\n    return encodeUint8ArrayList(value, buf, offset) as T\n  }\n}\n\nexport function decode (buf: Uint8ArrayList | Uint8Array, offset: number = 0): number {\n  if (buf instanceof Uint8Array) {\n    return decodeUint8Array(buf, offset)\n  } else {\n    return decodeUint8ArrayList(buf, offset)\n  }\n}\n", "const f32 = new Float32Array([-0])\nconst f8b = new Uint8Array(f32.buffer)\n\n/**\n * Writes a 32 bit float to a buffer using little endian byte order\n */\nexport function writeFloatLE (val: number, buf: Uint8Array, pos: number): void {\n  f32[0] = val\n  buf[pos] = f8b[0]\n  buf[pos + 1] = f8b[1]\n  buf[pos + 2] = f8b[2]\n  buf[pos + 3] = f8b[3]\n}\n\n/**\n * Writes a 32 bit float to a buffer using big endian byte order\n */\nexport function writeFloatBE (val: number, buf: Uint8Array, pos: number): void {\n  f32[0] = val\n  buf[pos] = f8b[3]\n  buf[pos + 1] = f8b[2]\n  buf[pos + 2] = f8b[1]\n  buf[pos + 3] = f8b[0]\n}\n\n/**\n * Reads a 32 bit float from a buffer using little endian byte order\n */\nexport function readFloatLE (buf: Uint8Array, pos: number): number {\n  f8b[0] = buf[pos]\n  f8b[1] = buf[pos + 1]\n  f8b[2] = buf[pos + 2]\n  f8b[3] = buf[pos + 3]\n  return f32[0]\n}\n\n/**\n * Reads a 32 bit float from a buffer using big endian byte order\n */\nexport function readFloatBE (buf: Uint8Array, pos: number): number {\n  f8b[3] = buf[pos]\n  f8b[2] = buf[pos + 1]\n  f8b[1] = buf[pos + 2]\n  f8b[0] = buf[pos + 3]\n  return f32[0]\n}\n\nconst f64 = new Float64Array([-0])\nconst d8b = new Uint8Array(f64.buffer)\n\n/**\n * Writes a 64 bit double to a buffer using little endian byte order\n */\nexport function writeDoubleLE (val: number, buf: Uint8Array, pos: number): void {\n  f64[0] = val\n  buf[pos] = d8b[0]\n  buf[pos + 1] = d8b[1]\n  buf[pos + 2] = d8b[2]\n  buf[pos + 3] = d8b[3]\n  buf[pos + 4] = d8b[4]\n  buf[pos + 5] = d8b[5]\n  buf[pos + 6] = d8b[6]\n  buf[pos + 7] = d8b[7]\n}\n\n/**\n * Writes a 64 bit double to a buffer using big endian byte order\n */\nexport function writeDoubleBE (val: number, buf: Uint8Array, pos: number): void {\n  f64[0] = val\n  buf[pos] = d8b[7]\n  buf[pos + 1] = d8b[6]\n  buf[pos + 2] = d8b[5]\n  buf[pos + 3] = d8b[4]\n  buf[pos + 4] = d8b[3]\n  buf[pos + 5] = d8b[2]\n  buf[pos + 6] = d8b[1]\n  buf[pos + 7] = d8b[0]\n}\n\n/**\n * Reads a 64 bit double from a buffer using little endian byte order\n */\nexport function readDoubleLE (buf: Uint8Array, pos: number): number {\n  d8b[0] = buf[pos]\n  d8b[1] = buf[pos + 1]\n  d8b[2] = buf[pos + 2]\n  d8b[3] = buf[pos + 3]\n  d8b[4] = buf[pos + 4]\n  d8b[5] = buf[pos + 5]\n  d8b[6] = buf[pos + 6]\n  d8b[7] = buf[pos + 7]\n  return f64[0]\n}\n\n/**\n * Reads a 64 bit double from a buffer using big endian byte order\n */\nexport function readDoubleBE (buf: Uint8Array, pos: number): number {\n  d8b[7] = buf[pos]\n  d8b[6] = buf[pos + 1]\n  d8b[5] = buf[pos + 2]\n  d8b[4] = buf[pos + 3]\n  d8b[3] = buf[pos + 4]\n  d8b[2] = buf[pos + 5]\n  d8b[1] = buf[pos + 6]\n  d8b[0] = buf[pos + 7]\n  return f64[0]\n}\n", "// the largest BigInt we can safely downcast to a Number\nconst MAX_SAFE_NUMBER_INTEGER = BigInt(Number.MAX_SAFE_INTEGER)\nconst MIN_SAFE_NUMBER_INTEGER = BigInt(Number.MIN_SAFE_INTEGER)\n\n/**\n * Constructs new long bits.\n *\n * @classdesc Helper class for working with the low and high bits of a 64 bit value.\n * @memberof util\n * @function Object() { [native code] }\n * @param {number} lo - Low 32 bits, unsigned\n * @param {number} hi - High 32 bits, unsigned\n */\nexport class LongBits {\n  public lo: number\n  public hi: number\n\n  constructor (lo: number, hi: number) {\n    // note that the casts below are theoretically unnecessary as of today, but older statically\n    // generated converter code might still call the ctor with signed 32bits. kept for compat.\n\n    /**\n     * Low bits\n     */\n    this.lo = lo | 0\n\n    /**\n     * High bits\n     */\n    this.hi = hi | 0\n  }\n\n  /**\n   * Converts this long bits to a possibly unsafe JavaScript number\n   */\n  toNumber (unsigned: boolean = false): number {\n    if (!unsigned && (this.hi >>> 31) > 0) {\n      const lo = ~this.lo + 1 >>> 0\n      let hi = ~this.hi >>> 0\n      if (lo === 0) {\n        hi = hi + 1 >>> 0\n      }\n      return -(lo + hi * 4294967296)\n    }\n    return this.lo + this.hi * 4294967296\n  }\n\n  /**\n   * Converts this long bits to a bigint\n   */\n  toBigInt (unsigned: boolean = false): bigint {\n    if (unsigned) {\n      return BigInt(this.lo >>> 0) + (BigInt(this.hi >>> 0) << 32n)\n    }\n\n    if ((this.hi >>> 31) !== 0) {\n      const lo = ~this.lo + 1 >>> 0\n      let hi = ~this.hi >>> 0\n      if (lo === 0) {\n        hi = hi + 1 >>> 0\n      }\n      return -(BigInt(lo) + (BigInt(hi) << 32n))\n    }\n\n    return BigInt(this.lo >>> 0) + (BigInt(this.hi >>> 0) << 32n)\n  }\n\n  /**\n   * Converts this long bits to a string\n   */\n  toString (unsigned: boolean = false): string {\n    return this.toBigInt(unsigned).toString()\n  }\n\n  /**\n   * Zig-zag encodes this long bits\n   */\n  zzEncode (): this {\n    const mask = this.hi >> 31\n    this.hi = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0\n    this.lo = (this.lo << 1 ^ mask) >>> 0\n    return this\n  }\n\n  /**\n   * Zig-zag decodes this long bits\n   */\n  zzDecode (): this {\n    const mask = -(this.lo & 1)\n    this.lo = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0\n    this.hi = (this.hi >>> 1 ^ mask) >>> 0\n    return this\n  }\n\n  /**\n   * Calculates the length of this longbits when encoded as a varint.\n   */\n  length (): number {\n    const part0 = this.lo\n    const part1 = (this.lo >>> 28 | this.hi << 4) >>> 0\n    const part2 = this.hi >>> 24\n    return part2 === 0\n      ? part1 === 0\n        ? part0 < 16384\n          ? part0 < 128 ? 1 : 2\n          : part0 < 2097152 ? 3 : 4\n        : part1 < 16384\n          ? part1 < 128 ? 5 : 6\n          : part1 < 2097152 ? 7 : 8\n      : part2 < 128 ? 9 : 10\n  }\n\n  /**\n   * Constructs new long bits from the specified number\n   */\n  static fromBigInt (value: bigint): LongBits {\n    if (value === 0n) {\n      return zero\n    }\n\n    if (value < MAX_SAFE_NUMBER_INTEGER && value > MIN_SAFE_NUMBER_INTEGER) {\n      return this.fromNumber(Number(value))\n    }\n\n    const negative = value < 0n\n\n    if (negative) {\n      value = -value\n    }\n\n    let hi = value >> 32n\n    let lo = value - (hi << 32n)\n\n    if (negative) {\n      hi = ~hi | 0n\n      lo = ~lo | 0n\n\n      if (++lo > TWO_32) {\n        lo = 0n\n        if (++hi > TWO_32) { hi = 0n }\n      }\n    }\n\n    return new LongBits(Number(lo), Number(hi))\n  }\n\n  /**\n   * Constructs new long bits from the specified number\n   */\n  static fromNumber (value: number): LongBits {\n    if (value === 0) { return zero }\n    const sign = value < 0\n    if (sign) { value = -value }\n    let lo = value >>> 0\n    let hi = (value - lo) / 4294967296 >>> 0\n    if (sign) {\n      hi = ~hi >>> 0\n      lo = ~lo >>> 0\n      if (++lo > 4294967295) {\n        lo = 0\n        if (++hi > 4294967295) { hi = 0 }\n      }\n    }\n    return new LongBits(lo, hi)\n  }\n\n  /**\n   * Constructs new long bits from a number, long or string\n   */\n  static from (value: bigint | number | string | { low: number, high: number }): LongBits {\n    if (typeof value === 'number') {\n      return LongBits.fromNumber(value)\n    }\n    if (typeof value === 'bigint') {\n      return LongBits.fromBigInt(value)\n    }\n    if (typeof value === 'string') {\n      return LongBits.fromBigInt(BigInt(value))\n    }\n    return value.low != null || value.high != null ? new LongBits(value.low >>> 0, value.high >>> 0) : zero\n  }\n}\n\nconst zero = new LongBits(0, 0)\nzero.toBigInt = function () { return 0n }\nzero.zzEncode = zero.zzDecode = function () { return this }\nzero.length = function () { return 1 }\n\nconst TWO_32 = 4294967296n\n", "/**\n * Calculates the UTF8 byte length of a string\n */\nexport function length (string: string): number {\n  let len = 0\n  let c = 0\n  for (let i = 0; i < string.length; ++i) {\n    c = string.charCodeAt(i)\n\n    if (c < 128) {\n      len += 1\n    } else if (c < 2048) {\n      len += 2\n    } else if ((c & 0xFC00) === 0xD800 && (string.charCodeAt(i + 1) & 0xFC00) === 0xDC00) {\n      ++i\n      len += 4\n    } else {\n      len += 3\n    }\n  }\n\n  return len\n}\n\n/**\n * Reads UTF8 bytes as a string\n */\nexport function read (buffer: Uint8Array, start: number, end: number): string {\n  const len = end - start\n\n  if (len < 1) {\n    return ''\n  }\n\n  let parts: string[] | undefined\n  const chunk: number[] = []\n  let i = 0 // char offset\n  let t: number // temporary\n\n  while (start < end) {\n    t = buffer[start++]\n\n    if (t < 128) {\n      chunk[i++] = t\n    } else if (t > 191 && t < 224) {\n      chunk[i++] = (t & 31) << 6 | buffer[start++] & 63\n    } else if (t > 239 && t < 365) {\n      t = ((t & 7) << 18 | (buffer[start++] & 63) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63) - 0x10000\n      chunk[i++] = 0xD800 + (t >> 10)\n      chunk[i++] = 0xDC00 + (t & 1023)\n    } else {\n      chunk[i++] = (t & 15) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63\n    }\n\n    if (i > 8191) {\n      (parts ?? (parts = [])).push(String.fromCharCode.apply(String, chunk))\n      i = 0\n    }\n  }\n\n  if (parts != null) {\n    if (i > 0) {\n      parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)))\n    }\n\n    return parts.join('')\n  }\n\n  return String.fromCharCode.apply(String, chunk.slice(0, i))\n}\n\n/**\n * Writes a string as UTF8 bytes\n */\nexport function write (string: string, buffer: Uint8Array, offset: number): number {\n  const start = offset\n  let c1 // character 1\n  let c2 // character 2\n\n  for (let i = 0; i < string.length; ++i) {\n    c1 = string.charCodeAt(i)\n\n    if (c1 < 128) {\n      buffer[offset++] = c1\n    } else if (c1 < 2048) {\n      buffer[offset++] = c1 >> 6 | 192\n      buffer[offset++] = c1 & 63 | 128\n    } else if ((c1 & 0xFC00) === 0xD800 && ((c2 = string.charCodeAt(i + 1)) & 0xFC00) === 0xDC00) {\n      c1 = 0x10000 + ((c1 & 0x03FF) << 10) + (c2 & 0x03FF)\n      ++i\n      buffer[offset++] = c1 >> 18 | 240\n      buffer[offset++] = c1 >> 12 & 63 | 128\n      buffer[offset++] = c1 >> 6 & 63 | 128\n      buffer[offset++] = c1 & 63 | 128\n    } else {\n      buffer[offset++] = c1 >> 12 | 224\n      buffer[offset++] = c1 >> 6 & 63 | 128\n      buffer[offset++] = c1 & 63 | 128\n    }\n  }\n\n  return offset - start\n}\n", "import { decodeUint8Array, encodingLength } from 'uint8-varint'\nimport { readFloatLE, readDoubleLE } from './float.js'\nimport { LongBits } from './longbits.js'\nimport * as utf8 from './utf8.js'\nimport type { Reader } from '../index.js'\nimport type { Uint8ArrayList } from 'uint8arraylist'\n\n/* istanbul ignore next */\nfunction indexOutOfRange (reader: Reader, writeLength?: number): RangeError {\n  return RangeError(`index out of range: ${reader.pos} + ${writeLength ?? 1} > ${reader.len}`)\n}\n\nfunction readFixed32End (buf: Uint8Array, end: number): number { // note that this uses `end`, not `pos`\n  return (buf[end - 4] |\n        buf[end - 3] << 8 |\n        buf[end - 2] << 16 |\n        buf[end - 1] << 24) >>> 0\n}\n\n/**\n * Constructs a new reader instance using the specified buffer.\n */\nexport class Uint8ArrayReader implements Reader {\n  public buf: Uint8Array\n  public pos: number\n  public len: number\n\n  public _slice = Uint8Array.prototype.subarray\n\n  constructor (buffer: Uint8Array) {\n    /**\n     * Read buffer\n     */\n    this.buf = buffer\n\n    /**\n     * Read buffer position\n     */\n    this.pos = 0\n\n    /**\n     * Read buffer length\n     */\n    this.len = buffer.length\n  }\n\n  /**\n   * Reads a varint as an unsigned 32 bit value\n   */\n  uint32 (): number {\n    let value = 4294967295\n\n    value = (this.buf[this.pos] & 127) >>> 0; if (this.buf[this.pos++] < 128) { return value }\n    value = (value | (this.buf[this.pos] & 127) << 7) >>> 0; if (this.buf[this.pos++] < 128) { return value }\n    value = (value | (this.buf[this.pos] & 127) << 14) >>> 0; if (this.buf[this.pos++] < 128) { return value }\n    value = (value | (this.buf[this.pos] & 127) << 21) >>> 0; if (this.buf[this.pos++] < 128) { return value }\n    value = (value | (this.buf[this.pos] & 15) << 28) >>> 0; if (this.buf[this.pos++] < 128) { return value }\n\n    if ((this.pos += 5) > this.len) {\n      this.pos = this.len\n      throw indexOutOfRange(this, 10)\n    }\n\n    return value\n  }\n\n  /**\n   * Reads a varint as a signed 32 bit value\n   */\n  int32 (): number {\n    return this.uint32() | 0\n  }\n\n  /**\n   * Reads a zig-zag encoded varint as a signed 32 bit value\n   */\n  sint32 (): number {\n    const value = this.uint32()\n    return value >>> 1 ^ -(value & 1) | 0\n  }\n\n  /**\n   * Reads a varint as a boolean\n   */\n  bool (): boolean {\n    return this.uint32() !== 0\n  }\n\n  /**\n   * Reads fixed 32 bits as an unsigned 32 bit integer\n   */\n  fixed32 (): number {\n    if (this.pos + 4 > this.len) { throw indexOutOfRange(this, 4) }\n\n    const res = readFixed32End(this.buf, this.pos += 4)\n\n    return res\n  }\n\n  /**\n   * Reads fixed 32 bits as a signed 32 bit integer\n   */\n  sfixed32 (): number {\n    if (this.pos + 4 > this.len) {\n      throw indexOutOfRange(this, 4)\n    }\n\n    const res = readFixed32End(this.buf, this.pos += 4) | 0\n\n    return res\n  }\n\n  /**\n   * Reads a float (32 bit) as a number\n   */\n  float (): number {\n    if (this.pos + 4 > this.len) {\n      throw indexOutOfRange(this, 4)\n    }\n\n    const value = readFloatLE(this.buf, this.pos)\n    this.pos += 4\n    return value\n  }\n\n  /**\n   * Reads a double (64 bit float) as a number\n   */\n  double (): number {\n    /* istanbul ignore if */\n    if (this.pos + 8 > this.len) { throw indexOutOfRange(this, 4) }\n\n    const value = readDoubleLE(this.buf, this.pos)\n    this.pos += 8\n    return value\n  }\n\n  /**\n   * Reads a sequence of bytes preceded by its length as a varint\n   */\n  bytes (): Uint8Array {\n    const length = this.uint32()\n    const start = this.pos\n    const end = this.pos + length\n\n    /* istanbul ignore if */\n    if (end > this.len) {\n      throw indexOutOfRange(this, length)\n    }\n\n    this.pos += length\n\n    return start === end // fix for IE 10/Win8 and others' subarray returning array of size 1\n      ? new Uint8Array(0)\n      : this.buf.subarray(start, end)\n  }\n\n  /**\n   * Reads a string preceded by its byte length as a varint\n   */\n  string (): string {\n    const bytes = this.bytes()\n    return utf8.read(bytes, 0, bytes.length)\n  }\n\n  /**\n   * Skips the specified number of bytes if specified, otherwise skips a varint\n   */\n  skip (length?: number): this {\n    if (typeof length === 'number') {\n      /* istanbul ignore if */\n      if (this.pos + length > this.len) { throw indexOutOfRange(this, length) }\n      this.pos += length\n    } else {\n      do {\n        /* istanbul ignore if */\n        if (this.pos >= this.len) {\n          throw indexOutOfRange(this)\n        }\n      } while ((this.buf[this.pos++] & 128) !== 0)\n    }\n    return this\n  }\n\n  /**\n   * Skips the next element of the specified wire type\n   */\n  skipType (wireType: number): this {\n    switch (wireType) {\n      case 0:\n        this.skip()\n        break\n      case 1:\n        this.skip(8)\n        break\n      case 2:\n        this.skip(this.uint32())\n        break\n      case 3:\n        while ((wireType = this.uint32() & 7) !== 4) {\n          this.skipType(wireType)\n        }\n        break\n      case 5:\n        this.skip(4)\n        break\n\n        /* istanbul ignore next */\n      default:\n        throw Error(`invalid wire type ${wireType} at offset ${this.pos}`)\n    }\n    return this\n  }\n\n  private readLongVarint (): LongBits {\n    // tends to deopt with local vars for octet etc.\n    const bits = new LongBits(0, 0)\n    let i = 0\n    if (this.len - this.pos > 4) { // fast route (lo)\n      for (; i < 4; ++i) {\n        // 1st..4th\n        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0\n        if (this.buf[this.pos++] < 128) { return bits }\n      }\n      // 5th\n      bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0\n      bits.hi = (bits.hi | (this.buf[this.pos] & 127) >> 4) >>> 0\n      if (this.buf[this.pos++] < 128) { return bits }\n      i = 0\n    } else {\n      for (; i < 3; ++i) {\n        /* istanbul ignore if */\n        if (this.pos >= this.len) { throw indexOutOfRange(this) }\n        // 1st..3th\n        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0\n        if (this.buf[this.pos++] < 128) { return bits }\n      }\n      // 4th\n      bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0\n      return bits\n    }\n    if (this.len - this.pos > 4) { // fast route (hi)\n      for (; i < 5; ++i) {\n        // 6th..10th\n        bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0\n        if (this.buf[this.pos++] < 128) { return bits }\n      }\n    } else {\n      for (; i < 5; ++i) {\n        if (this.pos >= this.len) {\n          throw indexOutOfRange(this)\n        }\n\n        // 6th..10th\n        bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0\n        if (this.buf[this.pos++] < 128) { return bits }\n      }\n    }\n\n    throw Error('invalid varint encoding')\n  }\n\n  private readFixed64 (): LongBits {\n    if (this.pos + 8 > this.len) {\n      throw indexOutOfRange(this, 8)\n    }\n\n    const lo = readFixed32End(this.buf, this.pos += 4)\n    const hi = readFixed32End(this.buf, this.pos += 4)\n\n    return new LongBits(lo, hi)\n  }\n\n  /**\n   * Reads a varint as a signed 64 bit value\n   */\n  int64 (): bigint {\n    return this.readLongVarint().toBigInt()\n  }\n\n  /**\n   * Reads a varint as a signed 64 bit value returned as a possibly unsafe\n   * JavaScript number\n   */\n  int64Number (): number {\n    return this.readLongVarint().toNumber()\n  }\n\n  /**\n   * Reads a varint as a signed 64 bit value returned as a string\n   */\n  int64String (): string {\n    return this.readLongVarint().toString()\n  }\n\n  /**\n   * Reads a varint as an unsigned 64 bit value\n   */\n  uint64 (): bigint {\n    return this.readLongVarint().toBigInt(true)\n  }\n\n  /**\n   * Reads a varint as an unsigned 64 bit value returned as a possibly unsafe\n   * JavaScript number\n   */\n  uint64Number (): number {\n    const value = decodeUint8Array(this.buf, this.pos)\n    this.pos += encodingLength(value)\n    return value\n  }\n\n  /**\n   * Reads a varint as an unsigned 64 bit value returned as a string\n   */\n  uint64String (): string {\n    return this.readLongVarint().toString(true)\n  }\n\n  /**\n   * Reads a zig-zag encoded varint as a signed 64 bit value\n   */\n  sint64 (): bigint {\n    return this.readLongVarint().zzDecode().toBigInt()\n  }\n\n  /**\n   * Reads a zig-zag encoded varint as a signed 64 bit value returned as a\n   * possibly unsafe JavaScript number\n   */\n  sint64Number (): number {\n    return this.readLongVarint().zzDecode().toNumber()\n  }\n\n  /**\n   * Reads a zig-zag encoded varint as a signed 64 bit value returned as a\n   * string\n   */\n  sint64String (): string {\n    return this.readLongVarint().zzDecode().toString()\n  }\n\n  /**\n   * Reads fixed 64 bits\n   */\n  fixed64 (): bigint {\n    return this.readFixed64().toBigInt()\n  }\n\n  /**\n   * Reads fixed 64 bits returned as a possibly unsafe JavaScript number\n   */\n  fixed64Number (): number {\n    return this.readFixed64().toNumber()\n  }\n\n  /**\n   * Reads fixed 64 bits returned as a string\n   */\n  fixed64String (): string {\n    return this.readFixed64().toString()\n  }\n\n  /**\n   * Reads zig-zag encoded fixed 64 bits\n   */\n  sfixed64 (): bigint {\n    return this.readFixed64().toBigInt()\n  }\n\n  /**\n   * Reads zig-zag encoded fixed 64 bits returned as a possibly unsafe\n   * JavaScript number\n   */\n  sfixed64Number (): number {\n    return this.readFixed64().toNumber()\n  }\n\n  /**\n   * Reads zig-zag encoded fixed 64 bits returned as a string\n   */\n  sfixed64String (): string {\n    return this.readFixed64().toString()\n  }\n}\n\nexport function createReader (buf: Uint8Array | Uint8ArrayList): Reader {\n  return new Uint8ArrayReader(buf instanceof Uint8Array ? buf : buf.subarray())\n}\n", "import { createReader } from './utils/reader.js'\nimport type { Codec, DecodeOptions } from './codec.js'\nimport type { Uint8ArrayList } from 'uint8arraylist'\n\nexport function decodeMessage <T> (buf: Uint8Array | Uint8ArrayList, codec: Pick<Codec<T>, 'decode'>, opts?: DecodeOptions<T>): T {\n  const reader = createReader(buf)\n\n  return codec.decode(reader, undefined, opts)\n}\n", "import { baseX } from './base.js'\n\nexport const base10 = baseX({\n  prefix: '9',\n  name: 'base10',\n  alphabet: '0123456789'\n})\n", "import { rfc4648 } from './base.js'\n\nexport const base16 = rfc4648({\n  prefix: 'f',\n  name: 'base16',\n  alphabet: '0123456789abcdef',\n  bitsPerChar: 4\n})\n\nexport const base16upper = rfc4648({\n  prefix: 'F',\n  name: 'base16upper',\n  alphabet: '0123456789ABCDEF',\n  bitsPerChar: 4\n})\n", "import { rfc4648 } from './base.js'\n\nexport const base2 = rfc4648({\n  prefix: '0',\n  name: 'base2',\n  alphabet: '01',\n  bitsPerChar: 1\n})\n", "import { from } from './base.js'\n\nconst alphabet = Array.from('\uD83D\uDE80\uD83E\uDE90\u2604\uD83D\uDEF0\uD83C\uDF0C\uD83C\uDF11\uD83C\uDF12\uD83C\uDF13\uD83C\uDF14\uD83C\uDF15\uD83C\uDF16\uD83C\uDF17\uD83C\uDF18\uD83C\uDF0D\uD83C\uDF0F\uD83C\uDF0E\uD83D\uDC09\u2600\uD83D\uDCBB\uD83D\uDDA5\uD83D\uDCBE\uD83D\uDCBF\uD83D\uDE02\u2764\uD83D\uDE0D\uD83E\uDD23\uD83D\uDE0A\uD83D\uDE4F\uD83D\uDC95\uD83D\uDE2D\uD83D\uDE18\uD83D\uDC4D\uD83D\uDE05\uD83D\uDC4F\uD83D\uDE01\uD83D\uDD25\uD83E\uDD70\uD83D\uDC94\uD83D\uDC96\uD83D\uDC99\uD83D\uDE22\uD83E\uDD14\uD83D\uDE06\uD83D\uDE44\uD83D\uDCAA\uD83D\uDE09\u263A\uD83D\uDC4C\uD83E\uDD17\uD83D\uDC9C\uD83D\uDE14\uD83D\uDE0E\uD83D\uDE07\uD83C\uDF39\uD83E\uDD26\uD83C\uDF89\uD83D\uDC9E\u270C\u2728\uD83E\uDD37\uD83D\uDE31\uD83D\uDE0C\uD83C\uDF38\uD83D\uDE4C\uD83D\uDE0B\uD83D\uDC97\uD83D\uDC9A\uD83D\uDE0F\uD83D\uDC9B\uD83D\uDE42\uD83D\uDC93\uD83E\uDD29\uD83D\uDE04\uD83D\uDE00\uD83D\uDDA4\uD83D\uDE03\uD83D\uDCAF\uD83D\uDE48\uD83D\uDC47\uD83C\uDFB6\uD83D\uDE12\uD83E\uDD2D\u2763\uD83D\uDE1C\uD83D\uDC8B\uD83D\uDC40\uD83D\uDE2A\uD83D\uDE11\uD83D\uDCA5\uD83D\uDE4B\uD83D\uDE1E\uD83D\uDE29\uD83D\uDE21\uD83E\uDD2A\uD83D\uDC4A\uD83E\uDD73\uD83D\uDE25\uD83E\uDD24\uD83D\uDC49\uD83D\uDC83\uD83D\uDE33\u270B\uD83D\uDE1A\uD83D\uDE1D\uD83D\uDE34\uD83C\uDF1F\uD83D\uDE2C\uD83D\uDE43\uD83C\uDF40\uD83C\uDF37\uD83D\uDE3B\uD83D\uDE13\u2B50\u2705\uD83E\uDD7A\uD83C\uDF08\uD83D\uDE08\uD83E\uDD18\uD83D\uDCA6\u2714\uD83D\uDE23\uD83C\uDFC3\uD83D\uDC90\u2639\uD83C\uDF8A\uD83D\uDC98\uD83D\uDE20\u261D\uD83D\uDE15\uD83C\uDF3A\uD83C\uDF82\uD83C\uDF3B\uD83D\uDE10\uD83D\uDD95\uD83D\uDC9D\uD83D\uDE4A\uD83D\uDE39\uD83D\uDDE3\uD83D\uDCAB\uD83D\uDC80\uD83D\uDC51\uD83C\uDFB5\uD83E\uDD1E\uD83D\uDE1B\uD83D\uDD34\uD83D\uDE24\uD83C\uDF3C\uD83D\uDE2B\u26BD\uD83E\uDD19\u2615\uD83C\uDFC6\uD83E\uDD2B\uD83D\uDC48\uD83D\uDE2E\uD83D\uDE46\uD83C\uDF7B\uD83C\uDF43\uD83D\uDC36\uD83D\uDC81\uD83D\uDE32\uD83C\uDF3F\uD83E\uDDE1\uD83C\uDF81\u26A1\uD83C\uDF1E\uD83C\uDF88\u274C\u270A\uD83D\uDC4B\uD83D\uDE30\uD83E\uDD28\uD83D\uDE36\uD83E\uDD1D\uD83D\uDEB6\uD83D\uDCB0\uD83C\uDF53\uD83D\uDCA2\uD83E\uDD1F\uD83D\uDE41\uD83D\uDEA8\uD83D\uDCA8\uD83E\uDD2C\u2708\uD83C\uDF80\uD83C\uDF7A\uD83E\uDD13\uD83D\uDE19\uD83D\uDC9F\uD83C\uDF31\uD83D\uDE16\uD83D\uDC76\uD83E\uDD74\u25B6\u27A1\u2753\uD83D\uDC8E\uD83D\uDCB8\u2B07\uD83D\uDE28\uD83C\uDF1A\uD83E\uDD8B\uD83D\uDE37\uD83D\uDD7A\u26A0\uD83D\uDE45\uD83D\uDE1F\uD83D\uDE35\uD83D\uDC4E\uD83E\uDD32\uD83E\uDD20\uD83E\uDD27\uD83D\uDCCC\uD83D\uDD35\uD83D\uDC85\uD83E\uDDD0\uD83D\uDC3E\uD83C\uDF52\uD83D\uDE17\uD83E\uDD11\uD83C\uDF0A\uD83E\uDD2F\uD83D\uDC37\u260E\uD83D\uDCA7\uD83D\uDE2F\uD83D\uDC86\uD83D\uDC46\uD83C\uDFA4\uD83D\uDE47\uD83C\uDF51\u2744\uD83C\uDF34\uD83D\uDCA3\uD83D\uDC38\uD83D\uDC8C\uD83D\uDCCD\uD83E\uDD40\uD83E\uDD22\uD83D\uDC45\uD83D\uDCA1\uD83D\uDCA9\uD83D\uDC50\uD83D\uDCF8\uD83D\uDC7B\uD83E\uDD10\uD83E\uDD2E\uD83C\uDFBC\uD83E\uDD75\uD83D\uDEA9\uD83C\uDF4E\uD83C\uDF4A\uD83D\uDC7C\uD83D\uDC8D\uD83D\uDCE3\uD83E\uDD42')\nconst alphabetBytesToChars: string[] = (alphabet.reduce<string[]>((p, c, i) => { p[i] = c; return p }, ([])))\nconst alphabetCharsToBytes: number[] = (alphabet.reduce<number[]>((p, c, i) => {\n  const codePoint = c.codePointAt(0)\n  if (codePoint == null) {\n    throw new Error(`Invalid character: ${c}`)\n  }\n  p[codePoint] = i\n  return p\n}, ([])))\n\nfunction encode (data: Uint8Array): string {\n  return data.reduce((p, c) => {\n    p += alphabetBytesToChars[c]\n    return p\n  }, '')\n}\n\nfunction decode (str: string): Uint8Array {\n  const byts = []\n  for (const char of str) {\n    const codePoint = char.codePointAt(0)\n    if (codePoint == null) {\n      throw new Error(`Invalid character: ${char}`)\n    }\n    const byt = alphabetCharsToBytes[codePoint]\n    if (byt == null) {\n      throw new Error(`Non-base256emoji character: ${char}`)\n    }\n    byts.push(byt)\n  }\n  return new Uint8Array(byts)\n}\n\nexport const base256emoji = from({\n  prefix: '\uD83D\uDE80',\n  name: 'base256emoji',\n  encode,\n  decode\n})\n", "import { rfc4648 } from './base.js'\n\nexport const base64 = rfc4648({\n  prefix: 'm',\n  name: 'base64',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',\n  bitsPerChar: 6\n})\n\nexport const base64pad = rfc4648({\n  prefix: 'M',\n  name: 'base64pad',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=',\n  bitsPerChar: 6\n})\n\nexport const base64url = rfc4648({\n  prefix: 'u',\n  name: 'base64url',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_',\n  bitsPerChar: 6\n})\n\nexport const base64urlpad = rfc4648({\n  prefix: 'U',\n  name: 'base64urlpad',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=',\n  bitsPerChar: 6\n})\n", "import { rfc4648 } from './base.js'\n\nexport const base8 = rfc4648({\n  prefix: '7',\n  name: 'base8',\n  alphabet: '01234567',\n  bitsPerChar: 3\n})\n", "import { fromString, toString } from '../bytes.js'\nimport { from } from './base.js'\n\nexport const identity = from({\n  prefix: '\\x00',\n  name: 'identity',\n  encode: (buf) => toString(buf),\n  decode: (str) => fromString(str)\n})\n", "import type { ArrayBufferView, ByteView } from './interface.js'\n\nconst textEncoder = new TextEncoder()\nconst textDecoder = new TextDecoder()\n\nexport const name = 'json'\nexport const code = 0x0200\n\nexport function encode <T> (node: T): ByteView<T> {\n  return textEncoder.encode(JSON.stringify(node))\n}\n\nexport function decode <T> (data: ByteView<T> | ArrayBufferView<T>): T {\n  return JSON.parse(textDecoder.decode(data))\n}\n", "import { coerce } from '../bytes.js'\nimport type { ArrayBufferView, ByteView } from './interface.js'\n\nexport const name = 'raw'\nexport const code = 0x55\n\nexport function encode (node: Uint8Array): ByteView<Uint8Array> {\n  return coerce(node)\n}\n\nexport function decode (data: ByteView<Uint8Array> | ArrayBufferView<Uint8Array>): Uint8Array {\n  return coerce(data)\n}\n", "import { coerce } from '../bytes.js'\nimport * as Digest from './digest.js'\n\nconst code: 0x0 = 0x0\nconst name = 'identity'\n\nconst encode: (input: Uint8Array) => Uint8Array = coerce\n\nfunction digest (input: Uint8Array): Digest.Digest<typeof code, number> {\n  return Digest.create(code, encode(input))\n}\n\nexport const identity = { code, name, encode, digest }\n", "/* global crypto */\n\nimport { from } from './hasher.js'\n\nfunction sha (name: AlgorithmIdentifier): (data: Uint8Array) => Promise<Uint8Array> {\n  return async data => new Uint8Array(await crypto.subtle.digest(name, data))\n}\n\nexport const sha256 = from({\n  name: 'sha2-256',\n  code: 0x12,\n  encode: sha('SHA-256')\n})\n\nexport const sha512 = from({\n  name: 'sha2-512',\n  code: 0x13,\n  encode: sha('SHA-512')\n})\n", "import * as Digest from './digest.js'\nimport type { MultihashHasher } from './interface.js'\n\ntype Await<T> = Promise<T> | T\n\nexport function from <Name extends string, Code extends number> ({ name, code, encode }: { name: Name, code: Code, encode(input: Uint8Array): Await<Uint8Array> }): Hasher<Name, Code> {\n  return new Hasher(name, code, encode)\n}\n\n/**\n * Hasher represents a hashing algorithm implementation that produces as\n * `MultihashDigest`.\n */\nexport class Hasher<Name extends string, Code extends number> implements MultihashHasher<Code> {\n  readonly name: Name\n  readonly code: Code\n  readonly encode: (input: Uint8Array) => Await<Uint8Array>\n\n  constructor (name: Name, code: Code, encode: (input: Uint8Array) => Await<Uint8Array>) {\n    this.name = name\n    this.code = code\n    this.encode = encode\n  }\n\n  digest (input: Uint8Array): Await<Digest.Digest<Code, number>> {\n    if (input instanceof Uint8Array) {\n      const result = this.encode(input)\n      return result instanceof Uint8Array\n        ? Digest.create(this.code, result)\n        /* c8 ignore next 1 */\n        : result.then(digest => Digest.create(this.code, digest))\n    } else {\n      throw Error('Unknown type, must be binary type')\n      /* c8 ignore next 1 */\n    }\n  }\n}\n", "import * as base10 from './bases/base10.js'\nimport * as base16 from './bases/base16.js'\nimport * as base2 from './bases/base2.js'\nimport * as base256emoji from './bases/base256emoji.js'\nimport * as base32 from './bases/base32.js'\nimport * as base36 from './bases/base36.js'\nimport * as base58 from './bases/base58.js'\nimport * as base64 from './bases/base64.js'\nimport * as base8 from './bases/base8.js'\nimport * as identityBase from './bases/identity.js'\nimport * as json from './codecs/json.js'\nimport * as raw from './codecs/raw.js'\nimport * as identity from './hashes/identity.js'\nimport * as sha2 from './hashes/sha2.js'\nimport { CID, hasher, digest, varint, bytes } from './index.js'\n\nexport const bases = { ...identityBase, ...base2, ...base8, ...base10, ...base16, ...base32, ...base36, ...base58, ...base64, ...base256emoji }\nexport const hashes = { ...sha2, ...identity }\nexport const codecs = { raw, json }\n\nexport { CID, hasher, digest, varint, bytes }\n", "import { bases } from 'multiformats/basics'\nimport type { MultibaseCodec } from 'multiformats'\nimport { allocUnsafe } from '#alloc'\n\nfunction createCodec (name: string, prefix: string, encode: (buf: Uint8Array) => string, decode: (str: string) => Uint8Array): MultibaseCodec<any> {\n  return {\n    name,\n    prefix,\n    encoder: {\n      name,\n      prefix,\n      encode\n    },\n    decoder: {\n      decode\n    }\n  }\n}\n\nconst string = createCodec('utf8', 'u', (buf) => {\n  const decoder = new TextDecoder('utf8')\n  return 'u' + decoder.decode(buf)\n}, (str) => {\n  const encoder = new TextEncoder()\n  return encoder.encode(str.substring(1))\n})\n\nconst ascii = createCodec('ascii', 'a', (buf) => {\n  let string = 'a'\n\n  for (let i = 0; i < buf.length; i++) {\n    string += String.fromCharCode(buf[i])\n  }\n  return string\n}, (str) => {\n  str = str.substring(1)\n  const buf = allocUnsafe(str.length)\n\n  for (let i = 0; i < str.length; i++) {\n    buf[i] = str.charCodeAt(i)\n  }\n\n  return buf\n})\n\nexport type SupportedEncodings = 'utf8' | 'utf-8' | 'hex' | 'latin1' | 'ascii' | 'binary' | keyof typeof bases\n\nconst BASES: Record<SupportedEncodings, MultibaseCodec<any>> = {\n  utf8: string,\n  'utf-8': string,\n  hex: bases.base16,\n  latin1: ascii,\n  ascii,\n  binary: ascii,\n\n  ...bases\n}\n\nexport default BASES\n", "import bases, { type SupportedEncodings } from './util/bases.js'\n\nexport type { SupportedEncodings }\n\n/**\n * Create a `Uint8Array` from the passed string\n *\n * Supports `utf8`, `utf-8`, `hex`, and any encoding supported by the multiformats module.\n *\n * Also `ascii` which is similar to node's 'binary' encoding.\n */\nexport function fromString (string: string, encoding: SupportedEncodings = 'utf8'): Uint8Array {\n  const base = bases[encoding]\n\n  if (base == null) {\n    throw new Error(`Unsupported encoding \"${encoding}\"`)\n  }\n\n  // add multibase prefix\n  return base.decoder.decode(`${base.prefix}${string}`) // eslint-disable-line @typescript-eslint/restrict-template-expressions\n}\n", "import { allocUnsafe } from 'uint8arrays/alloc'\n\n/**\n * A general purpose buffer pool\n */\nexport default function pool (size?: number): (size: number) => Uint8Array {\n  const SIZE = size ?? 8192\n  const MAX = SIZE >>> 1\n  let slab: Uint8Array\n  let offset = SIZE\n  return function poolAlloc (size: number) {\n    if (size < 1 || size > MAX) {\n      return allocUnsafe(size)\n    }\n\n    if (offset + size > SIZE) {\n      slab = allocUnsafe(SIZE)\n      offset = 0\n    }\n\n    const buf = slab.subarray(offset, offset += size)\n\n    if ((offset & 7) !== 0) {\n      // align to 32 bit\n      offset = (offset | 7) + 1\n    }\n\n    return buf\n  }\n}\n", "import { encodeUint8Array, encodingLength } from 'uint8-varint'\nimport { allocUnsafe } from 'uint8arrays/alloc'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport { writeFloatLE, writeDoubleLE } from './float.js'\nimport { LongBits } from './longbits.js'\nimport pool from './pool.js'\nimport * as utf8 from './utf8.js'\nimport type { Writer } from '../index.js'\n\ninterface WriterOperation<T> {\n  (val: T, buf: Uint8Array, pos: number): any\n}\n\n/**\n * Constructs a new writer operation instance.\n *\n * @classdesc Scheduled writer operation\n */\nclass Op<T> {\n  /**\n   * Function to call\n   */\n  public fn: WriterOperation<T>\n\n  /**\n   * Value byte length\n   */\n  public len: number\n\n  /**\n   * Next operation\n   */\n  public next?: Op<any>\n\n  /**\n   * Value to write\n   */\n  public val: T\n\n  constructor (fn: WriterOperation<T>, len: number, val: T) {\n    this.fn = fn\n    this.len = len\n    this.next = undefined\n    this.val = val // type varies\n  }\n}\n\n/* istanbul ignore next */\nfunction noop (): void {}\n\n/**\n * Constructs a new writer state instance\n */\nclass State {\n  /**\n   * Current head\n   */\n  public head: Op<any>\n\n  /**\n   * Current tail\n   */\n  public tail: Op<any>\n\n  /**\n   * Current buffer length\n   */\n  public len: number\n\n  /**\n   * Next state\n   */\n  public next?: State\n\n  constructor (writer: Uint8ArrayWriter) {\n    this.head = writer.head\n    this.tail = writer.tail\n    this.len = writer.len\n    this.next = writer.states\n  }\n}\n\nconst bufferPool = pool()\n\n/**\n * Allocates a buffer of the specified size\n */\nfunction alloc (size: number): Uint8Array {\n  if (globalThis.Buffer != null) {\n    return allocUnsafe(size)\n  }\n\n  return bufferPool(size)\n}\n\n/**\n * When a value is written, the writer calculates its byte length and puts it into a linked\n * list of operations to perform when finish() is called. This both allows us to allocate\n * buffers of the exact required size and reduces the amount of work we have to do compared\n * to first calculating over objects and then encoding over objects. In our case, the encoding\n * part is just a linked list walk calling operations with already prepared values.\n */\nclass Uint8ArrayWriter implements Writer {\n  /**\n   * Current length\n   */\n  public len: number\n\n  /**\n   * Operations head\n   */\n  public head: Op<any>\n\n  /**\n   * Operations tail\n   */\n  public tail: Op<any>\n\n  /**\n   * Linked forked states\n   */\n  public states?: any\n\n  constructor () {\n    this.len = 0\n    this.head = new Op(noop, 0, 0)\n    this.tail = this.head\n    this.states = null\n  }\n\n  /**\n   * Pushes a new operation to the queue\n   */\n  _push (fn: WriterOperation<any>, len: number, val: any): this {\n    this.tail = this.tail.next = new Op(fn, len, val)\n    this.len += len\n\n    return this\n  }\n\n  /**\n   * Writes an unsigned 32 bit value as a varint\n   */\n  uint32 (value: number): this {\n    // here, the call to this.push has been inlined and a varint specific Op subclass is used.\n    // uint32 is by far the most frequently used operation and benefits significantly from this.\n    this.len += (this.tail = this.tail.next = new VarintOp(\n      (value = value >>> 0) <\n                128\n        ? 1\n        : value < 16384\n          ? 2\n          : value < 2097152\n            ? 3\n            : value < 268435456\n              ? 4\n              : 5,\n      value)).len\n    return this\n  }\n\n  /**\n   * Writes a signed 32 bit value as a varint`\n   */\n  int32 (value: number): this {\n    return value < 0\n      ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) // 10 bytes per spec\n      : this.uint32(value)\n  }\n\n  /**\n   * Writes a 32 bit value as a varint, zig-zag encoded\n   */\n  sint32 (value: number): this {\n    return this.uint32((value << 1 ^ value >> 31) >>> 0)\n  }\n\n  /**\n   * Writes an unsigned 64 bit value as a varint\n   */\n  uint64 (value: bigint): this {\n    const bits = LongBits.fromBigInt(value)\n    return this._push(writeVarint64, bits.length(), bits)\n  }\n\n  /**\n   * Writes an unsigned 64 bit value as a varint\n   */\n  uint64Number (value: number): this {\n    return this._push(encodeUint8Array, encodingLength(value), value)\n  }\n\n  /**\n   * Writes an unsigned 64 bit value as a varint\n   */\n  uint64String (value: string): this {\n    return this.uint64(BigInt(value))\n  }\n\n  /**\n   * Writes a signed 64 bit value as a varint\n   */\n  int64 (value: bigint): this {\n    return this.uint64(value)\n  }\n\n  /**\n   * Writes a signed 64 bit value as a varint\n   */\n  int64Number (value: number): this {\n    return this.uint64Number(value)\n  }\n\n  /**\n   * Writes a signed 64 bit value as a varint\n   */\n  int64String (value: string): this {\n    return this.uint64String(value)\n  }\n\n  /**\n   * Writes a signed 64 bit value as a varint, zig-zag encoded\n   */\n  sint64 (value: bigint): this {\n    const bits = LongBits.fromBigInt(value).zzEncode()\n    return this._push(writeVarint64, bits.length(), bits)\n  }\n\n  /**\n   * Writes a signed 64 bit value as a varint, zig-zag encoded\n   */\n  sint64Number (value: number): this {\n    const bits = LongBits.fromNumber(value).zzEncode()\n    return this._push(writeVarint64, bits.length(), bits)\n  }\n\n  /**\n   * Writes a signed 64 bit value as a varint, zig-zag encoded\n   */\n  sint64String (value: string): this {\n    return this.sint64(BigInt(value))\n  }\n\n  /**\n   * Writes a boolish value as a varint\n   */\n  bool (value: boolean): this {\n    return this._push(writeByte, 1, value ? 1 : 0)\n  }\n\n  /**\n   * Writes an unsigned 32 bit value as fixed 32 bits\n   */\n  fixed32 (value: number): this {\n    return this._push(writeFixed32, 4, value >>> 0)\n  }\n\n  /**\n   * Writes a signed 32 bit value as fixed 32 bits\n   */\n  sfixed32 (value: number): this {\n    return this.fixed32(value)\n  }\n\n  /**\n   * Writes an unsigned 64 bit value as fixed 64 bits\n   */\n  fixed64 (value: bigint): this {\n    const bits = LongBits.fromBigInt(value)\n    return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi)\n  }\n\n  /**\n   * Writes an unsigned 64 bit value as fixed 64 bits\n   */\n  fixed64Number (value: number): this {\n    const bits = LongBits.fromNumber(value)\n    return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi)\n  }\n\n  /**\n   * Writes an unsigned 64 bit value as fixed 64 bits\n   */\n  fixed64String (value: string): this {\n    return this.fixed64(BigInt(value))\n  }\n\n  /**\n   * Writes a signed 64 bit value as fixed 64 bits\n   */\n  sfixed64 (value: bigint): this {\n    return this.fixed64(value)\n  }\n\n  /**\n   * Writes a signed 64 bit value as fixed 64 bits\n   */\n  sfixed64Number (value: number): this {\n    return this.fixed64Number(value)\n  }\n\n  /**\n   * Writes a signed 64 bit value as fixed 64 bits\n   */\n  sfixed64String (value: string): this {\n    return this.fixed64String(value)\n  }\n\n  /**\n   * Writes a float (32 bit)\n   */\n  float (value: number): this {\n    return this._push(writeFloatLE, 4, value)\n  }\n\n  /**\n   * Writes a double (64 bit float).\n   *\n   * @function\n   * @param {number} value - Value to write\n   * @returns {Writer} `this`\n   */\n  double (value: number): this {\n    return this._push(writeDoubleLE, 8, value)\n  }\n\n  /**\n   * Writes a sequence of bytes\n   */\n  bytes (value: Uint8Array): this {\n    const len = value.length >>> 0\n\n    if (len === 0) {\n      return this._push(writeByte, 1, 0)\n    }\n\n    return this.uint32(len)._push(writeBytes, len, value)\n  }\n\n  /**\n   * Writes a string\n   */\n  string (value: string): this {\n    const len = utf8.length(value)\n    return len !== 0\n      ? this.uint32(len)._push(utf8.write, len, value)\n      : this._push(writeByte, 1, 0)\n  }\n\n  /**\n   * Forks this writer's state by pushing it to a stack.\n   * Calling {@link Writer#reset|reset} or {@link Writer#ldelim|ldelim} resets the writer to the previous state.\n   */\n  fork (): this {\n    this.states = new State(this)\n    this.head = this.tail = new Op(noop, 0, 0)\n    this.len = 0\n    return this\n  }\n\n  /**\n   * Resets this instance to the last state\n   */\n  reset (): this {\n    if (this.states != null) {\n      this.head = this.states.head\n      this.tail = this.states.tail\n      this.len = this.states.len\n      this.states = this.states.next\n    } else {\n      this.head = this.tail = new Op(noop, 0, 0)\n      this.len = 0\n    }\n    return this\n  }\n\n  /**\n   * Resets to the last state and appends the fork state's current write length as a varint followed by its operations.\n   */\n  ldelim (): this {\n    const head = this.head\n    const tail = this.tail\n    const len = this.len\n    this.reset().uint32(len)\n    if (len !== 0) {\n      this.tail.next = head.next // skip noop\n      this.tail = tail\n      this.len += len\n    }\n    return this\n  }\n\n  /**\n   * Finishes the write operation\n   */\n  finish (): Uint8Array {\n    let head = this.head.next // skip noop\n    const buf = alloc(this.len)\n    let pos = 0\n    while (head != null) {\n      head.fn(head.val, buf, pos)\n      pos += head.len\n      head = head.next\n    }\n    // this.head = this.tail = null;\n    return buf\n  }\n}\n\nfunction writeByte (val: number, buf: Uint8Array, pos: number): void {\n  buf[pos] = val & 255\n}\n\nfunction writeVarint32 (val: number, buf: Uint8Array, pos: number): void {\n  while (val > 127) {\n    buf[pos++] = val & 127 | 128\n    val >>>= 7\n  }\n  buf[pos] = val\n}\n\n/**\n * Constructs a new varint writer operation instance.\n *\n * @classdesc Scheduled varint writer operation\n */\nclass VarintOp extends Op<number> {\n  public next?: Op<any>\n\n  constructor (len: number, val: number) {\n    super(writeVarint32, len, val)\n    this.next = undefined\n  }\n}\n\nfunction writeVarint64 (val: LongBits, buf: Uint8Array, pos: number): void {\n  while (val.hi !== 0) {\n    buf[pos++] = val.lo & 127 | 128\n    val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0\n    val.hi >>>= 7\n  }\n  while (val.lo > 127) {\n    buf[pos++] = val.lo & 127 | 128\n    val.lo = val.lo >>> 7\n  }\n  buf[pos++] = val.lo\n}\n\nfunction writeFixed32 (val: number, buf: Uint8Array, pos: number): void {\n  buf[pos] = val & 255\n  buf[pos + 1] = val >>> 8 & 255\n  buf[pos + 2] = val >>> 16 & 255\n  buf[pos + 3] = val >>> 24\n}\n\nfunction writeBytes (val: Uint8Array, buf: Uint8Array, pos: number): void {\n  buf.set(val, pos)\n}\n\nif (globalThis.Buffer != null) {\n  Uint8ArrayWriter.prototype.bytes = function (value: Uint8Array) {\n    const len = value.length >>> 0\n\n    this.uint32(len)\n\n    if (len > 0) {\n      this._push(writeBytesBuffer, len, value)\n    }\n\n    return this\n  }\n\n  Uint8ArrayWriter.prototype.string = function (value: string) {\n    const len = globalThis.Buffer.byteLength(value)\n\n    this.uint32(len)\n\n    if (len > 0) {\n      this._push(writeStringBuffer, len, value)\n    }\n\n    return this\n  }\n}\n\nfunction writeBytesBuffer (val: Uint8Array, buf: Uint8Array, pos: number): void {\n  buf.set(val, pos) // faster than copy (requires node >= 4 where Buffers extend Uint8Array and set is properly inherited)\n  // also works for plain array values\n}\n\nfunction writeStringBuffer (val: string, buf: Uint8Array, pos: number): void {\n  if (val.length < 40) {\n    // plain js is faster for short strings (probably due to redundant assertions)\n    utf8.write(val, buf, pos)\n    // @ts-expect-error buf isn't a Uint8Array?\n  } else if (buf.utf8Write != null) {\n    // @ts-expect-error buf isn't a Uint8Array?\n    buf.utf8Write(val, pos)\n  } else {\n    buf.set(uint8ArrayFromString(val), pos)\n  }\n}\n\n/**\n * Creates a new writer\n */\nexport function createWriter (): Writer {\n  return new Uint8ArrayWriter()\n}\n", "import { createWriter } from './utils/writer.js'\nimport type { Codec } from './codec.js'\n\nexport function encodeMessage <T> (message: Partial<T>, codec: Pick<Codec<T>, 'encode'>): Uint8Array {\n  const w = createWriter()\n\n  codec.encode(message, w, {\n    lengthDelimited: false\n  })\n\n  return w.finish()\n}\n", "import type { Writer, Reader } from './index.js'\n\n// https://developers.google.com/protocol-buffers/docs/encoding#structure\nexport enum CODEC_TYPES {\n  VARINT = 0,\n  BIT64,\n  LENGTH_DELIMITED,\n  START_GROUP,\n  END_GROUP,\n  BIT32\n}\n\nexport interface EncodeOptions {\n  lengthDelimited?: boolean\n  writeDefaults?: boolean\n}\n\nexport interface EncodeFunction<T> {\n  (value: Partial<T>, writer: Writer, opts?: EncodeOptions): void\n}\n\n// protobuf types that contain multiple values\ntype CollectionTypes = any[] | Map<any, any>\n\n// protobuf types that are not collections or messages\ntype PrimitiveTypes = boolean | number | string | bigint | Uint8Array\n\n// recursive array/map field length limits\ntype CollectionLimits <T> = {\n  [K in keyof T]: T[K] extends CollectionTypes ? number :\n    T[K] extends PrimitiveTypes ? never : Limits<T[K]>\n}\n\n// recursive array member array/map field length limits\ntype ArrayElementLimits <T> = {\n  [K in keyof T as `${string & K}$`]: T[K] extends Array<infer ElementType> ?\n      (ElementType extends PrimitiveTypes ? never : Limits<ElementType>) :\n      (T[K] extends PrimitiveTypes ? never : Limits<T[K]>)\n}\n\n// recursive map value array/map field length limits\ntype MapValueLimits <T> = {\n  [K in keyof T as `${string & K}$value`]: T[K] extends Map<any, infer MapValueType> ?\n      (MapValueType extends PrimitiveTypes ? never : Limits<MapValueType>) :\n      (T[K] extends PrimitiveTypes ? never : Limits<T[K]>)\n}\n\n// union of collection and array elements\ntype Limits<T> = Partial<CollectionLimits<T> & ArrayElementLimits<T> & MapValueLimits<T>>\n\nexport interface DecodeOptions<T> {\n  /**\n   * Runtime-specified limits for lengths of repeated/map fields\n   */\n  limits?: Limits<T>\n}\n\nexport interface DecodeFunction<T> {\n  (reader: Reader, length?: number, opts?: DecodeOptions<T>): T\n}\n\nexport interface Codec<T> {\n  name: string\n  type: CODEC_TYPES\n  encode: EncodeFunction<T>\n  decode: DecodeFunction<T>\n}\n\nexport function createCodec <T> (name: string, type: CODEC_TYPES, encode: EncodeFunction<T>, decode: DecodeFunction<T>): Codec<T> {\n  return {\n    name,\n    type,\n    encode,\n    decode\n  }\n}\n", "import { createCodec, CODEC_TYPES } from '../codec.js'\nimport type { DecodeFunction, EncodeFunction, Codec } from '../codec.js'\n\nexport function enumeration <T> (v: any): Codec<T> {\n  function findValue (val: string | number): number {\n    // Use the reverse mapping to look up the enum key for the stored value\n    // https://www.typescriptlang.org/docs/handbook/enums.html#reverse-mappings\n    if (v[val.toString()] == null) {\n      throw new Error('Invalid enum value')\n    }\n\n    return v[val]\n  }\n\n  const encode: EncodeFunction<number | string> = function enumEncode (val, writer) {\n    const enumValue = findValue(val)\n\n    writer.int32(enumValue)\n  }\n\n  const decode: DecodeFunction<number | string> = function enumDecode (reader) {\n    const val = reader.int32()\n\n    return findValue(val)\n  }\n\n  // @ts-expect-error yeah yeah\n  return createCodec('enum', CODEC_TYPES.VARINT, encode, decode)\n}\n", "import { createCodec, CODEC_TYPES } from '../codec.js'\nimport type { EncodeFunction, DecodeFunction, Codec } from '../codec.js'\n\nexport interface Factory<A, T> {\n  new (obj: A): T\n}\n\nexport function message <T> (encode: EncodeFunction<T>, decode: DecodeFunction<T>): Codec<T> {\n  return createCodec('message', CODEC_TYPES.LENGTH_DELIMITED, encode, decode)\n}\n", "import { enumeration, encodeMessage, decodeMessage, message } from 'protons-runtime'\nimport type { Codec } from 'protons-runtime'\nimport type { Uint8ArrayList } from 'uint8arraylist'\n\nexport interface Data {\n  Type?: Data.DataType\n  Data?: Uint8Array\n  filesize?: bigint\n  blocksizes: bigint[]\n  hashType?: bigint\n  fanout?: bigint\n  mode?: number\n  mtime?: UnixTime\n}\n\nexport namespace Data {\n  export enum DataType {\n    Raw = 'Raw',\n    Directory = 'Directory',\n    File = 'File',\n    Metadata = 'Metadata',\n    Symlink = 'Symlink',\n    HAMTShard = 'HAMTShard'\n  }\n\n  enum __DataTypeValues {\n    Raw = 0,\n    Directory = 1,\n    File = 2,\n    Metadata = 3,\n    Symlink = 4,\n    HAMTShard = 5\n  }\n\n  export namespace DataType {\n    export const codec = (): Codec<DataType> => {\n      return enumeration<DataType>(__DataTypeValues)\n    }\n  }\n\n  let _codec: Codec<Data>\n\n  export const codec = (): Codec<Data> => {\n    if (_codec == null) {\n      _codec = message<Data>((obj, w, opts = {}) => {\n        if (opts.lengthDelimited !== false) {\n          w.fork()\n        }\n\n        if (obj.Type != null) {\n          w.uint32(8)\n          Data.DataType.codec().encode(obj.Type, w)\n        }\n\n        if (obj.Data != null) {\n          w.uint32(18)\n          w.bytes(obj.Data)\n        }\n\n        if (obj.filesize != null) {\n          w.uint32(24)\n          w.uint64(obj.filesize)\n        }\n\n        if (obj.blocksizes != null) {\n          for (const value of obj.blocksizes) {\n            w.uint32(32)\n            w.uint64(value)\n          }\n        }\n\n        if (obj.hashType != null) {\n          w.uint32(40)\n          w.uint64(obj.hashType)\n        }\n\n        if (obj.fanout != null) {\n          w.uint32(48)\n          w.uint64(obj.fanout)\n        }\n\n        if (obj.mode != null) {\n          w.uint32(56)\n          w.uint32(obj.mode)\n        }\n\n        if (obj.mtime != null) {\n          w.uint32(66)\n          UnixTime.codec().encode(obj.mtime, w)\n        }\n\n        if (opts.lengthDelimited !== false) {\n          w.ldelim()\n        }\n      }, (reader, length) => {\n        const obj: any = {\n          blocksizes: []\n        }\n\n        const end = length == null ? reader.len : reader.pos + length\n\n        while (reader.pos < end) {\n          const tag = reader.uint32()\n\n          switch (tag >>> 3) {\n            case 1:\n              obj.Type = Data.DataType.codec().decode(reader)\n              break\n            case 2:\n              obj.Data = reader.bytes()\n              break\n            case 3:\n              obj.filesize = reader.uint64()\n              break\n            case 4:\n              obj.blocksizes.push(reader.uint64())\n              break\n            case 5:\n              obj.hashType = reader.uint64()\n              break\n            case 6:\n              obj.fanout = reader.uint64()\n              break\n            case 7:\n              obj.mode = reader.uint32()\n              break\n            case 8:\n              obj.mtime = UnixTime.codec().decode(reader, reader.uint32())\n              break\n            default:\n              reader.skipType(tag & 7)\n              break\n          }\n        }\n\n        return obj\n      })\n    }\n\n    return _codec\n  }\n\n  export const encode = (obj: Partial<Data>): Uint8Array => {\n    return encodeMessage(obj, Data.codec())\n  }\n\n  export const decode = (buf: Uint8Array | Uint8ArrayList): Data => {\n    return decodeMessage(buf, Data.codec())\n  }\n}\n\nexport interface UnixTime {\n  Seconds?: bigint\n  FractionalNanoseconds?: number\n}\n\nexport namespace UnixTime {\n  let _codec: Codec<UnixTime>\n\n  export const codec = (): Codec<UnixTime> => {\n    if (_codec == null) {\n      _codec = message<UnixTime>((obj, w, opts = {}) => {\n        if (opts.lengthDelimited !== false) {\n          w.fork()\n        }\n\n        if (obj.Seconds != null) {\n          w.uint32(8)\n          w.int64(obj.Seconds)\n        }\n\n        if (obj.FractionalNanoseconds != null) {\n          w.uint32(21)\n          w.fixed32(obj.FractionalNanoseconds)\n        }\n\n        if (opts.lengthDelimited !== false) {\n          w.ldelim()\n        }\n      }, (reader, length) => {\n        const obj: any = {}\n\n        const end = length == null ? reader.len : reader.pos + length\n\n        while (reader.pos < end) {\n          const tag = reader.uint32()\n\n          switch (tag >>> 3) {\n            case 1:\n              obj.Seconds = reader.int64()\n              break\n            case 2:\n              obj.FractionalNanoseconds = reader.fixed32()\n              break\n            default:\n              reader.skipType(tag & 7)\n              break\n          }\n        }\n\n        return obj\n      })\n    }\n\n    return _codec\n  }\n\n  export const encode = (obj: Partial<UnixTime>): Uint8Array => {\n    return encodeMessage(obj, UnixTime.codec())\n  }\n\n  export const decode = (buf: Uint8Array | Uint8ArrayList): UnixTime => {\n    return decodeMessage(buf, UnixTime.codec())\n  }\n}\n\nexport interface Metadata {\n  MimeType?: string\n}\n\nexport namespace Metadata {\n  let _codec: Codec<Metadata>\n\n  export const codec = (): Codec<Metadata> => {\n    if (_codec == null) {\n      _codec = message<Metadata>((obj, w, opts = {}) => {\n        if (opts.lengthDelimited !== false) {\n          w.fork()\n        }\n\n        if (obj.MimeType != null) {\n          w.uint32(10)\n          w.string(obj.MimeType)\n        }\n\n        if (opts.lengthDelimited !== false) {\n          w.ldelim()\n        }\n      }, (reader, length) => {\n        const obj: any = {}\n\n        const end = length == null ? reader.len : reader.pos + length\n\n        while (reader.pos < end) {\n          const tag = reader.uint32()\n\n          switch (tag >>> 3) {\n            case 1:\n              obj.MimeType = reader.string()\n              break\n            default:\n              reader.skipType(tag & 7)\n              break\n          }\n        }\n\n        return obj\n      })\n    }\n\n    return _codec\n  }\n\n  export const encode = (obj: Partial<Metadata>): Uint8Array => {\n    return encodeMessage(obj, Metadata.codec())\n  }\n\n  export const decode = (buf: Uint8Array | Uint8ArrayList): Metadata => {\n    return decodeMessage(buf, Metadata.codec())\n  }\n}\n", "/**\n * @packageDocumentation\n *\n * This module contains the protobuf definition of the UnixFS data structure found at the root of all UnixFS DAGs.\n *\n * The UnixFS spec can be found in the [ipfs/specs repository](http://github.com/ipfs/specs)\n *\n * @example Create a file composed of several blocks\n *\n * ```TypeScript\n * import { UnixFS } from 'ipfs-unixfs'\n *\n * const data = new UnixFS({ type: 'file' })\n * data.addBlockSize(256n) // add the size of each block\n * data.addBlockSize(256n)\n * // ...\n * ```\n *\n * @example Create a directory that contains several files\n *\n * Creating a directory that contains several files is achieve by creating a unixfs element that identifies a MerkleDAG node as a directory. The links of that MerkleDAG node are the files that are contained in this directory.\n *\n * ```TypeScript\n * import { UnixFS } from 'ipfs-unixfs'\n *\n * const data = new UnixFS({ type: 'directory' })\n * ```\n *\n * @example Create an unixfs Data element\n *\n * ```TypeScript\n * import { UnixFS } from 'ipfs-unixfs'\n *\n * const data = new UnixFS({\n *   // ...options\n * })\n * ```\n *\n * `options` is an optional object argument that might include the following keys:\n *\n * - type (string, default `file`): The type of UnixFS entry.  Can be:\n *   - `raw`\n *   - `directory`\n *   - `file`\n *   - `metadata`\n *   - `symlink`\n *   - `hamt-sharded-directory`\n * - data (Uint8Array): The optional data field for this node\n * - blockSizes (Array, default: `[]`): If this is a `file` node that is made up of multiple blocks, `blockSizes` is a list numbers that represent the size of the file chunks stored in each child node. It is used to calculate the total file size.\n * - mode (Number, default `0644` for files, `0755` for directories/hamt-sharded-directories) file mode\n * - mtime (`Date`, `{ secs, nsecs }`, `{ Seconds, FractionalNanoseconds }`, `[ secs, nsecs ]`): The modification time of this node\n *\n * @example Add and remove a block size to the block size list\n *\n * ```TypeScript\n * import { UnixFS } from 'ipfs-unixfs'\n *\n * const data = new UnixFS({ type: 'file' })\n * const sizeInBytes = 100n\n * data.addBlockSize(sizeInBytes)\n * ```\n *\n * ```TypeScript\n * import { UnixFS } from 'ipfs-unixfs'\n *\n * const data = new UnixFS({ type: 'file' })\n *\n * const index = 0\n * data.removeBlockSize(index)\n * ```\n *\n * @example Get total fileSize\n *\n * ```TypeScript\n * import { UnixFS } from 'ipfs-unixfs'\n *\n * const data = new UnixFS({ type: 'file' })\n * data.fileSize() // => size in bytes\n * ```\n *\n * @example Marshal and unmarshal\n *\n * ```TypeScript\n * import { UnixFS } from 'ipfs-unixfs'\n *\n * const data = new UnixFS({ type: 'file' })\n * const marshaled = data.marshal()\n * const unmarshaled = UnixFS.unmarshal(marshaled)\n * ```\n *\n * @example Is this UnixFS entry a directory?\n *\n * ```TypeScript\n * import { UnixFS } from 'ipfs-unixfs'\n *\n * const dir = new UnixFS({ type: 'directory' })\n * dir.isDirectory() // true\n *\n * const file = new UnixFS({ type: 'file' })\n * file.isDirectory() // false\n * ```\n *\n * @example Has an mtime been set?\n *\n * If no modification time has been set, no `mtime` property will be present on the `Data` instance:\n *\n * ```TypeScript\n * import { UnixFS } from 'ipfs-unixfs'\n *\n * const file = new UnixFS({ type: 'file' })\n * file.mtime // undefined\n *\n * Object.prototype.hasOwnProperty.call(file, 'mtime') // false\n *\n * const dir = new UnixFS({ type: 'directory', mtime: { secs: 5n } })\n * dir.mtime // { secs: Number, nsecs: Number }\n * ```\n */\n\nimport { InvalidTypeError, InvalidUnixFSMessageError } from './errors.js'\nimport { Data as PBData } from './unixfs.js'\n\nexport interface Mtime {\n  secs: bigint\n  nsecs?: number\n}\n\nexport type MtimeLike = Mtime | { Seconds: number, FractionalNanoseconds?: number } | [number, number] | Date\n\nexport type UnixFSType = 'raw' | 'directory' | 'file' | 'metadata' | 'symlink' | 'hamt-sharded-directory'\n\nconst types: Record<string, UnixFSType> = {\n  Raw: 'raw',\n  Directory: 'directory',\n  File: 'file',\n  Metadata: 'metadata',\n  Symlink: 'symlink',\n  HAMTShard: 'hamt-sharded-directory'\n}\n\nconst dirTypes = [\n  'directory',\n  'hamt-sharded-directory'\n]\n\nconst DEFAULT_FILE_MODE = parseInt('0644', 8)\nconst DEFAULT_DIRECTORY_MODE = parseInt('0755', 8)\n\n// https://github.com/ipfs/boxo/blob/364c5040ec91ec8e2a61446e9921e9225704c34d/ipld/unixfs/hamt/hamt.go#L778\nconst MAX_FANOUT = BigInt(1 << 10)\n\nexport interface UnixFSOptions {\n  type?: UnixFSType\n  data?: Uint8Array\n  blockSizes?: bigint[]\n  hashType?: bigint\n  fanout?: bigint\n  mtime?: Mtime\n  mode?: number\n}\n\nclass UnixFS {\n  /**\n   * Decode from protobuf https://github.com/ipfs/specs/blob/master/UNIXFS.md\n   */\n  static unmarshal (marshaled: Uint8Array): UnixFS {\n    const message = PBData.decode(marshaled)\n\n    if (message.fanout != null && message.fanout > MAX_FANOUT) {\n      throw new InvalidUnixFSMessageError(`Fanout size was too large - ${message.fanout} > ${MAX_FANOUT}`)\n    }\n\n    const data = new UnixFS({\n      type: types[message.Type != null ? message.Type.toString() : 'File'],\n      data: message.Data,\n      blockSizes: message.blocksizes,\n      mode: message.mode,\n      mtime: message.mtime != null\n        ? {\n            secs: message.mtime.Seconds ?? 0n,\n            nsecs: message.mtime.FractionalNanoseconds\n          }\n        : undefined,\n      fanout: message.fanout\n    })\n\n    // make sure we honour the original mode\n    data._originalMode = message.mode ?? 0\n\n    return data\n  }\n\n  public type: string\n  public data?: Uint8Array\n  public blockSizes: bigint[]\n  public hashType?: bigint\n  public fanout?: bigint\n  public mtime?: Mtime\n\n  private _mode?: number\n  private _originalMode: number\n\n  constructor (options: UnixFSOptions = {\n    type: 'file'\n  }) {\n    const {\n      type,\n      data,\n      blockSizes,\n      hashType,\n      fanout,\n      mtime,\n      mode\n    } = options\n\n    if (type != null && !Object.values(types).includes(type)) {\n      throw new InvalidTypeError('Type: ' + type + ' is not valid')\n    }\n\n    this.type = type ?? 'file'\n    this.data = data\n    this.hashType = hashType\n    this.fanout = fanout\n    this.blockSizes = blockSizes ?? []\n    this._originalMode = 0\n    this.mode = mode\n    this.mtime = mtime\n  }\n\n  set mode (mode: number | undefined) {\n    if (mode == null) {\n      this._mode = this.isDirectory() ? DEFAULT_DIRECTORY_MODE : DEFAULT_FILE_MODE\n    } else {\n      this._mode = (mode & 0xFFF)\n    }\n  }\n\n  get mode (): number | undefined {\n    return this._mode\n  }\n\n  isDirectory (): boolean {\n    return dirTypes.includes(this.type)\n  }\n\n  addBlockSize (size: bigint): void {\n    this.blockSizes.push(size)\n  }\n\n  removeBlockSize (index: number): void {\n    this.blockSizes.splice(index, 1)\n  }\n\n  /**\n   * Returns `0n` for directories or `data.length + sum(blockSizes)` for everything else\n   */\n  fileSize (): bigint {\n    if (this.isDirectory()) {\n      // dirs don't have file size\n      return 0n\n    }\n\n    let sum = 0n\n    this.blockSizes.forEach((size) => {\n      sum += size\n    })\n\n    if (this.data != null) {\n      sum += BigInt(this.data.length)\n    }\n\n    return sum\n  }\n\n  /**\n   * encode to protobuf Uint8Array\n   */\n  marshal (): Uint8Array {\n    let type\n\n    switch (this.type) {\n      case 'raw': type = PBData.DataType.Raw; break\n      case 'directory': type = PBData.DataType.Directory; break\n      case 'file': type = PBData.DataType.File; break\n      case 'metadata': type = PBData.DataType.Metadata; break\n      case 'symlink': type = PBData.DataType.Symlink; break\n      case 'hamt-sharded-directory': type = PBData.DataType.HAMTShard; break\n      default:\n        throw new InvalidTypeError(`Type: ${type} is not valid`)\n    }\n\n    let data = this.data\n\n    if (this.data == null || this.data.length === 0) {\n      data = undefined\n    }\n\n    let mode\n\n    if (this.mode != null) {\n      mode = (this._originalMode & 0xFFFFF000) | (this.mode ?? 0)\n\n      if (mode === DEFAULT_FILE_MODE && !this.isDirectory()) {\n        mode = undefined\n      }\n\n      if (mode === DEFAULT_DIRECTORY_MODE && this.isDirectory()) {\n        mode = undefined\n      }\n    }\n\n    let mtime\n\n    if (this.mtime != null) {\n      mtime = {\n        Seconds: this.mtime.secs,\n        FractionalNanoseconds: this.mtime.nsecs\n      }\n    }\n\n    return PBData.encode({\n      Type: type,\n      Data: data,\n      filesize: this.isDirectory() ? undefined : this.fileSize(),\n      blocksizes: this.blockSizes,\n      hashType: this.hashType,\n      fanout: this.fanout,\n      mode,\n      mtime\n    })\n  }\n}\n\nexport { UnixFS }\nexport * from './errors.js'\n", "/**\n * Progress events are emitted during long running operations\n */\nexport interface ProgressEvent<T extends string = any, D = unknown> {\n  /**\n   * The event type\n   */\n  type: T\n\n  /**\n   * Context-specific event information\n   */\n  detail: D\n}\n\n/**\n * An implementation of the ProgressEvent interface, this is essentially\n * a typed `CustomEvent` with a `type` property that lets us disambiguate\n * events passed to `progress` callbacks.\n */\nexport class CustomProgressEvent<D = unknown, T extends string = any> extends Event implements ProgressEvent<T, D> {\n  public type: T\n  public detail: D\n\n  constructor (type: T, detail?: D) {\n    super(type)\n\n    this.type = type\n    // @ts-expect-error detail may be undefined\n    this.detail = detail\n  }\n}\n\n/**\n * Define an `onProgress` callback that can be invoked with `ProgressEvent`s\n *\n * @example\n *\n * ```typescript\n * type MyOperationProgressEvents =\n *   ProgressEvent<'operation:start'> |\n *   ProgressEvent<'operation:success', Result> |\n *   ProgressEvent<'operation:error', Error>\n *\n * export interface MyOperationOptions extends ProgressOptions<MyOperationProgressEvents> {\n *  // define options here\n * }\n * ```\n */\nexport interface ProgressOptions<Event extends ProgressEvent = any> {\n  onProgress?: (evt: Event) => void\n}\n", "import * as dagPb from '@ipld/dag-pb'\nimport { CID } from 'multiformats/cid'\nimport { sha256 } from 'multiformats/hashes/sha2'\nimport type { WritableStorage } from '../index.js'\nimport type { Version as CIDVersion } from 'multiformats/cid'\nimport type { BlockCodec } from 'multiformats/codecs/interface'\nimport type { ProgressOptions } from 'progress-events'\n\nexport interface PersistOptions extends ProgressOptions {\n  codec?: BlockCodec<any, any>\n  cidVersion: CIDVersion\n  signal?: AbortSignal\n}\n\nexport const persist = async (buffer: Uint8Array, blockstore: WritableStorage, options: PersistOptions): Promise<CID> => {\n  if (options.codec == null) {\n    options.codec = dagPb\n  }\n\n  const multihash = await sha256.digest(buffer)\n  const cid = CID.create(options.cidVersion, options.codec.code, multihash)\n\n  await blockstore.put(cid, buffer, options)\n\n  return cid\n}\n", "import * as dagPb from '@ipld/dag-pb'\nimport { UnixFS } from 'ipfs-unixfs'\nimport * as raw from 'multiformats/codecs/raw'\nimport { CustomProgressEvent } from 'progress-events'\nimport { persist } from '../utils/persist.js'\nimport type { BufferImporter } from '../index.js'\nimport type { PersistOptions } from '../utils/persist.js'\nimport type { CID, Version } from 'multiformats/cid'\nimport type { ProgressOptions, ProgressEvent } from 'progress-events'\n\n/**\n * Passed to the onProgress callback while importing files\n */\nexport interface ImportWriteProgress {\n  /**\n   * How many bytes we have written for this source so far - this may be\n   * bigger than the file size due to the DAG-PB wrappers of each block\n   */\n  bytesWritten: bigint\n\n  /**\n   * The CID of the block that has been written\n   */\n  cid: CID\n\n  /**\n   * The path of the file being imported, if one was specified\n   */\n  path?: string\n}\n\nexport type BufferImportProgressEvents =\n  ProgressEvent<'unixfs:importer:progress:file:write', ImportWriteProgress>\n\nexport interface BufferImporterOptions extends ProgressOptions<BufferImportProgressEvents> {\n  cidVersion: Version\n  rawLeaves: boolean\n  leafType: 'file' | 'raw'\n}\n\nexport function defaultBufferImporter (options: BufferImporterOptions): BufferImporter {\n  return async function * bufferImporter (file, blockstore) {\n    let bytesWritten = 0n\n\n    for await (let block of file.content) {\n      yield async () => { // eslint-disable-line no-loop-func\n        let unixfs\n\n        const opts: PersistOptions = {\n          codec: dagPb,\n          cidVersion: options.cidVersion,\n          onProgress: options.onProgress\n        }\n\n        if (options.rawLeaves) {\n          opts.codec = raw\n          opts.cidVersion = 1\n        } else {\n          unixfs = new UnixFS({\n            type: options.leafType,\n            data: block\n          })\n\n          block = dagPb.encode({\n            Data: unixfs.marshal(),\n            Links: []\n          })\n        }\n\n        const cid = await persist(block, blockstore, opts)\n\n        bytesWritten += BigInt(block.byteLength)\n\n        options.onProgress?.(new CustomProgressEvent<ImportWriteProgress>('unixfs:importer:progress:file:write', {\n          bytesWritten,\n          cid,\n          path: file.path\n        }))\n\n        return {\n          cid,\n          unixfs,\n          size: BigInt(block.length),\n          block\n        }\n      }\n    }\n  }\n}\n", "export class InvalidParametersError extends Error {\n  static name = 'InvalidParametersError'\n  static code = 'ERR_INVALID_PARAMS'\n  name = InvalidParametersError.name\n  code = InvalidParametersError.code\n\n  constructor (message = 'Invalid parameters') {\n    super(message)\n  }\n}\n\nexport class InvalidAvgChunkSizeError extends Error {\n  static name = 'InvalidAvgChunkSizeError'\n  static code = 'ERR_INVALID_AVG_CHUNK_SIZE'\n  name = InvalidAvgChunkSizeError.name\n  code = InvalidAvgChunkSizeError.code\n\n  constructor (message = 'Invalid avg chunk size') {\n    super(message)\n  }\n}\n\nexport class InvalidChunkSizeError extends Error {\n  static name = 'InvalidChunkSizeError'\n  static code = 'ERR_INVALID_CHUNK_SIZE'\n  name = InvalidChunkSizeError.name\n  code = InvalidChunkSizeError.code\n\n  constructor (message = 'Invalid chunk size') {\n    super(message)\n  }\n}\n\nexport class InvalidMinChunkSizeError extends Error {\n  static name = 'InvalidMinChunkSizeError'\n  static code = 'ERR_INVALID_MIN_CHUNK_SIZE'\n  name = InvalidMinChunkSizeError.name\n  code = InvalidMinChunkSizeError.code\n\n  constructor (message = 'Invalid min chunk size') {\n    super(message)\n  }\n}\n\nexport class InvalidContentError extends Error {\n  static name = 'InvalidContentError'\n  static code = 'ERR_INVALID_CONTENT'\n  name = InvalidContentError.name\n  code = InvalidContentError.code\n\n  constructor (message = 'Invalid content') {\n    super(message)\n  }\n}\n", "import { encode, prepare } from '@ipld/dag-pb'\nimport { UnixFS } from 'ipfs-unixfs'\nimport { persist } from '../utils/persist.js'\nimport type { Directory, InProgressImportResult, WritableStorage } from '../index.js'\nimport type { Version } from 'multiformats/cid'\n\nexport interface DirBuilderOptions {\n  cidVersion: Version\n  signal?: AbortSignal\n}\n\nexport interface DirBuilder {\n  (dir: Directory, blockstore: WritableStorage, options: DirBuilderOptions): Promise<InProgressImportResult>\n}\n\nexport const defaultDirBuilder: DirBuilder = async (dir: Directory, blockstore: WritableStorage, options: DirBuilderOptions): Promise<InProgressImportResult> => {\n  const unixfs = new UnixFS({\n    type: 'directory',\n    mtime: dir.mtime,\n    mode: dir.mode\n  })\n\n  const block = encode(prepare({ Data: unixfs.marshal() }))\n  const cid = await persist(block, blockstore, options)\n  const path = dir.path\n\n  return {\n    cid,\n    path,\n    unixfs,\n    size: BigInt(block.length),\n    originalPath: dir.originalPath,\n    block\n  }\n}\n", "import { encode, prepare } from '@ipld/dag-pb'\nimport { UnixFS } from 'ipfs-unixfs'\nimport parallelBatch from 'it-parallel-batch'\nimport * as rawCodec from 'multiformats/codecs/raw'\nimport { CustomProgressEvent } from 'progress-events'\nimport { persist } from '../utils/persist.js'\nimport type { BufferImporter, File, InProgressImportResult, WritableStorage, SingleBlockImportResult, ImporterProgressEvents } from '../index.js'\nimport type { FileLayout, Reducer } from '../layout/index.js'\nimport type { PBLink, PBNode } from '@ipld/dag-pb'\nimport type { CID, Version } from 'multiformats/cid'\nimport type { ProgressOptions, ProgressEvent } from 'progress-events'\n\ninterface BuildFileBatchOptions {\n  bufferImporter: BufferImporter\n  blockWriteConcurrency: number\n}\n\nasync function * buildFileBatch (file: File, blockstore: WritableStorage, options: BuildFileBatchOptions): AsyncGenerator<InProgressImportResult> {\n  let count = -1\n  let previous: SingleBlockImportResult | undefined\n\n  for await (const entry of parallelBatch(options.bufferImporter(file, blockstore), options.blockWriteConcurrency)) {\n    count++\n\n    if (count === 0) {\n      // cache the first entry if case there aren't any more\n      previous = {\n        ...entry,\n        single: true\n      }\n\n      continue\n    } else if (count === 1 && previous != null) {\n      // we have the second block of a multiple block import so yield the first\n      yield {\n        ...previous,\n        block: undefined,\n        single: undefined\n      }\n      previous = undefined\n    }\n\n    // yield the second or later block of a multiple block import\n    yield {\n      ...entry,\n      block: undefined\n    }\n  }\n\n  if (previous != null) {\n    yield previous\n  }\n}\n\nexport interface LayoutLeafProgress {\n  /**\n   * The CID of the leaf being written\n   */\n  cid: CID\n\n  /**\n   * The path of the file being imported, if one was specified\n   */\n  path?: string\n}\n\nexport type ReducerProgressEvents =\n  ProgressEvent<'unixfs:importer:progress:file:layout', LayoutLeafProgress>\n\ninterface ReduceOptions extends ProgressOptions<ImporterProgressEvents> {\n  reduceSingleLeafToSelf: boolean\n  cidVersion: Version\n  signal?: AbortSignal\n}\n\nfunction isSingleBlockImport (result: any): result is SingleBlockImportResult {\n  return result.single === true\n}\n\nconst reduce = (file: File, blockstore: WritableStorage, options: ReduceOptions): Reducer => {\n  const reducer: Reducer = async function (leaves) {\n    if (leaves.length === 1 && isSingleBlockImport(leaves[0]) && options.reduceSingleLeafToSelf) {\n      const leaf = leaves[0]\n      let node: Uint8Array | PBNode = leaf.block\n\n      if (isSingleBlockImport(leaf) && (file.mtime !== undefined || file.mode !== undefined)) {\n        // only one leaf node which is a raw leaf - we have metadata so convert it into a\n        // UnixFS entry otherwise we'll have nowhere to store the metadata\n        leaf.unixfs = new UnixFS({\n          type: 'file',\n          mtime: file.mtime,\n          mode: file.mode,\n          data: leaf.block\n        })\n\n        node = { Data: leaf.unixfs.marshal(), Links: [] }\n\n        leaf.block = encode(prepare(node))\n\n        leaf.cid = await persist(leaf.block, blockstore, {\n          ...options,\n          cidVersion: options.cidVersion\n        })\n        leaf.size = BigInt(leaf.block.length)\n      }\n\n      options.onProgress?.(new CustomProgressEvent<LayoutLeafProgress>('unixfs:importer:progress:file:layout', {\n        cid: leaf.cid,\n        path: leaf.originalPath\n      }))\n\n      return {\n        cid: leaf.cid,\n        path: file.path,\n        unixfs: leaf.unixfs,\n        size: leaf.size,\n        originalPath: leaf.originalPath\n      }\n    }\n\n    // create a parent node and add all the leaves\n    const f = new UnixFS({\n      type: 'file',\n      mtime: file.mtime,\n      mode: file.mode\n    })\n\n    const links: PBLink[] = leaves\n      .filter(leaf => {\n        if (leaf.cid.code === rawCodec.code && leaf.size > 0) {\n          return true\n        }\n\n        if (leaf.unixfs != null && leaf.unixfs.data == null && leaf.unixfs.fileSize() > 0n) {\n          return true\n        }\n\n        return Boolean(leaf.unixfs?.data?.length)\n      })\n      .map((leaf) => {\n        if (leaf.cid.code === rawCodec.code) {\n          // node is a leaf buffer\n          f.addBlockSize(leaf.size)\n\n          return {\n            Name: '',\n            Tsize: Number(leaf.size),\n            Hash: leaf.cid\n          }\n        }\n\n        if ((leaf.unixfs?.data == null)) {\n          // node is an intermediate node\n          f.addBlockSize(leaf.unixfs?.fileSize() ?? 0n)\n        } else {\n          // node is a unixfs 'file' leaf node\n          f.addBlockSize(BigInt(leaf.unixfs.data.length))\n        }\n\n        return {\n          Name: '',\n          Tsize: Number(leaf.size),\n          Hash: leaf.cid\n        }\n      })\n\n    const node = {\n      Data: f.marshal(),\n      Links: links\n    }\n    const block = encode(prepare(node))\n    const cid = await persist(block, blockstore, options)\n\n    options.onProgress?.(new CustomProgressEvent<LayoutLeafProgress>('unixfs:importer:progress:file:layout', {\n      cid,\n      path: file.originalPath\n    }))\n\n    return {\n      cid,\n      path: file.path,\n      unixfs: f,\n      size: BigInt(block.length + node.Links.reduce((acc, curr) => acc + (curr.Tsize ?? 0), 0)),\n      originalPath: file.originalPath,\n      block\n    }\n  }\n\n  return reducer\n}\n\nexport interface FileBuilder {\n  (file: File, blockstore: WritableStorage, options: FileBuilderOptions): Promise<InProgressImportResult>\n}\n\nexport interface FileBuilderOptions extends BuildFileBatchOptions, ReduceOptions {\n  layout: FileLayout\n}\n\nexport const defaultFileBuilder: FileBuilder = async (file: File, block: WritableStorage, options: FileBuilderOptions): Promise<InProgressImportResult> => {\n  return options.layout(\n    buildFileBatch(file, block, options),\n    reduce(file, block, options)\n  )\n}\n", "import { CustomProgressEvent } from 'progress-events'\nimport { InvalidContentError } from '../errors.js'\nimport { defaultDirBuilder } from './dir.js'\nimport { defaultFileBuilder } from './file.js'\nimport type { DirBuilder, DirBuilderOptions } from './dir.js'\nimport type { FileBuilder, FileBuilderOptions } from './file.js'\nimport type { ChunkValidator } from './validate-chunks.js'\nimport type { Chunker } from '../chunker/index.js'\nimport type { Directory, File, FileCandidate, ImportCandidate, ImporterProgressEvents, InProgressImportResult, WritableStorage } from '../index.js'\nimport type { ProgressEvent, ProgressOptions } from 'progress-events'\n\n/**\n * Passed to the onProgress callback while importing files\n */\nexport interface ImportReadProgress {\n  /**\n   * How many bytes we have read from this source so far\n   */\n  bytesRead: bigint\n\n  /**\n   * The size of the current chunk\n   */\n  chunkSize: bigint\n\n  /**\n   * The path of the file being imported, if one was specified\n   */\n  path?: string\n}\n\nexport type DagBuilderProgressEvents =\n  ProgressEvent<'unixfs:importer:progress:file:read', ImportReadProgress>\n\nfunction isIterable (thing: any): thing is Iterable<any> {\n  return Symbol.iterator in thing\n}\n\nfunction isAsyncIterable (thing: any): thing is AsyncIterable<any> {\n  return Symbol.asyncIterator in thing\n}\n\nfunction contentAsAsyncIterable (content: Uint8Array | AsyncIterable<Uint8Array> | Iterable<Uint8Array>): AsyncIterable<Uint8Array> {\n  try {\n    if (content instanceof Uint8Array) {\n      return (async function * () {\n        yield content\n      })()\n    } else if (isIterable(content)) {\n      return (async function * () {\n        yield * content\n      })()\n    } else if (isAsyncIterable(content)) {\n      return content\n    }\n  } catch {\n    throw new InvalidContentError('Content was invalid')\n  }\n\n  throw new InvalidContentError('Content was invalid')\n}\n\nexport interface DagBuilderOptions extends FileBuilderOptions, DirBuilderOptions, ProgressOptions<ImporterProgressEvents> {\n  chunker: Chunker\n  chunkValidator: ChunkValidator\n  wrapWithDirectory: boolean\n  dirBuilder?: DirBuilder\n  fileBuilder?: FileBuilder\n}\n\nexport type ImporterSourceStream = AsyncIterable<ImportCandidate> | Iterable<ImportCandidate>\n\nexport interface DAGBuilder {\n  (source: ImporterSourceStream, blockstore: WritableStorage): AsyncIterable<() => Promise<InProgressImportResult>>\n}\n\nexport function defaultDagBuilder (options: DagBuilderOptions): DAGBuilder {\n  return async function * dagBuilder (source, blockstore) {\n    for await (const entry of source) {\n      let originalPath: string | undefined\n\n      if (entry.path != null) {\n        originalPath = entry.path\n        entry.path = entry.path\n          .split('/')\n          .filter(path => path != null && path !== '.')\n          .join('/')\n      }\n\n      if (isFileCandidate(entry)) {\n        const file: File = {\n          path: entry.path,\n          mtime: entry.mtime,\n          mode: entry.mode,\n          content: (async function * () {\n            let bytesRead = 0n\n\n            for await (const chunk of options.chunker(options.chunkValidator(contentAsAsyncIterable(entry.content)))) {\n              const currentChunkSize = BigInt(chunk.byteLength)\n              bytesRead += currentChunkSize\n\n              options.onProgress?.(new CustomProgressEvent<ImportReadProgress>('unixfs:importer:progress:file:read', {\n                bytesRead,\n                chunkSize: currentChunkSize,\n                path: entry.path\n              }))\n\n              yield chunk\n            }\n          })(),\n          originalPath\n        }\n\n        const fileBuilder = options.fileBuilder ?? defaultFileBuilder\n\n        yield async () => fileBuilder(file, blockstore, options)\n      } else if (entry.path != null) {\n        const dir: Directory = {\n          path: entry.path,\n          mtime: entry.mtime,\n          mode: entry.mode,\n          originalPath\n        }\n\n        const dirBuilder = options.dirBuilder ?? defaultDirBuilder\n\n        yield async () => dirBuilder(dir, blockstore, options)\n      } else {\n        throw new Error('Import candidate must have content or path or both')\n      }\n    }\n  }\n}\n\nfunction isFileCandidate (entry: any): entry is FileCandidate {\n  return entry.content != null\n}\n", "import { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport { InvalidContentError } from '../errors.js'\n\nexport interface ChunkValidator { (source: AsyncIterable<Uint8Array>): AsyncIterable<Uint8Array> }\n\nexport const defaultChunkValidator = (): ChunkValidator => {\n  return async function * validateChunks (source) {\n    for await (const content of source) {\n      if (content.length === undefined) {\n        throw new InvalidContentError('Content was invalid')\n      }\n\n      if (typeof content === 'string' || content instanceof String) {\n        yield uint8ArrayFromString(content.toString())\n      } else if (Array.isArray(content)) {\n        yield Uint8Array.from(content)\n      } else if (content instanceof Uint8Array) {\n        yield content\n      } else {\n        throw new InvalidContentError('Content was invalid')\n      }\n    }\n  }\n}\n", "import batch from 'it-batch'\nimport type { FileLayout } from './index.js'\nimport type { InProgressImportResult } from '../index.js'\n\nconst DEFAULT_MAX_CHILDREN_PER_NODE = 174\n\nexport interface BalancedOptions {\n  maxChildrenPerNode?: number\n}\n\nexport function balanced (options?: BalancedOptions): FileLayout {\n  const maxChildrenPerNode = options?.maxChildrenPerNode ?? DEFAULT_MAX_CHILDREN_PER_NODE\n\n  return async function balancedLayout (source, reduce): Promise<InProgressImportResult> {\n    const roots = []\n\n    for await (const chunked of batch(source, maxChildrenPerNode)) {\n      roots.push(await reduce(chunked))\n    }\n\n    if (roots.length > 1) {\n      return balancedLayout(roots, reduce)\n    }\n\n    return roots[0]\n  }\n}\n", "/**\n * @packageDocumentation\n *\n * For when you need a one-liner to collect iterable values.\n *\n * @example\n *\n * ```javascript\n * import all from 'it-all'\n *\n * // This can also be an iterator, etc\n * const values = function * () {\n *   yield * [0, 1, 2, 3, 4]\n * }\n *\n * const arr = all(values)\n *\n * console.info(arr) // 0, 1, 2, 3, 4\n * ```\n *\n * Async sources must be awaited:\n *\n * ```javascript\n * const values = async function * () {\n *   yield * [0, 1, 2, 3, 4]\n * }\n *\n * const arr = await all(values())\n *\n * console.info(arr) // 0, 1, 2, 3, 4\n * ```\n */\n\nfunction isAsyncIterable <T> (thing: any): thing is AsyncIterable<T> {\n  return thing[Symbol.asyncIterator] != null\n}\n\n/**\n * Collects all values from an (async) iterable and returns them as an array\n */\nfunction all <T> (source: Iterable<T>): T[]\nfunction all <T> (source: Iterable<T> | AsyncIterable<T>): Promise<T[]>\nfunction all <T> (source: Iterable<T> | AsyncIterable<T>): Promise<T[]> | T[] {\n  if (isAsyncIterable(source)) {\n    return (async () => {\n      const arr = []\n\n      for await (const entry of source) {\n        arr.push(entry)\n      }\n\n      return arr\n    })()\n  }\n\n  const arr = []\n\n  for (const entry of source) {\n    arr.push(entry)\n  }\n\n  return arr\n}\n\nexport default all\n", "import { CID } from 'multiformats/cid'\nimport type { WritableStorage, ImportResult, InProgressImportResult } from './index.js'\nimport type { PersistOptions } from './utils/persist.js'\nimport type { Mtime, UnixFS } from 'ipfs-unixfs'\n\nexport interface DirProps {\n  root: boolean\n  dir: boolean\n  path: string\n  dirty: boolean\n  flat: boolean\n  parent?: Dir\n  parentKey?: string\n  unixfs?: UnixFS\n  mode?: number\n  mtime?: Mtime\n}\n\nexport abstract class Dir {\n  public options: PersistOptions\n  public root: boolean\n  public dir: boolean\n  public path: string\n  public dirty: boolean\n  public flat: boolean\n  public parent?: Dir\n  public parentKey?: string\n  public unixfs?: UnixFS\n  public mode?: number\n  public mtime?: Mtime\n  public cid?: CID\n  public size?: number\n  public nodeSize?: number\n\n  constructor (props: DirProps, options: PersistOptions) {\n    this.options = options ?? {}\n\n    this.root = props.root\n    this.dir = props.dir\n    this.path = props.path\n    this.dirty = props.dirty\n    this.flat = props.flat\n    this.parent = props.parent\n    this.parentKey = props.parentKey\n    this.unixfs = props.unixfs\n    this.mode = props.mode\n    this.mtime = props.mtime\n  }\n\n  abstract put (name: string, value: InProgressImportResult | Dir): Promise<void>\n  abstract get (name: string): Promise<InProgressImportResult | Dir | undefined>\n  abstract eachChildSeries (): Iterable<{ key: string, child: InProgressImportResult | Dir }>\n  abstract flush (blockstore: WritableStorage): AsyncGenerator<ImportResult>\n  abstract estimateNodeSize (): number\n  abstract childCount (): number\n}\n\n// we use these to calculate the node size to use as a check for whether a directory\n// should be sharded or not. Since CIDs have a constant length and We're only\n// interested in the data length and not the actual content identifier we can use\n// any old CID instead of having to hash the data which is expensive.\nexport const CID_V0 = CID.parse('QmUNLLsPACCz1vLxQVkXqqLX5R1X345qqfHbsf67hvA3Nn')\nexport const CID_V1 = CID.parse('zdj7WbTaiJT1fgatdet9Ei9iDB5hdCxkbVyhyh8YTUnXMiwYi')\n", "import { encode, prepare } from '@ipld/dag-pb'\nimport { UnixFS } from 'ipfs-unixfs'\nimport { Dir, CID_V0, CID_V1 } from './dir.js'\nimport { persist } from './utils/persist.js'\nimport type { DirProps } from './dir.js'\nimport type { ImportResult, InProgressImportResult } from './index.js'\nimport type { PersistOptions } from './utils/persist.js'\nimport type { PBNode } from '@ipld/dag-pb'\nimport type { Blockstore } from 'interface-blockstore'\nimport type { CID } from 'multiformats/cid'\n\nexport class DirFlat extends Dir {\n  private readonly _children: Map<string, InProgressImportResult | Dir>\n\n  constructor (props: DirProps, options: PersistOptions) {\n    super(props, options)\n\n    this._children = new Map()\n  }\n\n  async put (name: string, value: InProgressImportResult | Dir): Promise<void> {\n    this.cid = undefined\n    this.size = undefined\n    this.nodeSize = undefined\n\n    this._children.set(name, value)\n  }\n\n  async get (name: string): Promise<InProgressImportResult | Dir | undefined> {\n    return Promise.resolve(this._children.get(name))\n  }\n\n  childCount (): number {\n    return this._children.size\n  }\n\n  directChildrenCount (): number {\n    return this.childCount()\n  }\n\n  onlyChild (): InProgressImportResult | Dir | undefined {\n    return this._children.values().next().value\n  }\n\n  * eachChildSeries (): Generator<{ key: string, child: InProgressImportResult | Dir }, void, undefined> {\n    for (const [key, child] of this._children.entries()) {\n      yield {\n        key,\n        child\n      }\n    }\n  }\n\n  estimateNodeSize (): number {\n    if (this.nodeSize !== undefined) {\n      return this.nodeSize\n    }\n\n    this.nodeSize = 0\n\n    // estimate size only based on DAGLink name and CID byte lengths\n    // https://github.com/ipfs/go-unixfsnode/blob/37b47f1f917f1b2f54c207682f38886e49896ef9/data/builder/directory.go#L81-L96\n    for (const [name, child] of this._children.entries()) {\n      if (child.size != null && (child.cid != null)) {\n        this.nodeSize += name.length + (this.options.cidVersion === 1 ? CID_V1.bytes.byteLength : CID_V0.bytes.byteLength)\n      }\n    }\n\n    return this.nodeSize\n  }\n\n  async * flush (block: Blockstore): AsyncGenerator<ImportResult> {\n    const links = []\n\n    for (const [name, child] of this._children.entries()) {\n      let result: { size?: bigint | number, cid?: CID } = child\n\n      if (child instanceof Dir) {\n        for await (const entry of child.flush(block)) {\n          result = entry\n\n          yield entry\n        }\n      }\n\n      if (result.size != null && (result.cid != null)) {\n        links.push({\n          Name: name,\n          Tsize: Number(result.size),\n          Hash: result.cid\n        })\n      }\n    }\n\n    const unixfs = new UnixFS({\n      type: 'directory',\n      mtime: this.mtime,\n      mode: this.mode\n    })\n\n    const node: PBNode = { Data: unixfs.marshal(), Links: links }\n    const buffer = encode(prepare(node))\n    const cid = await persist(buffer, block, this.options)\n    const size = buffer.length + node.Links.reduce(\n      /**\n       * @param {number} acc\n       * @param {PBLink} curr\n       */\n      (acc, curr) => acc + (curr.Tsize ?? 0),\n      0)\n\n    this.cid = cid\n    this.size = size\n\n    yield {\n      cid,\n      unixfs,\n      path: this.path,\n      size: BigInt(size)\n    }\n  }\n}\n", "import { bytes } from 'multiformats'\nimport { from } from 'multiformats/hashes/hasher'\n// @ts-expect-error no types\nimport mur from 'murmurhash3js-revisited'\n\n/**\n * @param {number} number\n * @returns {Uint8Array}\n */\nfunction fromNumberTo32BitBuf (number) {\n  const bytes = new Array(4)\n  for (let i = 0; i < 4; i++) {\n    bytes[i] = number & 0xff\n    number = number >> 8\n  }\n  return new Uint8Array(bytes)\n}\n\nexport const murmur332 = from({\n  name: 'murmur3-32',\n  code: 0x23,\n  encode: (input) => fromNumberTo32BitBuf(mur.x86.hash32(input))\n})\n\nexport const murmur3128 = from({\n  name: 'murmur3-128',\n  code: 0x22,\n  encode: (input) => bytes.fromHex(mur.x64.hash128(input))\n})\n\n// A special-use 0x22 that truncates 64 bits, specifically for use in the UnixFS HAMT\nexport const murmur364 = from({\n  name: 'murmur3-x64-64',\n  code: 0x22,\n  encode: (input) => bytes.fromHex(mur.x64.hash128(input)).subarray(0, 8)\n})\n", "// @ts-expect-error no types\nimport SparseArray from 'sparse-array'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport type { InfiniteHash } from './consumable-hash.js'\n\nexport interface BucketChild<V> {\n  key: string\n  value: V\n  hash: InfiniteHash\n}\n\ninterface SA<B> {\n  length: number\n  compactArray(): B[]\n  get(i: number): B\n  set(i: number, value: B): void\n  reduce <A> (fn: (acc: A, curr: B, index: number) => A, initial: A): B\n  find(fn: (item: B) => boolean): B | undefined\n  bitField(): number[]\n  unset(i: number): void\n}\n\nexport interface BucketPosition<T> {\n  bucket: Bucket<T>\n  pos: number\n  hash: InfiniteHash\n  existingChild?: BucketChild<T>\n}\n\nexport interface BucketOptions {\n  bits: number\n  hash(value: Uint8Array | InfiniteHash): InfiniteHash\n}\n\nexport class Bucket<T> {\n  _options: BucketOptions\n  _popCount: number\n  _parent?: Bucket<T>\n  _posAtParent: number\n  _children: SA<Bucket<T> | BucketChild<T>>\n\n  key: string | null\n\n  constructor (options: BucketOptions, parent?: Bucket<T>, posAtParent = 0) {\n    this._options = options\n    this._popCount = 0\n    this._parent = parent\n    this._posAtParent = posAtParent\n    this._children = new SparseArray()\n    this.key = null\n  }\n\n  async put (key: string, value: T): Promise<void> {\n    const place = await this._findNewBucketAndPos(key)\n\n    place.bucket._putAt(place, key, value)\n  }\n\n  async get (key: string): Promise<T | undefined> {\n    const child = await this._findChild(key)\n\n    if (child != null) {\n      return child.value\n    }\n  }\n\n  async del (key: string): Promise<void> {\n    const place = await this._findPlace(key)\n    const child = place.bucket._at(place.pos)\n\n    if (child != null && child.key === key) {\n      place.bucket._delAt(place.pos)\n    }\n  }\n\n  leafCount (): number {\n    const children = this._children.compactArray()\n\n    return children.reduce((acc, child) => {\n      if (child instanceof Bucket) {\n        return acc + child.leafCount()\n      }\n\n      return acc + 1\n    }, 0)\n  }\n\n  childrenCount (): number {\n    return this._children.length\n  }\n\n  onlyChild (): Bucket<T> | BucketChild<T> {\n    return this._children.get(0)\n  }\n\n  * eachLeafSeries (): Iterable<BucketChild<T>> {\n    const children = this._children.compactArray()\n\n    for (const child of children) {\n      if (child instanceof Bucket) {\n        yield * child.eachLeafSeries()\n      } else {\n        yield child\n      }\n    }\n  }\n\n  serialize <M> (map: (value: BucketChild<T>, index: number) => M, reduce: (reduced: Bucket<T> | BucketChild<T>) => M): M {\n    const acc: M[] = []\n    // serialize to a custom non-sparse representation\n    return reduce(this._children.reduce((acc, child, index) => {\n      if (child != null) {\n        if (child instanceof Bucket) {\n          acc.push(child.serialize(map, reduce))\n        } else {\n          acc.push(map(child, index))\n        }\n      }\n      return acc\n    }, acc))\n  }\n\n  async asyncTransform <R = T> (asyncMap: (value: BucketChild<T>) => Promise<T[]>, asyncReduce: (reduced: any) => Promise<R>): Promise<R> {\n    return asyncTransformBucket(this, asyncMap, asyncReduce)\n  }\n\n  toJSON (): Record<string, any> {\n    return this.serialize(mapNode, reduceNodes)\n  }\n\n  prettyPrint (): string {\n    return JSON.stringify(this.toJSON(), null, '  ')\n  }\n\n  tableSize (): number {\n    return Math.pow(2, this._options.bits)\n  }\n\n  async _findChild (key: string): Promise<BucketChild<T> | undefined> {\n    const result = await this._findPlace(key)\n    const child = result.bucket._at(result.pos)\n\n    if (child instanceof Bucket) {\n      // should not be possible, this._findPlace should always\n      // return a location for a child, not a bucket\n      return undefined\n    }\n\n    if (child != null && child.key === key) {\n      return child\n    }\n  }\n\n  async _findPlace (key: string | InfiniteHash): Promise<BucketPosition<T>> {\n    const hashValue = this._options.hash(typeof key === 'string' ? uint8ArrayFromString(key) : key)\n    const index = await hashValue.take(this._options.bits)\n\n    const child = this._children.get(index)\n\n    if (child instanceof Bucket) {\n      return child._findPlace(hashValue)\n    }\n\n    return {\n      bucket: this,\n      pos: index,\n      hash: hashValue,\n      existingChild: child\n    }\n  }\n\n  async _findNewBucketAndPos (key: string | InfiniteHash): Promise<BucketPosition<T>> {\n    const place = await this._findPlace(key)\n\n    if ((place.existingChild != null) && place.existingChild.key !== key) {\n      // conflict\n      const bucket = new Bucket(this._options, place.bucket, place.pos)\n      place.bucket._putObjectAt(place.pos, bucket)\n\n      // put the previous value\n      const newPlace = await bucket._findPlace(place.existingChild.hash)\n      newPlace.bucket._putAt(newPlace, place.existingChild.key, place.existingChild.value)\n\n      return bucket._findNewBucketAndPos(place.hash)\n    }\n\n    // no conflict, we found the place\n    return place\n  }\n\n  _putAt (place: BucketPosition<T>, key: string, value: T): void {\n    this._putObjectAt(place.pos, {\n      key,\n      value,\n      hash: place.hash\n    })\n  }\n\n  _putObjectAt (pos: number, object: Bucket<T> | BucketChild<T>): void {\n    if (this._children.get(pos) == null) {\n      this._popCount++\n    }\n    this._children.set(pos, object)\n  }\n\n  _delAt (pos: number): void {\n    if (pos === -1) {\n      throw new Error('Invalid position')\n    }\n\n    if (this._children.get(pos) != null) {\n      this._popCount--\n    }\n    this._children.unset(pos)\n    this._level()\n  }\n\n  _level (): void {\n    if (this._parent != null && this._popCount <= 1) {\n      if (this._popCount === 1) {\n        // remove myself from parent, replacing me with my only child\n        const onlyChild = this._children.find(exists)\n\n        if ((onlyChild != null) && !(onlyChild instanceof Bucket)) {\n          const hash = onlyChild.hash\n          hash.untake(this._options.bits)\n          const place = {\n            pos: this._posAtParent,\n            hash,\n            bucket: this._parent\n          }\n          this._parent._putAt(place, onlyChild.key, onlyChild.value)\n        }\n      } else {\n        this._parent._delAt(this._posAtParent)\n      }\n    }\n  }\n\n  _at (index: number): Bucket<T> | BucketChild<T> {\n    return this._children.get(index)\n  }\n}\n\nfunction exists (o: any): boolean {\n  return Boolean(o)\n}\n\nfunction mapNode (node: { key: string }, _: number): string {\n  return node.key\n}\n\nfunction reduceNodes <T> (nodes: T): any {\n  return nodes\n}\n\nasync function asyncTransformBucket <T, R = T> (bucket: Bucket<T>, asyncMap: (value: BucketChild<T>) => Promise<T[]>, asyncReduce: (reduced: any) => Promise<R>): Promise<R> {\n  const output = []\n\n  for (const child of bucket._children.compactArray()) {\n    if (child instanceof Bucket) {\n      await asyncTransformBucket(child, asyncMap, asyncReduce)\n    } else {\n      const mappedChildren = await asyncMap(child)\n\n      output.push({\n        bitField: bucket._children.bitField(),\n        children: mappedChildren\n      })\n    }\n  }\n\n  return asyncReduce(output)\n}\n", "const START_MASKS = [\n  0b11111111,\n  0b11111110,\n  0b11111100,\n  0b11111000,\n  0b11110000,\n  0b11100000,\n  0b11000000,\n  0b10000000\n]\n\nconst STOP_MASKS = [\n  0b00000001,\n  0b00000011,\n  0b00000111,\n  0b00001111,\n  0b00011111,\n  0b00111111,\n  0b01111111,\n  0b11111111\n]\n\nexport class ConsumableBuffer {\n  _value: Uint8Array\n  _currentBytePos: number\n  _currentBitPos: number\n\n  constructor (value: Uint8Array) {\n    this._value = value\n    this._currentBytePos = value.length - 1\n    this._currentBitPos = 7\n  }\n\n  availableBits (): number {\n    return this._currentBitPos + 1 + this._currentBytePos * 8\n  }\n\n  totalBits (): number {\n    return this._value.length * 8\n  }\n\n  take (bits: number): number {\n    let pendingBits = bits\n    let result = 0\n    while (pendingBits > 0 && this._haveBits()) {\n      const byte = this._value[this._currentBytePos]\n      const availableBits = this._currentBitPos + 1\n      const taking = Math.min(availableBits, pendingBits)\n      const value = byteBitsToInt(byte, availableBits - taking, taking)\n      result = (result << taking) + value\n\n      pendingBits -= taking\n\n      this._currentBitPos -= taking\n      if (this._currentBitPos < 0) {\n        this._currentBitPos = 7\n        this._currentBytePos--\n      }\n    }\n\n    return result\n  }\n\n  untake (bits: number): void {\n    this._currentBitPos += bits\n    while (this._currentBitPos > 7) {\n      this._currentBitPos -= 8\n      this._currentBytePos += 1\n    }\n  }\n\n  _haveBits (): boolean {\n    return this._currentBytePos >= 0\n  }\n}\n\nfunction byteBitsToInt (byte: number, start: number, length: number): number {\n  const mask = maskFor(start, length)\n  return (byte & mask) >>> start\n}\n\nfunction maskFor (start: number, length: number): number {\n  return START_MASKS[start] & STOP_MASKS[Math.min(length + start - 1, 7)]\n}\n", "import { concat as uint8ArrayConcat } from 'uint8arrays/concat'\nimport { ConsumableBuffer } from './consumable-buffer.js'\n\nexport function wrapHash (hashFn: (value: Uint8Array) => Promise<Uint8Array>): (value: InfiniteHash | Uint8Array) => InfiniteHash {\n  function hashing (value: InfiniteHash | Uint8Array): InfiniteHash {\n    if (value instanceof InfiniteHash) {\n      // already a hash. return it\n      return value\n    } else {\n      return new InfiniteHash(value, hashFn)\n    }\n  }\n\n  return hashing\n}\n\nexport class InfiniteHash {\n  _value: Uint8Array\n  _hashFn: (value: Uint8Array) => Promise<Uint8Array>\n  _depth: number\n  _availableBits: number\n  _currentBufferIndex: number\n  _buffers: ConsumableBuffer[]\n\n  constructor (value: Uint8Array, hashFn: (value: Uint8Array) => Promise<Uint8Array>) {\n    if (!(value instanceof Uint8Array)) {\n      throw new Error('can only hash Uint8Arrays')\n    }\n\n    this._value = value\n    this._hashFn = hashFn\n    this._depth = -1\n    this._availableBits = 0\n    this._currentBufferIndex = 0\n    this._buffers = []\n  }\n\n  async take (bits: number): Promise<number> {\n    let pendingBits = bits\n\n    while (this._availableBits < pendingBits) {\n      await this._produceMoreBits()\n    }\n\n    let result = 0\n\n    while (pendingBits > 0) {\n      const hash = this._buffers[this._currentBufferIndex]\n      const available = Math.min(hash.availableBits(), pendingBits)\n      const took = hash.take(available)\n      result = (result << available) + took\n      pendingBits -= available\n      this._availableBits -= available\n\n      if (hash.availableBits() === 0) {\n        this._currentBufferIndex++\n      }\n    }\n\n    return result\n  }\n\n  untake (bits: number): void {\n    let pendingBits = bits\n\n    while (pendingBits > 0) {\n      const hash = this._buffers[this._currentBufferIndex]\n      const availableForUntake = Math.min(hash.totalBits() - hash.availableBits(), pendingBits)\n      hash.untake(availableForUntake)\n      pendingBits -= availableForUntake\n      this._availableBits += availableForUntake\n\n      if (this._currentBufferIndex > 0 && hash.totalBits() === hash.availableBits()) {\n        this._depth--\n        this._currentBufferIndex--\n      }\n    }\n  }\n\n  async _produceMoreBits (): Promise<void> {\n    this._depth++\n\n    const value = this._depth > 0 ? uint8ArrayConcat([this._value, Uint8Array.from([this._depth])]) : this._value\n    const hashValue = await this._hashFn(value)\n    const buffer = new ConsumableBuffer(hashValue)\n\n    this._buffers.push(buffer)\n    this._availableBits += buffer.availableBits()\n  }\n}\n", "/**\n * @packageDocumentation\n *\n * A [Hash Mapped Trie](https://en.wikipedia.org/wiki/Hash_array_mapped_trie) implementation for JavaScript.\n *\n * This is used by [@helia/unixfs](https://www.npmjs.com/package/@helia/unixfs) for it's HAMT-sharded directory implementation.\n *\n * @example\n *\n * ```TypeScript\n * import { createHAMT } from 'hamt-sharding'\n * import crypto from 'crypto-promise'\n *\n * // decide how to hash buffers made from keys, can return a Promise\n * const hashFn = async (buf) => {\n *   return crypto\n *     .createHash('sha256')\n *     .update(buf)\n *     .digest()\n * }\n *\n * const bucket = createHAMT({\n *   hashFn: hashFn\n * })\n *\n * await bucket.put('key', 'value')\n *\n * const output = await bucket.get('key')\n * // output === 'value'\n * ```\n */\n\nimport { Bucket } from './bucket.js'\nimport { wrapHash } from './consumable-hash.js'\nimport type { BucketOptions, BucketPosition, BucketChild } from './bucket.js'\n\ninterface UserBucketOptions {\n  hashFn(value: Uint8Array): Promise<Uint8Array>\n  bits?: number\n}\n\nexport function createHAMT<T> (options: UserBucketOptions): Bucket<T> {\n  if (options == null || options.hashFn == null) {\n    throw new Error('please define an options.hashFn')\n  }\n\n  const bucketOptions = {\n    bits: options.bits ?? 8,\n    hash: wrapHash(options.hashFn)\n  }\n\n  return new Bucket<T>(bucketOptions)\n}\n\nexport { Bucket }\nexport type { BucketOptions, BucketPosition, BucketChild }\n", "import { encode, prepare } from '@ipld/dag-pb'\nimport { murmur3128 } from '@multiformats/murmur3'\nimport { createHAMT, Bucket } from 'hamt-sharding'\nimport { UnixFS } from 'ipfs-unixfs'\nimport { Dir, CID_V0, CID_V1 } from './dir.js'\nimport { persist } from './utils/persist.js'\nimport type { DirProps } from './dir.js'\nimport type { ImportResult, InProgressImportResult } from './index.js'\nimport type { PersistOptions } from './utils/persist.js'\nimport type { PBLink } from '@ipld/dag-pb'\nimport type { BucketChild } from 'hamt-sharding'\nimport type { Blockstore } from 'interface-blockstore'\n\nasync function hamtHashFn (buf: Uint8Array): Promise<Uint8Array> {\n  return (await murmur3128.encode(buf))\n    // Murmur3 outputs 128 bit but, accidentally, IPFS Go's\n    // implementation only uses the first 64, so we must do the same\n    // for parity..\n    .slice(0, 8)\n    // Invert buffer because that's how Go impl does it\n    .reverse()\n}\n\nconst HAMT_HASH_CODE = BigInt(0x22)\nconst DEFAULT_FANOUT_BITS = 8\n\nexport interface DirShardedOptions extends PersistOptions {\n  shardFanoutBits: number\n}\n\nclass DirSharded extends Dir {\n  private readonly _bucket: Bucket<InProgressImportResult | Dir>\n\n  constructor (props: DirProps, options: DirShardedOptions) {\n    super(props, options)\n\n    this._bucket = createHAMT({\n      hashFn: hamtHashFn,\n      bits: options.shardFanoutBits ?? DEFAULT_FANOUT_BITS\n    })\n  }\n\n  async put (name: string, value: InProgressImportResult | Dir): Promise<void> {\n    this.cid = undefined\n    this.size = undefined\n    this.nodeSize = undefined\n\n    await this._bucket.put(name, value)\n  }\n\n  async get (name: string): Promise<InProgressImportResult | Dir | undefined> {\n    return this._bucket.get(name)\n  }\n\n  childCount (): number {\n    return this._bucket.leafCount()\n  }\n\n  directChildrenCount (): number {\n    return this._bucket.childrenCount()\n  }\n\n  onlyChild (): Bucket<InProgressImportResult | Dir> | BucketChild<InProgressImportResult | Dir> {\n    return this._bucket.onlyChild()\n  }\n\n  * eachChildSeries (): Generator<{ key: string, child: InProgressImportResult | Dir }> {\n    for (const { key, value } of this._bucket.eachLeafSeries()) {\n      yield {\n        key,\n        child: value\n      }\n    }\n  }\n\n  estimateNodeSize (): number {\n    if (this.nodeSize !== undefined) {\n      return this.nodeSize\n    }\n\n    this.nodeSize = calculateSize(this._bucket, this, this.options)\n\n    return this.nodeSize\n  }\n\n  async * flush (blockstore: Blockstore): AsyncGenerator<ImportResult> {\n    for await (const entry of flush(this._bucket, blockstore, this, this.options)) {\n      yield {\n        ...entry,\n        path: this.path\n      }\n    }\n  }\n}\n\nexport default DirSharded\n\nasync function * flush (bucket: Bucket<Dir | InProgressImportResult>, blockstore: Blockstore, shardRoot: DirSharded | null, options: PersistOptions): AsyncIterable<ImportResult> {\n  const children = bucket._children\n  const padLength = (bucket.tableSize() - 1).toString(16).length\n  const links: PBLink[] = []\n  let childrenSize = 0n\n\n  for (let i = 0; i < children.length; i++) {\n    const child = children.get(i)\n\n    if (child == null) {\n      continue\n    }\n\n    const labelPrefix = i.toString(16).toUpperCase().padStart(padLength, '0')\n\n    if (child instanceof Bucket) {\n      let shard\n\n      for await (const subShard of flush(child, blockstore, null, options)) {\n        shard = subShard\n      }\n\n      if (shard == null) {\n        throw new Error('Could not flush sharded directory, no subshard found')\n      }\n\n      links.push({\n        Name: labelPrefix,\n        Tsize: Number(shard.size),\n        Hash: shard.cid\n      })\n      childrenSize += shard.size\n    } else if (isDir(child.value)) {\n      const dir = child.value\n      let flushedDir: ImportResult | undefined\n\n      for await (const entry of dir.flush(blockstore)) {\n        flushedDir = entry\n\n        yield flushedDir\n      }\n\n      if (flushedDir == null) {\n        throw new Error('Did not flush dir')\n      }\n\n      const label = labelPrefix + child.key\n      links.push({\n        Name: label,\n        Tsize: Number(flushedDir.size),\n        Hash: flushedDir.cid\n      })\n\n      childrenSize += flushedDir.size\n    } else {\n      const value = child.value\n\n      if (value.cid == null) {\n        continue\n      }\n\n      const label = labelPrefix + child.key\n      const size = value.size\n\n      links.push({\n        Name: label,\n        Tsize: Number(size),\n        Hash: value.cid\n      })\n      childrenSize += BigInt(size ?? 0)\n    }\n  }\n\n  // go-ipfs uses little endian, that's why we have to\n  // reverse the bit field before storing it\n  const data = Uint8Array.from(children.bitField().reverse())\n  const dir = new UnixFS({\n    type: 'hamt-sharded-directory',\n    data,\n    fanout: BigInt(bucket.tableSize()),\n    hashType: HAMT_HASH_CODE,\n    mtime: shardRoot?.mtime,\n    mode: shardRoot?.mode\n  })\n\n  const node = {\n    Data: dir.marshal(),\n    Links: links\n  }\n  const buffer = encode(prepare(node))\n  const cid = await persist(buffer, blockstore, options)\n  const size = BigInt(buffer.byteLength) + childrenSize\n\n  yield {\n    cid,\n    unixfs: dir,\n    size\n  }\n}\n\nfunction isDir (obj: any): obj is Dir {\n  return typeof obj.flush === 'function'\n}\n\nfunction calculateSize (bucket: Bucket<any>, shardRoot: DirSharded | null, options: PersistOptions): number {\n  const children = bucket._children\n  const padLength = (bucket.tableSize() - 1).toString(16).length\n  const links: PBLink[] = []\n\n  for (let i = 0; i < children.length; i++) {\n    const child = children.get(i)\n\n    if (child == null) {\n      continue\n    }\n\n    const labelPrefix = i.toString(16).toUpperCase().padStart(padLength, '0')\n\n    if (child instanceof Bucket) {\n      const size = calculateSize(child, null, options)\n\n      links.push({\n        Name: labelPrefix,\n        Tsize: Number(size),\n        Hash: options.cidVersion === 0 ? CID_V0 : CID_V1\n      })\n    } else if (typeof child.value.flush === 'function') {\n      const dir = child.value\n      const size = dir.nodeSize()\n\n      links.push({\n        Name: labelPrefix + child.key,\n        Tsize: Number(size),\n        Hash: options.cidVersion === 0 ? CID_V0 : CID_V1\n      })\n    } else {\n      const value = child.value\n\n      if (value.cid == null) {\n        continue\n      }\n\n      const label = labelPrefix + child.key\n      const size = value.size\n\n      links.push({\n        Name: label,\n        Tsize: Number(size),\n        Hash: value.cid\n      })\n    }\n  }\n\n  // go-ipfs uses little endian, that's why we have to\n  // reverse the bit field before storing it\n  const data = Uint8Array.from(children.bitField().reverse())\n  const dir = new UnixFS({\n    type: 'hamt-sharded-directory',\n    data,\n    fanout: BigInt(bucket.tableSize()),\n    hashType: HAMT_HASH_CODE,\n    mtime: shardRoot?.mtime,\n    mode: shardRoot?.mode\n  })\n\n  const buffer = encode(prepare({\n    Data: dir.marshal(),\n    Links: links\n  }))\n\n  return buffer.length\n}\n", "import { DirFlat } from './dir-flat.js'\nimport DirSharded from './dir-sharded.js'\nimport type { DirShardedOptions } from './dir-sharded.js'\nimport type { Dir } from './dir.js'\n\nexport async function flatToShard (child: Dir | null, dir: Dir, threshold: number, options: DirShardedOptions): Promise<DirSharded> {\n  let newDir = dir as DirSharded\n\n  if (dir instanceof DirFlat && dir.estimateNodeSize() > threshold) {\n    newDir = await convertToShard(dir, options)\n  }\n\n  const parent = newDir.parent\n\n  if (parent != null) {\n    if (newDir !== dir) {\n      if (child != null) {\n        child.parent = newDir\n      }\n\n      if (newDir.parentKey == null) {\n        throw new Error('No parent key found')\n      }\n\n      await parent.put(newDir.parentKey, newDir)\n    }\n\n    return flatToShard(newDir, parent, threshold, options)\n  }\n\n  return newDir\n}\n\nasync function convertToShard (oldDir: DirFlat, options: DirShardedOptions): Promise<DirSharded> {\n  const newDir = new DirSharded({\n    root: oldDir.root,\n    dir: true,\n    parent: oldDir.parent,\n    parentKey: oldDir.parentKey,\n    path: oldDir.path,\n    dirty: oldDir.dirty,\n    flat: false,\n    mtime: oldDir.mtime,\n    mode: oldDir.mode\n  }, options)\n\n  for (const { key, child } of oldDir.eachChildSeries()) {\n    await newDir.put(key, child)\n  }\n\n  return newDir\n}\n", "export const toPathComponents = (path: string = ''): string[] => {\n  // split on / unless escaped with \\\n  return path.split(/(?<!\\\\)\\//).filter(Boolean)\n}\n", "import { DirFlat } from './dir-flat.js'\nimport { Dir } from './dir.js'\nimport { flatToShard } from './flat-to-shard.js'\nimport { toPathComponents } from './utils/to-path-components.js'\nimport type { ImportResult, InProgressImportResult, TreeBuilder, WritableStorage } from './index.js'\nimport type { PersistOptions } from './utils/persist.js'\n\nexport interface AddToTreeOptions extends PersistOptions {\n  shardSplitThresholdBytes: number\n  shardFanoutBits: number\n}\n\nasync function addToTree (elem: InProgressImportResult, tree: Dir, options: AddToTreeOptions): Promise<Dir> {\n  const pathElems = toPathComponents(elem.path ?? '')\n  const lastIndex = pathElems.length - 1\n  let parent = tree\n  let currentPath = ''\n\n  for (let i = 0; i < pathElems.length; i++) {\n    const pathElem = pathElems[i]\n\n    currentPath += `${currentPath !== '' ? '/' : ''}${pathElem}`\n\n    const last = (i === lastIndex)\n    parent.dirty = true\n    parent.cid = undefined\n    parent.size = undefined\n\n    if (last) {\n      await parent.put(pathElem, elem)\n      tree = await flatToShard(null, parent, options.shardSplitThresholdBytes, options)\n    } else {\n      let dir = await parent.get(pathElem)\n\n      if ((dir == null) || !(dir instanceof Dir)) {\n        dir = new DirFlat({\n          root: false,\n          dir: true,\n          parent,\n          parentKey: pathElem,\n          path: currentPath,\n          dirty: true,\n          flat: true,\n          mtime: dir?.unixfs?.mtime,\n          mode: dir?.unixfs?.mode\n        }, options)\n      }\n\n      await parent.put(pathElem, dir)\n\n      parent = dir\n    }\n  }\n\n  return tree\n}\n\nasync function * flushAndYield (tree: Dir | InProgressImportResult, blockstore: WritableStorage): AsyncGenerator<ImportResult> {\n  if (!(tree instanceof Dir)) {\n    if (tree.unixfs?.isDirectory() === true) {\n      yield tree\n    }\n\n    return\n  }\n\n  yield * tree.flush(blockstore)\n}\n\nexport interface TreeBuilderOptions extends AddToTreeOptions {\n  wrapWithDirectory: boolean\n}\n\nexport function defaultTreeBuilder (options: TreeBuilderOptions): TreeBuilder {\n  return async function * treeBuilder (source, block) {\n    let tree: Dir = new DirFlat({\n      root: true,\n      dir: true,\n      path: '',\n      dirty: true,\n      flat: true\n    }, options)\n\n    let rootDir: string | undefined\n    let singleRoot = false\n\n    for await (const entry of source) {\n      if (entry == null) {\n        continue\n      }\n\n      // if all paths are from the same root directory, we should\n      // wrap them all in that root directory\n      const dir = `${entry.originalPath ?? ''}`.split('/')[0]\n\n      if (dir != null && dir !== '') {\n        if (rootDir == null) {\n          rootDir = dir\n          singleRoot = true\n        } else if (rootDir !== dir) {\n          singleRoot = false\n        }\n      }\n\n      tree = await addToTree(entry, tree, options)\n\n      if (entry.unixfs?.isDirectory() !== true) {\n        yield entry\n      }\n    }\n\n    if (options.wrapWithDirectory || (singleRoot && tree.childCount() > 1)) {\n      yield * flushAndYield(tree, block)\n    } else {\n      for (const unwrapped of tree.eachChildSeries()) {\n        if (unwrapped == null) {\n          continue\n        }\n\n        yield * flushAndYield(unwrapped.child, block)\n      }\n    }\n  }\n}\n", "/**\n * @packageDocumentation\n *\n * @example\n *\n * Let's create a little directory to import:\n *\n * ```console\n * > cd /tmp\n * > mkdir foo\n * > echo 'hello' > foo/bar\n * > echo 'world' > foo/quux\n * ```\n *\n * And write the importing logic:\n *\n * ```TypeScript\n * import { importer } from 'ipfs-unixfs-importer'\n * import { MemoryBlockstore } from 'blockstore-core/memory'\n * import * as fs from 'node:fs'\n *\n * // Where the blocks will be stored\n * const blockstore = new MemoryBlockstore()\n *\n * // Import path /tmp/foo/\n * const source = [{\n *   path: '/tmp/foo/bar',\n *   content: fs.createReadStream('/tmp/foo/bar')\n * }, {\n *   path: '/tmp/foo/quxx',\n *   content: fs.createReadStream('/tmp/foo/quux')\n * }]\n *\n * for await (const entry of importer(source, blockstore)) {\n *   console.info(entry)\n * }\n * ```\n *\n * When run, metadata about DAGNodes in the created tree is printed until the root:\n *\n * ```\n * {\n *   cid: CID, // see https://github.com/multiformats/js-cid\n *   path: 'tmp/foo/bar',\n *   unixfs: UnixFS // see https://github.com/ipfs/js-ipfs-unixfs\n * }\n * {\n *   cid: CID, // see https://github.com/multiformats/js-cid\n *   path: 'tmp/foo/quxx',\n *   unixfs: UnixFS // see https://github.com/ipfs/js-ipfs-unixfs\n * }\n * {\n *   cid: CID, // see https://github.com/multiformats/js-cid\n *   path: 'tmp/foo',\n *   unixfs: UnixFS // see https://github.com/ipfs/js-ipfs-unixfs\n * }\n * {\n *   cid: CID, // see https://github.com/multiformats/js-cid\n *   path: 'tmp',\n *   unixfs: UnixFS // see https://github.com/ipfs/js-ipfs-unixfs\n * }\n * ```\n */\n\nimport first from 'it-first'\nimport parallelBatch from 'it-parallel-batch'\nimport { fixedSize } from './chunker/fixed-size.js'\nimport { defaultBufferImporter } from './dag-builder/buffer-importer.js'\nimport { defaultDagBuilder } from './dag-builder/index.js'\nimport { defaultChunkValidator } from './dag-builder/validate-chunks.js'\nimport { InvalidParametersError } from './errors.js'\nimport { balanced } from './layout/index.js'\nimport { defaultTreeBuilder } from './tree-builder.js'\nimport type { Chunker } from './chunker/index.js'\nimport type { BufferImportProgressEvents } from './dag-builder/buffer-importer.js'\nimport type { DirBuilder } from './dag-builder/dir.js'\nimport type { FileBuilder, ReducerProgressEvents } from './dag-builder/file.js'\nimport type { DAGBuilder, DagBuilderProgressEvents } from './dag-builder/index.js'\nimport type { ChunkValidator } from './dag-builder/validate-chunks.js'\nimport type { FileLayout } from './layout/index.js'\nimport type { Blockstore } from 'interface-blockstore'\nimport type { AwaitIterable } from 'interface-store'\nimport type { UnixFS, Mtime } from 'ipfs-unixfs'\nimport type { CID, Version as CIDVersion } from 'multiformats/cid'\nimport type { ProgressOptions } from 'progress-events'\n\nexport * from './errors.js'\n\nexport type ByteStream = AwaitIterable<Uint8Array>\nexport type ImportContent = ByteStream | Uint8Array\n\nexport type WritableStorage = Pick<Blockstore, 'put'>\n\nexport interface FileCandidate<T extends ImportContent = ImportContent> {\n  path?: string\n  content: T\n  mtime?: Mtime\n  mode?: number\n}\n\nexport interface DirectoryCandidate {\n  path: string\n  mtime?: Mtime\n  mode?: number\n}\n\nexport type ImportCandidate = FileCandidate | DirectoryCandidate\n\nexport interface File {\n  content: AsyncIterable<Uint8Array>\n  path?: string\n  mtime?: Mtime\n  mode?: number\n  originalPath?: string\n}\n\nexport interface Directory {\n  path?: string\n  mtime?: Mtime\n  mode?: number\n  originalPath?: string\n}\n\nexport interface ImportResult {\n  cid: CID\n  size: bigint\n  path?: string\n  unixfs?: UnixFS\n}\n\nexport interface MultipleBlockImportResult extends ImportResult {\n  originalPath?: string\n}\n\nexport interface SingleBlockImportResult extends ImportResult {\n  single: true\n  originalPath?: string\n  block: Uint8Array\n}\n\nexport type InProgressImportResult = SingleBlockImportResult | MultipleBlockImportResult\n\nexport interface BufferImporterResult extends ImportResult {\n  block: Uint8Array\n}\n\nexport interface HamtHashFn { (value: Uint8Array): Promise<Uint8Array> }\nexport interface TreeBuilder { (source: AsyncIterable<InProgressImportResult>, blockstore: WritableStorage): AsyncIterable<ImportResult> }\nexport interface BufferImporter { (file: File, blockstore: WritableStorage): AsyncIterable<() => Promise<BufferImporterResult>> }\n\nexport type ImporterProgressEvents =\n  BufferImportProgressEvents |\n  DagBuilderProgressEvents |\n  ReducerProgressEvents\n\n/**\n * Options to control the importer's behaviour\n */\nexport interface ImporterOptions extends ProgressOptions<ImporterProgressEvents> {\n  /**\n   * When a file would span multiple DAGNodes, if this is true the leaf nodes\n   * will not be wrapped in `UnixFS` protobufs and will instead contain the\n   * raw file bytes. Default: true\n   */\n  rawLeaves?: boolean\n\n  /**\n   * If the file being imported is small enough to fit into one DAGNodes, store\n   * the file data in the root node along with the UnixFS metadata instead of\n   * in a leaf node which would then require additional I/O to load. Default: true\n   */\n  reduceSingleLeafToSelf?: boolean\n\n  /**\n   * What type of UnixFS node leaves should be - can be `'file'` or `'raw'`\n   * (ignored when `rawLeaves` is `true`).\n   *\n   * This option exists to simulate kubo's trickle dag which uses a combination\n   * of `'raw'` UnixFS leaves and `reduceSingleLeafToSelf: false`.\n   *\n   * For modern code the `rawLeaves: true` option should be used instead so leaves\n   * are plain Uint8Arrays without a UnixFS/Protobuf wrapper.\n   */\n  leafType?: 'file' | 'raw'\n\n  /**\n   * the CID version to use when storing the data. Default: 1\n   */\n  cidVersion?: CIDVersion\n\n  /**\n   * If the serialized node is larger than this it might be converted to a HAMT\n   * sharded directory. Default: 256KiB\n   */\n  shardSplitThresholdBytes?: number\n\n  /**\n   * The number of bits of a hash digest used at each level of sharding to\n   * the child index. 2**shardFanoutBits will dictate the maximum number of\n   * children for any shard in the HAMT. Default: 8\n   */\n  shardFanoutBits?: number\n\n  /**\n   * How many files to import concurrently. For large numbers of small files this\n   * should be high (e.g. 50). Default: 10\n   */\n  fileImportConcurrency?: number\n\n  /**\n   * How many blocks to hash and write to the block store concurrently. For small\n   * numbers of large files this should be high (e.g. 50). Default: 50\n   */\n  blockWriteConcurrency?: number\n\n  /**\n   * If true, all imported files and folders will be contained in a directory that\n   * will correspond to the CID of the final entry yielded. Default: false\n   */\n  wrapWithDirectory?: boolean\n\n  /**\n   * The chunking strategy. See [./src/chunker/index.ts](./src/chunker/index.ts)\n   * for available chunkers. Default: fixedSize\n   */\n  chunker?: Chunker\n\n  /**\n   * How the DAG that represents files are created. See\n   * [./src/layout/index.ts](./src/layout/index.ts) for available layouts. Default: balanced\n   */\n  layout?: FileLayout\n\n  /**\n   * This option can be used to override the importer internals.\n   *\n   * This function should read `{ path, content }` entries from `source` and turn them\n   * into DAGs\n   * It should yield a `function` that returns a `Promise` that resolves to\n   * `{ cid, path, unixfs, node }` where `cid` is a `CID`, `path` is a string, `unixfs`\n   * is a UnixFS entry and `node` is a `DAGNode`.\n   * Values will be pulled from this generator in parallel - the amount of parallelisation\n   * is controlled by the `fileImportConcurrency` option (default: 50)\n   */\n  dagBuilder?: DAGBuilder\n\n  /**\n   * This option can be used to override the importer internals.\n   *\n   * This function should read `{ cid, path, unixfs, node }` entries from `source` and\n   * place them in a directory structure\n   * It should yield an object with the properties `{ cid, path, unixfs, size }` where\n   * `cid` is a `CID`, `path` is a string, `unixfs` is a UnixFS entry and `size` is a `Number`.\n   */\n  treeBuilder?: TreeBuilder\n\n  /**\n   * This option can be used to override the importer internals.\n   *\n   * This function should read `Buffer`s from `source` and persist them using `blockstore.put`\n   * or similar\n   * `entry` is the `{ path, content }` entry, where `entry.content` is an async\n   * generator that yields Buffers\n   * It should yield functions that return a Promise that resolves to an object with\n   * the properties `{ cid, unixfs, size }` where `cid` is a [CID], `unixfs` is a [UnixFS] entry and `size` is a `Number` that represents the serialized size of the [IPLD] node that holds the buffer data.\n   * Values will be pulled from this generator in parallel - the amount of\n   * parallelisation is controlled by the `blockWriteConcurrency` option (default: 10)\n   */\n  bufferImporter?: BufferImporter\n\n  /**\n   * This option can be used to override the importer internals.\n   *\n   * This function takes input from the `content` field of imported entries.\n   * It should transform them into `Buffer`s, throwing an error if it cannot.\n   * It should yield `Buffer` objects constructed from the `source` or throw an\n   * `Error`\n   */\n  chunkValidator?: ChunkValidator\n\n  /**\n   * This option can be used to override how a directory IPLD node is built.\n   *\n   * This function takes a `Directory` object and returns a `Promise` that resolves to an `InProgressImportResult`.\n   */\n  dirBuilder?: DirBuilder\n\n  /**\n   * This option can be used to override how a file IPLD node is built.\n   *\n   * This function takes a `File` object and returns a `Promise` that resolves to an `InProgressImportResult`.\n   */\n  fileBuilder?: FileBuilder\n}\n\nexport type ImportCandidateStream = AsyncIterable<FileCandidate | DirectoryCandidate> | Iterable<FileCandidate | DirectoryCandidate>\n\n/**\n * The importer creates UnixFS DAGs and stores the blocks that make\n * them up in the passed blockstore.\n *\n * @example\n *\n * ```typescript\n * import { importer } from 'ipfs-unixfs-importer'\n * import { MemoryBlockstore } from 'blockstore-core'\n *\n * // store blocks in memory, other blockstores are available\n * const blockstore = new MemoryBlockstore()\n *\n * const input = [{\n *   path: './foo.txt',\n *   content: Uint8Array.from([0, 1, 2, 3, 4])\n * }, {\n *   path: './bar.txt',\n *   content: Uint8Array.from([0, 1, 2, 3, 4])\n * }]\n *\n * for await (const entry of importer(input, blockstore)) {\n *   console.info(entry)\n *   // { cid: CID(), ... }\n * }\n * ```\n */\nexport async function * importer (source: ImportCandidateStream, blockstore: WritableStorage, options: ImporterOptions = {}): AsyncGenerator<ImportResult, void, unknown> {\n  let candidates: AsyncIterable<FileCandidate | DirectoryCandidate> | Iterable<FileCandidate | DirectoryCandidate>\n\n  if (Symbol.asyncIterator in source || Symbol.iterator in source) {\n    candidates = source\n  } else {\n    candidates = [source]\n  }\n\n  const wrapWithDirectory = options.wrapWithDirectory ?? false\n  const shardSplitThresholdBytes = options.shardSplitThresholdBytes ?? 262144\n  const shardFanoutBits = options.shardFanoutBits ?? 8\n  const cidVersion = options.cidVersion ?? 1\n  const rawLeaves = options.rawLeaves ?? true\n  const leafType = options.leafType ?? 'file'\n  const fileImportConcurrency = options.fileImportConcurrency ?? 50\n  const blockWriteConcurrency = options.blockWriteConcurrency ?? 10\n  const reduceSingleLeafToSelf = options.reduceSingleLeafToSelf ?? true\n\n  const chunker = options.chunker ?? fixedSize()\n  const chunkValidator = options.chunkValidator ?? defaultChunkValidator()\n  const buildDag: DAGBuilder = options.dagBuilder ?? defaultDagBuilder({\n    chunker,\n    chunkValidator,\n    wrapWithDirectory,\n    layout: options.layout ?? balanced(),\n    bufferImporter: options.bufferImporter ?? defaultBufferImporter({\n      cidVersion,\n      rawLeaves,\n      leafType,\n      onProgress: options.onProgress\n    }),\n    blockWriteConcurrency,\n    reduceSingleLeafToSelf,\n    cidVersion,\n    onProgress: options.onProgress,\n    dirBuilder: options.dirBuilder,\n    fileBuilder: options.fileBuilder\n  })\n  const buildTree: TreeBuilder = options.treeBuilder ?? defaultTreeBuilder({\n    wrapWithDirectory,\n    shardSplitThresholdBytes,\n    shardFanoutBits,\n    cidVersion,\n    onProgress: options.onProgress\n  })\n\n  for await (const entry of buildTree(parallelBatch(buildDag(candidates, blockstore), fileImportConcurrency), blockstore)) {\n    yield {\n      cid: entry.cid,\n      path: entry.path,\n      unixfs: entry.unixfs,\n      size: entry.size\n    }\n  }\n}\n\n/**\n * `importFile` is similar to `importer` except it accepts a single\n * `FileCandidate` and returns a promise of a single `ImportResult`\n * instead of a stream of results.\n *\n * @example\n *\n * ```typescript\n * import { importFile } from 'ipfs-unixfs-importer'\n * import { MemoryBlockstore } from 'blockstore-core'\n *\n * // store blocks in memory, other blockstores are available\n * const blockstore = new MemoryBlockstore()\n *\n * const input: FileCandidate = {\n *   path: './foo.txt',\n *   content: Uint8Array.from([0, 1, 2, 3, 4])\n * }\n *\n * const entry = await importFile(input, blockstore)\n * ```\n */\nexport async function importFile (content: FileCandidate, blockstore: WritableStorage, options: ImporterOptions = {}): Promise<ImportResult> {\n  const result = await first(importer([content], blockstore, options))\n\n  if (result == null) {\n    throw new InvalidParametersError('Nothing imported')\n  }\n\n  return result\n}\n\n/**\n * `importDir` is similar to `importer` except it accepts a single\n * `DirectoryCandidate` and returns a promise of a single `ImportResult`\n * instead of a stream of results.\n *\n * @example\n *\n * ```typescript\n * import { importDirectory } from 'ipfs-unixfs-importer'\n * import { MemoryBlockstore } from 'blockstore-core'\n *\n * // store blocks in memory, other blockstores are available\n * const blockstore = new MemoryBlockstore()\n *\n * const input: DirectoryCandidate = {\n *   path: './foo.txt'\n * }\n *\n * const entry = await importDirectory(input, blockstore)\n * ```\n */\nexport async function importDirectory (content: DirectoryCandidate, blockstore: WritableStorage, options: ImporterOptions = {}): Promise<ImportResult> {\n  const result = await first(importer([content], blockstore, options))\n\n  if (result == null) {\n    throw new InvalidParametersError('Nothing imported')\n  }\n\n  return result\n}\n\n/**\n * `importBytes` accepts a single Uint8Array and returns a promise\n * of a single `ImportResult`.\n *\n * @example\n *\n * ```typescript\n * import { importBytes } from 'ipfs-unixfs-importer'\n * import { MemoryBlockstore } from 'blockstore-core'\n *\n * // store blocks in memory, other blockstores are available\n * const blockstore = new MemoryBlockstore()\n *\n * const input = Uint8Array.from([0, 1, 2, 3, 4])\n *\n * const entry = await importBytes(input, blockstore)\n * ```\n */\nexport async function importBytes (buf: ImportContent, blockstore: WritableStorage, options: ImporterOptions = {}): Promise<ImportResult> {\n  return importFile({\n    content: buf\n  }, blockstore, options)\n}\n\n/**\n * `importByteStream` accepts a single stream of Uint8Arrays and\n * returns a promise of a single `ImportResult`.\n *\n * @example\n *\n * ```typescript\n * import { importByteStream } from 'ipfs-unixfs-importer'\n * import { MemoryBlockstore } from 'blockstore-core'\n *\n * // store blocks in memory, other blockstores are available\n * const blockstore = new MemoryBlockstore()\n *\n * const input = [\n *   Uint8Array.from([0, 1, 2, 3, 4]),\n *   Uint8Array.from([5, 6, 7, 8, 9])\n * ]\n *\n * const entry = await importByteStream(input, blockstore)\n * ```\n */\nexport async function importByteStream (bufs: ByteStream, blockstore: WritableStorage, options: ImporterOptions = {}): Promise<ImportResult> {\n  return importFile({\n    content: bufs\n  }, blockstore, options)\n}\n", "/**\n * @packageDocumentation\n *\n * Return the last value from an (async)iterable.\n *\n * @example\n *\n * ```javascript\n * import last from 'it-last'\n *\n * // This can also be an iterator, generator, etc\n * const values = [0, 1, 2, 3, 4]\n *\n * const res = last(values)\n *\n * console.info(res) // 4\n * ```\n *\n * Async sources must be awaited:\n *\n * ```javascript\n * import last from 'it-last'\n *\n * const values = async function * () {\n *   yield * [0, 1, 2, 3, 4]\n * }\n *\n * const res = await last(values())\n *\n * console.info(res) // 4\n * ```\n */\n\nfunction isAsyncIterable <T> (thing: any): thing is AsyncIterable<T> {\n  return thing[Symbol.asyncIterator] != null\n}\n\n/**\n * Returns the last item of an (async) iterable, unless empty, in which case\n * return `undefined`\n */\nfunction last <T> (source: Iterable<T>): T | undefined\nfunction last <T> (source: Iterable<T> | AsyncIterable<T>): Promise<T | undefined>\nfunction last <T> (source: Iterable<T> | AsyncIterable<T>): Promise<T | undefined> | T | undefined {\n  if (isAsyncIterable(source)) {\n    return (async () => {\n      let res\n\n      for await (const entry of source) {\n        res = entry\n      }\n\n      return res\n    })()\n  }\n\n  let res\n\n  for (const entry of source) {\n    res = entry\n  }\n\n  return res\n}\n\nexport default last\n", "export abstract class UnixFSError extends Error {\n  public readonly name: string\n  public readonly code: string\n\n  constructor (message: string, name: string, code: string) {\n    super(message)\n\n    this.name = name\n    this.code = code\n  }\n}\n\nexport class NotUnixFSError extends UnixFSError {\n  constructor (message = 'not a Unixfs node') {\n    super(message, 'NotUnixFSError', 'ERR_NOT_UNIXFS')\n  }\n}\n\nexport class InvalidPBNodeError extends UnixFSError {\n  constructor (message = 'invalid PBNode') {\n    super(message, 'InvalidPBNodeError', 'ERR_INVALID_PB_NODE')\n  }\n}\n\nexport class UnknownError extends UnixFSError {\n  constructor (message = 'unknown error') {\n    super(message, 'InvalidPBNodeError', 'ERR_UNKNOWN_ERROR')\n  }\n}\n\nexport class AlreadyExistsError extends UnixFSError {\n  constructor (message = 'path already exists') {\n    super(message, 'AlreadyExistsError', 'ERR_ALREADY_EXISTS')\n  }\n}\n\nexport class DoesNotExistError extends UnixFSError {\n  constructor (message = 'path does not exist') {\n    super(message, 'DoesNotExistError', 'ERR_DOES_NOT_EXIST')\n  }\n}\n\nexport class NoContentError extends UnixFSError {\n  constructor (message = 'no content') {\n    super(message, 'NoContentError', 'ERR_NO_CONTENT')\n  }\n}\n\nexport class NotAFileError extends UnixFSError {\n  constructor (message = 'not a file') {\n    super(message, 'NotAFileError', 'ERR_NOT_A_FILE')\n  }\n}\n\nexport class NotADirectoryError extends UnixFSError {\n  constructor (message = 'not a directory') {\n    super(message, 'NotADirectoryError', 'ERR_NOT_A_DIRECTORY')\n  }\n}\n\nexport class InvalidParametersError extends UnixFSError {\n  constructor (message = 'invalid parameters') {\n    super(message, 'InvalidParametersError', 'ERR_INVALID_PARAMETERS')\n  }\n}\n", "import { importBytes, importByteStream, importer } from 'ipfs-unixfs-importer'\nimport { fixedSize } from 'ipfs-unixfs-importer/chunker'\nimport { balanced } from 'ipfs-unixfs-importer/layout'\nimport first from 'it-first'\nimport last from 'it-last'\nimport { InvalidParametersError } from '../errors.js'\nimport type { FileCandidate, AddOptions, AddFileOptions } from '../index.js'\nimport type { PutStore } from '../unixfs.js'\nimport type { ByteStream, DirectoryCandidate, ImportCandidateStream, ImportResult } from 'ipfs-unixfs-importer'\nimport type { CID } from 'multiformats/cid'\n\n/**\n * Default importer settings match Filecoin\n */\nconst defaultImporterSettings: AddOptions = {\n  cidVersion: 1,\n  rawLeaves: true,\n  layout: balanced({\n    maxChildrenPerNode: 1024\n  }),\n  chunker: fixedSize({\n    chunkSize: 1_048_576\n  })\n}\n\nexport async function * addAll (source: ImportCandidateStream, blockstore: PutStore, options: Partial<AddOptions> = {}): AsyncGenerator<ImportResult, void, unknown> {\n  yield * importer(source, blockstore, {\n    ...defaultImporterSettings,\n    ...options\n  })\n}\n\nexport async function addBytes (bytes: Uint8Array, blockstore: PutStore, options: Partial<AddFileOptions> = {}): Promise<CID> {\n  const { cid } = await importBytes(bytes, blockstore, {\n    ...defaultImporterSettings,\n    ...options\n  })\n\n  return cid\n}\n\nexport async function addByteStream (bytes: ByteStream, blockstore: PutStore, options: Partial<AddFileOptions> = {}): Promise<CID> {\n  const { cid } = await importByteStream(bytes, blockstore, {\n    ...defaultImporterSettings,\n    ...options\n  })\n\n  return cid\n}\n\nexport async function addFile (file: FileCandidate, blockstore: PutStore, options: Partial<AddFileOptions> = {}): Promise<CID> {\n  if (file.path == null) {\n    throw new InvalidParametersError('path is required')\n  }\n\n  if (file.content == null) {\n    throw new InvalidParametersError('content is required')\n  }\n\n  const result = await last(addAll([file], blockstore, {\n    ...defaultImporterSettings,\n    ...options,\n    wrapWithDirectory: true\n  }))\n\n  if (result == null) {\n    throw new InvalidParametersError('Nothing imported')\n  }\n\n  return result.cid\n}\n\nexport async function addDirectory (dir: Partial<DirectoryCandidate>, blockstore: PutStore, options: Partial<AddFileOptions> = {}): Promise<CID> {\n  // @ts-expect-error field is not in the types\n  if (dir.content != null) {\n    throw new InvalidParametersError('Directories cannot have content, use addFile instead')\n  }\n\n  const ord = dir.path == null ? first : last\n\n  const result = await ord(addAll([{\n    ...dir,\n    path: dir.path ?? '-'\n  }], blockstore, {\n    ...defaultImporterSettings,\n    ...options,\n    wrapWithDirectory: dir.path != null\n  }))\n\n  if (result == null) {\n    throw new InvalidParametersError('Nothing imported')\n  }\n\n  return result.cid\n}\n", "export default function isPlainObject(value) {\n\tif (typeof value !== 'object' || value === null) {\n\t\treturn false;\n\t}\n\n\tconst prototype = Object.getPrototypeOf(value);\n\treturn (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in value) && !(Symbol.iterator in value);\n}\n", "import isOptionObject from 'is-plain-obj'\n\nconst { hasOwnProperty } = Object.prototype\nconst { propertyIsEnumerable } = Object\nconst defineProperty = (object: any, name: any, value: any): void => {\n  Object.defineProperty(object, name, {\n    value,\n    writable: true,\n    enumerable: true,\n    configurable: true\n  })\n}\n\nconst globalThis = this\nconst defaultMergeOptions = {\n  concatArrays: false,\n  ignoreUndefined: false\n}\n\nconst getEnumerableOwnPropertyKeys = (value: any): any[] => {\n  const keys = []\n\n  for (const key in value) {\n    if (hasOwnProperty.call(value, key)) {\n      keys.push(key)\n    }\n  }\n\n  /* istanbul ignore else  */\n  if (Object.getOwnPropertySymbols) {\n    const symbols = Object.getOwnPropertySymbols(value)\n\n    for (const symbol of symbols) {\n      if (propertyIsEnumerable.call(value, symbol)) {\n        keys.push(symbol)\n      }\n    }\n  }\n\n  return keys\n}\n\nfunction clone <T> (value: T): T\nfunction clone <T> (value: T[]): T[]\nfunction clone (value: any): any {\n  if (Array.isArray(value)) {\n    return cloneArray(value)\n  }\n\n  if (isOptionObject(value)) {\n    return cloneOptionObject(value)\n  }\n\n  return value\n}\n\nfunction cloneArray <T> (array: T[]): T[] {\n  const result = array.slice(0, 0)\n\n  getEnumerableOwnPropertyKeys(array).forEach(key => {\n    defineProperty(result, key, clone(array[key]))\n  })\n\n  return result\n}\n\nfunction cloneOptionObject (object: any): any {\n  const result = Object.getPrototypeOf(object) === null ? Object.create(null) : {}\n\n  getEnumerableOwnPropertyKeys(object).forEach(key => {\n    defineProperty(result, key, clone(object[key]))\n  })\n\n  return result\n}\n\nconst mergeKeys = (merged: any, source: any, keys: any[], config: any): any => {\n  keys.forEach(key => {\n    if (typeof source[key] === 'undefined' && config.ignoreUndefined) {\n      return\n    }\n\n    // Do not recurse into prototype chain of merged\n    if (key in merged && merged[key] !== Object.getPrototypeOf(merged)) {\n      defineProperty(merged, key, merge(merged[key], source[key], config))\n    } else {\n      defineProperty(merged, key, clone(source[key]))\n    }\n  })\n\n  return merged\n}\n\n/**\n * see [Array.prototype.concat ( ...arguments )](http://www.ecma-international.org/ecma-262/6.0/#sec-array.prototype.concat)\n */\nconst concatArrays = (merged: any, source: any, config: any): any => {\n  let result = merged.slice(0, 0)\n  let resultIndex = 0;\n\n  [merged, source].forEach(array => {\n    const indices: any[] = []\n\n    // `result.concat(array)` with cloning\n    for (let k = 0; k < array.length; k++) {\n      if (!hasOwnProperty.call(array, k)) {\n        continue\n      }\n\n      indices.push(String(k))\n\n      if (array === merged) {\n        // Already cloned\n        defineProperty(result, resultIndex++, array[k])\n      } else {\n        defineProperty(result, resultIndex++, clone(array[k]))\n      }\n    }\n\n    // Merge non-index keys\n    result = mergeKeys(result, array, getEnumerableOwnPropertyKeys(array).filter(key => !indices.includes(key)), config)\n  })\n\n  return result\n}\n\nfunction merge (merged: any, source: any, config: any): any {\n  if (config.concatArrays && Array.isArray(merged) && Array.isArray(source)) {\n    return concatArrays(merged, source, config)\n  }\n\n  if (!isOptionObject(source) || !isOptionObject(merged)) {\n    return clone(source)\n  }\n\n  return mergeKeys(merged, source, getEnumerableOwnPropertyKeys(source), config)\n}\n\n/**\n * Port of `merge-options` to typescript\n *\n * @see https://github.com/schnittstabil/merge-options/pull/28\n */\nexport function mergeOptions (this: any, ...options: any[]): any {\n  const config = merge(clone(defaultMergeOptions), (this !== globalThis && this) || {}, defaultMergeOptions)\n  let merged = { _: {} }\n\n  for (const option of options) {\n    if (option === undefined) {\n      continue\n    }\n\n    if (!isOptionObject(option)) {\n      throw new TypeError('`' + option + '` is not an Option Object')\n    }\n\n    merged = merge(merged, { _: option }, config)\n  }\n\n  return merged._\n}\n", "export class BadPathError extends Error {\n  static name = 'BadPathError'\n  static code = 'ERR_BAD_PATH'\n  name = BadPathError.name\n  code = BadPathError.code\n\n  constructor (message = 'Bad path') {\n    super(message)\n  }\n}\n\nexport class NotFoundError extends Error {\n  static name = 'NotFoundError'\n  static code = 'ERR_NOT_FOUND'\n  name = NotFoundError.name\n  code = NotFoundError.code\n\n  constructor (message = 'Not found') {\n    super(message)\n  }\n}\n\nexport class NoResolverError extends Error {\n  static name = 'NoResolverError'\n  static code = 'ERR_NO_RESOLVER'\n  name = NoResolverError.name\n  code = NoResolverError.code\n\n  constructor (message = 'No resolver') {\n    super(message)\n  }\n}\n\nexport class NotUnixFSError extends Error {\n  static name = 'NotUnixFSError'\n  static code = 'ERR_NOT_UNIXFS'\n  name = NotUnixFSError.name\n  code = NotUnixFSError.code\n\n  constructor (message = 'Not UnixFS') {\n    super(message)\n  }\n}\n\nexport class OverReadError extends Error {\n  static name = 'OverReadError'\n  static code = 'ERR_OVER_READ'\n  name = OverReadError.name\n  code = OverReadError.code\n\n  constructor (message = 'Over read') {\n    super(message)\n  }\n}\n\nexport class UnderReadError extends Error {\n  static name = 'UnderReadError'\n  static code = 'ERR_UNDER_READ'\n  name = UnderReadError.name\n  code = UnderReadError.code\n\n  constructor (message = 'Under read') {\n    super(message)\n  }\n}\n\nexport class NoPropError extends Error {\n  static name = 'NoPropError'\n  static code = 'ERR_NO_PROP'\n  name = NoPropError.name\n  code = NoPropError.code\n\n  constructor (message = 'No Property found') {\n    super(message)\n  }\n}\n\nexport class InvalidParametersError extends Error {\n  static name = 'InvalidParametersError'\n  static code = 'ERR_INVALID_PARAMS'\n  name = InvalidParametersError.name\n  code = InvalidParametersError.code\n\n  constructor (message = 'Invalid parameters') {\n    super(message)\n  }\n}\n", "// This is an unfortunate replacement for @sindresorhus/is that we need to\n// re-implement for performance purposes. In particular the is.observable()\n// check is expensive, and unnecessary for our purposes. The values returned\n// are compatible with @sindresorhus/is, however.\n\nconst typeofs = [\n  'string',\n  'number',\n  'bigint',\n  'symbol'\n]\n\nconst objectTypeNames = [\n  'Function',\n  'Generator',\n  'AsyncGenerator',\n  'GeneratorFunction',\n  'AsyncGeneratorFunction',\n  'AsyncFunction',\n  'Observable',\n  'Array',\n  'Buffer',\n  'Object',\n  'RegExp',\n  'Date',\n  'Error',\n  'Map',\n  'Set',\n  'WeakMap',\n  'WeakSet',\n  'ArrayBuffer',\n  'SharedArrayBuffer',\n  'DataView',\n  'Promise',\n  'URL',\n  'HTMLElement',\n  'Int8Array',\n  'Uint8Array',\n  'Uint8ClampedArray',\n  'Int16Array',\n  'Uint16Array',\n  'Int32Array',\n  'Uint32Array',\n  'Float32Array',\n  'Float64Array',\n  'BigInt64Array',\n  'BigUint64Array'\n]\n\n/**\n * @param {any} value\n * @returns {string}\n */\nexport function is (value) {\n  if (value === null) {\n    return 'null'\n  }\n  if (value === undefined) {\n    return 'undefined'\n  }\n  if (value === true || value === false) {\n    return 'boolean'\n  }\n  const typeOf = typeof value\n  if (typeofs.includes(typeOf)) {\n    return typeOf\n  }\n  /* c8 ignore next 4 */\n  // not going to bother testing this, it's not going to be valid anyway\n  if (typeOf === 'function') {\n    return 'Function'\n  }\n  if (Array.isArray(value)) {\n    return 'Array'\n  }\n  if (isBuffer(value)) {\n    return 'Buffer'\n  }\n  const objectType = getObjectType(value)\n  if (objectType) {\n    return objectType\n  }\n  /* c8 ignore next */\n  return 'Object'\n}\n\n/**\n * @param {any} value\n * @returns {boolean}\n */\nfunction isBuffer (value) {\n  return value && value.constructor && value.constructor.isBuffer && value.constructor.isBuffer.call(null, value)\n}\n\n/**\n * @param {any} value\n * @returns {string|undefined}\n */\nfunction getObjectType (value) {\n  const objectTypeName = Object.prototype.toString.call(value).slice(8, -1)\n  if (objectTypeNames.includes(objectTypeName)) {\n    return objectTypeName\n  }\n  /* c8 ignore next */\n  return undefined\n}\n", "class Type {\n  /**\n   * @param {number} major\n   * @param {string} name\n   * @param {boolean} terminal\n   */\n  constructor (major, name, terminal) {\n    this.major = major\n    this.majorEncoded = major << 5\n    this.name = name\n    this.terminal = terminal\n  }\n\n  /* c8 ignore next 3 */\n  toString () {\n    return `Type[${this.major}].${this.name}`\n  }\n\n  /**\n   * @param {Type} typ\n   * @returns {number}\n   */\n  compare (typ) {\n    /* c8 ignore next 1 */\n    return this.major < typ.major ? -1 : this.major > typ.major ? 1 : 0\n  }\n}\n\n// convert to static fields when better supported\nType.uint = new Type(0, 'uint', true)\nType.negint = new Type(1, 'negint', true)\nType.bytes = new Type(2, 'bytes', true)\nType.string = new Type(3, 'string', true)\nType.array = new Type(4, 'array', false)\nType.map = new Type(5, 'map', false)\nType.tag = new Type(6, 'tag', false) // terminal?\nType.float = new Type(7, 'float', true)\nType.false = new Type(7, 'false', true)\nType.true = new Type(7, 'true', true)\nType.null = new Type(7, 'null', true)\nType.undefined = new Type(7, 'undefined', true)\nType.break = new Type(7, 'break', true)\n// Type.indefiniteLength = new Type(0, 'indefiniteLength', true)\n\nclass Token {\n  /**\n   * @param {Type} type\n   * @param {any} [value]\n   * @param {number} [encodedLength]\n   */\n  constructor (type, value, encodedLength) {\n    this.type = type\n    this.value = value\n    this.encodedLength = encodedLength\n    /** @type {Uint8Array|undefined} */\n    this.encodedBytes = undefined\n    /** @type {Uint8Array|undefined} */\n    this.byteValue = undefined\n  }\n\n  /* c8 ignore next 3 */\n  toString () {\n    return `Token[${this.type}].${this.value}`\n  }\n}\n\nexport { Type, Token }\n", "// Use Uint8Array directly in the browser, use Buffer in Node.js but don't\n// speak its name directly to avoid bundlers pulling in the `Buffer` polyfill\n\n// @ts-ignore\nexport const useBuffer = globalThis.process &&\n  // @ts-ignore\n  !globalThis.process.browser &&\n  // @ts-ignore\n  globalThis.Buffer &&\n  // @ts-ignore\n  typeof globalThis.Buffer.isBuffer === 'function'\n\nconst textDecoder = new TextDecoder()\nconst textEncoder = new TextEncoder()\n\n/**\n * @param {Uint8Array} buf\n * @returns {boolean}\n */\nfunction isBuffer (buf) {\n  // @ts-ignore\n  return useBuffer && globalThis.Buffer.isBuffer(buf)\n}\n\n/**\n * @param {Uint8Array|number[]} buf\n * @returns {Uint8Array}\n */\nexport function asU8A (buf) {\n  /* c8 ignore next */\n  if (!(buf instanceof Uint8Array)) {\n    return Uint8Array.from(buf)\n  }\n  return isBuffer(buf) ? new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength) : buf\n}\n\nexport const toString = useBuffer\n  ? // eslint-disable-line operator-linebreak\n    /**\n     * @param {Uint8Array} bytes\n     * @param {number} start\n     * @param {number} end\n     */\n    (bytes, start, end) => {\n      return end - start > 64\n        ? // eslint-disable-line operator-linebreak\n      // @ts-ignore\n        globalThis.Buffer.from(bytes.subarray(start, end)).toString('utf8')\n        : utf8Slice(bytes, start, end)\n    }\n  /* c8 ignore next 11 */\n  : // eslint-disable-line operator-linebreak\n    /**\n     * @param {Uint8Array} bytes\n     * @param {number} start\n     * @param {number} end\n     */\n    (bytes, start, end) => {\n      return end - start > 64\n        ? textDecoder.decode(bytes.subarray(start, end))\n        : utf8Slice(bytes, start, end)\n    }\n\nexport const fromString = useBuffer\n  ? // eslint-disable-line operator-linebreak\n    /**\n     * @param {string} string\n     */\n    (string) => {\n      return string.length > 64\n        ? // eslint-disable-line operator-linebreak\n      // @ts-ignore\n        globalThis.Buffer.from(string)\n        : utf8ToBytes(string)\n    }\n  /* c8 ignore next 7 */\n  : // eslint-disable-line operator-linebreak\n    /**\n     * @param {string} string\n     */\n    (string) => {\n      return string.length > 64 ? textEncoder.encode(string) : utf8ToBytes(string)\n    }\n\n/**\n * Buffer variant not fast enough for what we need\n * @param {number[]} arr\n * @returns {Uint8Array}\n */\nexport const fromArray = (arr) => {\n  return Uint8Array.from(arr)\n}\n\nexport const slice = useBuffer\n  ? // eslint-disable-line operator-linebreak\n    /**\n     * @param {Uint8Array} bytes\n     * @param {number} start\n     * @param {number} end\n     */\n    (bytes, start, end) => {\n      if (isBuffer(bytes)) {\n        return new Uint8Array(bytes.subarray(start, end))\n      }\n      return bytes.slice(start, end)\n    }\n  /* c8 ignore next 9 */\n  : // eslint-disable-line operator-linebreak\n    /**\n     * @param {Uint8Array} bytes\n     * @param {number} start\n     * @param {number} end\n     */\n    (bytes, start, end) => {\n      return bytes.slice(start, end)\n    }\n\nexport const concat = useBuffer\n  ? // eslint-disable-line operator-linebreak\n    /**\n     * @param {Uint8Array[]} chunks\n     * @param {number} length\n     * @returns {Uint8Array}\n     */\n    (chunks, length) => {\n      // might get a stray plain Array here\n      /* c8 ignore next 1 */\n      chunks = chunks.map((c) => c instanceof Uint8Array\n        ? c\n        // this case is occasionally missed during test runs so becomes coverage-flaky\n        /* c8 ignore next 4 */\n        : // eslint-disable-line operator-linebreak\n        // @ts-ignore\n        globalThis.Buffer.from(c))\n      // @ts-ignore\n      return asU8A(globalThis.Buffer.concat(chunks, length))\n    }\n  /* c8 ignore next 19 */\n  : // eslint-disable-line operator-linebreak\n    /**\n     * @param {Uint8Array[]} chunks\n     * @param {number} length\n     * @returns {Uint8Array}\n     */\n    (chunks, length) => {\n      const out = new Uint8Array(length)\n      let off = 0\n      for (let b of chunks) {\n        if (off + b.length > out.length) {\n          // final chunk that's bigger than we need\n          b = b.subarray(0, out.length - off)\n        }\n        out.set(b, off)\n        off += b.length\n      }\n      return out\n    }\n\nexport const alloc = useBuffer\n  ? // eslint-disable-line operator-linebreak\n    /**\n     * @param {number} size\n     * @returns {Uint8Array}\n     */\n    (size) => {\n      // we always write over the contents we expose so this should be safe\n      // @ts-ignore\n      return globalThis.Buffer.allocUnsafe(size)\n    }\n  /* c8 ignore next 8 */\n  : // eslint-disable-line operator-linebreak\n    /**\n     * @param {number} size\n     * @returns {Uint8Array}\n     */\n    (size) => {\n      return new Uint8Array(size)\n    }\n\nexport const toHex = useBuffer\n  ? // eslint-disable-line operator-linebreak\n    /**\n     * @param {Uint8Array} d\n     * @returns {string}\n     */\n    (d) => {\n      if (typeof d === 'string') {\n        return d\n      }\n      // @ts-ignore\n      return globalThis.Buffer.from(toBytes(d)).toString('hex')\n    }\n  /* c8 ignore next 12 */\n  : // eslint-disable-line operator-linebreak\n    /**\n     * @param {Uint8Array} d\n     * @returns {string}\n     */\n    (d) => {\n      if (typeof d === 'string') {\n        return d\n      }\n      // @ts-ignore not smart enough to figure this out\n      return Array.prototype.reduce.call(toBytes(d), (p, c) => `${p}${c.toString(16).padStart(2, '0')}`, '')\n    }\n\nexport const fromHex = useBuffer\n  ? // eslint-disable-line operator-linebreak\n  /**\n   * @param {string|Uint8Array} hex\n   * @returns {Uint8Array}\n   */\n    (hex) => {\n      if (hex instanceof Uint8Array) {\n        return hex\n      }\n      // @ts-ignore\n      return globalThis.Buffer.from(hex, 'hex')\n    }\n  /* c8 ignore next 17 */\n  : // eslint-disable-line operator-linebreak\n  /**\n   * @param {string|Uint8Array} hex\n   * @returns {Uint8Array}\n   */\n    (hex) => {\n      if (hex instanceof Uint8Array) {\n        return hex\n      }\n      if (!hex.length) {\n        return new Uint8Array(0)\n      }\n      return new Uint8Array(hex.split('')\n        .map((/** @type {string} */ c, /** @type {number} */ i, /** @type {string[]} */ d) => i % 2 === 0 ? `0x${c}${d[i + 1]}` : '')\n        .filter(Boolean)\n        .map((/** @type {string} */ e) => parseInt(e, 16)))\n    }\n\n/**\n * @param {Uint8Array|ArrayBuffer|ArrayBufferView} obj\n * @returns {Uint8Array}\n */\nfunction toBytes (obj) {\n  if (obj instanceof Uint8Array && obj.constructor.name === 'Uint8Array') {\n    return obj\n  }\n  if (obj instanceof ArrayBuffer) {\n    return new Uint8Array(obj)\n  }\n  if (ArrayBuffer.isView(obj)) {\n    return new Uint8Array(obj.buffer, obj.byteOffset, obj.byteLength)\n  }\n  /* c8 ignore next */\n  throw new Error('Unknown type, must be binary type')\n}\n\n/**\n * @param {Uint8Array} b1\n * @param {Uint8Array} b2\n * @returns {number}\n */\nexport function compare (b1, b2) {\n  /* c8 ignore next 5 */\n  if (isBuffer(b1) && isBuffer(b2)) {\n    // probably not possible to get here in the current API\n    // @ts-ignore Buffer\n    return b1.compare(b2)\n  }\n  for (let i = 0; i < b1.length; i++) {\n    if (b1[i] === b2[i]) {\n      continue\n    }\n    return b1[i] < b2[i] ? -1 : 1\n  } /* c8 ignore next 3 */\n  return 0\n}\n\n// The below code is taken from https://github.com/google/closure-library/blob/8598d87242af59aac233270742c8984e2b2bdbe0/closure/goog/crypt/crypt.js#L117-L143\n// Licensed Apache-2.0.\n\n/**\n * @param {string} str\n * @returns {number[]}\n */\nfunction utf8ToBytes (str) {\n  const out = []\n  let p = 0\n  for (let i = 0; i < str.length; i++) {\n    let c = str.charCodeAt(i)\n    if (c < 128) {\n      out[p++] = c\n    } else if (c < 2048) {\n      out[p++] = (c >> 6) | 192\n      out[p++] = (c & 63) | 128\n    } else if (\n      ((c & 0xFC00) === 0xD800) && (i + 1) < str.length &&\n      ((str.charCodeAt(i + 1) & 0xFC00) === 0xDC00)) {\n      // Surrogate Pair\n      c = 0x10000 + ((c & 0x03FF) << 10) + (str.charCodeAt(++i) & 0x03FF)\n      out[p++] = (c >> 18) | 240\n      out[p++] = ((c >> 12) & 63) | 128\n      out[p++] = ((c >> 6) & 63) | 128\n      out[p++] = (c & 63) | 128\n    } else {\n      out[p++] = (c >> 12) | 224\n      out[p++] = ((c >> 6) & 63) | 128\n      out[p++] = (c & 63) | 128\n    }\n  }\n  return out\n}\n\n// The below code is mostly taken from https://github.com/feross/buffer\n// Licensed MIT. Copyright (c) Feross Aboukhadijeh\n\n/**\n * @param {Uint8Array} buf\n * @param {number} offset\n * @param {number} end\n * @returns {string}\n */\nfunction utf8Slice (buf, offset, end) {\n  const res = []\n\n  while (offset < end) {\n    const firstByte = buf[offset]\n    let codePoint = null\n    let bytesPerSequence = (firstByte > 0xef) ? 4 : (firstByte > 0xdf) ? 3 : (firstByte > 0xbf) ? 2 : 1\n\n    if (offset + bytesPerSequence <= end) {\n      let secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[offset + 1]\n          if ((secondByte & 0xc0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1f) << 0x6 | (secondByte & 0x3f)\n            if (tempCodePoint > 0x7f) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[offset + 1]\n          thirdByte = buf[offset + 2]\n          if ((secondByte & 0xc0) === 0x80 && (thirdByte & 0xc0) === 0x80) {\n            tempCodePoint = (firstByte & 0xf) << 0xc | (secondByte & 0x3f) << 0x6 | (thirdByte & 0x3f)\n            /* c8 ignore next 3 */\n            if (tempCodePoint > 0x7ff && (tempCodePoint < 0xd800 || tempCodePoint > 0xdfff)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[offset + 1]\n          thirdByte = buf[offset + 2]\n          fourthByte = buf[offset + 3]\n          if ((secondByte & 0xc0) === 0x80 && (thirdByte & 0xc0) === 0x80 && (fourthByte & 0xc0) === 0x80) {\n            tempCodePoint = (firstByte & 0xf) << 0x12 | (secondByte & 0x3f) << 0xc | (thirdByte & 0x3f) << 0x6 | (fourthByte & 0x3f)\n            if (tempCodePoint > 0xffff && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    /* c8 ignore next 5 */\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xfffd\n      bytesPerSequence = 1\n    } else if (codePoint > 0xffff) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3ff | 0xd800)\n      codePoint = 0xdc00 | codePoint & 0x3ff\n    }\n\n    res.push(codePoint)\n    offset += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nconst MAX_ARGUMENTS_LENGTH = 0x1000\n\n/**\n * @param {number[]} codePoints\n * @returns {string}\n */\nexport function decodeCodePointsArray (codePoints) {\n  const len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n  /* c8 ignore next 10 */\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  let res = ''\n  let i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n", "/**\n * Bl is a list of byte chunks, similar to https://github.com/rvagg/bl but for\n * writing rather than reading.\n * A Bl object accepts set() operations for individual bytes and copyTo() for\n * inserting byte arrays. These write operations don't automatically increment\n * the internal cursor so its \"length\" won't be changed. Instead, increment()\n * must be called to extend its length to cover the inserted data.\n * The toBytes() call will convert all internal memory to a single Uint8Array of\n * the correct length, truncating any data that is stored but hasn't been\n * included by an increment().\n * get() can retrieve a single byte.\n * All operations (except toBytes()) take an \"offset\" argument that will perform\n * the write at the offset _from the current cursor_. For most operations this\n * will be `0` to write at the current cursor position but it can be ahead of\n * the current cursor. Negative offsets probably work but are untested.\n */\n\n// TODO: ipjs doesn't support this, only for test files: https://github.com/mikeal/ipjs/blob/master/src/package/testFile.js#L39\nimport { alloc, concat, slice } from './byte-utils.js'\n\n// the ts-ignores in this file are almost all for the `Uint8Array|number[]` duality that exists\n// for perf reasons. Consider better approaches to this or removing it entirely, it is quite\n// risky because of some assumptions about small chunks === number[] and everything else === Uint8Array.\n\nconst defaultChunkSize = 256\n\nexport class Bl {\n  /**\n   * @param {number} [chunkSize]\n   */\n  constructor (chunkSize = defaultChunkSize) {\n    this.chunkSize = chunkSize\n    /** @type {number} */\n    this.cursor = 0\n    /** @type {number} */\n    this.maxCursor = -1\n    /** @type {(Uint8Array|number[])[]} */\n    this.chunks = []\n    // keep the first chunk around if we can to save allocations for future encodes\n    /** @type {Uint8Array|number[]|null} */\n    this._initReuseChunk = null\n  }\n\n  reset () {\n    this.cursor = 0\n    this.maxCursor = -1\n    if (this.chunks.length) {\n      this.chunks = []\n    }\n    if (this._initReuseChunk !== null) {\n      this.chunks.push(this._initReuseChunk)\n      this.maxCursor = this._initReuseChunk.length - 1\n    }\n  }\n\n  /**\n   * @param {Uint8Array|number[]} bytes\n   */\n  push (bytes) {\n    let topChunk = this.chunks[this.chunks.length - 1]\n    const newMax = this.cursor + bytes.length\n    if (newMax <= this.maxCursor + 1) {\n      // we have at least one chunk and we can fit these bytes into that chunk\n      const chunkPos = topChunk.length - (this.maxCursor - this.cursor) - 1\n      // @ts-ignore\n      topChunk.set(bytes, chunkPos)\n    } else {\n      // can't fit it in\n      if (topChunk) {\n        // trip the last chunk to `cursor` if we need to\n        const chunkPos = topChunk.length - (this.maxCursor - this.cursor) - 1\n        if (chunkPos < topChunk.length) {\n          // @ts-ignore\n          this.chunks[this.chunks.length - 1] = topChunk.subarray(0, chunkPos)\n          this.maxCursor = this.cursor - 1\n        }\n      }\n      if (bytes.length < 64 && bytes.length < this.chunkSize) {\n        // make a new chunk and copy the new one into it\n        topChunk = alloc(this.chunkSize)\n        this.chunks.push(topChunk)\n        this.maxCursor += topChunk.length\n        if (this._initReuseChunk === null) {\n          this._initReuseChunk = topChunk\n        }\n        // @ts-ignore\n        topChunk.set(bytes, 0)\n      } else {\n        // push the new bytes in as its own chunk\n        this.chunks.push(bytes)\n        this.maxCursor += bytes.length\n      }\n    }\n    this.cursor += bytes.length\n  }\n\n  /**\n   * @param {boolean} [reset]\n   * @returns {Uint8Array}\n   */\n  toBytes (reset = false) {\n    let byts\n    if (this.chunks.length === 1) {\n      const chunk = this.chunks[0]\n      if (reset && this.cursor > chunk.length / 2) {\n        /* c8 ignore next 2 */\n        // @ts-ignore\n        byts = this.cursor === chunk.length ? chunk : chunk.subarray(0, this.cursor)\n        this._initReuseChunk = null\n        this.chunks = []\n      } else {\n        // @ts-ignore\n        byts = slice(chunk, 0, this.cursor)\n      }\n    } else {\n      // @ts-ignore\n      byts = concat(this.chunks, this.cursor)\n    }\n    if (reset) {\n      this.reset()\n    }\n    return byts\n  }\n}\n", "const decodeErrPrefix = 'CBOR decode error:'\nconst encodeErrPrefix = 'CBOR encode error:'\n\nconst uintMinorPrefixBytes = []\nuintMinorPrefixBytes[23] = 1\nuintMinorPrefixBytes[24] = 2\nuintMinorPrefixBytes[25] = 3\nuintMinorPrefixBytes[26] = 5\nuintMinorPrefixBytes[27] = 9\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} need\n */\nfunction assertEnoughData (data, pos, need) {\n  if (data.length - pos < need) {\n    throw new Error(`${decodeErrPrefix} not enough data for type`)\n  }\n}\n\nexport {\n  decodeErrPrefix,\n  encodeErrPrefix,\n  uintMinorPrefixBytes,\n  assertEnoughData\n}\n", "/* globals BigInt */\n\nimport { Token, Type } from './token.js'\nimport { decodeErrPrefix, assertEnoughData } from './common.js'\n\nexport const uintBoundaries = [24, 256, 65536, 4294967296, BigInt('18446744073709551616')]\n\n/**\n * @typedef {import('./bl.js').Bl} Bl\n * @typedef {import('../interface').DecodeOptions} DecodeOptions\n */\n\n/**\n * @param {Uint8Array} data\n * @param {number} offset\n * @param {DecodeOptions} options\n * @returns {number}\n */\nexport function readUint8 (data, offset, options) {\n  assertEnoughData(data, offset, 1)\n  const value = data[offset]\n  if (options.strict === true && value < uintBoundaries[0]) {\n    throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`)\n  }\n  return value\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} offset\n * @param {DecodeOptions} options\n * @returns {number}\n */\nexport function readUint16 (data, offset, options) {\n  assertEnoughData(data, offset, 2)\n  const value = (data[offset] << 8) | data[offset + 1]\n  if (options.strict === true && value < uintBoundaries[1]) {\n    throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`)\n  }\n  return value\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} offset\n * @param {DecodeOptions} options\n * @returns {number}\n */\nexport function readUint32 (data, offset, options) {\n  assertEnoughData(data, offset, 4)\n  const value = (data[offset] * 16777216 /* 2 ** 24 */) + (data[offset + 1] << 16) + (data[offset + 2] << 8) + data[offset + 3]\n  if (options.strict === true && value < uintBoundaries[2]) {\n    throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`)\n  }\n  return value\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} offset\n * @param {DecodeOptions} options\n * @returns {number|bigint}\n */\nexport function readUint64 (data, offset, options) {\n  // assume BigInt, convert back to Number if within safe range\n  assertEnoughData(data, offset, 8)\n  const hi = (data[offset] * 16777216 /* 2 ** 24 */) + (data[offset + 1] << 16) + (data[offset + 2] << 8) + data[offset + 3]\n  const lo = (data[offset + 4] * 16777216 /* 2 ** 24 */) + (data[offset + 5] << 16) + (data[offset + 6] << 8) + data[offset + 7]\n  const value = (BigInt(hi) << BigInt(32)) + BigInt(lo)\n  if (options.strict === true && value < uintBoundaries[3]) {\n    throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`)\n  }\n  if (value <= Number.MAX_SAFE_INTEGER) {\n    return Number(value)\n  }\n  if (options.allowBigInt === true) {\n    return value\n  }\n  throw new Error(`${decodeErrPrefix} integers outside of the safe integer range are not supported`)\n}\n\n/* not required thanks to quick[] list\nconst oneByteTokens = new Array(24).fill(0).map((v, i) => new Token(Type.uint, i, 1))\nexport function decodeUintCompact (data, pos, minor, options) {\n  return oneByteTokens[minor]\n}\n*/\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeUint8 (data, pos, _minor, options) {\n  return new Token(Type.uint, readUint8(data, pos + 1, options), 2)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeUint16 (data, pos, _minor, options) {\n  return new Token(Type.uint, readUint16(data, pos + 1, options), 3)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeUint32 (data, pos, _minor, options) {\n  return new Token(Type.uint, readUint32(data, pos + 1, options), 5)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeUint64 (data, pos, _minor, options) {\n  return new Token(Type.uint, readUint64(data, pos + 1, options), 9)\n}\n\n/**\n * @param {Bl} buf\n * @param {Token} token\n */\nexport function encodeUint (buf, token) {\n  return encodeUintValue(buf, 0, token.value)\n}\n\n/**\n * @param {Bl} buf\n * @param {number} major\n * @param {number|bigint} uint\n */\nexport function encodeUintValue (buf, major, uint) {\n  if (uint < uintBoundaries[0]) {\n    const nuint = Number(uint)\n    // pack into one byte, minor=0, additional=value\n    buf.push([major | nuint])\n  } else if (uint < uintBoundaries[1]) {\n    const nuint = Number(uint)\n    // pack into two byte, minor=0, additional=24\n    buf.push([major | 24, nuint])\n  } else if (uint < uintBoundaries[2]) {\n    const nuint = Number(uint)\n    // pack into three byte, minor=0, additional=25\n    buf.push([major | 25, nuint >>> 8, nuint & 0xff])\n  } else if (uint < uintBoundaries[3]) {\n    const nuint = Number(uint)\n    // pack into five byte, minor=0, additional=26\n    buf.push([major | 26, (nuint >>> 24) & 0xff, (nuint >>> 16) & 0xff, (nuint >>> 8) & 0xff, nuint & 0xff])\n  } else {\n    const buint = BigInt(uint)\n    if (buint < uintBoundaries[4]) {\n      // pack into nine byte, minor=0, additional=27\n      const set = [major | 27, 0, 0, 0, 0, 0, 0, 0]\n      // simulate bitwise above 32 bits\n      let lo = Number(buint & BigInt(0xffffffff))\n      let hi = Number(buint >> BigInt(32) & BigInt(0xffffffff))\n      set[8] = lo & 0xff\n      lo = lo >> 8\n      set[7] = lo & 0xff\n      lo = lo >> 8\n      set[6] = lo & 0xff\n      lo = lo >> 8\n      set[5] = lo & 0xff\n      set[4] = hi & 0xff\n      hi = hi >> 8\n      set[3] = hi & 0xff\n      hi = hi >> 8\n      set[2] = hi & 0xff\n      hi = hi >> 8\n      set[1] = hi & 0xff\n      buf.push(set)\n    } else {\n      throw new Error(`${decodeErrPrefix} encountered BigInt larger than allowable range`)\n    }\n  }\n}\n\n/**\n * @param {Token} token\n * @returns {number}\n */\nencodeUint.encodedSize = function encodedSize (token) {\n  return encodeUintValue.encodedSize(token.value)\n}\n\n/**\n * @param {number} uint\n * @returns {number}\n */\nencodeUintValue.encodedSize = function encodedSize (uint) {\n  if (uint < uintBoundaries[0]) {\n    return 1\n  }\n  if (uint < uintBoundaries[1]) {\n    return 2\n  }\n  if (uint < uintBoundaries[2]) {\n    return 3\n  }\n  if (uint < uintBoundaries[3]) {\n    return 5\n  }\n  return 9\n}\n\n/**\n * @param {Token} tok1\n * @param {Token} tok2\n * @returns {number}\n */\nencodeUint.compareTokens = function compareTokens (tok1, tok2) {\n  return tok1.value < tok2.value ? -1 : tok1.value > tok2.value ? 1 : /* c8 ignore next */ 0\n}\n", "/* eslint-env es2020 */\n\nimport { Token, Type } from './token.js'\nimport * as uint from './0uint.js'\nimport { decodeErrPrefix } from './common.js'\n\n/**\n * @typedef {import('./bl.js').Bl} Bl\n * @typedef {import('../interface').DecodeOptions} DecodeOptions\n */\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeNegint8 (data, pos, _minor, options) {\n  return new Token(Type.negint, -1 - uint.readUint8(data, pos + 1, options), 2)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeNegint16 (data, pos, _minor, options) {\n  return new Token(Type.negint, -1 - uint.readUint16(data, pos + 1, options), 3)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeNegint32 (data, pos, _minor, options) {\n  return new Token(Type.negint, -1 - uint.readUint32(data, pos + 1, options), 5)\n}\n\nconst neg1b = BigInt(-1)\nconst pos1b = BigInt(1)\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeNegint64 (data, pos, _minor, options) {\n  const int = uint.readUint64(data, pos + 1, options)\n  if (typeof int !== 'bigint') {\n    const value = -1 - int\n    if (value >= Number.MIN_SAFE_INTEGER) {\n      return new Token(Type.negint, value, 9)\n    }\n  }\n  if (options.allowBigInt !== true) {\n    throw new Error(`${decodeErrPrefix} integers outside of the safe integer range are not supported`)\n  }\n  return new Token(Type.negint, neg1b - BigInt(int), 9)\n}\n\n/**\n * @param {Bl} buf\n * @param {Token} token\n */\nexport function encodeNegint (buf, token) {\n  const negint = token.value\n  const unsigned = (typeof negint === 'bigint' ? (negint * neg1b - pos1b) : (negint * -1 - 1))\n  uint.encodeUintValue(buf, token.type.majorEncoded, unsigned)\n}\n\n/**\n * @param {Token} token\n * @returns {number}\n */\nencodeNegint.encodedSize = function encodedSize (token) {\n  const negint = token.value\n  const unsigned = (typeof negint === 'bigint' ? (negint * neg1b - pos1b) : (negint * -1 - 1))\n  /* c8 ignore next 4 */\n  // handled by quickEncode, we shouldn't get here but it's included for completeness\n  if (unsigned < uint.uintBoundaries[0]) {\n    return 1\n  }\n  if (unsigned < uint.uintBoundaries[1]) {\n    return 2\n  }\n  if (unsigned < uint.uintBoundaries[2]) {\n    return 3\n  }\n  if (unsigned < uint.uintBoundaries[3]) {\n    return 5\n  }\n  return 9\n}\n\n/**\n * @param {Token} tok1\n * @param {Token} tok2\n * @returns {number}\n */\nencodeNegint.compareTokens = function compareTokens (tok1, tok2) {\n  // opposite of the uint comparison since we store the uint version in bytes\n  return tok1.value < tok2.value ? 1 : tok1.value > tok2.value ? -1 : /* c8 ignore next */ 0\n}\n", "import { Token, Type } from './token.js'\nimport { assertEnoughData, decodeErrPrefix } from './common.js'\nimport * as uint from './0uint.js'\nimport { compare, fromString, slice } from './byte-utils.js'\n\n/**\n * @typedef {import('./bl.js').Bl} Bl\n * @typedef {import('../interface').DecodeOptions} DecodeOptions\n */\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} prefix\n * @param {number} length\n * @returns {Token}\n */\nfunction toToken (data, pos, prefix, length) {\n  assertEnoughData(data, pos, prefix + length)\n  const buf = slice(data, pos + prefix, pos + prefix + length)\n  return new Token(Type.bytes, buf, prefix + length)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} minor\n * @param {DecodeOptions} _options\n * @returns {Token}\n */\nexport function decodeBytesCompact (data, pos, minor, _options) {\n  return toToken(data, pos, 1, minor)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeBytes8 (data, pos, _minor, options) {\n  return toToken(data, pos, 2, uint.readUint8(data, pos + 1, options))\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeBytes16 (data, pos, _minor, options) {\n  return toToken(data, pos, 3, uint.readUint16(data, pos + 1, options))\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeBytes32 (data, pos, _minor, options) {\n  return toToken(data, pos, 5, uint.readUint32(data, pos + 1, options))\n}\n\n// TODO: maybe we shouldn't support this ..\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeBytes64 (data, pos, _minor, options) {\n  const l = uint.readUint64(data, pos + 1, options)\n  if (typeof l === 'bigint') {\n    throw new Error(`${decodeErrPrefix} 64-bit integer bytes lengths not supported`)\n  }\n  return toToken(data, pos, 9, l)\n}\n\n/**\n * `encodedBytes` allows for caching when we do a byte version of a string\n * for key sorting purposes\n * @param {Token} token\n * @returns {Uint8Array}\n */\nfunction tokenBytes (token) {\n  if (token.encodedBytes === undefined) {\n    token.encodedBytes = token.type === Type.string ? fromString(token.value) : token.value\n  }\n  // @ts-ignore c'mon\n  return token.encodedBytes\n}\n\n/**\n * @param {Bl} buf\n * @param {Token} token\n */\nexport function encodeBytes (buf, token) {\n  const bytes = tokenBytes(token)\n  uint.encodeUintValue(buf, token.type.majorEncoded, bytes.length)\n  buf.push(bytes)\n}\n\n/**\n * @param {Token} token\n * @returns {number}\n */\nencodeBytes.encodedSize = function encodedSize (token) {\n  const bytes = tokenBytes(token)\n  return uint.encodeUintValue.encodedSize(bytes.length) + bytes.length\n}\n\n/**\n * @param {Token} tok1\n * @param {Token} tok2\n * @returns {number}\n */\nencodeBytes.compareTokens = function compareTokens (tok1, tok2) {\n  return compareBytes(tokenBytes(tok1), tokenBytes(tok2))\n}\n\n/**\n * @param {Uint8Array} b1\n * @param {Uint8Array} b2\n * @returns {number}\n */\nexport function compareBytes (b1, b2) {\n  return b1.length < b2.length ? -1 : b1.length > b2.length ? 1 : compare(b1, b2)\n}\n", "import { Token, Type } from './token.js'\nimport { assertEnoughData, decodeErrPrefix } from './common.js'\nimport * as uint from './0uint.js'\nimport { encodeBytes } from './2bytes.js'\nimport { toString, slice } from './byte-utils.js'\n\n/**\n * @typedef {import('./bl.js').Bl} Bl\n * @typedef {import('../interface').DecodeOptions} DecodeOptions\n */\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} prefix\n * @param {number} length\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nfunction toToken (data, pos, prefix, length, options) {\n  const totLength = prefix + length\n  assertEnoughData(data, pos, totLength)\n  const tok = new Token(Type.string, toString(data, pos + prefix, pos + totLength), totLength)\n  if (options.retainStringBytes === true) {\n    tok.byteValue = slice(data, pos + prefix, pos + totLength)\n  }\n  return tok\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeStringCompact (data, pos, minor, options) {\n  return toToken(data, pos, 1, minor, options)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeString8 (data, pos, _minor, options) {\n  return toToken(data, pos, 2, uint.readUint8(data, pos + 1, options), options)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeString16 (data, pos, _minor, options) {\n  return toToken(data, pos, 3, uint.readUint16(data, pos + 1, options), options)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeString32 (data, pos, _minor, options) {\n  return toToken(data, pos, 5, uint.readUint32(data, pos + 1, options), options)\n}\n\n// TODO: maybe we shouldn't support this ..\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeString64 (data, pos, _minor, options) {\n  const l = uint.readUint64(data, pos + 1, options)\n  if (typeof l === 'bigint') {\n    throw new Error(`${decodeErrPrefix} 64-bit integer string lengths not supported`)\n  }\n  return toToken(data, pos, 9, l, options)\n}\n\nexport const encodeString = encodeBytes\n", "import { Token, Type } from './token.js'\nimport * as uint from './0uint.js'\nimport { decodeErrPrefix } from './common.js'\n\n/**\n * @typedef {import('./bl.js').Bl} Bl\n * @typedef {import('../interface').DecodeOptions} DecodeOptions\n */\n\n/**\n * @param {Uint8Array} _data\n * @param {number} _pos\n * @param {number} prefix\n * @param {number} length\n * @returns {Token}\n */\nfunction toToken (_data, _pos, prefix, length) {\n  return new Token(Type.array, length, prefix)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} minor\n * @param {DecodeOptions} _options\n * @returns {Token}\n */\nexport function decodeArrayCompact (data, pos, minor, _options) {\n  return toToken(data, pos, 1, minor)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeArray8 (data, pos, _minor, options) {\n  return toToken(data, pos, 2, uint.readUint8(data, pos + 1, options))\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeArray16 (data, pos, _minor, options) {\n  return toToken(data, pos, 3, uint.readUint16(data, pos + 1, options))\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeArray32 (data, pos, _minor, options) {\n  return toToken(data, pos, 5, uint.readUint32(data, pos + 1, options))\n}\n\n// TODO: maybe we shouldn't support this ..\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeArray64 (data, pos, _minor, options) {\n  const l = uint.readUint64(data, pos + 1, options)\n  if (typeof l === 'bigint') {\n    throw new Error(`${decodeErrPrefix} 64-bit integer array lengths not supported`)\n  }\n  return toToken(data, pos, 9, l)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeArrayIndefinite (data, pos, _minor, options) {\n  if (options.allowIndefinite === false) {\n    throw new Error(`${decodeErrPrefix} indefinite length items not allowed`)\n  }\n  return toToken(data, pos, 1, Infinity)\n}\n\n/**\n * @param {Bl} buf\n * @param {Token} token\n */\nexport function encodeArray (buf, token) {\n  uint.encodeUintValue(buf, Type.array.majorEncoded, token.value)\n}\n\n// using an array as a map key, are you sure about this? we can only sort\n// by map length here, it's up to the encoder to decide to look deeper\nencodeArray.compareTokens = uint.encodeUint.compareTokens\n\n/**\n * @param {Token} token\n * @returns {number}\n */\nencodeArray.encodedSize = function encodedSize (token) {\n  return uint.encodeUintValue.encodedSize(token.value)\n}\n", "import { Token, Type } from './token.js'\nimport * as uint from './0uint.js'\nimport { decodeErrPrefix } from './common.js'\n\n/**\n * @typedef {import('./bl.js').Bl} Bl\n * @typedef {import('../interface').DecodeOptions} DecodeOptions\n */\n\n/**\n * @param {Uint8Array} _data\n * @param {number} _pos\n * @param {number} prefix\n * @param {number} length\n * @returns {Token}\n */\nfunction toToken (_data, _pos, prefix, length) {\n  return new Token(Type.map, length, prefix)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} minor\n * @param {DecodeOptions} _options\n * @returns {Token}\n */\nexport function decodeMapCompact (data, pos, minor, _options) {\n  return toToken(data, pos, 1, minor)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeMap8 (data, pos, _minor, options) {\n  return toToken(data, pos, 2, uint.readUint8(data, pos + 1, options))\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeMap16 (data, pos, _minor, options) {\n  return toToken(data, pos, 3, uint.readUint16(data, pos + 1, options))\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeMap32 (data, pos, _minor, options) {\n  return toToken(data, pos, 5, uint.readUint32(data, pos + 1, options))\n}\n\n// TODO: maybe we shouldn't support this ..\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeMap64 (data, pos, _minor, options) {\n  const l = uint.readUint64(data, pos + 1, options)\n  if (typeof l === 'bigint') {\n    throw new Error(`${decodeErrPrefix} 64-bit integer map lengths not supported`)\n  }\n  return toToken(data, pos, 9, l)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeMapIndefinite (data, pos, _minor, options) {\n  if (options.allowIndefinite === false) {\n    throw new Error(`${decodeErrPrefix} indefinite length items not allowed`)\n  }\n  return toToken(data, pos, 1, Infinity)\n}\n\n/**\n * @param {Bl} buf\n * @param {Token} token\n */\nexport function encodeMap (buf, token) {\n  uint.encodeUintValue(buf, Type.map.majorEncoded, token.value)\n}\n\n// using a map as a map key, are you sure about this? we can only sort\n// by map length here, it's up to the encoder to decide to look deeper\nencodeMap.compareTokens = uint.encodeUint.compareTokens\n\n/**\n * @param {Token} token\n * @returns {number}\n */\nencodeMap.encodedSize = function encodedSize (token) {\n  return uint.encodeUintValue.encodedSize(token.value)\n}\n", "import { Token, Type } from './token.js'\nimport * as uint from './0uint.js'\n\n/**\n * @typedef {import('./bl.js').Bl} Bl\n * @typedef {import('../interface').DecodeOptions} DecodeOptions\n */\n\n/**\n * @param {Uint8Array} _data\n * @param {number} _pos\n * @param {number} minor\n * @param {DecodeOptions} _options\n * @returns {Token}\n */\nexport function decodeTagCompact (_data, _pos, minor, _options) {\n  return new Token(Type.tag, minor, 1)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeTag8 (data, pos, _minor, options) {\n  return new Token(Type.tag, uint.readUint8(data, pos + 1, options), 2)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeTag16 (data, pos, _minor, options) {\n  return new Token(Type.tag, uint.readUint16(data, pos + 1, options), 3)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeTag32 (data, pos, _minor, options) {\n  return new Token(Type.tag, uint.readUint32(data, pos + 1, options), 5)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeTag64 (data, pos, _minor, options) {\n  return new Token(Type.tag, uint.readUint64(data, pos + 1, options), 9)\n}\n\n/**\n * @param {Bl} buf\n * @param {Token} token\n */\nexport function encodeTag (buf, token) {\n  uint.encodeUintValue(buf, Type.tag.majorEncoded, token.value)\n}\n\nencodeTag.compareTokens = uint.encodeUint.compareTokens\n\n/**\n * @param {Token} token\n * @returns {number}\n */\nencodeTag.encodedSize = function encodedSize (token) {\n  return uint.encodeUintValue.encodedSize(token.value)\n}\n", "// TODO: shift some of the bytes logic to bytes-utils so we can use Buffer\n// where possible\n\nimport { Token, Type } from './token.js'\nimport { decodeErrPrefix } from './common.js'\nimport { encodeUint } from './0uint.js'\n\n/**\n * @typedef {import('./bl.js').Bl} Bl\n * @typedef {import('../interface').DecodeOptions} DecodeOptions\n * @typedef {import('../interface').EncodeOptions} EncodeOptions\n */\n\nconst MINOR_FALSE = 20\nconst MINOR_TRUE = 21\nconst MINOR_NULL = 22\nconst MINOR_UNDEFINED = 23\n\n/**\n * @param {Uint8Array} _data\n * @param {number} _pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeUndefined (_data, _pos, _minor, options) {\n  if (options.allowUndefined === false) {\n    throw new Error(`${decodeErrPrefix} undefined values are not supported`)\n  } else if (options.coerceUndefinedToNull === true) {\n    return new Token(Type.null, null, 1)\n  }\n  return new Token(Type.undefined, undefined, 1)\n}\n\n/**\n * @param {Uint8Array} _data\n * @param {number} _pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeBreak (_data, _pos, _minor, options) {\n  if (options.allowIndefinite === false) {\n    throw new Error(`${decodeErrPrefix} indefinite length items not allowed`)\n  }\n  return new Token(Type.break, undefined, 1)\n}\n\n/**\n * @param {number} value\n * @param {number} bytes\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nfunction createToken (value, bytes, options) {\n  if (options) {\n    if (options.allowNaN === false && Number.isNaN(value)) {\n      throw new Error(`${decodeErrPrefix} NaN values are not supported`)\n    }\n    if (options.allowInfinity === false && (value === Infinity || value === -Infinity)) {\n      throw new Error(`${decodeErrPrefix} Infinity values are not supported`)\n    }\n  }\n  return new Token(Type.float, value, bytes)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeFloat16 (data, pos, _minor, options) {\n  return createToken(readFloat16(data, pos + 1), 3, options)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeFloat32 (data, pos, _minor, options) {\n  return createToken(readFloat32(data, pos + 1), 5, options)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeFloat64 (data, pos, _minor, options) {\n  return createToken(readFloat64(data, pos + 1), 9, options)\n}\n\n/**\n * @param {Bl} buf\n * @param {Token} token\n * @param {EncodeOptions} options\n */\nexport function encodeFloat (buf, token, options) {\n  const float = token.value\n\n  if (float === false) {\n    buf.push([Type.float.majorEncoded | MINOR_FALSE])\n  } else if (float === true) {\n    buf.push([Type.float.majorEncoded | MINOR_TRUE])\n  } else if (float === null) {\n    buf.push([Type.float.majorEncoded | MINOR_NULL])\n  } else if (float === undefined) {\n    buf.push([Type.float.majorEncoded | MINOR_UNDEFINED])\n  } else {\n    let decoded\n    let success = false\n    if (!options || options.float64 !== true) {\n      encodeFloat16(float)\n      decoded = readFloat16(ui8a, 1)\n      if (float === decoded || Number.isNaN(float)) {\n        ui8a[0] = 0xf9\n        buf.push(ui8a.slice(0, 3))\n        success = true\n      } else {\n        encodeFloat32(float)\n        decoded = readFloat32(ui8a, 1)\n        if (float === decoded) {\n          ui8a[0] = 0xfa\n          buf.push(ui8a.slice(0, 5))\n          success = true\n        }\n      }\n    }\n    if (!success) {\n      encodeFloat64(float)\n      decoded = readFloat64(ui8a, 1)\n      ui8a[0] = 0xfb\n      buf.push(ui8a.slice(0, 9))\n    }\n  }\n}\n\n/**\n * @param {Token} token\n * @param {EncodeOptions} options\n * @returns {number}\n */\nencodeFloat.encodedSize = function encodedSize (token, options) {\n  const float = token.value\n\n  if (float === false || float === true || float === null || float === undefined) {\n    return 1\n  }\n\n  if (!options || options.float64 !== true) {\n    encodeFloat16(float)\n    let decoded = readFloat16(ui8a, 1)\n    if (float === decoded || Number.isNaN(float)) {\n      return 3\n    }\n    encodeFloat32(float)\n    decoded = readFloat32(ui8a, 1)\n    if (float === decoded) {\n      return 5\n    }\n  }\n  return 9\n}\n\nconst buffer = new ArrayBuffer(9)\nconst dataView = new DataView(buffer, 1)\nconst ui8a = new Uint8Array(buffer, 0)\n\n/**\n * @param {number} inp\n */\nfunction encodeFloat16 (inp) {\n  if (inp === Infinity) {\n    dataView.setUint16(0, 0x7c00, false)\n  } else if (inp === -Infinity) {\n    dataView.setUint16(0, 0xfc00, false)\n  } else if (Number.isNaN(inp)) {\n    dataView.setUint16(0, 0x7e00, false)\n  } else {\n    dataView.setFloat32(0, inp)\n    const valu32 = dataView.getUint32(0)\n    const exponent = (valu32 & 0x7f800000) >> 23\n    const mantissa = valu32 & 0x7fffff\n\n    /* c8 ignore next 6 */\n    if (exponent === 0xff) {\n      // too big, Infinity, but this should be hard (impossible?) to trigger\n      dataView.setUint16(0, 0x7c00, false)\n    } else if (exponent === 0x00) {\n      // 0.0, -0.0 and subnormals, shouldn't be possible to get here because 0.0 should be counted as an int\n      dataView.setUint16(0, ((inp & 0x80000000) >> 16) | (mantissa >> 13), false)\n    } else { // standard numbers\n      // chunks of logic here borrowed from https://github.com/PJK/libcbor/blob/c78f437182533e3efa8d963ff4b945bb635c2284/src/cbor/encoding.c#L127\n      const logicalExponent = exponent - 127\n      // Now we know that 2^exponent <= 0 logically\n      /* c8 ignore next 6 */\n      if (logicalExponent < -24) {\n        /* No unambiguous representation exists, this float is not a half float\n          and is too small to be represented using a half, round off to zero.\n          Consistent with the reference implementation. */\n        // should be difficult (impossible?) to get here in JS\n        dataView.setUint16(0, 0)\n      } else if (logicalExponent < -14) {\n        /* Offset the remaining decimal places by shifting the significand, the\n          value is lost. This is an implementation decision that works around the\n          absence of standard half-float in the language. */\n        dataView.setUint16(0, ((valu32 & 0x80000000) >> 16) | /* sign bit */ (1 << (24 + logicalExponent)), false)\n      } else {\n        dataView.setUint16(0, ((valu32 & 0x80000000) >> 16) | ((logicalExponent + 15) << 10) | (mantissa >> 13), false)\n      }\n    }\n  }\n}\n\n/**\n * @param {Uint8Array} ui8a\n * @param {number} pos\n * @returns {number}\n */\nfunction readFloat16 (ui8a, pos) {\n  if (ui8a.length - pos < 2) {\n    throw new Error(`${decodeErrPrefix} not enough data for float16`)\n  }\n\n  const half = (ui8a[pos] << 8) + ui8a[pos + 1]\n  if (half === 0x7c00) {\n    return Infinity\n  }\n  if (half === 0xfc00) {\n    return -Infinity\n  }\n  if (half === 0x7e00) {\n    return NaN\n  }\n  const exp = (half >> 10) & 0x1f\n  const mant = half & 0x3ff\n  let val\n  if (exp === 0) {\n    val = mant * (2 ** -24)\n  } else if (exp !== 31) {\n    val = (mant + 1024) * (2 ** (exp - 25))\n  /* c8 ignore next 4 */\n  } else {\n    // may not be possible to get here\n    val = mant === 0 ? Infinity : NaN\n  }\n  return (half & 0x8000) ? -val : val\n}\n\n/**\n * @param {number} inp\n */\nfunction encodeFloat32 (inp) {\n  dataView.setFloat32(0, inp, false)\n}\n\n/**\n * @param {Uint8Array} ui8a\n * @param {number} pos\n * @returns {number}\n */\nfunction readFloat32 (ui8a, pos) {\n  if (ui8a.length - pos < 4) {\n    throw new Error(`${decodeErrPrefix} not enough data for float32`)\n  }\n  const offset = (ui8a.byteOffset || 0) + pos\n  return new DataView(ui8a.buffer, offset, 4).getFloat32(0, false)\n}\n\n/**\n * @param {number} inp\n */\nfunction encodeFloat64 (inp) {\n  dataView.setFloat64(0, inp, false)\n}\n\n/**\n * @param {Uint8Array} ui8a\n * @param {number} pos\n * @returns {number}\n */\nfunction readFloat64 (ui8a, pos) {\n  if (ui8a.length - pos < 8) {\n    throw new Error(`${decodeErrPrefix} not enough data for float64`)\n  }\n  const offset = (ui8a.byteOffset || 0) + pos\n  return new DataView(ui8a.buffer, offset, 8).getFloat64(0, false)\n}\n\n/**\n * @param {Token} _tok1\n * @param {Token} _tok2\n * @returns {number}\n */\nencodeFloat.compareTokens = encodeUint.compareTokens\n/*\nencodeFloat.compareTokens = function compareTokens (_tok1, _tok2) {\n  return _tok1\n  throw new Error(`${encodeErrPrefix} cannot use floats as map keys`)\n}\n*/\n", "import { Token, Type } from './token.js'\nimport * as uint from './0uint.js'\nimport * as negint from './1negint.js'\nimport * as bytes from './2bytes.js'\nimport * as string from './3string.js'\nimport * as array from './4array.js'\nimport * as map from './5map.js'\nimport * as tag from './6tag.js'\nimport * as float from './7float.js'\nimport { decodeErrPrefix } from './common.js'\nimport { fromArray } from './byte-utils.js'\n\n/**\n * @typedef {import('../interface').DecodeOptions} DecodeOptions\n */\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} minor\n */\nfunction invalidMinor (data, pos, minor) {\n  throw new Error(`${decodeErrPrefix} encountered invalid minor (${minor}) for major ${data[pos] >>> 5}`)\n}\n\n/**\n * @param {string} msg\n * @returns {()=>any}\n */\nfunction errorer (msg) {\n  return () => { throw new Error(`${decodeErrPrefix} ${msg}`) }\n}\n\n/** @type {((data:Uint8Array, pos:number, minor:number, options?:DecodeOptions) => any)[]} */\nexport const jump = []\n\n// unsigned integer, 0x00..0x17 (0..23)\nfor (let i = 0; i <= 0x17; i++) {\n  jump[i] = invalidMinor // uint.decodeUintCompact, handled by quick[]\n}\njump[0x18] = uint.decodeUint8 // unsigned integer, one-byte uint8_t follows\njump[0x19] = uint.decodeUint16 // unsigned integer, two-byte uint16_t follows\njump[0x1a] = uint.decodeUint32 // unsigned integer, four-byte uint32_t follows\njump[0x1b] = uint.decodeUint64 // unsigned integer, eight-byte uint64_t follows\njump[0x1c] = invalidMinor\njump[0x1d] = invalidMinor\njump[0x1e] = invalidMinor\njump[0x1f] = invalidMinor\n// negative integer, -1-0x00..-1-0x17 (-1..-24)\nfor (let i = 0x20; i <= 0x37; i++) {\n  jump[i] = invalidMinor // negintDecode, handled by quick[]\n}\njump[0x38] = negint.decodeNegint8 // negative integer, -1-n one-byte uint8_t for n follows\njump[0x39] = negint.decodeNegint16 // negative integer, -1-n two-byte uint16_t for n follows\njump[0x3a] = negint.decodeNegint32 // negative integer, -1-n four-byte uint32_t for follows\njump[0x3b] = negint.decodeNegint64 // negative integer, -1-n eight-byte uint64_t for follows\njump[0x3c] = invalidMinor\njump[0x3d] = invalidMinor\njump[0x3e] = invalidMinor\njump[0x3f] = invalidMinor\n// byte string, 0x00..0x17 bytes follow\nfor (let i = 0x40; i <= 0x57; i++) {\n  jump[i] = bytes.decodeBytesCompact\n}\njump[0x58] = bytes.decodeBytes8 // byte string, one-byte uint8_t for n, and then n bytes follow\njump[0x59] = bytes.decodeBytes16 // byte string, two-byte uint16_t for n, and then n bytes follow\njump[0x5a] = bytes.decodeBytes32 // byte string, four-byte uint32_t for n, and then n bytes follow\njump[0x5b] = bytes.decodeBytes64 // byte string, eight-byte uint64_t for n, and then n bytes follow\njump[0x5c] = invalidMinor\njump[0x5d] = invalidMinor\njump[0x5e] = invalidMinor\njump[0x5f] = errorer('indefinite length bytes/strings are not supported') // byte string, byte strings follow, terminated by \"break\"\n// UTF-8 string 0x00..0x17 bytes follow\nfor (let i = 0x60; i <= 0x77; i++) {\n  jump[i] = string.decodeStringCompact\n}\njump[0x78] = string.decodeString8 // UTF-8 string, one-byte uint8_t for n, and then n bytes follow\njump[0x79] = string.decodeString16 // UTF-8 string, two-byte uint16_t for n, and then n bytes follow\njump[0x7a] = string.decodeString32 // UTF-8 string, four-byte uint32_t for n, and then n bytes follow\njump[0x7b] = string.decodeString64 // UTF-8 string, eight-byte uint64_t for n, and then n bytes follow\njump[0x7c] = invalidMinor\njump[0x7d] = invalidMinor\njump[0x7e] = invalidMinor\njump[0x7f] = errorer('indefinite length bytes/strings are not supported') // UTF-8 strings follow, terminated by \"break\"\n// array, 0x00..0x17 data items follow\nfor (let i = 0x80; i <= 0x97; i++) {\n  jump[i] = array.decodeArrayCompact\n}\njump[0x98] = array.decodeArray8 // array, one-byte uint8_t for n, and then n data items follow\njump[0x99] = array.decodeArray16 // array, two-byte uint16_t for n, and then n data items follow\njump[0x9a] = array.decodeArray32 // array, four-byte uint32_t for n, and then n data items follow\njump[0x9b] = array.decodeArray64 // array, eight-byte uint64_t for n, and then n data items follow\njump[0x9c] = invalidMinor\njump[0x9d] = invalidMinor\njump[0x9e] = invalidMinor\njump[0x9f] = array.decodeArrayIndefinite // array, data items follow, terminated by \"break\"\n// map, 0x00..0x17 pairs of data items follow\nfor (let i = 0xa0; i <= 0xb7; i++) {\n  jump[i] = map.decodeMapCompact\n}\njump[0xb8] = map.decodeMap8 // map, one-byte uint8_t for n, and then n pairs of data items follow\njump[0xb9] = map.decodeMap16 // map, two-byte uint16_t for n, and then n pairs of data items follow\njump[0xba] = map.decodeMap32 // map, four-byte uint32_t for n, and then n pairs of data items follow\njump[0xbb] = map.decodeMap64 // map, eight-byte uint64_t for n, and then n pairs of data items follow\njump[0xbc] = invalidMinor\njump[0xbd] = invalidMinor\njump[0xbe] = invalidMinor\njump[0xbf] = map.decodeMapIndefinite // map, pairs of data items follow, terminated by \"break\"\n// tags\nfor (let i = 0xc0; i <= 0xd7; i++) {\n  jump[i] = tag.decodeTagCompact\n}\njump[0xd8] = tag.decodeTag8\njump[0xd9] = tag.decodeTag16\njump[0xda] = tag.decodeTag32\njump[0xdb] = tag.decodeTag64\njump[0xdc] = invalidMinor\njump[0xdd] = invalidMinor\njump[0xde] = invalidMinor\njump[0xdf] = invalidMinor\n// 0xe0..0xf3 simple values, unsupported\nfor (let i = 0xe0; i <= 0xf3; i++) {\n  jump[i] = errorer('simple values are not supported')\n}\njump[0xf4] = invalidMinor // false, handled by quick[]\njump[0xf5] = invalidMinor // true, handled by quick[]\njump[0xf6] = invalidMinor // null, handled by quick[]\njump[0xf7] = float.decodeUndefined // undefined\njump[0xf8] = errorer('simple values are not supported') // simple value, one byte follows, unsupported\njump[0xf9] = float.decodeFloat16 // half-precision float (two-byte IEEE 754)\njump[0xfa] = float.decodeFloat32 // single-precision float (four-byte IEEE 754)\njump[0xfb] = float.decodeFloat64 // double-precision float (eight-byte IEEE 754)\njump[0xfc] = invalidMinor\njump[0xfd] = invalidMinor\njump[0xfe] = invalidMinor\njump[0xff] = float.decodeBreak // \"break\" stop code\n\n/** @type {Token[]} */\nexport const quick = []\n// ints <24\nfor (let i = 0; i < 24; i++) {\n  quick[i] = new Token(Type.uint, i, 1)\n}\n// negints >= -24\nfor (let i = -1; i >= -24; i--) {\n  quick[31 - i] = new Token(Type.negint, i, 1)\n}\n// empty bytes\nquick[0x40] = new Token(Type.bytes, new Uint8Array(0), 1)\n// empty string\nquick[0x60] = new Token(Type.string, '', 1)\n// empty list\nquick[0x80] = new Token(Type.array, 0, 1)\n// empty map\nquick[0xa0] = new Token(Type.map, 0, 1)\n// false\nquick[0xf4] = new Token(Type.false, false, 1)\n// true\nquick[0xf5] = new Token(Type.true, true, 1)\n// null\nquick[0xf6] = new Token(Type.null, null, 1)\n\n/**\n * @param {Token} token\n * @returns {Uint8Array|undefined}\n */\nexport function quickEncodeToken (token) {\n  switch (token.type) {\n    case Type.false:\n      return fromArray([0xf4])\n    case Type.true:\n      return fromArray([0xf5])\n    case Type.null:\n      return fromArray([0xf6])\n    case Type.bytes:\n      if (!token.value.length) {\n        return fromArray([0x40])\n      }\n      return\n    case Type.string:\n      if (token.value === '') {\n        return fromArray([0x60])\n      }\n      return\n    case Type.array:\n      if (token.value === 0) {\n        return fromArray([0x80])\n      }\n      /* c8 ignore next 2 */\n      // shouldn't be possible if this were called when there was only one token\n      return\n    case Type.map:\n      if (token.value === 0) {\n        return fromArray([0xa0])\n      }\n      /* c8 ignore next 2 */\n      // shouldn't be possible if this were called when there was only one token\n      return\n    case Type.uint:\n      if (token.value < 24) {\n        return fromArray([Number(token.value)])\n      }\n      return\n    case Type.negint:\n      if (token.value >= -24) {\n        return fromArray([31 - Number(token.value)])\n      }\n  }\n}\n", "import { is } from './is.js'\nimport { Token, Type } from './token.js'\nimport { Bl } from './bl.js'\nimport { encodeErrPrefix } from './common.js'\nimport { quickEncodeToken } from './jump.js'\nimport { asU8A } from './byte-utils.js'\n\nimport { encodeUint } from './0uint.js'\nimport { encodeNegint } from './1negint.js'\nimport { encodeBytes } from './2bytes.js'\nimport { encodeString } from './3string.js'\nimport { encodeArray } from './4array.js'\nimport { encodeMap } from './5map.js'\nimport { encodeTag } from './6tag.js'\nimport { encodeFloat } from './7float.js'\n\n/**\n * @typedef {import('../interface').EncodeOptions} EncodeOptions\n * @typedef {import('../interface').OptionalTypeEncoder} OptionalTypeEncoder\n * @typedef {import('../interface').Reference} Reference\n * @typedef {import('../interface').StrictTypeEncoder} StrictTypeEncoder\n * @typedef {import('../interface').TokenTypeEncoder} TokenTypeEncoder\n * @typedef {import('../interface').TokenOrNestedTokens} TokenOrNestedTokens\n */\n\n/** @type {EncodeOptions} */\nconst defaultEncodeOptions = {\n  float64: false,\n  mapSorter,\n  quickEncodeToken\n}\n\n/** @returns {TokenTypeEncoder[]} */\nexport function makeCborEncoders () {\n  const encoders = []\n  encoders[Type.uint.major] = encodeUint\n  encoders[Type.negint.major] = encodeNegint\n  encoders[Type.bytes.major] = encodeBytes\n  encoders[Type.string.major] = encodeString\n  encoders[Type.array.major] = encodeArray\n  encoders[Type.map.major] = encodeMap\n  encoders[Type.tag.major] = encodeTag\n  encoders[Type.float.major] = encodeFloat\n  return encoders\n}\n\nconst cborEncoders = makeCborEncoders()\n\nconst buf = new Bl()\n\n/** @implements {Reference} */\nclass Ref {\n  /**\n   * @param {object|any[]} obj\n   * @param {Reference|undefined} parent\n   */\n  constructor (obj, parent) {\n    this.obj = obj\n    this.parent = parent\n  }\n\n  /**\n   * @param {object|any[]} obj\n   * @returns {boolean}\n   */\n  includes (obj) {\n    /** @type {Reference|undefined} */\n    let p = this\n    do {\n      if (p.obj === obj) {\n        return true\n      }\n    } while (p = p.parent) // eslint-disable-line\n    return false\n  }\n\n  /**\n   * @param {Reference|undefined} stack\n   * @param {object|any[]} obj\n   * @returns {Reference}\n   */\n  static createCheck (stack, obj) {\n    if (stack && stack.includes(obj)) {\n      throw new Error(`${encodeErrPrefix} object contains circular references`)\n    }\n    return new Ref(obj, stack)\n  }\n}\n\nconst simpleTokens = {\n  null: new Token(Type.null, null),\n  undefined: new Token(Type.undefined, undefined),\n  true: new Token(Type.true, true),\n  false: new Token(Type.false, false),\n  emptyArray: new Token(Type.array, 0),\n  emptyMap: new Token(Type.map, 0)\n}\n\n/** @type {{[typeName: string]: StrictTypeEncoder}} */\nconst typeEncoders = {\n  /**\n   * @param {any} obj\n   * @param {string} _typ\n   * @param {EncodeOptions} _options\n   * @param {Reference} [_refStack]\n   * @returns {TokenOrNestedTokens}\n   */\n  number (obj, _typ, _options, _refStack) {\n    if (!Number.isInteger(obj) || !Number.isSafeInteger(obj)) {\n      return new Token(Type.float, obj)\n    } else if (obj >= 0) {\n      return new Token(Type.uint, obj)\n    } else {\n      return new Token(Type.negint, obj)\n    }\n  },\n\n  /**\n   * @param {any} obj\n   * @param {string} _typ\n   * @param {EncodeOptions} _options\n   * @param {Reference} [_refStack]\n   * @returns {TokenOrNestedTokens}\n   */\n  bigint (obj, _typ, _options, _refStack) {\n    if (obj >= BigInt(0)) {\n      return new Token(Type.uint, obj)\n    } else {\n      return new Token(Type.negint, obj)\n    }\n  },\n\n  /**\n   * @param {any} obj\n   * @param {string} _typ\n   * @param {EncodeOptions} _options\n   * @param {Reference} [_refStack]\n   * @returns {TokenOrNestedTokens}\n   */\n  Uint8Array (obj, _typ, _options, _refStack) {\n    return new Token(Type.bytes, obj)\n  },\n\n  /**\n   * @param {any} obj\n   * @param {string} _typ\n   * @param {EncodeOptions} _options\n   * @param {Reference} [_refStack]\n   * @returns {TokenOrNestedTokens}\n   */\n  string (obj, _typ, _options, _refStack) {\n    return new Token(Type.string, obj)\n  },\n\n  /**\n   * @param {any} obj\n   * @param {string} _typ\n   * @param {EncodeOptions} _options\n   * @param {Reference} [_refStack]\n   * @returns {TokenOrNestedTokens}\n   */\n  boolean (obj, _typ, _options, _refStack) {\n    return obj ? simpleTokens.true : simpleTokens.false\n  },\n\n  /**\n   * @param {any} _obj\n   * @param {string} _typ\n   * @param {EncodeOptions} _options\n   * @param {Reference} [_refStack]\n   * @returns {TokenOrNestedTokens}\n   */\n  null (_obj, _typ, _options, _refStack) {\n    return simpleTokens.null\n  },\n\n  /**\n   * @param {any} _obj\n   * @param {string} _typ\n   * @param {EncodeOptions} _options\n   * @param {Reference} [_refStack]\n   * @returns {TokenOrNestedTokens}\n   */\n  undefined (_obj, _typ, _options, _refStack) {\n    return simpleTokens.undefined\n  },\n\n  /**\n   * @param {any} obj\n   * @param {string} _typ\n   * @param {EncodeOptions} _options\n   * @param {Reference} [_refStack]\n   * @returns {TokenOrNestedTokens}\n   */\n  ArrayBuffer (obj, _typ, _options, _refStack) {\n    return new Token(Type.bytes, new Uint8Array(obj))\n  },\n\n  /**\n   * @param {any} obj\n   * @param {string} _typ\n   * @param {EncodeOptions} _options\n   * @param {Reference} [_refStack]\n   * @returns {TokenOrNestedTokens}\n   */\n  DataView (obj, _typ, _options, _refStack) {\n    return new Token(Type.bytes, new Uint8Array(obj.buffer, obj.byteOffset, obj.byteLength))\n  },\n\n  /**\n   * @param {any} obj\n   * @param {string} _typ\n   * @param {EncodeOptions} options\n   * @param {Reference} [refStack]\n   * @returns {TokenOrNestedTokens}\n   */\n  Array (obj, _typ, options, refStack) {\n    if (!obj.length) {\n      if (options.addBreakTokens === true) {\n        return [simpleTokens.emptyArray, new Token(Type.break)]\n      }\n      return simpleTokens.emptyArray\n    }\n    refStack = Ref.createCheck(refStack, obj)\n    const entries = []\n    let i = 0\n    for (const e of obj) {\n      entries[i++] = objectToTokens(e, options, refStack)\n    }\n    if (options.addBreakTokens) {\n      return [new Token(Type.array, obj.length), entries, new Token(Type.break)]\n    }\n    return [new Token(Type.array, obj.length), entries]\n  },\n\n  /**\n   * @param {any} obj\n   * @param {string} typ\n   * @param {EncodeOptions} options\n   * @param {Reference} [refStack]\n   * @returns {TokenOrNestedTokens}\n   */\n  Object (obj, typ, options, refStack) {\n    // could be an Object or a Map\n    const isMap = typ !== 'Object'\n    // it's slightly quicker to use Object.keys() than Object.entries()\n    const keys = isMap ? obj.keys() : Object.keys(obj)\n    const length = isMap ? obj.size : keys.length\n    if (!length) {\n      if (options.addBreakTokens === true) {\n        return [simpleTokens.emptyMap, new Token(Type.break)]\n      }\n      return simpleTokens.emptyMap\n    }\n    refStack = Ref.createCheck(refStack, obj)\n    /** @type {TokenOrNestedTokens[]} */\n    const entries = []\n    let i = 0\n    for (const key of keys) {\n      entries[i++] = [\n        objectToTokens(key, options, refStack),\n        objectToTokens(isMap ? obj.get(key) : obj[key], options, refStack)\n      ]\n    }\n    sortMapEntries(entries, options)\n    if (options.addBreakTokens) {\n      return [new Token(Type.map, length), entries, new Token(Type.break)]\n    }\n    return [new Token(Type.map, length), entries]\n  }\n}\n\ntypeEncoders.Map = typeEncoders.Object\ntypeEncoders.Buffer = typeEncoders.Uint8Array\nfor (const typ of 'Uint8Clamped Uint16 Uint32 Int8 Int16 Int32 BigUint64 BigInt64 Float32 Float64'.split(' ')) {\n  typeEncoders[`${typ}Array`] = typeEncoders.DataView\n}\n\n/**\n * @param {any} obj\n * @param {EncodeOptions} [options]\n * @param {Reference} [refStack]\n * @returns {TokenOrNestedTokens}\n */\nfunction objectToTokens (obj, options = {}, refStack) {\n  const typ = is(obj)\n  const customTypeEncoder = (options && options.typeEncoders && /** @type {OptionalTypeEncoder} */ options.typeEncoders[typ]) || typeEncoders[typ]\n  if (typeof customTypeEncoder === 'function') {\n    const tokens = customTypeEncoder(obj, typ, options, refStack)\n    if (tokens != null) {\n      return tokens\n    }\n  }\n  const typeEncoder = typeEncoders[typ]\n  if (!typeEncoder) {\n    throw new Error(`${encodeErrPrefix} unsupported type: ${typ}`)\n  }\n  return typeEncoder(obj, typ, options, refStack)\n}\n\n/*\nCBOR key sorting is a mess.\n\nThe canonicalisation recommendation from https://tools.ietf.org/html/rfc7049#section-3.9\nincludes the wording:\n\n> The keys in every map must be sorted lowest value to highest.\n> Sorting is performed on the bytes of the representation of the key\n> data items without paying attention to the 3/5 bit splitting for\n> major types.\n> ...\n>  *  If two keys have different lengths, the shorter one sorts\n      earlier;\n>  *  If two keys have the same length, the one with the lower value\n      in (byte-wise) lexical order sorts earlier.\n\n1. It is not clear what \"bytes of the representation of the key\" means: is it\n   the CBOR representation, or the binary representation of the object itself?\n   Consider the int and uint difference here.\n2. It is not clear what \"without paying attention to\" means: do we include it\n   and compare on that? Or do we omit the special prefix byte, (mostly) treating\n   the key in its plain binary representation form.\n\nThe FIDO 2.0: Client To Authenticator Protocol spec takes the original CBOR\nwording and clarifies it according to their understanding.\nhttps://fidoalliance.org/specs/fido-v2.0-rd-20170927/fido-client-to-authenticator-protocol-v2.0-rd-20170927.html#message-encoding\n\n> The keys in every map must be sorted lowest value to highest. Sorting is\n> performed on the bytes of the representation of the key data items without\n> paying attention to the 3/5 bit splitting for major types. The sorting rules\n> are:\n>  * If the major types are different, the one with the lower value in numerical\n>    order sorts earlier.\n>  * If two keys have different lengths, the shorter one sorts earlier;\n>  * If two keys have the same length, the one with the lower value in\n>    (byte-wise) lexical order sorts earlier.\n\nSome other implementations, such as borc, do a full encode then do a\nlength-first, byte-wise-second comparison:\nhttps://github.com/dignifiedquire/borc/blob/b6bae8b0bcde7c3976b0f0f0957208095c392a36/src/encoder.js#L358\nhttps://github.com/dignifiedquire/borc/blob/b6bae8b0bcde7c3976b0f0f0957208095c392a36/src/utils.js#L143-L151\n\nThis has the benefit of being able to easily handle arbitrary keys, including\ncomplex types (maps and arrays).\n\nWe'll opt for the FIDO approach, since it affords some efficies since we don't\nneed a full encode of each key to determine order and can defer to the types\nto determine how to most efficiently order their values (i.e. int and uint\nordering can be done on the numbers, no need for byte-wise, for example).\n\nRecommendation: stick to single key types or you'll get into trouble, and prefer\nstring keys because it's much simpler that way.\n*/\n\n/*\n(UPDATE, Dec 2020)\nhttps://tools.ietf.org/html/rfc8949 is the updated CBOR spec and clarifies some\nof the questions above with a new recommendation for sorting order being much\ncloser to what would be expected in other environments (i.e. no length-first\nweirdness).\nThis new sorting order is not yet implemented here but could be added as an\noption. \"Determinism\" (canonicity) is system dependent and it's difficult to\nchange existing systems that are built with existing expectations. So if a new\nordering is introduced here, the old needs to be kept as well with the user\nhaving the option.\n*/\n\n/**\n * @param {TokenOrNestedTokens[]} entries\n * @param {EncodeOptions} options\n */\nfunction sortMapEntries (entries, options) {\n  if (options.mapSorter) {\n    entries.sort(options.mapSorter)\n  }\n}\n\n/**\n * @param {(Token|Token[])[]} e1\n * @param {(Token|Token[])[]} e2\n * @returns {number}\n */\nfunction mapSorter (e1, e2) {\n  // the key position ([0]) could have a single token or an array\n  // almost always it'll be a single token but complex key might get involved\n  /* c8 ignore next 2 */\n  const keyToken1 = Array.isArray(e1[0]) ? e1[0][0] : e1[0]\n  const keyToken2 = Array.isArray(e2[0]) ? e2[0][0] : e2[0]\n\n  // different key types\n  if (keyToken1.type !== keyToken2.type) {\n    return keyToken1.type.compare(keyToken2.type)\n  }\n\n  const major = keyToken1.type.major\n  // TODO: handle case where cmp === 0 but there are more keyToken e. complex type)\n  const tcmp = cborEncoders[major].compareTokens(keyToken1, keyToken2)\n  /* c8 ignore next 5 */\n  if (tcmp === 0) {\n    // duplicate key or complex type where the first token matched,\n    // i.e. a map or array and we're only comparing the opening token\n    console.warn('WARNING: complex key types used, CBOR key sorting guarantees are gone')\n  }\n  return tcmp\n}\n\n/**\n * @param {Bl} buf\n * @param {TokenOrNestedTokens} tokens\n * @param {TokenTypeEncoder[]} encoders\n * @param {EncodeOptions} options\n */\nfunction tokensToEncoded (buf, tokens, encoders, options) {\n  if (Array.isArray(tokens)) {\n    for (const token of tokens) {\n      tokensToEncoded(buf, token, encoders, options)\n    }\n  } else {\n    encoders[tokens.type.major](buf, tokens, options)\n  }\n}\n\n/**\n * @param {any} data\n * @param {TokenTypeEncoder[]} encoders\n * @param {EncodeOptions} options\n * @returns {Uint8Array}\n */\nfunction encodeCustom (data, encoders, options) {\n  const tokens = objectToTokens(data, options)\n  if (!Array.isArray(tokens) && options.quickEncodeToken) {\n    const quickBytes = options.quickEncodeToken(tokens)\n    if (quickBytes) {\n      return quickBytes\n    }\n    const encoder = encoders[tokens.type.major]\n    if (encoder.encodedSize) {\n      const size = encoder.encodedSize(tokens, options)\n      const buf = new Bl(size)\n      encoder(buf, tokens, options)\n      /* c8 ignore next 4 */\n      // this would be a problem with encodedSize() functions\n      if (buf.chunks.length !== 1) {\n        throw new Error(`Unexpected error: pre-calculated length for ${tokens} was wrong`)\n      }\n      return asU8A(buf.chunks[0])\n    }\n  }\n  buf.reset()\n  tokensToEncoded(buf, tokens, encoders, options)\n  return buf.toBytes(true)\n}\n\n/**\n * @param {any} data\n * @param {EncodeOptions} [options]\n * @returns {Uint8Array}\n */\nfunction encode (data, options) {\n  options = Object.assign({}, defaultEncodeOptions, options)\n  return encodeCustom(data, cborEncoders, options)\n}\n\nexport { objectToTokens, encode, encodeCustom, Ref }\n", "import { decodeErrPrefix } from './common.js'\nimport { Type } from './token.js'\nimport { jump, quick } from './jump.js'\n\n/**\n * @typedef {import('./token.js').Token} Token\n * @typedef {import('../interface').DecodeOptions} DecodeOptions\n * @typedef {import('../interface').DecodeTokenizer} DecodeTokenizer\n */\n\nconst defaultDecodeOptions = {\n  strict: false,\n  allowIndefinite: true,\n  allowUndefined: true,\n  allowBigInt: true\n}\n\n/**\n * @implements {DecodeTokenizer}\n */\nclass Tokeniser {\n  /**\n   * @param {Uint8Array} data\n   * @param {DecodeOptions} options\n   */\n  constructor (data, options = {}) {\n    this._pos = 0\n    this.data = data\n    this.options = options\n  }\n\n  pos () {\n    return this._pos\n  }\n\n  done () {\n    return this._pos >= this.data.length\n  }\n\n  next () {\n    const byt = this.data[this._pos]\n    let token = quick[byt]\n    if (token === undefined) {\n      const decoder = jump[byt]\n      /* c8 ignore next 4 */\n      // if we're here then there's something wrong with our jump or quick lists!\n      if (!decoder) {\n        throw new Error(`${decodeErrPrefix} no decoder for major type ${byt >>> 5} (byte 0x${byt.toString(16).padStart(2, '0')})`)\n      }\n      const minor = byt & 31\n      token = decoder(this.data, this._pos, minor, this.options)\n    }\n    // @ts-ignore we get to assume encodedLength is set (crossing fingers slightly)\n    this._pos += token.encodedLength\n    return token\n  }\n}\n\nconst DONE = Symbol.for('DONE')\nconst BREAK = Symbol.for('BREAK')\n\n/**\n * @param {Token} token\n * @param {DecodeTokenizer} tokeniser\n * @param {DecodeOptions} options\n * @returns {any|BREAK|DONE}\n */\nfunction tokenToArray (token, tokeniser, options) {\n  const arr = []\n  for (let i = 0; i < token.value; i++) {\n    const value = tokensToObject(tokeniser, options)\n    if (value === BREAK) {\n      if (token.value === Infinity) {\n        // normal end to indefinite length array\n        break\n      }\n      throw new Error(`${decodeErrPrefix} got unexpected break to lengthed array`)\n    }\n    if (value === DONE) {\n      throw new Error(`${decodeErrPrefix} found array but not enough entries (got ${i}, expected ${token.value})`)\n    }\n    arr[i] = value\n  }\n  return arr\n}\n\n/**\n * @param {Token} token\n * @param {DecodeTokenizer} tokeniser\n * @param {DecodeOptions} options\n * @returns {any|BREAK|DONE}\n */\nfunction tokenToMap (token, tokeniser, options) {\n  const useMaps = options.useMaps === true\n  const obj = useMaps ? undefined : {}\n  const m = useMaps ? new Map() : undefined\n  for (let i = 0; i < token.value; i++) {\n    const key = tokensToObject(tokeniser, options)\n    if (key === BREAK) {\n      if (token.value === Infinity) {\n        // normal end to indefinite length map\n        break\n      }\n      throw new Error(`${decodeErrPrefix} got unexpected break to lengthed map`)\n    }\n    if (key === DONE) {\n      throw new Error(`${decodeErrPrefix} found map but not enough entries (got ${i} [no key], expected ${token.value})`)\n    }\n    if (useMaps !== true && typeof key !== 'string') {\n      throw new Error(`${decodeErrPrefix} non-string keys not supported (got ${typeof key})`)\n    }\n    if (options.rejectDuplicateMapKeys === true) {\n      // @ts-ignore\n      if ((useMaps && m.has(key)) || (!useMaps && (key in obj))) {\n        throw new Error(`${decodeErrPrefix} found repeat map key \"${key}\"`)\n      }\n    }\n    const value = tokensToObject(tokeniser, options)\n    if (value === DONE) {\n      throw new Error(`${decodeErrPrefix} found map but not enough entries (got ${i} [no value], expected ${token.value})`)\n    }\n    if (useMaps) {\n      // @ts-ignore TODO reconsider this .. maybe needs to be strict about key types\n      m.set(key, value)\n    } else {\n      // @ts-ignore TODO reconsider this .. maybe needs to be strict about key types\n      obj[key] = value\n    }\n  }\n  // @ts-ignore c'mon man\n  return useMaps ? m : obj\n}\n\n/**\n * @param {DecodeTokenizer} tokeniser\n * @param {DecodeOptions} options\n * @returns {any|BREAK|DONE}\n */\nfunction tokensToObject (tokeniser, options) {\n  // should we support array as an argument?\n  // check for tokenIter[Symbol.iterator] and replace tokenIter with what that returns?\n  if (tokeniser.done()) {\n    return DONE\n  }\n\n  const token = tokeniser.next()\n\n  if (token.type === Type.break) {\n    return BREAK\n  }\n\n  if (token.type.terminal) {\n    return token.value\n  }\n\n  if (token.type === Type.array) {\n    return tokenToArray(token, tokeniser, options)\n  }\n\n  if (token.type === Type.map) {\n    return tokenToMap(token, tokeniser, options)\n  }\n\n  if (token.type === Type.tag) {\n    if (options.tags && typeof options.tags[token.value] === 'function') {\n      const tagged = tokensToObject(tokeniser, options)\n      return options.tags[token.value](tagged)\n    }\n    throw new Error(`${decodeErrPrefix} tag not supported (${token.value})`)\n  }\n  /* c8 ignore next */\n  throw new Error('unsupported')\n}\n\n/**\n * @param {Uint8Array} data\n * @param {DecodeOptions} [options]\n * @returns {[any, Uint8Array]}\n */\nfunction decodeFirst (data, options) {\n  if (!(data instanceof Uint8Array)) {\n    throw new Error(`${decodeErrPrefix} data to decode must be a Uint8Array`)\n  }\n  options = Object.assign({}, defaultDecodeOptions, options)\n  const tokeniser = options.tokenizer || new Tokeniser(data, options)\n  const decoded = tokensToObject(tokeniser, options)\n  if (decoded === DONE) {\n    throw new Error(`${decodeErrPrefix} did not find any content to decode`)\n  }\n  if (decoded === BREAK) {\n    throw new Error(`${decodeErrPrefix} got unexpected break`)\n  }\n  return [decoded, data.subarray(tokeniser.pos())]\n}\n\n/**\n * @param {Uint8Array} data\n * @param {DecodeOptions} [options]\n * @returns {any}\n */\nfunction decode (data, options) {\n  const [decoded, remainder] = decodeFirst(data, options)\n  if (remainder.length > 0) {\n    throw new Error(`${decodeErrPrefix} too many terminals, data makes no sense`)\n  }\n  return decoded\n}\n\nexport { Tokeniser, tokensToObject, decode, decodeFirst }\n", "import * as cborg from 'cborg'\nimport { CID } from 'multiformats/cid'\n\n// https://github.com/ipfs/go-ipfs/issues/3570#issuecomment-273931692\nconst CID_CBOR_TAG = 42\n\n/**\n * @template T\n * @typedef {import('multiformats/codecs/interface').ByteView<T>} ByteView\n */\n\n/**\n * @template T\n * @typedef {import('multiformats/codecs/interface').ArrayBufferView<T>} ArrayBufferView\n */\n\n/**\n * @template T\n * @param {ByteView<T> | ArrayBufferView<T>} buf\n * @returns {ByteView<T>}\n */\nexport function toByteView (buf) {\n  if (buf instanceof ArrayBuffer) {\n    return new Uint8Array(buf, 0, buf.byteLength)\n  }\n\n  return buf\n}\n\n/**\n * cidEncoder will receive all Objects during encode, it needs to filter out\n * anything that's not a CID and return `null` for that so it's encoded as\n * normal.\n *\n * @param {any} obj\n * @returns {cborg.Token[]|null}\n */\nfunction cidEncoder (obj) {\n  if (obj.asCID !== obj && obj['/'] !== obj.bytes) {\n    return null // any other kind of object\n  }\n  const cid = CID.asCID(obj)\n  /* c8 ignore next 4 */\n  // very unlikely case, and it'll probably throw a recursion error in cborg\n  if (!cid) {\n    return null\n  }\n  const bytes = new Uint8Array(cid.bytes.byteLength + 1)\n  bytes.set(cid.bytes, 1) // prefix is 0x00, for historical reasons\n  return [\n    new cborg.Token(cborg.Type.tag, CID_CBOR_TAG),\n    new cborg.Token(cborg.Type.bytes, bytes)\n  ]\n}\n\n// eslint-disable-next-line jsdoc/require-returns-check\n/**\n * Intercept all `undefined` values from an object walk and reject the entire\n * object if we find one.\n *\n * @returns {null}\n */\nfunction undefinedEncoder () {\n  throw new Error('`undefined` is not supported by the IPLD Data Model and cannot be encoded')\n}\n\n/**\n * Intercept all `number` values from an object walk and reject the entire\n * object if we find something that doesn't fit the IPLD data model (NaN &\n * Infinity).\n *\n * @param {number} num\n * @returns {null}\n */\nfunction numberEncoder (num) {\n  if (Number.isNaN(num)) {\n    throw new Error('`NaN` is not supported by the IPLD Data Model and cannot be encoded')\n  }\n  if (num === Infinity || num === -Infinity) {\n    throw new Error('`Infinity` and `-Infinity` is not supported by the IPLD Data Model and cannot be encoded')\n  }\n  return null\n}\n\nconst _encodeOptions = {\n  float64: true,\n  typeEncoders: {\n    Object: cidEncoder,\n    undefined: undefinedEncoder,\n    number: numberEncoder\n  }\n}\n\nexport const encodeOptions = {\n  ..._encodeOptions,\n  typeEncoders: {\n    ..._encodeOptions.typeEncoders\n  }\n}\n\n/**\n * @param {Uint8Array} bytes\n * @returns {CID}\n */\nfunction cidDecoder (bytes) {\n  if (bytes[0] !== 0) {\n    throw new Error('Invalid CID for CBOR tag 42; expected leading 0x00')\n  }\n  return CID.decode(bytes.subarray(1)) // ignore leading 0x00\n}\n\nconst _decodeOptions = {\n  allowIndefinite: false,\n  coerceUndefinedToNull: true,\n  allowNaN: false,\n  allowInfinity: false,\n  allowBigInt: true, // this will lead to BigInt for ints outside of\n  // safe-integer range, which may surprise users\n  strict: true,\n  useMaps: false,\n  rejectDuplicateMapKeys: true,\n  /** @type {import('cborg').TagDecoder[]} */\n  tags: []\n}\n_decodeOptions.tags[CID_CBOR_TAG] = cidDecoder\n\nexport const decodeOptions = {\n  ..._decodeOptions,\n  tags: _decodeOptions.tags.slice()\n}\n\nexport const name = 'dag-cbor'\nexport const code = 0x71\n\n/**\n * @template T\n * @param {T} node\n * @returns {ByteView<T>}\n */\nexport const encode = (node) => cborg.encode(node, _encodeOptions)\n\n/**\n * @template T\n * @param {ByteView<T> | ArrayBufferView<T>} data\n * @returns {T}\n */\nexport const decode = (data) => cborg.decode(toByteView(data), _decodeOptions)\n", "import { Type } from '../token.js'\nimport { encodeCustom } from '../encode.js'\nimport { encodeErrPrefix } from '../common.js'\nimport { asU8A, fromString } from '../byte-utils.js'\n\n/**\n * @typedef {import('../../interface').EncodeOptions} EncodeOptions\n * @typedef {import('../token').Token} Token\n * @typedef {import('../bl').Bl} Bl\n */\n\nclass JSONEncoder extends Array {\n  constructor () {\n    super()\n    /** @type {{type:Type,elements:number}[]} */\n    this.inRecursive = []\n  }\n\n  /**\n   * @param {Bl} buf\n   */\n  prefix (buf) {\n    const recurs = this.inRecursive[this.inRecursive.length - 1]\n    if (recurs) {\n      if (recurs.type === Type.array) {\n        recurs.elements++\n        if (recurs.elements !== 1) { // >first\n          buf.push([44]) // ','\n        }\n      }\n      if (recurs.type === Type.map) {\n        recurs.elements++\n        if (recurs.elements !== 1) { // >first\n          if (recurs.elements % 2 === 1) { // key\n            buf.push([44]) // ','\n          } else {\n            buf.push([58]) // ':'\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * @param {Bl} buf\n   * @param {Token} token\n   */\n  [Type.uint.major] (buf, token) {\n    this.prefix(buf)\n    const is = String(token.value)\n    const isa = []\n    for (let i = 0; i < is.length; i++) {\n      isa[i] = is.charCodeAt(i)\n    }\n    buf.push(isa)\n  }\n\n  /**\n   * @param {Bl} buf\n   * @param {Token} token\n   */\n  [Type.negint.major] (buf, token) {\n    // @ts-ignore hack\n    this[Type.uint.major](buf, token)\n  }\n\n  /**\n   * @param {Bl} _buf\n   * @param {Token} _token\n   */\n  [Type.bytes.major] (_buf, _token) {\n    throw new Error(`${encodeErrPrefix} unsupported type: Uint8Array`)\n  }\n\n  /**\n   * @param {Bl} buf\n   * @param {Token} token\n   */\n  [Type.string.major] (buf, token) {\n    this.prefix(buf)\n    // buf.push(34) // '\"'\n    // encodeUtf8(token.value, byts)\n    // buf.push(34) // '\"'\n    const byts = fromString(JSON.stringify(token.value))\n    buf.push(byts.length > 32 ? asU8A(byts) : byts)\n  }\n\n  /**\n   * @param {Bl} buf\n   * @param {Token} _token\n   */\n  [Type.array.major] (buf, _token) {\n    this.prefix(buf)\n    this.inRecursive.push({ type: Type.array, elements: 0 })\n    buf.push([91]) // '['\n  }\n\n  /**\n   * @param {Bl} buf\n   * @param {Token} _token\n   */\n  [Type.map.major] (buf, _token) {\n    this.prefix(buf)\n    this.inRecursive.push({ type: Type.map, elements: 0 })\n    buf.push([123]) // '{'\n  }\n\n  /**\n   * @param {Bl} _buf\n   * @param {Token} _token\n   */\n  [Type.tag.major] (_buf, _token) {}\n\n  /**\n   * @param {Bl} buf\n   * @param {Token} token\n   */\n  [Type.float.major] (buf, token) {\n    if (token.type.name === 'break') {\n      const recurs = this.inRecursive.pop()\n      if (recurs) {\n        if (recurs.type === Type.array) {\n          buf.push([93]) // ']'\n        } else if (recurs.type === Type.map) {\n          buf.push([125]) // '}'\n        /* c8 ignore next 3 */\n        } else {\n          throw new Error('Unexpected recursive type; this should not happen!')\n        }\n        return\n      }\n      /* c8 ignore next 2 */\n      throw new Error('Unexpected break; this should not happen!')\n    }\n    if (token.value === undefined) {\n      throw new Error(`${encodeErrPrefix} unsupported type: undefined`)\n    }\n\n    this.prefix(buf)\n    if (token.type.name === 'true') {\n      buf.push([116, 114, 117, 101]) // 'true'\n      return\n    } else if (token.type.name === 'false') {\n      buf.push([102, 97, 108, 115, 101]) // 'false'\n      return\n    } else if (token.type.name === 'null') {\n      buf.push([110, 117, 108, 108]) // 'null'\n      return\n    }\n\n    // number\n    const is = String(token.value)\n    const isa = []\n    let dp = false\n    for (let i = 0; i < is.length; i++) {\n      isa[i] = is.charCodeAt(i)\n      if (!dp && (isa[i] === 46 || isa[i] === 101 || isa[i] === 69)) { // '[.eE]'\n        dp = true\n      }\n    }\n    if (!dp) { // need a decimal point for floats\n      isa.push(46) // '.'\n      isa.push(48) // '0'\n    }\n    buf.push(isa)\n  }\n}\n\n// The below code is mostly taken and modified from https://github.com/feross/buffer\n// Licensed MIT. Copyright (c) Feross Aboukhadijeh\n// function encodeUtf8 (string, byts) {\n//   let codePoint\n//   const length = string.length\n//   let leadSurrogate = null\n\n//   for (let i = 0; i < length; ++i) {\n//     codePoint = string.charCodeAt(i)\n\n//     // is surrogate component\n//     if (codePoint > 0xd7ff && codePoint < 0xe000) {\n//       // last char was a lead\n//       if (!leadSurrogate) {\n//         // no lead yet\n//         /* c8 ignore next 9 */\n//         if (codePoint > 0xdbff) {\n//           // unexpected trail\n//           byts.push(0xef, 0xbf, 0xbd)\n//           continue\n//         } else if (i + 1 === length) {\n//           // unpaired lead\n//           byts.push(0xef, 0xbf, 0xbd)\n//           continue\n//         }\n\n//         // valid lead\n//         leadSurrogate = codePoint\n\n//         continue\n//       }\n\n//       // 2 leads in a row\n//       /* c8 ignore next 5 */\n//       if (codePoint < 0xdc00) {\n//         byts.push(0xef, 0xbf, 0xbd)\n//         leadSurrogate = codePoint\n//         continue\n//       }\n\n//       // valid surrogate pair\n//       codePoint = (leadSurrogate - 0xd800 << 10 | codePoint - 0xdc00) + 0x10000\n//     /* c8 ignore next 4 */\n//     } else if (leadSurrogate) {\n//       // valid bmp char, but last char was a lead\n//       byts.push(0xef, 0xbf, 0xbd)\n//     }\n\n//     leadSurrogate = null\n\n//     // encode utf8\n//     if (codePoint < 0x80) {\n//       // special JSON escapes\n//       switch (codePoint) {\n//         case 8: // '\\b'\n//           byts.push(92, 98) // '\\\\b'\n//           continue\n//         case 9: // '\\t'\n//           byts.push(92, 116) // '\\\\t'\n//           continue\n//         case 10: // '\\n'\n//           byts.push(92, 110) // '\\\\n'\n//           continue\n//         case 12: // '\\f'\n//           byts.push(92, 102) // '\\\\f'\n//           continue\n//         case 13: // '\\r'\n//           byts.push(92, 114) // '\\\\r'\n//           continue\n//         case 34: // '\"'\n//           byts.push(92, 34) // '\\\\\"'\n//           continue\n//         case 92: // '\\\\'\n//           byts.push(92, 92) // '\\\\\\\\'\n//           continue\n//       }\n\n//       byts.push(codePoint)\n//     } else if (codePoint < 0x800) {\n//       /* c8 ignore next 1 */\n//       byts.push(\n//         codePoint >> 0x6 | 0xc0,\n//         codePoint & 0x3f | 0x80\n//       )\n//     } else if (codePoint < 0x10000) {\n//       /* c8 ignore next 1 */\n//       byts.push(\n//         codePoint >> 0xc | 0xe0,\n//         codePoint >> 0x6 & 0x3f | 0x80,\n//         codePoint & 0x3f | 0x80\n//       )\n//     /* c8 ignore next 9 */\n//     } else if (codePoint < 0x110000) {\n//       byts.push(\n//         codePoint >> 0x12 | 0xf0,\n//         codePoint >> 0xc & 0x3f | 0x80,\n//         codePoint >> 0x6 & 0x3f | 0x80,\n//         codePoint & 0x3f | 0x80\n//       )\n//     } else {\n//       /* c8 ignore next 2 */\n//       throw new Error('Invalid code point')\n//     }\n//   }\n// }\n\n/**\n * @param {(Token|Token[])[]} e1\n * @param {(Token|Token[])[]} e2\n * @returns {number}\n */\nfunction mapSorter (e1, e2) {\n  if (Array.isArray(e1[0]) || Array.isArray(e2[0])) {\n    throw new Error(`${encodeErrPrefix} complex map keys are not supported`)\n  }\n  const keyToken1 = e1[0]\n  const keyToken2 = e2[0]\n  if (keyToken1.type !== Type.string || keyToken2.type !== Type.string) {\n    throw new Error(`${encodeErrPrefix} non-string map keys are not supported`)\n  }\n  if (keyToken1 < keyToken2) {\n    return -1\n  }\n  if (keyToken1 > keyToken2) {\n    return 1\n  }\n  /* c8 ignore next 1 */\n  throw new Error(`${encodeErrPrefix} unexpected duplicate map keys, this is not supported`)\n}\n\nconst defaultEncodeOptions = { addBreakTokens: true, mapSorter }\n\n/**\n * @param {any} data\n * @param {EncodeOptions} [options]\n * @returns {Uint8Array}\n */\nfunction encode (data, options) {\n  options = Object.assign({}, defaultEncodeOptions, options)\n  // @ts-ignore TokenTypeEncoder[] requires compareTokens() on each encoder, we don't use them here\n  return encodeCustom(data, new JSONEncoder(), options)\n}\n\nexport { encode }\n", "import { decode as _decode, decodeFirst as _decodeFirst } from '../decode.js'\nimport { Token, Type } from '../token.js'\nimport { decodeCodePointsArray } from '../byte-utils.js'\nimport { decodeErrPrefix } from '../common.js'\n\n/**\n * @typedef {import('../../interface').DecodeOptions} DecodeOptions\n * @typedef {import('../../interface').DecodeTokenizer} DecodeTokenizer\n */\n\n/**\n * @implements {DecodeTokenizer}\n */\nclass Tokenizer {\n  /**\n   * @param {Uint8Array} data\n   * @param {DecodeOptions} options\n   */\n  constructor (data, options = {}) {\n    this._pos = 0\n    this.data = data\n    this.options = options\n    /** @type {string[]} */\n    this.modeStack = ['value']\n    this.lastToken = ''\n  }\n\n  pos () {\n    return this._pos\n  }\n\n  /**\n   * @returns {boolean}\n   */\n  done () {\n    return this._pos >= this.data.length\n  }\n\n  /**\n   * @returns {number}\n   */\n  ch () {\n    return this.data[this._pos]\n  }\n\n  /**\n   * @returns {string}\n   */\n  currentMode () {\n    return this.modeStack[this.modeStack.length - 1]\n  }\n\n  skipWhitespace () {\n    let c = this.ch()\n    // @ts-ignore\n    while (c === 32 /* ' ' */ || c === 9 /* '\\t' */ || c === 13 /* '\\r' */ || c === 10 /* '\\n' */) {\n      c = this.data[++this._pos]\n    }\n  }\n\n  /**\n   * @param {number[]} str\n   */\n  expect (str) {\n    if (this.data.length - this._pos < str.length) {\n      throw new Error(`${decodeErrPrefix} unexpected end of input at position ${this._pos}`)\n    }\n    for (let i = 0; i < str.length; i++) {\n      if (this.data[this._pos++] !== str[i]) {\n        throw new Error(`${decodeErrPrefix} unexpected token at position ${this._pos}, expected to find '${String.fromCharCode(...str)}'`)\n      }\n    }\n  }\n\n  parseNumber () {\n    const startPos = this._pos\n    let negative = false\n    let float = false\n\n    /**\n     * @param {number[]} chars\n     */\n    const swallow = (chars) => {\n      while (!this.done()) {\n        const ch = this.ch()\n        if (chars.includes(ch)) {\n          this._pos++\n        } else {\n          break\n        }\n      }\n    }\n\n    // lead\n    if (this.ch() === 45) { // '-'\n      negative = true\n      this._pos++\n    }\n    if (this.ch() === 48) { // '0'\n      this._pos++\n      if (this.ch() === 46) { // '.'\n        this._pos++\n        float = true\n      } else {\n        return new Token(Type.uint, 0, this._pos - startPos)\n      }\n    }\n    swallow([48, 49, 50, 51, 52, 53, 54, 55, 56, 57]) // DIGIT\n    if (negative && this._pos === startPos + 1) {\n      throw new Error(`${decodeErrPrefix} unexpected token at position ${this._pos}`)\n    }\n    if (!this.done() && this.ch() === 46) { // '.'\n      if (float) {\n        throw new Error(`${decodeErrPrefix} unexpected token at position ${this._pos}`)\n      }\n      float = true\n      this._pos++\n      swallow([48, 49, 50, 51, 52, 53, 54, 55, 56, 57]) // DIGIT\n    }\n    if (!this.done() && (this.ch() === 101 || this.ch() === 69)) { // '[eE]'\n      float = true\n      this._pos++\n      if (!this.done() && (this.ch() === 43 || this.ch() === 45)) { // '+', '-'\n        this._pos++\n      }\n      swallow([48, 49, 50, 51, 52, 53, 54, 55, 56, 57]) // DIGIT\n    }\n    // @ts-ignore\n    const numStr = String.fromCharCode.apply(null, this.data.subarray(startPos, this._pos))\n    const num = parseFloat(numStr)\n    if (float) {\n      return new Token(Type.float, num, this._pos - startPos)\n    }\n    if (this.options.allowBigInt !== true || Number.isSafeInteger(num)) {\n      return new Token(num >= 0 ? Type.uint : Type.negint, num, this._pos - startPos)\n    }\n    return new Token(num >= 0 ? Type.uint : Type.negint, BigInt(numStr), this._pos - startPos)\n  }\n\n  /**\n   * @returns {Token}\n   */\n  parseString () {\n    /* c8 ignore next 4 */\n    if (this.ch() !== 34) { // '\"'\n      // this would be a programming error\n      throw new Error(`${decodeErrPrefix} unexpected character at position ${this._pos}; this shouldn't happen`)\n    }\n    this._pos++\n\n    // check for simple fast-path, all printable ascii, no escapes\n    // >0x10000 elements may fail fn.apply() (http://stackoverflow.com/a/22747272/680742)\n    for (let i = this._pos, l = 0; i < this.data.length && l < 0x10000; i++, l++) {\n      const ch = this.data[i]\n      if (ch === 92 || ch < 32 || ch >= 128) { // '\\', ' ', control-chars or non-trivial\n        break\n      }\n      if (ch === 34) { // '\"'\n        // @ts-ignore\n        const str = String.fromCharCode.apply(null, this.data.subarray(this._pos, i))\n        this._pos = i + 1\n        return new Token(Type.string, str, l)\n      }\n    }\n\n    const startPos = this._pos\n    const chars = []\n\n    const readu4 = () => {\n      if (this._pos + 4 >= this.data.length) {\n        throw new Error(`${decodeErrPrefix} unexpected end of unicode escape sequence at position ${this._pos}`)\n      }\n      let u4 = 0\n      for (let i = 0; i < 4; i++) {\n        let ch = this.ch()\n        if (ch >= 48 && ch <= 57) { // '0' && '9'\n          ch -= 48\n        } else if (ch >= 97 && ch <= 102) { // 'a' && 'f'\n          ch = ch - 97 + 10\n        } else if (ch >= 65 && ch <= 70) { // 'A' && 'F'\n          ch = ch - 65 + 10\n        } else {\n          throw new Error(`${decodeErrPrefix} unexpected unicode escape character at position ${this._pos}`)\n        }\n        u4 = u4 * 16 + ch\n        this._pos++\n      }\n      return u4\n    }\n\n    // mostly taken from feross/buffer and adjusted to fit\n    const readUtf8Char = () => {\n      const firstByte = this.ch()\n      let codePoint = null\n      /* c8 ignore next 1 */\n      let bytesPerSequence = (firstByte > 0xef) ? 4 : (firstByte > 0xdf) ? 3 : (firstByte > 0xbf) ? 2 : 1\n\n      if (this._pos + bytesPerSequence > this.data.length) {\n        throw new Error(`${decodeErrPrefix} unexpected unicode sequence at position ${this._pos}`)\n      }\n\n      let secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        /* c8 ignore next 6 */\n        // this case is dealt with by the caller function\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = this.data[this._pos + 1]\n          if ((secondByte & 0xc0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1f) << 0x6 | (secondByte & 0x3f)\n            if (tempCodePoint > 0x7f) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = this.data[this._pos + 1]\n          thirdByte = this.data[this._pos + 2]\n          if ((secondByte & 0xc0) === 0x80 && (thirdByte & 0xc0) === 0x80) {\n            tempCodePoint = (firstByte & 0xf) << 0xc | (secondByte & 0x3f) << 0x6 | (thirdByte & 0x3f)\n            /* c8 ignore next 3 */\n            if (tempCodePoint > 0x7ff && (tempCodePoint < 0xd800 || tempCodePoint > 0xdfff)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = this.data[this._pos + 1]\n          thirdByte = this.data[this._pos + 2]\n          fourthByte = this.data[this._pos + 3]\n          if ((secondByte & 0xc0) === 0x80 && (thirdByte & 0xc0) === 0x80 && (fourthByte & 0xc0) === 0x80) {\n            tempCodePoint = (firstByte & 0xf) << 0x12 | (secondByte & 0x3f) << 0xc | (thirdByte & 0x3f) << 0x6 | (fourthByte & 0x3f)\n            if (tempCodePoint > 0xffff && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n\n      /* c8 ignore next 5 */\n      if (codePoint === null) {\n        // we did not generate a valid codePoint so insert a\n        // replacement char (U+FFFD) and advance only 1 byte\n        codePoint = 0xfffd\n        bytesPerSequence = 1\n      } else if (codePoint > 0xffff) {\n        // encode to utf16 (surrogate pair dance)\n        codePoint -= 0x10000\n        chars.push(codePoint >>> 10 & 0x3ff | 0xd800)\n        codePoint = 0xdc00 | codePoint & 0x3ff\n      }\n\n      chars.push(codePoint)\n      this._pos += bytesPerSequence\n    }\n\n    // TODO: could take the approach of a quick first scan for special chars like encoding/json/decode.go#unquoteBytes\n    // and converting all of the ascii chars from the base array in bulk\n    while (!this.done()) {\n      const ch = this.ch()\n      let ch1\n      switch (ch) {\n        case 92: // '\\'\n          this._pos++\n          if (this.done()) {\n            throw new Error(`${decodeErrPrefix} unexpected string termination at position ${this._pos}`)\n          }\n          ch1 = this.ch()\n          this._pos++\n          switch (ch1) {\n            case 34: // '\"'\n            case 39: // '\\''\n            case 92: // '\\'\n            case 47: // '/'\n              chars.push(ch1)\n              break\n            case 98: // 'b'\n              chars.push(8)\n              break\n            case 116: // 't'\n              chars.push(9)\n              break\n            case 110: // 'n'\n              chars.push(10)\n              break\n            case 102: // 'f'\n              chars.push(12)\n              break\n            case 114: // 'r'\n              chars.push(13)\n              break\n            case 117: // 'u'\n              chars.push(readu4())\n              break\n            default:\n              throw new Error(`${decodeErrPrefix} unexpected string escape character at position ${this._pos}`)\n          }\n          break\n        case 34: // '\"'\n          this._pos++\n          return new Token(Type.string, decodeCodePointsArray(chars), this._pos - startPos)\n        default:\n          if (ch < 32) { // ' '\n            throw new Error(`${decodeErrPrefix} invalid control character at position ${this._pos}`)\n          } else if (ch < 0x80) {\n            chars.push(ch)\n            this._pos++\n          } else {\n            readUtf8Char()\n          }\n      }\n    }\n\n    throw new Error(`${decodeErrPrefix} unexpected end of string at position ${this._pos}`)\n  }\n\n  /**\n   * @returns {Token}\n   */\n  parseValue () {\n    switch (this.ch()) {\n      case 123: // '{'\n        this.modeStack.push('obj-start')\n        this._pos++\n        return new Token(Type.map, Infinity, 1)\n      case 91: // '['\n        this.modeStack.push('array-start')\n        this._pos++\n        return new Token(Type.array, Infinity, 1)\n      case 34: { // '\"'\n        return this.parseString()\n      }\n      case 110: // 'n' / null\n        this.expect([110, 117, 108, 108]) // 'null'\n        return new Token(Type.null, null, 4)\n      case 102: // 'f' / // false\n        this.expect([102, 97, 108, 115, 101]) // 'false'\n        return new Token(Type.false, false, 5)\n      case 116: // 't' / // true\n        this.expect([116, 114, 117, 101]) // 'true'\n        return new Token(Type.true, true, 4)\n      case 45: // '-'\n      case 48: // '0'\n      case 49: // '1'\n      case 50: // '2'\n      case 51: // '3'\n      case 52: // '4'\n      case 53: // '5'\n      case 54: // '6'\n      case 55: // '7'\n      case 56: // '8'\n      case 57: // '9'\n        return this.parseNumber()\n      default:\n        throw new Error(`${decodeErrPrefix} unexpected character at position ${this._pos}`)\n    }\n  }\n\n  /**\n   * @returns {Token}\n   */\n  next () {\n    this.skipWhitespace()\n    switch (this.currentMode()) {\n      case 'value':\n        this.modeStack.pop()\n        return this.parseValue()\n      case 'array-value': {\n        this.modeStack.pop()\n        if (this.ch() === 93) { // ']'\n          this._pos++\n          this.skipWhitespace()\n          return new Token(Type.break, undefined, 1)\n        }\n        if (this.ch() !== 44) { // ','\n          throw new Error(`${decodeErrPrefix} unexpected character at position ${this._pos}, was expecting array delimiter but found '${String.fromCharCode(this.ch())}'`)\n        }\n        this._pos++\n        this.modeStack.push('array-value')\n        this.skipWhitespace()\n        return this.parseValue()\n      }\n      case 'array-start': {\n        this.modeStack.pop()\n        if (this.ch() === 93) { // ']'\n          this._pos++\n          this.skipWhitespace()\n          return new Token(Type.break, undefined, 1)\n        }\n        this.modeStack.push('array-value')\n        this.skipWhitespace()\n        return this.parseValue()\n      }\n      // @ts-ignore\n      case 'obj-key':\n        if (this.ch() === 125) { // '}'\n          this.modeStack.pop()\n          this._pos++\n          this.skipWhitespace()\n          return new Token(Type.break, undefined, 1)\n        }\n        if (this.ch() !== 44) { // ','\n          throw new Error(`${decodeErrPrefix} unexpected character at position ${this._pos}, was expecting object delimiter but found '${String.fromCharCode(this.ch())}'`)\n        }\n        this._pos++\n        this.skipWhitespace()\n      case 'obj-start': { // eslint-disable-line no-fallthrough\n        this.modeStack.pop()\n        if (this.ch() === 125) { // '}'\n          this._pos++\n          this.skipWhitespace()\n          return new Token(Type.break, undefined, 1)\n        }\n        const token = this.parseString()\n        this.skipWhitespace()\n        if (this.ch() !== 58) { // ':'\n          throw new Error(`${decodeErrPrefix} unexpected character at position ${this._pos}, was expecting key/value delimiter ':' but found '${String.fromCharCode(this.ch())}'`)\n        }\n        this._pos++\n        this.modeStack.push('obj-value')\n        return token\n      }\n      case 'obj-value': {\n        this.modeStack.pop()\n        this.modeStack.push('obj-key')\n        this.skipWhitespace()\n        return this.parseValue()\n      }\n      /* c8 ignore next 2 */\n      default:\n        throw new Error(`${decodeErrPrefix} unexpected parse state at position ${this._pos}; this shouldn't happen`)\n    }\n  }\n}\n\n/**\n * @param {Uint8Array} data\n * @param {DecodeOptions} [options]\n * @returns {any}\n */\nfunction decode (data, options) {\n  options = Object.assign({ tokenizer: new Tokenizer(data, options) }, options)\n  return _decode(data, options)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {DecodeOptions} [options]\n * @returns {[any, Uint8Array]}\n */\nfunction decodeFirst (data, options) {\n  options = Object.assign({ tokenizer: new Tokenizer(data, options) }, options)\n  return _decodeFirst(data, options)\n}\n\nexport { decode, decodeFirst, Tokenizer }\n", "/* eslint max-depth: [\"error\", 7] */\nimport { Token, Type } from 'cborg'\nimport * as cborgJson from 'cborg/json'\nimport { CID } from 'multiformats'\nimport { base64 } from 'multiformats/bases/base64'\n\n/**\n * @template T\n * @typedef {import('multiformats/codecs/interface').ByteView<T>} ByteView\n */\n/**\n * @template T\n * @typedef {import('multiformats/codecs/interface').ArrayBufferView<T>} ArrayBufferView\n */\n/**\n * @template T\n * @typedef {import('multiformats').ToString<T>} ToString\n */\n/**\n * @typedef {import('cborg/interface').DecodeTokenizer} DecodeTokenizer\n */\n\n/**\n * @template T\n * @param {ByteView<T> | ArrayBufferView<T>} buf\n * @returns {ByteView<T>}\n */\nfunction toByteView (buf) {\n  if (buf instanceof ArrayBuffer) {\n    return new Uint8Array(buf, 0, buf.byteLength)\n  }\n\n  return buf\n}\n\n/**\n * cidEncoder will receive all Objects during encode, it needs to filter out\n * anything that's not a CID and return `null` for that so it's encoded as\n * normal. Encoding a CID means replacing it with a `{\"/\":\"<CidString>}`\n * object as per the DAG-JSON spec.\n *\n * @param {any} obj\n * @returns {Token[]|null}\n */\nfunction cidEncoder (obj) {\n  if (obj.asCID !== obj && obj['/'] !== obj.bytes) {\n    return null // any other kind of object\n  }\n  const cid = CID.asCID(obj)\n  /* c8 ignore next 4 */\n  // very unlikely case, and it'll probably throw a recursion error in cborg\n  if (!cid) {\n    return null\n  }\n  const cidString = cid.toString()\n\n  return [\n    new Token(Type.map, Infinity, 1),\n    new Token(Type.string, '/', 1), // key\n    new Token(Type.string, cidString, cidString.length), // value\n    new Token(Type.break, undefined, 1)\n  ]\n}\n\n/**\n * bytesEncoder will receive all Uint8Arrays (and friends) during encode, it\n * needs to replace it with a `{\"/\":{\"bytes\":\"Base64ByteString\"}}` object as\n * per the DAG-JSON spec.\n *\n * @param {Uint8Array} bytes\n * @returns {Token[]|null}\n */\nfunction bytesEncoder (bytes) {\n  const bytesString = base64.encode(bytes).slice(1) // no mbase prefix\n  return [\n    new Token(Type.map, Infinity, 1),\n    new Token(Type.string, '/', 1), // key\n    new Token(Type.map, Infinity, 1), // value\n    new Token(Type.string, 'bytes', 5), // inner key\n    new Token(Type.string, bytesString, bytesString.length), // inner value\n    new Token(Type.break, undefined, 1),\n    new Token(Type.break, undefined, 1)\n  ]\n}\n\n/**\n * taBytesEncoder wraps bytesEncoder() but for the more exotic typed arrays so\n * that we access the underlying ArrayBuffer data\n *\n * @param {Int8Array|Uint16Array|Int16Array|Uint32Array|Int32Array|Float32Array|Float64Array|Uint8ClampedArray|BigInt64Array|BigUint64Array} obj\n * @returns {Token[]|null}\n */\nfunction taBytesEncoder (obj) {\n  return bytesEncoder(new Uint8Array(obj.buffer, obj.byteOffset, obj.byteLength))\n}\n\n/**\n * abBytesEncoder wraps bytesEncoder() but for plain ArrayBuffers\n *\n * @param {ArrayBuffer} ab\n * @returns {Token[]|null}\n */\nfunction abBytesEncoder (ab) {\n  return bytesEncoder(new Uint8Array(ab))\n}\n\n// eslint-disable-next-line jsdoc/require-returns-check\n/**\n * Intercept all `undefined` values from an object walk and reject the entire\n * object if we find one.\n *\n * @returns {null}\n */\nfunction undefinedEncoder () {\n  throw new Error('`undefined` is not supported by the IPLD Data Model and cannot be encoded')\n}\n\n/**\n * Intercept all `number` values from an object walk and reject the entire\n * object if we find something that doesn't fit the IPLD data model (NaN &\n * Infinity).\n *\n * @param {number} num\n * @returns {null}\n */\nfunction numberEncoder (num) {\n  if (Number.isNaN(num)) {\n    throw new Error('`NaN` is not supported by the IPLD Data Model and cannot be encoded')\n  }\n  if (num === Infinity || num === -Infinity) {\n    throw new Error('`Infinity` and `-Infinity` is not supported by the IPLD Data Model and cannot be encoded')\n  }\n  return null // process with standard number encoder\n}\n\nconst encodeOptions = {\n  typeEncoders: {\n    Object: cidEncoder,\n    Buffer: bytesEncoder,\n    Uint8Array: bytesEncoder,\n    Int8Array: taBytesEncoder,\n    Uint16Array: taBytesEncoder,\n    Int16Array: taBytesEncoder,\n    Uint32Array: taBytesEncoder,\n    Int32Array: taBytesEncoder,\n    Float32Array: taBytesEncoder,\n    Float64Array: taBytesEncoder,\n    Uint8ClampedArray: taBytesEncoder,\n    BigInt64Array: taBytesEncoder,\n    BigUint64Array: taBytesEncoder,\n    DataView: taBytesEncoder,\n    ArrayBuffer: abBytesEncoder,\n    undefined: undefinedEncoder,\n    number: numberEncoder\n  }\n}\n\n/**\n * @implements {DecodeTokenizer}\n */\nclass DagJsonTokenizer extends cborgJson.Tokenizer {\n  /**\n   * @param {Uint8Array} data\n   * @param {object} [options]\n   */\n  constructor (data, options) {\n    super(data, options)\n    /** @type {Token[]} */\n    this.tokenBuffer = []\n  }\n\n  /**\n   * @returns {boolean}\n   */\n  done () {\n    return this.tokenBuffer.length === 0 && super.done()\n  }\n\n  /**\n   * @returns {Token}\n   */\n  _next () {\n    if (this.tokenBuffer.length > 0) {\n      // @ts-ignore https://github.com/Microsoft/TypeScript/issues/30406\n      return this.tokenBuffer.pop()\n    }\n    return super.next()\n  }\n\n  /**\n   * Implements rules outlined in https://github.com/ipld/specs/pull/356\n   *\n   * @returns {Token}\n   */\n  next () {\n    const token = this._next()\n\n    if (token.type === Type.map) {\n      const keyToken = this._next()\n      if (keyToken.type === Type.string && keyToken.value === '/') {\n        const valueToken = this._next()\n        if (valueToken.type === Type.string) { // *must* be a CID\n          const breakToken = this._next() // swallow the end-of-map token\n          if (breakToken.type !== Type.break) {\n            throw new Error('Invalid encoded CID form')\n          }\n          this.tokenBuffer.push(valueToken) // CID.parse will pick this up after our tag token\n          return new Token(Type.tag, 42, 0)\n        }\n        if (valueToken.type === Type.map) {\n          const innerKeyToken = this._next()\n          if (innerKeyToken.type === Type.string && innerKeyToken.value === 'bytes') {\n            const innerValueToken = this._next()\n            if (innerValueToken.type === Type.string) { // *must* be Bytes\n              for (let i = 0; i < 2; i++) {\n                const breakToken = this._next() // swallow two end-of-map tokens\n                if (breakToken.type !== Type.break) {\n                  throw new Error('Invalid encoded Bytes form')\n                }\n              }\n              const bytes = base64.decode(`m${innerValueToken.value}`)\n              return new Token(Type.bytes, bytes, innerValueToken.value.length)\n            }\n            this.tokenBuffer.push(innerValueToken) // bail\n          }\n          this.tokenBuffer.push(innerKeyToken) // bail\n        }\n        this.tokenBuffer.push(valueToken) // bail\n      }\n      this.tokenBuffer.push(keyToken) // bail\n    }\n    return token\n  }\n}\n\nconst decodeOptions = {\n  allowIndefinite: false,\n  allowUndefined: false,\n  allowNaN: false,\n  allowInfinity: false,\n  allowBigInt: true, // this will lead to BigInt for ints outside of\n  // safe-integer range, which may surprise users\n  strict: true,\n  useMaps: false,\n  rejectDuplicateMapKeys: true,\n  /** @type {import('cborg').TagDecoder[]} */\n  tags: []\n}\n\n// we're going to get TAG(42)STRING(\"bafy...\") from the tokenizer so we only need\n// to deal with the STRING(\"bafy...\") at this point\ndecodeOptions.tags[42] = CID.parse\n\nexport const name = 'dag-json'\nexport const code = 0x0129\n\n/**\n * @template T\n * @param {T} node\n * @returns {ByteView<T>}\n */\nexport const encode = (node) => cborgJson.encode(node, encodeOptions)\n\n/**\n * @template T\n * @param {ByteView<T> | ArrayBufferView<T>} data\n * @returns {T}\n */\nexport const decode = (data) => {\n  const buf = toByteView(data)\n  // the tokenizer is stateful so we need a single instance of it\n  const options = Object.assign(decodeOptions, { tokenizer: new DagJsonTokenizer(buf, decodeOptions) })\n  return cborgJson.decode(buf, options)\n}\n\n/**\n * @template T\n * @param {T} node\n * @returns {ToString<T>}\n */\nexport const format = (node) => utf8Decoder.decode(encode(node))\nexport { format as stringify }\nconst utf8Decoder = new TextDecoder()\n\n/**\n * @template T\n * @param {ToString<T>} data\n * @returns {T}\n */\nexport const parse = (data) => decode(utf8Encoder.encode(data))\nconst utf8Encoder = new TextEncoder()\n", "import { CID } from 'multiformats/cid'\nimport { NoPropError } from '../errors.js'\nimport type { ResolveResult } from '../index.js'\n\nexport function resolveObjectPath (object: any, block: Uint8Array, cid: CID, name: string, path: string, toResolve: string[], depth: number): ResolveResult {\n  let subObject = object\n  let subPath = path\n\n  while (toResolve.length > 0) {\n    const prop = toResolve[0]\n\n    if (prop in subObject) {\n      // remove the bit of the path we have resolved\n      toResolve.shift()\n      subPath = `${subPath}/${prop}`\n\n      const subObjectCid = CID.asCID(subObject[prop])\n      if (subObjectCid != null) {\n        return {\n          entry: {\n            type: 'object',\n            name,\n            path,\n            cid,\n            node: block,\n            depth,\n            size: BigInt(block.length),\n            content: async function * () {\n              yield object\n            }\n          },\n          next: {\n            cid: subObjectCid,\n            name: prop,\n            path: subPath,\n            toResolve\n          }\n        }\n      }\n\n      subObject = subObject[prop]\n    } else {\n      // cannot resolve further\n      throw new NoPropError(`No property named ${prop} found in node ${cid}`)\n    }\n  }\n\n  return {\n    entry: {\n      type: 'object',\n      name,\n      path,\n      cid,\n      node: block,\n      depth,\n      size: BigInt(block.length),\n      content: async function * () {\n        yield object\n      }\n    }\n  }\n}\n", "import * as dagCbor from '@ipld/dag-cbor'\nimport { resolveObjectPath } from '../utils/resolve-object-path.js'\nimport type { Resolver } from '../index.js'\n\nconst resolve: Resolver = async (cid, name, path, toResolve, resolve, depth, blockstore, options) => {\n  const block = await blockstore.get(cid, options)\n  const object = dagCbor.decode<any>(block)\n\n  return resolveObjectPath(object, block, cid, name, path, toResolve, depth)\n}\n\nexport default resolve\n", "import * as dagJson from '@ipld/dag-json'\nimport { resolveObjectPath } from '../utils/resolve-object-path.js'\nimport type { Resolver } from '../index.js'\n\nconst resolve: Resolver = async (cid, name, path, toResolve, resolve, depth, blockstore, options) => {\n  const block = await blockstore.get(cid, options)\n  const object = dagJson.decode<any>(block)\n\n  return resolveObjectPath(object, block, cid, name, path, toResolve, depth)\n}\n\nexport default resolve\n", "function extractDataFromBlock (block: Uint8Array, blockStart: bigint, requestedStart: bigint, requestedEnd: bigint): Uint8Array {\n  const blockLength = BigInt(block.length)\n  const blockEnd = BigInt(blockStart + blockLength)\n\n  if (requestedStart >= blockEnd || requestedEnd < blockStart) {\n    // If we are looking for a byte range that is starts after the start of the block,\n    // return an empty block.  This can happen when internal nodes contain data\n    return new Uint8Array(0)\n  }\n\n  if (requestedEnd >= blockStart && requestedEnd < blockEnd) {\n    // If the end byte is in the current block, truncate the block to the end byte\n    block = block.subarray(0, Number(requestedEnd - blockStart))\n  }\n\n  if (requestedStart >= blockStart && requestedStart < blockEnd) {\n    // If the start byte is in the current block, skip to the start byte\n    block = block.subarray(Number(requestedStart - blockStart))\n  }\n\n  return block\n}\n\nexport default extractDataFromBlock\n", "import { InvalidParametersError } from '../errors.js'\n\nconst validateOffsetAndLength = (size: number | bigint, offset: number | bigint = 0, length: number | bigint = size): { start: bigint, end: bigint } => {\n  const fileSize = BigInt(size)\n  const start = BigInt(offset ?? 0)\n  let end = BigInt(length)\n\n  if (end !== fileSize) {\n    end = start + end\n  }\n\n  if (end > fileSize) {\n    end = fileSize\n  }\n\n  if (start < 0n) {\n    throw new InvalidParametersError('Offset must be greater than or equal to 0')\n  }\n\n  if (start > fileSize) {\n    throw new InvalidParametersError('Offset must be less than the file size')\n  }\n\n  if (end < 0n) {\n    throw new InvalidParametersError('Length must be greater than or equal to 0')\n  }\n\n  if (end > fileSize) {\n    throw new InvalidParametersError('Length must be less than the file size')\n  }\n\n  return {\n    start,\n    end\n  }\n}\n\nexport default validateOffsetAndLength\n", "import * as mh from 'multiformats/hashes/digest'\nimport { CustomProgressEvent } from 'progress-events'\nimport { NotFoundError } from '../errors.js'\nimport extractDataFromBlock from '../utils/extract-data-from-block.js'\nimport validateOffsetAndLength from '../utils/validate-offset-and-length.js'\nimport type { ExporterOptions, Resolver, ExportProgress } from '../index.js'\n\nconst rawContent = (node: Uint8Array): ((options?: ExporterOptions) => AsyncGenerator<Uint8Array, void, undefined>) => {\n  async function * contentGenerator (options: ExporterOptions = {}): AsyncGenerator<Uint8Array, void, undefined> {\n    const {\n      start,\n      end\n    } = validateOffsetAndLength(node.length, options.offset, options.length)\n\n    const buf = extractDataFromBlock(node, 0n, start, end)\n\n    options.onProgress?.(new CustomProgressEvent<ExportProgress>('unixfs:exporter:progress:identity', {\n      bytesRead: BigInt(buf.byteLength),\n      totalBytes: end - start,\n      fileSize: BigInt(node.byteLength)\n    }))\n\n    yield buf\n  }\n\n  return contentGenerator\n}\n\nconst resolve: Resolver = async (cid, name, path, toResolve, resolve, depth, blockstore, options) => {\n  if (toResolve.length > 0) {\n    throw new NotFoundError(`No link named ${path} found in raw node ${cid}`)\n  }\n  const buf = mh.decode(cid.multihash.bytes)\n\n  return {\n    entry: {\n      type: 'identity',\n      name,\n      path,\n      cid,\n      content: rawContent(buf.digest),\n      depth,\n      size: BigInt(buf.digest.length),\n      node: buf.digest\n    }\n  }\n}\n\nexport default resolve\n", "import * as json from 'multiformats/codecs/json'\nimport { resolveObjectPath } from '../utils/resolve-object-path.js'\nimport type { Resolver } from '../index.js'\n\nconst resolve: Resolver = async (cid, name, path, toResolve, resolve, depth, blockstore, options) => {\n  const block = await blockstore.get(cid, options)\n  const object = json.decode<any>(block)\n\n  return resolveObjectPath(object, block, cid, name, path, toResolve, depth)\n}\n\nexport default resolve\n", "import { CustomProgressEvent } from 'progress-events'\nimport { NotFoundError } from '../errors.js'\nimport extractDataFromBlock from '../utils/extract-data-from-block.js'\nimport validateOffsetAndLength from '../utils/validate-offset-and-length.js'\nimport type { ExporterOptions, Resolver, ExportProgress } from '../index.js'\n\nconst rawContent = (node: Uint8Array): ((options?: ExporterOptions) => AsyncGenerator<Uint8Array, void, undefined>) => {\n  async function * contentGenerator (options: ExporterOptions = {}): AsyncGenerator<Uint8Array, void, undefined> {\n    const {\n      start,\n      end\n    } = validateOffsetAndLength(node.length, options.offset, options.length)\n\n    const buf = extractDataFromBlock(node, 0n, start, end)\n\n    options.onProgress?.(new CustomProgressEvent<ExportProgress>('unixfs:exporter:progress:raw', {\n      bytesRead: BigInt(buf.byteLength),\n      totalBytes: end - start,\n      fileSize: BigInt(node.byteLength)\n    }))\n\n    yield buf\n  }\n\n  return contentGenerator\n}\n\nconst resolve: Resolver = async (cid, name, path, toResolve, resolve, depth, blockstore, options) => {\n  if (toResolve.length > 0) {\n    throw new NotFoundError(`No link named ${path} found in raw node ${cid}`)\n  }\n\n  const block = await blockstore.get(cid, options)\n\n  return {\n    entry: {\n      type: 'raw',\n      name,\n      path,\n      cid,\n      content: rawContent(block),\n      depth,\n      size: BigInt(block.length),\n      node: block\n    }\n  }\n}\n\nexport default resolve\n", "import { decode } from '@ipld/dag-pb'\nimport { murmur3128 } from '@multiformats/murmur3'\nimport { Bucket, createHAMT } from 'hamt-sharding'\nimport { UnixFS } from 'ipfs-unixfs'\nimport { NotUnixFSError } from '../errors.js'\nimport type { ExporterOptions, ShardTraversalContext, ReadableStorage } from '../index.js'\nimport type { PBLink, PBNode } from '@ipld/dag-pb'\nimport type { BucketPosition } from 'hamt-sharding'\nimport type { CID } from 'multiformats/cid'\n\n// FIXME: this is copy/pasted from ipfs-unixfs-importer/src/options.js\nconst hashFn = async function (buf: Uint8Array): Promise<Uint8Array> {\n  return (await murmur3128.encode(buf))\n    // Murmur3 outputs 128 bit but, accidentally, IPFS Go's\n    // implementation only uses the first 64, so we must do the same\n    // for parity..\n    .slice(0, 8)\n    // Invert buffer because that's how Go impl does it\n    .reverse()\n}\n\nconst addLinksToHamtBucket = async (links: PBLink[], bucket: Bucket<boolean>, rootBucket: Bucket<boolean>): Promise<void> => {\n  const padLength = (bucket.tableSize() - 1).toString(16).length\n  await Promise.all(\n    links.map(async link => {\n      if (link.Name == null) {\n        // TODO(@rvagg): what do? this is technically possible\n        throw new Error('Unexpected Link without a Name')\n      }\n      if (link.Name.length === padLength) {\n        const pos = parseInt(link.Name, 16)\n\n        bucket._putObjectAt(pos, new Bucket({\n          hash: rootBucket._options.hash,\n          bits: rootBucket._options.bits\n        }, bucket, pos))\n        return\n      }\n\n      await rootBucket.put(link.Name.substring(2), true)\n    })\n  )\n}\n\nconst toPrefix = (position: number, padLength: number): string => {\n  return position\n    .toString(16)\n    .toUpperCase()\n    .padStart(padLength, '0')\n    .substring(0, padLength)\n}\n\nconst toBucketPath = (position: BucketPosition<boolean>): Array<Bucket<boolean>> => {\n  let bucket = position.bucket\n  const path = []\n\n  while (bucket._parent != null) {\n    path.push(bucket)\n\n    bucket = bucket._parent\n  }\n\n  path.push(bucket)\n\n  return path.reverse()\n}\n\nconst findShardCid = async (node: PBNode, name: string, blockstore: ReadableStorage, context?: ShardTraversalContext, options?: ExporterOptions): Promise<CID | undefined> => {\n  if (context == null) {\n    if (node.Data == null) {\n      throw new NotUnixFSError('no data in PBNode')\n    }\n\n    let dir: UnixFS\n    try {\n      dir = UnixFS.unmarshal(node.Data)\n    } catch (err: any) {\n      throw new NotUnixFSError(err.message)\n    }\n\n    if (dir.type !== 'hamt-sharded-directory') {\n      throw new NotUnixFSError('not a HAMT')\n    }\n    if (dir.fanout == null) {\n      throw new NotUnixFSError('missing fanout')\n    }\n\n    const rootBucket = createHAMT<boolean>({\n      hashFn,\n      bits: Math.log2(Number(dir.fanout))\n    })\n\n    context = {\n      rootBucket,\n      hamtDepth: 1,\n      lastBucket: rootBucket\n    }\n  }\n\n  const padLength = (context.lastBucket.tableSize() - 1).toString(16).length\n\n  await addLinksToHamtBucket(node.Links, context.lastBucket, context.rootBucket)\n\n  const position = await context.rootBucket._findNewBucketAndPos(name)\n  let prefix = toPrefix(position.pos, padLength)\n  const bucketPath = toBucketPath(position)\n\n  if (bucketPath.length > context.hamtDepth) {\n    context.lastBucket = bucketPath[context.hamtDepth]\n\n    prefix = toPrefix(context.lastBucket._posAtParent, padLength)\n  }\n\n  const link = node.Links.find(link => {\n    if (link.Name == null) {\n      return false\n    }\n\n    const entryPrefix = link.Name.substring(0, padLength)\n    const entryName = link.Name.substring(padLength)\n\n    if (entryPrefix !== prefix) {\n      // not the entry or subshard we're looking for\n      return false\n    }\n\n    if (entryName !== '' && entryName !== name) {\n      // not the entry we're looking for\n      return false\n    }\n\n    return true\n  })\n\n  if (link == null) {\n    return\n  }\n\n  if (link.Name != null && link.Name.substring(padLength) === name) {\n    return link.Hash\n  }\n\n  context.hamtDepth++\n\n  const block = await blockstore.get(link.Hash, options)\n  node = decode(block)\n\n  return findShardCid(node, name, blockstore, context, options)\n}\n\nexport default findShardCid\n", "/**\n * @packageDocumentation\n *\n * Lets you look at the contents of an async iterator and decide what to do\n *\n * @example\n *\n * ```javascript\n * import peekable from 'it-peekable'\n *\n * // This can also be an iterator, generator, etc\n * const values = [0, 1, 2, 3, 4]\n *\n * const it = peekable(value)\n *\n * const first = it.peek()\n *\n * console.info(first) // 0\n *\n * it.push(first)\n *\n * console.info([...it])\n * // [ 0, 1, 2, 3, 4 ]\n * ```\n *\n * Async sources must be awaited:\n *\n * ```javascript\n * import peekable from 'it-peekable'\n *\n * const values = async function * () {\n *   yield * [0, 1, 2, 3, 4]\n * }\n *\n * const it = peekable(values())\n *\n * const first = await it.peek()\n *\n * console.info(first) // 0\n *\n * it.push(first)\n *\n * console.info(await all(it))\n * // [ 0, 1, 2, 3, 4 ]\n * ```\n */\n\nexport interface Peek <T> {\n  peek(): IteratorResult<T, undefined>\n}\n\nexport interface AsyncPeek <T> {\n  peek(): Promise<IteratorResult<T, undefined>>\n}\n\nexport interface Push <T> {\n  push(value: T): void\n}\n\nexport type Peekable <T> = Iterable<T> & Peek<T> & Push<T> & Iterator<T>\n\nexport type AsyncPeekable <T> = AsyncIterable<T> & AsyncPeek<T> & Push<T> & AsyncIterator<T>\n\nfunction peekable <T> (iterable: Iterable<T>): Peekable<T>\nfunction peekable <T> (iterable: AsyncIterable<T>): AsyncPeekable<T>\nfunction peekable <T> (iterable: Iterable<T> | AsyncIterable<T>): Peekable<T> | AsyncPeekable<T> {\n  // @ts-expect-error can't use Symbol.asyncIterator to index iterable since it might be Iterable\n  const [iterator, symbol] = iterable[Symbol.asyncIterator] != null\n    // @ts-expect-error can't use Symbol.asyncIterator to index iterable since it might be Iterable\n    ? [iterable[Symbol.asyncIterator](), Symbol.asyncIterator]\n    // @ts-expect-error can't use Symbol.iterator to index iterable since it might be AsyncIterable\n    : [iterable[Symbol.iterator](), Symbol.iterator]\n\n  const queue: any[] = []\n\n  // @ts-expect-error can't use symbol to index peekable\n  return {\n    peek: () => {\n      return iterator.next()\n    },\n    push: (value: any) => {\n      queue.push(value)\n    },\n    next: () => {\n      if (queue.length > 0) {\n        return {\n          done: false,\n          value: queue.shift()\n        }\n      }\n\n      return iterator.next()\n    },\n    [symbol] () {\n      return this\n    }\n  }\n}\n\nexport default peekable\n", "/**\n * @packageDocumentation\n *\n * Filter values out of an (async)iterable\n *\n * @example\n *\n * ```javascript\n * import all from 'it-all'\n * import filter from 'it-filter'\n *\n * // This can also be an iterator, generator, etc\n * const values = [0, 1, 2, 3, 4]\n *\n * const fn = (val, index) => val > 2 // Return boolean to keep item\n *\n * const arr = all(filter(values, fn))\n *\n * console.info(arr) // 3, 4\n * ```\n *\n * Async sources and filter functions must be awaited:\n *\n * ```javascript\n * import all from 'it-all'\n * import filter from 'it-filter'\n *\n * const values = async function * () {\n *   yield * [0, 1, 2, 3, 4]\n * }\n *\n * const fn = async val => (val, index) > 2 // Return boolean or promise of boolean to keep item\n *\n * const arr = await all(filter(values, fn))\n *\n * console.info(arr) // 3, 4\n * ```\n */\n\nimport peek from 'it-peekable'\n\nfunction isAsyncIterable <T> (thing: any): thing is AsyncIterable<T> {\n  return thing[Symbol.asyncIterator] != null\n}\n\n/**\n * Filters the passed (async) iterable by using the filter function\n */\nfunction filter <T> (source: Iterable<T>, fn: (val: T, index: number) => Promise<boolean>): AsyncGenerator<T, void, undefined>\nfunction filter <T> (source: Iterable<T>, fn: (val: T, index: number) => boolean): Generator<T, void, undefined>\nfunction filter <T> (source: Iterable<T> | AsyncIterable<T>, fn: (val: T, index: number) => boolean | Promise<boolean>): AsyncGenerator<T, void, undefined>\nfunction filter <T> (source: Iterable<T> | AsyncIterable<T>, fn: (val: T, index: number) => boolean | Promise<boolean>): Generator<T, void, undefined> | AsyncGenerator<T, void, undefined> {\n  let index = 0\n\n  if (isAsyncIterable(source)) {\n    return (async function * () {\n      for await (const entry of source) {\n        if (await fn(entry, index++)) {\n          yield entry\n        }\n      }\n    })()\n  }\n\n  // if mapping function returns a promise we have to return an async generator\n  const peekable = peek(source)\n  const { value, done } = peekable.next()\n\n  if (done === true) {\n    return (function * () {}())\n  }\n\n  const res = fn(value, index++)\n\n  // @ts-expect-error .then is not present on O\n  if (typeof res.then === 'function') {\n    return (async function * () {\n      if (await res) {\n        yield value\n      }\n\n      for (const entry of peekable) {\n        if (await fn(entry, index++)) {\n          yield entry\n        }\n      }\n    })()\n  }\n\n  const func = fn as (val: T, index: number) => boolean\n\n  return (function * () {\n    if (res === true) {\n      yield value\n    }\n\n    for (const entry of peekable) {\n      if (func(entry, index++)) {\n        yield entry\n      }\n    }\n  })()\n}\n\nexport default filter\n", "/**\n * @packageDocumentation\n *\n * Convert one value from an (async)iterator into another.\n *\n * @example\n *\n * ```javascript\n * import map from 'it-map'\n *\n * // This can also be an iterator, generator, etc\n * const values = [0, 1, 2, 3, 4]\n *\n * const result = map(values, (val, index) => val++)\n *\n * console.info(result) // [1, 2, 3, 4, 5]\n * ```\n *\n * Async sources and transforms must be awaited:\n *\n * ```javascript\n * import map from 'it-map'\n *\n * const values = async function * () {\n *   yield * [0, 1, 2, 3, 4]\n * }\n *\n * const result = await map(values(), async (val, index) => val++)\n *\n * console.info(result) // [1, 2, 3, 4, 5]\n * ```\n */\n\nimport peek from 'it-peekable'\n\nfunction isAsyncIterable <T> (thing: any): thing is AsyncIterable<T> {\n  return thing[Symbol.asyncIterator] != null\n}\n\n/**\n * Takes an (async) iterable and returns one with each item mapped by the passed\n * function\n */\nfunction map <I, O> (source: Iterable<I>, func: (val: I, index: number) => Promise<O>): AsyncGenerator<O, void, undefined>\nfunction map <I, O> (source: Iterable<I>, func: (val: I, index: number) => O): Generator<O, void, undefined>\nfunction map <I, O> (source: AsyncIterable<I> | Iterable<I>, func: (val: I, index: number) => O | Promise<O>): AsyncGenerator<O, void, undefined>\nfunction map <I, O> (source: AsyncIterable<I> | Iterable<I>, func: (val: I, index: number) => O | Promise<O>): AsyncGenerator<O, void, undefined> | Generator<O, void, undefined> {\n  let index = 0\n\n  if (isAsyncIterable(source)) {\n    return (async function * () {\n      for await (const val of source) {\n        yield func(val, index++)\n      }\n    })()\n  }\n\n  // if mapping function returns a promise we have to return an async generator\n  const peekable = peek(source)\n  const { value, done } = peekable.next()\n\n  if (done === true) {\n    return (function * () {}())\n  }\n\n  const res = func(value, index++)\n\n  // @ts-expect-error .then is not present on O\n  if (typeof res.then === 'function') {\n    return (async function * () {\n      yield await res\n\n      for (const val of peekable) {\n        yield func(val, index++)\n      }\n    })()\n  }\n\n  const fn = func as (val: I, index: number) => O\n\n  return (function * () {\n    yield res as O\n\n    for (const val of peekable) {\n      yield fn(val, index++)\n    }\n  })()\n}\n\nexport default map\n", "export default function pDefer() {\n\tconst deferred = {};\n\n\tdeferred.promise = new Promise((resolve, reject) => {\n\t\tdeferred.resolve = resolve;\n\t\tdeferred.reject = reject;\n\t});\n\n\treturn deferred;\n}\n", "/**\n * @packageDocumentation\n *\n * Takes an (async) iterable that emits promise-returning functions, invokes them in parallel up to the concurrency limit and emits the results as they become available, optionally in the same order as the input\n *\n * @example\n *\n * ```javascript\n * import parallel from 'it-parallel'\n * import all from 'it-all'\n * import delay from 'delay'\n *\n * // This can also be an iterator, async iterator, generator, etc\n * const input = [\n *   async () => {\n *     console.info('start 1')\n *     await delay(500)\n *\n *     console.info('end 1')\n *     return 1\n *   },\n *   async () => {\n *     console.info('start 2')\n *     await delay(200)\n *\n *     console.info('end 2')\n *     return 2\n *   },\n *   async () => {\n *     console.info('start 3')\n *     await delay(100)\n *\n *     console.info('end 3')\n *     return 3\n *   }\n * ]\n *\n * const result = await all(parallel(input, {\n *   concurrency: 2\n * }))\n *\n * // output:\n * // start 1\n * // start 2\n * // end 2\n * // start 3\n * // end 3\n * // end 1\n *\n * console.info(result) // [2, 3, 1]\n * ```\n *\n * If order is important, pass `ordered: true` as an option:\n *\n * ```javascript\n * const result = await all(parallel(input, {\n *   concurrency: 2,\n *   ordered: true\n * }))\n *\n * // output:\n * // start 1\n * // start 2\n * // end 2\n * // start 3\n * // end 3\n * // end 1\n *\n * console.info(result) // [1, 2, 3]\n * ```\n */\n\nimport defer from 'p-defer'\n\ninterface Operation<T> {\n  done: boolean\n  ok: boolean\n  err: Error\n  value: T\n}\n\nconst CustomEvent = globalThis.CustomEvent ?? Event\n\nexport interface ParallelOptions {\n  /**\n   * How many jobs to execute in parallel (default: )\n   */\n  concurrency?: number\n  ordered?: boolean\n}\n\n/**\n * Takes an (async) iterator that emits promise-returning functions,\n * invokes them in parallel and emits the results as they become available but\n * in the same order as the input\n */\nexport default async function * parallel <T> (source: Iterable<() => Promise<T>> | AsyncIterable<() => Promise<T>>, options: ParallelOptions = {}): AsyncGenerator<T, void, undefined> {\n  let concurrency = options.concurrency ?? Infinity\n\n  if (concurrency < 1) {\n    concurrency = Infinity\n  }\n\n  const ordered = options.ordered ?? false\n  const emitter = new EventTarget()\n\n  const ops: Array<Operation<T>> = []\n  let slotAvailable = defer()\n  let resultAvailable = defer()\n  let sourceFinished = false\n  let sourceErr: Error | undefined\n  let opErred = false\n\n  emitter.addEventListener('task-complete', () => {\n    resultAvailable.resolve()\n  })\n\n  void Promise.resolve().then(async () => {\n    try {\n      for await (const task of source) {\n        if (ops.length === concurrency) {\n          slotAvailable = defer()\n          await slotAvailable.promise\n        }\n\n        if (opErred) {\n          break\n        }\n\n        const op: any = {\n          done: false\n        }\n        ops.push(op)\n\n        task()\n          .then(result => {\n            op.done = true\n            op.ok = true\n            op.value = result\n            emitter.dispatchEvent(new CustomEvent('task-complete'))\n          }, err => {\n            op.done = true\n            op.err = err\n            emitter.dispatchEvent(new CustomEvent('task-complete'))\n          })\n      }\n\n      sourceFinished = true\n      emitter.dispatchEvent(new CustomEvent('task-complete'))\n    } catch (err: any) {\n      sourceErr = err\n      emitter.dispatchEvent(new CustomEvent('task-complete'))\n    }\n  })\n\n  function valuesAvailable (): boolean {\n    if (ordered) {\n      return ops[0]?.done\n    }\n\n    return Boolean(ops.find(op => op.done))\n  }\n\n  function * yieldOrderedValues (): Generator<T, void, unknown> {\n    while ((ops.length > 0) && ops[0].done) {\n      const op = ops[0]\n      ops.shift()\n\n      if (op.ok) {\n        yield op.value\n      } else {\n        // allow the source to exit\n        opErred = true\n        slotAvailable.resolve()\n\n        throw op.err\n      }\n\n      slotAvailable.resolve()\n    }\n  }\n\n  function * yieldUnOrderedValues (): Generator<T, void, unknown> {\n    // more values can become available while we wait for `yield`\n    // to return control to this function\n    while (valuesAvailable()) {\n      for (let i = 0; i < ops.length; i++) {\n        if (ops[i].done) {\n          const op = ops[i]\n          ops.splice(i, 1)\n          i--\n\n          if (op.ok) {\n            yield op.value\n          } else {\n            opErred = true\n            slotAvailable.resolve()\n\n            throw op.err\n          }\n\n          slotAvailable.resolve()\n        }\n      }\n    }\n  }\n\n  while (true) {\n    if (!valuesAvailable()) {\n      resultAvailable = defer()\n      await resultAvailable.promise\n    }\n\n    if (sourceErr != null) {\n      // the source threw an error, propagate it\n      throw sourceErr\n    }\n\n    if (ordered) {\n      yield * yieldOrderedValues()\n    } else {\n      yield * yieldUnOrderedValues()\n    }\n\n    if (sourceErr != null) {\n      // if the source yields an array that is `yield *`, it can throw while the\n      // onward consumer is processing the array contents - make sure we\n      // propagate the error\n      // eslint-disable-next-line @typescript-eslint/only-throw-error\n      throw sourceErr\n    }\n\n    if (sourceFinished && ops.length === 0) {\n      // not waiting for any results and no more tasks so we are done\n      break\n    }\n  }\n}\n", "// ported from https://www.npmjs.com/package/fast-fifo\n\nexport interface Next<T> {\n  done?: boolean\n  error?: Error\n  value?: T\n}\n\nclass FixedFIFO<T> {\n  public buffer: Array<Next<T> | undefined>\n  private readonly mask: number\n  private top: number\n  private btm: number\n  public next: FixedFIFO<T> | null\n\n  constructor (hwm: number) {\n    if (!(hwm > 0) || ((hwm - 1) & hwm) !== 0) {\n      throw new Error('Max size for a FixedFIFO should be a power of two')\n    }\n\n    this.buffer = new Array(hwm)\n    this.mask = hwm - 1\n    this.top = 0\n    this.btm = 0\n    this.next = null\n  }\n\n  push (data: Next<T>): boolean {\n    if (this.buffer[this.top] !== undefined) {\n      return false\n    }\n\n    this.buffer[this.top] = data\n    this.top = (this.top + 1) & this.mask\n\n    return true\n  }\n\n  shift (): Next<T> | undefined {\n    const last = this.buffer[this.btm]\n\n    if (last === undefined) {\n      return undefined\n    }\n\n    this.buffer[this.btm] = undefined\n    this.btm = (this.btm + 1) & this.mask\n    return last\n  }\n\n  isEmpty (): boolean {\n    return this.buffer[this.btm] === undefined\n  }\n}\n\nexport interface FIFOOptions {\n  /**\n   * When the queue reaches this size, it will be split into head/tail parts\n   */\n  splitLimit?: number\n}\n\nexport class FIFO<T> {\n  public size: number\n  private readonly hwm: number\n  private head: FixedFIFO<T>\n  private tail: FixedFIFO<T>\n\n  constructor (options: FIFOOptions = {}) {\n    this.hwm = options.splitLimit ?? 16\n    this.head = new FixedFIFO<T>(this.hwm)\n    this.tail = this.head\n    this.size = 0\n  }\n\n  calculateSize (obj: any): number {\n    if (obj?.byteLength != null) {\n      return obj.byteLength\n    }\n\n    return 1\n  }\n\n  push (val: Next<T>): void {\n    if (val?.value != null) {\n      this.size += this.calculateSize(val.value)\n    }\n\n    if (!this.head.push(val)) {\n      const prev = this.head\n      this.head = prev.next = new FixedFIFO<T>(2 * this.head.buffer.length)\n      this.head.push(val)\n    }\n  }\n\n  shift (): Next<T> | undefined {\n    let val = this.tail.shift()\n\n    if (val === undefined && (this.tail.next != null)) {\n      const next = this.tail.next\n      this.tail.next = null\n      this.tail = next\n      val = this.tail.shift()\n    }\n\n    if (val?.value != null) {\n      this.size -= this.calculateSize(val.value)\n    }\n\n    return val\n  }\n\n  isEmpty (): boolean {\n    return this.head.isEmpty()\n  }\n}\n", "/**\n * @packageDocumentation\n *\n * An iterable that you can push values into.\n *\n * @example\n *\n * ```js\n * import { pushable } from 'it-pushable'\n *\n * const source = pushable()\n *\n * setTimeout(() => source.push('hello'), 100)\n * setTimeout(() => source.push('world'), 200)\n * setTimeout(() => source.end(), 300)\n *\n * const start = Date.now()\n *\n * for await (const value of source) {\n *   console.log(`got \"${value}\" after ${Date.now() - start}ms`)\n * }\n * console.log(`done after ${Date.now() - start}ms`)\n *\n * // Output:\n * // got \"hello\" after 105ms\n * // got \"world\" after 207ms\n * // done after 309ms\n * ```\n *\n * @example\n *\n * ```js\n * import { pushableV } from 'it-pushable'\n * import all from 'it-all'\n *\n * const source = pushableV()\n *\n * source.push(1)\n * source.push(2)\n * source.push(3)\n * source.end()\n *\n * console.info(await all(source))\n *\n * // Output:\n * // [ [1, 2, 3] ]\n * ```\n */\n\nimport deferred from 'p-defer'\nimport { FIFO, type Next } from './fifo.js'\n\nexport class AbortError extends Error {\n  type: string\n  code: string\n\n  constructor (message?: string, code?: string) {\n    super(message ?? 'The operation was aborted')\n    this.type = 'aborted'\n    this.code = code ?? 'ABORT_ERR'\n  }\n}\n\nexport interface AbortOptions {\n  signal?: AbortSignal\n}\n\ninterface BasePushable<T> {\n  /**\n   * End the iterable after all values in the buffer (if any) have been yielded. If an\n   * error is passed the buffer is cleared immediately and the next iteration will\n   * throw the passed error\n   */\n  end(err?: Error): this\n\n  /**\n   * Push a value into the iterable. Values are yielded from the iterable in the order\n   * they are pushed. Values not yet consumed from the iterable are buffered.\n   */\n  push(value: T): this\n\n  /**\n   * Returns a promise that resolves when the underlying queue becomes empty (e.g.\n   * this.readableLength === 0).\n   *\n   * If an AbortSignal is passed as an option and that signal aborts, it only\n   * causes the returned promise to reject - it does not end the pushable.\n   */\n  onEmpty(options?: AbortOptions): Promise<void>\n\n  /**\n   * This property contains the number of bytes (or objects) in the queue ready to be read.\n   *\n   * If `objectMode` is true, this is the number of objects in the queue, if false it's the\n   * total number of bytes in the queue.\n   */\n  readableLength: number\n}\n\n/**\n * An iterable that you can push values into.\n */\nexport interface Pushable<T, R = void, N = unknown> extends AsyncGenerator<T, R, N>, BasePushable<T> {}\n\n/**\n * Similar to `pushable`, except it yields multiple buffered chunks at a time. All values yielded from the iterable will be arrays.\n */\nexport interface PushableV<T, R = void, N = unknown> extends AsyncGenerator<T[], R, N>, BasePushable<T> {}\n\nexport interface Options {\n  /**\n   * A boolean value that means non-`Uint8Array`s will be passed to `.push`, default: `false`\n   */\n  objectMode?: boolean\n\n  /**\n   * A function called after *all* values have been yielded from the iterator (including\n   * buffered values). In the case when the iterator is ended with an error it will be\n   * passed the error as a parameter.\n   */\n  onEnd?(err?: Error): void\n}\n\nexport interface DoneResult { done: true }\nexport interface ValueResult<T> { done: false, value: T }\nexport type NextResult<T> = ValueResult<T> | DoneResult\n\ninterface getNext<T, V = T> { (buffer: FIFO<T>): NextResult<V> }\n\nexport interface ObjectPushableOptions extends Options {\n  objectMode: true\n}\n\nexport interface BytePushableOptions extends Options {\n  objectMode?: false\n}\n\n/**\n * Create a new async iterable. The values yielded from calls to `.next()`\n * or when used in a `for await of`loop are \"pushed\" into the iterable.\n * Returns an async iterable object with additional methods.\n */\nexport function pushable<T extends { byteLength: number } = Uint8Array> (options?: BytePushableOptions): Pushable<T>\nexport function pushable<T> (options: ObjectPushableOptions): Pushable<T>\nexport function pushable<T> (options: Options = {}): Pushable<T> {\n  const getNext = (buffer: FIFO<T>): NextResult<T> => {\n    const next: Next<T> | undefined = buffer.shift()\n\n    if (next == null) {\n      return { done: true }\n    }\n\n    if (next.error != null) {\n      throw next.error\n    }\n\n    return {\n      done: next.done === true,\n      // @ts-expect-error if done is false, value will be present\n      value: next.value\n    }\n  }\n\n  return _pushable<T, T, Pushable<T>>(getNext, options)\n}\n\nexport function pushableV<T extends { byteLength: number } = Uint8Array> (options?: BytePushableOptions): PushableV<T>\nexport function pushableV<T> (options: ObjectPushableOptions): PushableV<T>\nexport function pushableV<T> (options: Options = {}): PushableV<T> {\n  const getNext = (buffer: FIFO<T>): NextResult<T[]> => {\n    let next: Next<T> | undefined\n    const values: T[] = []\n\n    while (!buffer.isEmpty()) {\n      next = buffer.shift()\n\n      if (next == null) {\n        break\n      }\n\n      if (next.error != null) {\n        throw next.error\n      }\n\n      if (next.done === false) {\n        // @ts-expect-error if done is false value should be pushed\n        values.push(next.value)\n      }\n    }\n\n    if (next == null) {\n      return { done: true }\n    }\n\n    return {\n      done: next.done === true,\n      value: values\n    }\n  }\n\n  return _pushable<T, T[], PushableV<T>>(getNext, options)\n}\n\nfunction _pushable<PushType, ValueType, ReturnType> (getNext: getNext<PushType, ValueType>, options?: Options): ReturnType {\n  options = options ?? {}\n  let onEnd = options.onEnd\n  let buffer = new FIFO<PushType>()\n  let pushable: any\n  let onNext: ((next: Next<PushType>) => ReturnType) | null\n  let ended: boolean\n  let drain = deferred()\n\n  const waitNext = async (): Promise<NextResult<ValueType>> => {\n    try {\n      if (!buffer.isEmpty()) {\n        return getNext(buffer)\n      }\n\n      if (ended) {\n        return { done: true }\n      }\n\n      return await new Promise<NextResult<ValueType>>((resolve, reject) => {\n        onNext = (next: Next<PushType>) => {\n          onNext = null\n          buffer.push(next)\n\n          try {\n            resolve(getNext(buffer))\n          } catch (err) {\n            reject(err)\n          }\n\n          return pushable\n        }\n      })\n    } finally {\n      if (buffer.isEmpty()) {\n        // settle promise in the microtask queue to give consumers a chance to\n        // await after calling .push\n        queueMicrotask(() => {\n          drain.resolve()\n          drain = deferred()\n        })\n      }\n    }\n  }\n\n  const bufferNext = (next: Next<PushType>): ReturnType => {\n    if (onNext != null) {\n      return onNext(next)\n    }\n\n    buffer.push(next)\n    return pushable\n  }\n\n  const bufferError = (err: Error): ReturnType => {\n    buffer = new FIFO()\n\n    if (onNext != null) {\n      return onNext({ error: err })\n    }\n\n    buffer.push({ error: err })\n    return pushable\n  }\n\n  const push = (value: PushType): ReturnType => {\n    if (ended) {\n      return pushable\n    }\n\n    // @ts-expect-error `byteLength` is not declared on PushType\n    if (options?.objectMode !== true && value?.byteLength == null) {\n      throw new Error('objectMode was not true but tried to push non-Uint8Array value')\n    }\n\n    return bufferNext({ done: false, value })\n  }\n  const end = (err?: Error): ReturnType => {\n    if (ended) return pushable\n    ended = true\n\n    return (err != null) ? bufferError(err) : bufferNext({ done: true })\n  }\n  const _return = (): DoneResult => {\n    buffer = new FIFO()\n    end()\n\n    return { done: true }\n  }\n  const _throw = (err: Error): DoneResult => {\n    end(err)\n\n    return { done: true }\n  }\n\n  pushable = {\n    [Symbol.asyncIterator] () { return this },\n    next: waitNext,\n    return: _return,\n    throw: _throw,\n    push,\n    end,\n    get readableLength (): number {\n      return buffer.size\n    },\n    onEmpty: async (options?: AbortOptions) => {\n      const signal = options?.signal\n      signal?.throwIfAborted()\n\n      if (buffer.isEmpty()) {\n        return\n      }\n\n      let cancel: Promise<void> | undefined\n      let listener: (() => void) | undefined\n\n      if (signal != null) {\n        cancel = new Promise((resolve, reject) => {\n          listener = () => {\n            reject(new AbortError())\n          }\n\n          signal.addEventListener('abort', listener)\n        })\n      }\n\n      try {\n        await Promise.race([\n          drain.promise,\n          cancel\n        ])\n      } finally {\n        if (listener != null && signal != null) {\n          signal?.removeEventListener('abort', listener)\n        }\n      }\n    }\n  }\n\n  if (onEnd == null) {\n    return pushable\n  }\n\n  const _pushable = pushable\n\n  pushable = {\n    [Symbol.asyncIterator] () { return this },\n    next () {\n      return _pushable.next()\n    },\n    throw (err: Error) {\n      _pushable.throw(err)\n\n      if (onEnd != null) {\n        onEnd(err)\n        onEnd = undefined\n      }\n\n      return { done: true }\n    },\n    return () {\n      _pushable.return()\n\n      if (onEnd != null) {\n        onEnd()\n        onEnd = undefined\n      }\n\n      return { done: true }\n    },\n    push,\n    end (err: Error) {\n      _pushable.end(err)\n\n      if (onEnd != null) {\n        onEnd(err)\n        onEnd = undefined\n      }\n\n      return pushable\n    },\n    get readableLength () {\n      return _pushable.readableLength\n    },\n    onEmpty: (opts?: AbortOptions) => {\n      return _pushable.onEmpty(opts)\n    }\n  }\n\n  return pushable\n}\n", "/**\n * An abort error class that extends error\n */\nexport class AbortError extends Error {\n  public type: string\n  public code: string | string\n\n  constructor (message?: string, code?: string, name?: string) {\n    super(message ?? 'The operation was aborted')\n    this.type = 'aborted'\n    this.name = name ?? 'AbortError'\n    this.code = code ?? 'ABORT_ERR'\n  }\n}\n\nexport interface RaceSignalOptions {\n  /**\n   * The message for the error thrown if the signal aborts\n   */\n  errorMessage?: string\n\n  /**\n   * The code for the error thrown if the signal aborts\n   */\n  errorCode?: string\n\n  /**\n   * The name for the error thrown if the signal aborts\n   */\n  errorName?: string\n}\n\n/**\n * Race a promise against an abort signal\n */\nexport async function raceSignal <T> (promise: Promise<T>, signal?: AbortSignal, opts?: RaceSignalOptions): Promise<T> {\n  if (signal == null) {\n    return promise\n  }\n\n  if (signal.aborted) {\n    // the passed promise may yet resolve or reject but the use has signalled\n    // they are no longer interested so smother the error\n    promise.catch(() => {})\n    return Promise.reject(new AbortError(opts?.errorMessage, opts?.errorCode, opts?.errorName))\n  }\n\n  let listener\n\n  // create the error here so we have more context in the stack trace\n  const error = new AbortError(opts?.errorMessage, opts?.errorCode, opts?.errorName)\n\n  try {\n    return await Promise.race([\n      promise,\n      new Promise<T>((resolve, reject) => {\n        listener = () => {\n          reject(error)\n        }\n        signal.addEventListener('abort', listener)\n      })\n    ])\n  } finally {\n    if (listener != null) {\n      signal.removeEventListener('abort', listener)\n    }\n  }\n}\n", "/**\n * @packageDocumentation\n *\n * A pushable async generator that waits until the current value is consumed\n * before allowing a new value to be pushed.\n *\n * Useful for when you don't want to keep memory usage under control and/or\n * allow a downstream consumer to dictate how fast data flows through a pipe,\n * but you want to be able to apply a transform to that data.\n *\n * @example\n *\n * ```typescript\n * import { queuelessPushable } from 'it-queueless-pushable'\n *\n * const pushable = queuelessPushable<string>()\n *\n * // run asynchronously\n * Promise.resolve().then(async () => {\n *   // push a value - the returned promise will not resolve until the value is\n *   // read from the pushable\n *   await pushable.push('hello')\n * })\n *\n * // read a value\n * const result = await pushable.next()\n * console.info(result) // { done: false, value: 'hello' }\n * ```\n */\n\nimport deferred from 'p-defer'\nimport { raceSignal } from 'race-signal'\nimport type { AbortOptions } from 'abort-error'\nimport type { RaceSignalOptions } from 'race-signal'\n\nexport interface Pushable<T> extends AsyncGenerator<T, void, unknown> {\n  /**\n   * End the iterable after all values in the buffer (if any) have been yielded. If an\n   * error is passed the buffer is cleared immediately and the next iteration will\n   * throw the passed error\n   */\n  end(err?: Error, options?: AbortOptions & RaceSignalOptions): Promise<void>\n\n  /**\n   * Push a value into the iterable. Values are yielded from the iterable in the order\n   * they are pushed. Values not yet consumed from the iterable are buffered.\n   */\n  push(value: T, options?: AbortOptions & RaceSignalOptions): Promise<void>\n}\n\nclass QueuelessPushable <T> implements Pushable<T> {\n  private readNext: PromiseWithResolvers<void>\n  private haveNext: PromiseWithResolvers<void>\n  private ended: boolean\n  private nextResult: IteratorResult<T> | undefined\n  private error?: Error\n\n  constructor () {\n    this.ended = false\n\n    this.readNext = deferred()\n    this.haveNext = deferred()\n  }\n\n  [Symbol.asyncIterator] (): AsyncGenerator<T, void, unknown> {\n    return this\n  }\n\n  async next (): Promise<IteratorResult<T, void>> {\n    if (this.nextResult == null) {\n      // wait for the supplier to push a value\n      await this.haveNext.promise\n    }\n\n    if (this.nextResult == null) {\n      throw new Error('HaveNext promise resolved but nextResult was undefined')\n    }\n\n    const nextResult = this.nextResult\n    this.nextResult = undefined\n\n    // signal to the supplier that we read the value\n    this.readNext.resolve()\n    this.readNext = deferred()\n\n    return nextResult\n  }\n\n  async throw (err?: Error): Promise<IteratorReturnResult<undefined>> {\n    this.ended = true\n    this.error = err\n\n    if (err != null) {\n      // this can cause unhandled promise rejections if nothing is awaiting the\n      // next value so attach a dummy catch listener to the promise\n      this.haveNext.promise.catch(() => {})\n      this.haveNext.reject(err)\n    }\n\n    const result: IteratorReturnResult<undefined> = {\n      done: true,\n      value: undefined\n    }\n\n    return result\n  }\n\n  async return (): Promise<IteratorResult<T>> {\n    const result: IteratorReturnResult<undefined> = {\n      done: true,\n      value: undefined\n    }\n\n    this.ended = true\n    this.nextResult = result\n\n    // let the consumer know we have a new value\n    this.haveNext.resolve()\n\n    return result\n  }\n\n  async push (value: T, options?: AbortOptions & RaceSignalOptions): Promise<void> {\n    await this._push(value, options)\n  }\n\n  async end (err?: Error, options?: AbortOptions & RaceSignalOptions): Promise<void> {\n    if (err != null) {\n      await this.throw(err)\n    } else {\n      // abortable return\n      await this._push(undefined, options)\n    }\n  }\n\n  private async _push (value?: T, options?: AbortOptions & RaceSignalOptions): Promise<void> {\n    if (value != null && this.ended) {\n      throw this.error ?? new Error('Cannot push value onto an ended pushable')\n    }\n\n    // wait for all values to be read\n    while (this.nextResult != null) {\n      await this.readNext.promise\n    }\n\n    if (value != null) {\n      this.nextResult = { done: false, value }\n    } else {\n      this.ended = true\n      this.nextResult = { done: true, value: undefined }\n    }\n\n    // let the consumer know we have a new value\n    this.haveNext.resolve()\n    this.haveNext = deferred()\n\n    // wait for the consumer to have finished processing the value and requested\n    // the next one or for the passed signal to abort the waiting\n    await raceSignal(\n      this.readNext.promise,\n      options?.signal,\n      options\n    )\n  }\n}\n\nexport function queuelessPushable <T> (): Pushable<T> {\n  return new QueuelessPushable<T>()\n}\n", "/**\n * @packageDocumentation\n *\n * Merge several (async)iterables into one, yield values as they arrive.\n *\n * Nb. sources are iterated over in parallel so the order of emitted items is not guaranteed.\n *\n * @example\n *\n * ```javascript\n * import merge from 'it-merge'\n * import all from 'it-all'\n *\n * // This can also be an iterator, generator, etc\n * const values1 = [0, 1, 2, 3, 4]\n * const values2 = [5, 6, 7, 8, 9]\n *\n * const arr = all(merge(values1, values2))\n *\n * console.info(arr) // 0, 1, 2, 3, 4, 5, 6, 7, 8, 9\n * ```\n *\n * Async sources must be awaited:\n *\n * ```javascript\n * import merge from 'it-merge'\n * import all from 'it-all'\n *\n * // This can also be an iterator, async iterator, generator, etc\n * const values1 = async function * () {\n *   yield * [0, 1, 2, 3, 4]\n * }\n * const values2 = async function * () {\n *   yield * [5, 6, 7, 8, 9]\n * }\n *\n * const arr = await all(merge(values1(), values2()))\n *\n * console.info(arr) // 0, 1, 5, 6, 2, 3, 4, 7, 8, 9  <- nb. order is not guaranteed\n * ```\n */\n\nimport { queuelessPushable } from 'it-queueless-pushable'\nimport type { Pushable } from 'it-queueless-pushable'\n\nfunction isAsyncIterable <T> (thing: any): thing is AsyncIterable<T> {\n  return thing[Symbol.asyncIterator] != null\n}\n\nasync function addAllToPushable <T> (sources: Array<AsyncIterable<T> | Iterable<T>>, output: Pushable<T>, signal: AbortSignal): Promise<void> {\n  try {\n    await Promise.all(\n      sources.map(async (source) => {\n        for await (const item of source) {\n          await output.push(item, {\n            signal\n          })\n          signal.throwIfAborted()\n        }\n      })\n    )\n\n    await output.end(undefined, {\n      signal\n    })\n  } catch (err: any) {\n    await output.end(err, {\n      signal\n    })\n      .catch(() => {})\n  }\n}\n\nasync function * mergeSources <T> (sources: Array<AsyncIterable<T> | Iterable<T>>): AsyncGenerator<T, void, undefined> {\n  const controller = new AbortController()\n  const output = queuelessPushable<T>()\n\n  addAllToPushable(sources, output, controller.signal)\n    .catch(() => {})\n\n  try {\n    yield * output\n  } finally {\n    controller.abort()\n  }\n}\n\nfunction * mergeSyncSources <T> (syncSources: Array<Iterable<T>>): Generator<T, void, undefined> {\n  for (const source of syncSources) {\n    yield * source\n  }\n}\n\n/**\n * Treat one or more iterables as a single iterable.\n *\n * Nb. sources are iterated over in parallel so the\n * order of emitted items is not guaranteed.\n */\nfunction merge <T> (...sources: Array<Iterable<T>>): Generator<T, void, undefined>\nfunction merge <T> (...sources: Array<AsyncIterable<T> | Iterable<T>>): AsyncGenerator<T, void, undefined>\nfunction merge <T> (...sources: Array<AsyncIterable<T> | Iterable<T>>): AsyncGenerator<T, void, undefined> | Generator<T, void, undefined> {\n  const syncSources: Array<Iterable<T>> = []\n\n  for (const source of sources) {\n    if (!isAsyncIterable(source)) {\n      syncSources.push(source)\n    }\n  }\n\n  if (syncSources.length === sources.length) {\n    // all sources are synchronous\n    return mergeSyncSources(syncSources)\n  }\n\n  return mergeSources(sources)\n}\n\nexport default merge\n", "import { pushable } from 'it-pushable'\nimport merge from 'it-merge'\nimport type { Duplex, Transform, Sink } from 'it-stream-types'\n\ninterface SourceFn<A = any> { (): A }\n\ntype PipeSource<A = any> =\n  Iterable<A> |\n  AsyncIterable<A> |\n  SourceFn<A> |\n  Duplex<A, any, any>\n\ntype PipeTransform<A = any, B = any> =\n  Transform<A, B> |\n  Duplex<B, A>\n\ntype PipeSink<A = any, B = any> =\n  Sink<A, B> |\n  Duplex<any, A, B>\n\ntype PipeOutput<A> =\n  A extends Sink<any> ? ReturnType<A> :\n    A extends Duplex<any, any, any> ? ReturnType<A['sink']> :\n      never\n\n// single item pipe output includes pipe source types\ntype SingleItemPipeOutput<A> =\n  A extends Iterable<any> ? A :\n    A extends AsyncIterable<any> ? A :\n      A extends SourceFn ? ReturnType<A> :\n        A extends Duplex<any, any, any> ? A['source'] :\n          PipeOutput<A>\n\ntype PipeFnInput<A> =\n  A extends Iterable<any> ? A :\n    A extends AsyncIterable<any> ? A :\n      A extends SourceFn ? ReturnType<A> :\n        A extends Transform<any, any> ? ReturnType<A> :\n          A extends Duplex<any, any, any> ? A['source'] :\n            never\n\n// one item, just a pass-through\nexport function pipe<\n  A extends PipeSource\n> (\n  source: A\n): SingleItemPipeOutput<A>\n\n// two items, source to sink\nexport function pipe<\n  A extends PipeSource,\n  B extends PipeSink<PipeFnInput<A>>\n> (\n  source: A,\n  sink: B\n): PipeOutput<B>\n\n// three items, source to sink with transform(s) in between\nexport function pipe<\n  A extends PipeSource,\n  B extends PipeTransform<PipeFnInput<A>>,\n  C extends PipeSink<PipeFnInput<B>>\n> (\n  source: A,\n  transform1: B,\n  sink: C\n): PipeOutput<C>\n\n// many items, source to sink with transform(s) in between\nexport function pipe<\n  A extends PipeSource,\n  B extends PipeTransform<PipeFnInput<A>>,\n  C extends PipeTransform<PipeFnInput<B>>,\n  D extends PipeSink<PipeFnInput<C>>\n> (\n  source: A,\n  transform1: B,\n  transform2: C,\n  sink: D\n): PipeOutput<D>\n\n// lots of items, source to sink with transform(s) in between\nexport function pipe<\n  A extends PipeSource,\n  B extends PipeTransform<PipeFnInput<A>>,\n  C extends PipeTransform<PipeFnInput<B>>,\n  D extends PipeTransform<PipeFnInput<C>>,\n  E extends PipeSink<PipeFnInput<D>>\n> (\n  source: A,\n  transform1: B,\n  transform2: C,\n  transform3: D,\n  sink: E\n): PipeOutput<E>\n\n// lots of items, source to sink with transform(s) in between\nexport function pipe<\n  A extends PipeSource,\n  B extends PipeTransform<PipeFnInput<A>>,\n  C extends PipeTransform<PipeFnInput<B>>,\n  D extends PipeTransform<PipeFnInput<C>>,\n  E extends PipeTransform<PipeFnInput<D>>,\n  F extends PipeSink<PipeFnInput<E>>\n> (\n  source: A,\n  transform1: B,\n  transform2: C,\n  transform3: D,\n  transform4: E,\n  sink: F\n): PipeOutput<F>\n\n// lots of items, source to sink with transform(s) in between\nexport function pipe<\n  A extends PipeSource,\n  B extends PipeTransform<PipeFnInput<A>>,\n  C extends PipeTransform<PipeFnInput<B>>,\n  D extends PipeTransform<PipeFnInput<C>>,\n  E extends PipeTransform<PipeFnInput<D>>,\n  F extends PipeTransform<PipeFnInput<E>>,\n  G extends PipeSink<PipeFnInput<F>>\n> (\n  source: A,\n  transform1: B,\n  transform2: C,\n  transform3: D,\n  transform4: E,\n  transform5: F,\n  sink: G\n): PipeOutput<G>\n\n// lots of items, source to sink with transform(s) in between\nexport function pipe<\n  A extends PipeSource,\n  B extends PipeTransform<PipeFnInput<A>>,\n  C extends PipeTransform<PipeFnInput<B>>,\n  D extends PipeTransform<PipeFnInput<C>>,\n  E extends PipeTransform<PipeFnInput<D>>,\n  F extends PipeTransform<PipeFnInput<E>>,\n  G extends PipeTransform<PipeFnInput<F>>,\n  H extends PipeSink<PipeFnInput<G>>\n> (\n  source: A,\n  transform1: B,\n  transform2: C,\n  transform3: D,\n  transform4: E,\n  transform5: F,\n  transform6: G,\n  sink: H\n): PipeOutput<H>\n\n// lots of items, source to sink with transform(s) in between\nexport function pipe<\n  A extends PipeSource,\n  B extends PipeTransform<PipeFnInput<A>>,\n  C extends PipeTransform<PipeFnInput<B>>,\n  D extends PipeTransform<PipeFnInput<C>>,\n  E extends PipeTransform<PipeFnInput<D>>,\n  F extends PipeTransform<PipeFnInput<E>>,\n  G extends PipeTransform<PipeFnInput<F>>,\n  H extends PipeTransform<PipeFnInput<G>>,\n  I extends PipeSink<PipeFnInput<H>>\n> (\n  source: A,\n  transform1: B,\n  transform2: C,\n  transform3: D,\n  transform4: E,\n  transform5: F,\n  transform6: G,\n  transform7: H,\n  sink: I\n): PipeOutput<I>\n\n// lots of items, source to sink with transform(s) in between\nexport function pipe<\n  A extends PipeSource,\n  B extends PipeTransform<PipeFnInput<A>>,\n  C extends PipeTransform<PipeFnInput<B>>,\n  D extends PipeTransform<PipeFnInput<C>>,\n  E extends PipeTransform<PipeFnInput<D>>,\n  F extends PipeTransform<PipeFnInput<E>>,\n  G extends PipeTransform<PipeFnInput<F>>,\n  H extends PipeTransform<PipeFnInput<G>>,\n  I extends PipeTransform<PipeFnInput<H>>,\n  J extends PipeSink<PipeFnInput<I>>\n> (\n  source: A,\n  transform1: B,\n  transform2: C,\n  transform3: D,\n  transform4: E,\n  transform5: F,\n  transform6: G,\n  transform7: H,\n  transform8: I,\n  sink: J\n): PipeOutput<J>\n\n// lots of items, source to sink with transform(s) in between\nexport function pipe<\n  A extends PipeSource,\n  B extends PipeTransform<PipeFnInput<A>>,\n  C extends PipeTransform<PipeFnInput<B>>,\n  D extends PipeTransform<PipeFnInput<C>>,\n  E extends PipeTransform<PipeFnInput<D>>,\n  F extends PipeTransform<PipeFnInput<E>>,\n  G extends PipeTransform<PipeFnInput<F>>,\n  H extends PipeTransform<PipeFnInput<G>>,\n  I extends PipeTransform<PipeFnInput<H>>,\n  J extends PipeTransform<PipeFnInput<I>>,\n  K extends PipeSink<PipeFnInput<J>>\n> (\n  source: A,\n  transform1: B,\n  transform2: C,\n  transform3: D,\n  transform4: E,\n  transform5: F,\n  transform6: G,\n  transform7: H,\n  transform8: I,\n  transform9: J,\n  sink: K\n): PipeOutput<K>\n\n// lots of items, source to sink with transform(s) in between\nexport function pipe<\n  A extends PipeSource,\n  B extends PipeTransform<PipeFnInput<A>>,\n  C extends PipeTransform<PipeFnInput<B>>,\n  D extends PipeTransform<PipeFnInput<C>>,\n  E extends PipeTransform<PipeFnInput<D>>,\n  F extends PipeTransform<PipeFnInput<E>>,\n  G extends PipeTransform<PipeFnInput<F>>,\n  H extends PipeTransform<PipeFnInput<G>>,\n  I extends PipeTransform<PipeFnInput<H>>,\n  J extends PipeTransform<PipeFnInput<I>>,\n  K extends PipeTransform<PipeFnInput<J>>,\n  L extends PipeSink<PipeFnInput<K>>\n> (\n  source: A,\n  transform1: B,\n  transform2: C,\n  transform3: D,\n  transform4: E,\n  transform5: F,\n  transform6: G,\n  transform7: H,\n  transform8: I,\n  transform9: J,\n  transform10: K,\n  sink: L\n): PipeOutput<L>\n\nexport function pipe (first: any, ...rest: any[]): any {\n  if (first == null) {\n    throw new Error('Empty pipeline')\n  }\n\n  // Duplex at start: wrap in function and return duplex source\n  if (isDuplex(first)) {\n    const duplex = first\n    first = () => duplex.source\n  // Iterable at start: wrap in function\n  } else if (isIterable(first) || isAsyncIterable(first)) {\n    const source = first\n    first = () => source\n  }\n\n  const fns = [first, ...rest]\n\n  if (fns.length > 1) {\n    // Duplex at end: use duplex sink\n    if (isDuplex(fns[fns.length - 1])) {\n      fns[fns.length - 1] = fns[fns.length - 1].sink\n    }\n  }\n\n  if (fns.length > 2) {\n    // Duplex in the middle, consume source with duplex sink and return duplex source\n    for (let i = 1; i < fns.length - 1; i++) {\n      if (isDuplex(fns[i])) {\n        fns[i] = duplexPipelineFn(fns[i])\n      }\n    }\n  }\n\n  return rawPipe(...fns)\n}\n\nexport const rawPipe = (...fns: any): any => {\n  let res\n  while (fns.length > 0) {\n    res = fns.shift()(res)\n  }\n  return res\n}\n\nconst isAsyncIterable = (obj: any): obj is AsyncIterable<unknown> => {\n  return obj?.[Symbol.asyncIterator] != null\n}\n\nconst isIterable = (obj: any): obj is Iterable<unknown> => {\n  return obj?.[Symbol.iterator] != null\n}\n\nconst isDuplex = (obj: any): obj is Duplex => {\n  if (obj == null) {\n    return false\n  }\n\n  return obj.sink != null && obj.source != null\n}\n\nconst duplexPipelineFn = (duplex: Duplex<any, any, any>) => {\n  return (source: any) => {\n    const p = duplex.sink(source)\n\n    if (p?.then != null) {\n      const stream = pushable<any>({\n        objectMode: true\n      })\n      p.then(() => {\n        stream.end()\n      }, (err: Error) => {\n        stream.end(err)\n      })\n\n      let sourceWrap: () => Iterable<any> | AsyncIterable<any>\n      const source = duplex.source\n\n      if (isAsyncIterable(source)) {\n        sourceWrap = async function * () {\n          yield * source\n          stream.end()\n        }\n      } else if (isIterable(source)) {\n        sourceWrap = function * () {\n          yield * source\n          stream.end()\n        }\n      } else {\n        throw new Error('Unknown duplex source type - must be Iterable or AsyncIterable')\n      }\n\n      return merge(stream, sourceWrap())\n    }\n\n    return duplex.source\n  }\n}\n", "import filter from 'it-filter'\nimport map from 'it-map'\nimport parallel from 'it-parallel'\nimport { pipe } from 'it-pipe'\nimport { CustomProgressEvent } from 'progress-events'\nimport type { ExporterOptions, ExportWalk, UnixfsV1DirectoryContent, UnixfsV1Resolver } from '../../../index.js'\n\nconst directoryContent: UnixfsV1Resolver = (cid, node, unixfs, path, resolve, depth, blockstore) => {\n  async function * yieldDirectoryContent (options: ExporterOptions = {}): UnixfsV1DirectoryContent {\n    const offset = options.offset ?? 0\n    const length = options.length ?? node.Links.length\n    const links = node.Links.slice(offset, length)\n\n    options.onProgress?.(new CustomProgressEvent<ExportWalk>('unixfs:exporter:walk:directory', {\n      cid\n    }))\n\n    yield * pipe(\n      links,\n      source => map(source, link => {\n        return async () => {\n          const linkName = link.Name ?? ''\n          const linkPath = `${path}/${linkName}`\n          const result = await resolve(link.Hash, linkName, linkPath, [], depth + 1, blockstore, options)\n          return result.entry\n        }\n      }),\n      source => parallel(source, {\n        ordered: true,\n        concurrency: options.blockReadConcurrency\n      }),\n      source => filter(source, entry => entry != null)\n    )\n  }\n\n  return yieldDirectoryContent\n}\n\nexport default directoryContent\n", "import EventEmitter from './index.js'\n\nexport { EventEmitter }\nexport default EventEmitter\n", "export class TimeoutError extends Error {\n\tconstructor(message) {\n\t\tsuper(message);\n\t\tthis.name = 'TimeoutError';\n\t}\n}\n\n/**\nAn error to be thrown when the request is aborted by AbortController.\nDOMException is thrown instead of this Error when DOMException is available.\n*/\nexport class AbortError extends Error {\n\tconstructor(message) {\n\t\tsuper();\n\t\tthis.name = 'AbortError';\n\t\tthis.message = message;\n\t}\n}\n\n/**\nTODO: Remove AbortError and just throw DOMException when targeting Node 18.\n*/\nconst getDOMException = errorMessage => globalThis.DOMException === undefined\n\t? new AbortError(errorMessage)\n\t: new DOMException(errorMessage);\n\n/**\nTODO: Remove below function and just 'reject(signal.reason)' when targeting Node 18.\n*/\nconst getAbortedReason = signal => {\n\tconst reason = signal.reason === undefined\n\t\t? getDOMException('This operation was aborted.')\n\t\t: signal.reason;\n\n\treturn reason instanceof Error ? reason : getDOMException(reason);\n};\n\nexport default function pTimeout(promise, options) {\n\tconst {\n\t\tmilliseconds,\n\t\tfallback,\n\t\tmessage,\n\t\tcustomTimers = {setTimeout, clearTimeout},\n\t} = options;\n\n\tlet timer;\n\tlet abortHandler;\n\n\tconst wrappedPromise = new Promise((resolve, reject) => {\n\t\tif (typeof milliseconds !== 'number' || Math.sign(milliseconds) !== 1) {\n\t\t\tthrow new TypeError(`Expected \\`milliseconds\\` to be a positive number, got \\`${milliseconds}\\``);\n\t\t}\n\n\t\tif (options.signal) {\n\t\t\tconst {signal} = options;\n\t\t\tif (signal.aborted) {\n\t\t\t\treject(getAbortedReason(signal));\n\t\t\t}\n\n\t\t\tabortHandler = () => {\n\t\t\t\treject(getAbortedReason(signal));\n\t\t\t};\n\n\t\t\tsignal.addEventListener('abort', abortHandler, {once: true});\n\t\t}\n\n\t\tif (milliseconds === Number.POSITIVE_INFINITY) {\n\t\t\tpromise.then(resolve, reject);\n\t\t\treturn;\n\t\t}\n\n\t\t// We create the error outside of `setTimeout` to preserve the stack trace.\n\t\tconst timeoutError = new TimeoutError();\n\n\t\ttimer = customTimers.setTimeout.call(undefined, () => {\n\t\t\tif (fallback) {\n\t\t\t\ttry {\n\t\t\t\t\tresolve(fallback());\n\t\t\t\t} catch (error) {\n\t\t\t\t\treject(error);\n\t\t\t\t}\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (typeof promise.cancel === 'function') {\n\t\t\t\tpromise.cancel();\n\t\t\t}\n\n\t\t\tif (message === false) {\n\t\t\t\tresolve();\n\t\t\t} else if (message instanceof Error) {\n\t\t\t\treject(message);\n\t\t\t} else {\n\t\t\t\ttimeoutError.message = message ?? `Promise timed out after ${milliseconds} milliseconds`;\n\t\t\t\treject(timeoutError);\n\t\t\t}\n\t\t}, milliseconds);\n\n\t\t(async () => {\n\t\t\ttry {\n\t\t\t\tresolve(await promise);\n\t\t\t} catch (error) {\n\t\t\t\treject(error);\n\t\t\t}\n\t\t})();\n\t});\n\n\tconst cancelablePromise = wrappedPromise.finally(() => {\n\t\tcancelablePromise.clear();\n\t\tif (abortHandler && options.signal) {\n\t\t\toptions.signal.removeEventListener('abort', abortHandler);\n\t\t}\n\t});\n\n\tcancelablePromise.clear = () => {\n\t\tcustomTimers.clearTimeout.call(undefined, timer);\n\t\ttimer = undefined;\n\t};\n\n\treturn cancelablePromise;\n}\n", "// Port of lower_bound from https://en.cppreference.com/w/cpp/algorithm/lower_bound\n// Used to compute insertion index to keep queue sorted after insertion\nexport default function lowerBound(array, value, comparator) {\n    let first = 0;\n    let count = array.length;\n    while (count > 0) {\n        const step = Math.trunc(count / 2);\n        let it = first + step;\n        if (comparator(array[it], value) <= 0) {\n            first = ++it;\n            count -= step + 1;\n        }\n        else {\n            count = step;\n        }\n    }\n    return first;\n}\n", "import lowerBound from './lower-bound.js';\nexport default class PriorityQueue {\n    #queue = [];\n    enqueue(run, options) {\n        options = {\n            priority: 0,\n            ...options,\n        };\n        const element = {\n            priority: options.priority,\n            id: options.id,\n            run,\n        };\n        if (this.size === 0 || this.#queue[this.size - 1].priority >= options.priority) {\n            this.#queue.push(element);\n            return;\n        }\n        const index = lowerBound(this.#queue, element, (a, b) => b.priority - a.priority);\n        this.#queue.splice(index, 0, element);\n    }\n    setPriority(id, priority) {\n        const index = this.#queue.findIndex((element) => element.id === id);\n        if (index === -1) {\n            throw new ReferenceError(`No promise function with the id \"${id}\" exists in the queue.`);\n        }\n        const [item] = this.#queue.splice(index, 1);\n        this.enqueue(item.run, { priority, id });\n    }\n    dequeue() {\n        const item = this.#queue.shift();\n        return item?.run;\n    }\n    filter(options) {\n        return this.#queue.filter((element) => element.priority === options.priority).map((element) => element.run);\n    }\n    get size() {\n        return this.#queue.length;\n    }\n}\n", "import { EventEmitter } from 'eventemitter3';\nimport pTimeout, { TimeoutError } from 'p-timeout';\nimport PriorityQueue from './priority-queue.js';\n/**\nPromise queue with concurrency control.\n*/\nexport default class PQueue extends EventEmitter {\n    #carryoverConcurrencyCount;\n    #isIntervalIgnored;\n    #intervalCount = 0;\n    #intervalCap;\n    #interval;\n    #intervalEnd = 0;\n    #intervalId;\n    #timeoutId;\n    #queue;\n    #queueClass;\n    #pending = 0;\n    // The `!` is needed because of https://github.com/microsoft/TypeScript/issues/32194\n    #concurrency;\n    #isPaused;\n    #throwOnTimeout;\n    // Use to assign a unique identifier to a promise function, if not explicitly specified\n    #idAssigner = 1n;\n    /**\n    Per-operation timeout in milliseconds. Operations fulfill once `timeout` elapses if they haven't already.\n\n    Applies to each future operation.\n    */\n    timeout;\n    // TODO: The `throwOnTimeout` option should affect the return types of `add()` and `addAll()`\n    constructor(options) {\n        super();\n        // eslint-disable-next-line @typescript-eslint/consistent-type-assertions\n        options = {\n            carryoverConcurrencyCount: false,\n            intervalCap: Number.POSITIVE_INFINITY,\n            interval: 0,\n            concurrency: Number.POSITIVE_INFINITY,\n            autoStart: true,\n            queueClass: PriorityQueue,\n            ...options,\n        };\n        if (!(typeof options.intervalCap === 'number' && options.intervalCap >= 1)) {\n            throw new TypeError(`Expected \\`intervalCap\\` to be a number from 1 and up, got \\`${options.intervalCap?.toString() ?? ''}\\` (${typeof options.intervalCap})`);\n        }\n        if (options.interval === undefined || !(Number.isFinite(options.interval) && options.interval >= 0)) {\n            throw new TypeError(`Expected \\`interval\\` to be a finite number >= 0, got \\`${options.interval?.toString() ?? ''}\\` (${typeof options.interval})`);\n        }\n        this.#carryoverConcurrencyCount = options.carryoverConcurrencyCount;\n        this.#isIntervalIgnored = options.intervalCap === Number.POSITIVE_INFINITY || options.interval === 0;\n        this.#intervalCap = options.intervalCap;\n        this.#interval = options.interval;\n        this.#queue = new options.queueClass();\n        this.#queueClass = options.queueClass;\n        this.concurrency = options.concurrency;\n        this.timeout = options.timeout;\n        this.#throwOnTimeout = options.throwOnTimeout === true;\n        this.#isPaused = options.autoStart === false;\n    }\n    get #doesIntervalAllowAnother() {\n        return this.#isIntervalIgnored || this.#intervalCount < this.#intervalCap;\n    }\n    get #doesConcurrentAllowAnother() {\n        return this.#pending < this.#concurrency;\n    }\n    #next() {\n        this.#pending--;\n        this.#tryToStartAnother();\n        this.emit('next');\n    }\n    #onResumeInterval() {\n        this.#onInterval();\n        this.#initializeIntervalIfNeeded();\n        this.#timeoutId = undefined;\n    }\n    get #isIntervalPaused() {\n        const now = Date.now();\n        if (this.#intervalId === undefined) {\n            const delay = this.#intervalEnd - now;\n            if (delay < 0) {\n                // Act as the interval was done\n                // We don't need to resume it here because it will be resumed on line 160\n                this.#intervalCount = (this.#carryoverConcurrencyCount) ? this.#pending : 0;\n            }\n            else {\n                // Act as the interval is pending\n                if (this.#timeoutId === undefined) {\n                    this.#timeoutId = setTimeout(() => {\n                        this.#onResumeInterval();\n                    }, delay);\n                }\n                return true;\n            }\n        }\n        return false;\n    }\n    #tryToStartAnother() {\n        if (this.#queue.size === 0) {\n            // We can clear the interval (\"pause\")\n            // Because we can redo it later (\"resume\")\n            if (this.#intervalId) {\n                clearInterval(this.#intervalId);\n            }\n            this.#intervalId = undefined;\n            this.emit('empty');\n            if (this.#pending === 0) {\n                this.emit('idle');\n            }\n            return false;\n        }\n        if (!this.#isPaused) {\n            const canInitializeInterval = !this.#isIntervalPaused;\n            if (this.#doesIntervalAllowAnother && this.#doesConcurrentAllowAnother) {\n                const job = this.#queue.dequeue();\n                if (!job) {\n                    return false;\n                }\n                this.emit('active');\n                job();\n                if (canInitializeInterval) {\n                    this.#initializeIntervalIfNeeded();\n                }\n                return true;\n            }\n        }\n        return false;\n    }\n    #initializeIntervalIfNeeded() {\n        if (this.#isIntervalIgnored || this.#intervalId !== undefined) {\n            return;\n        }\n        this.#intervalId = setInterval(() => {\n            this.#onInterval();\n        }, this.#interval);\n        this.#intervalEnd = Date.now() + this.#interval;\n    }\n    #onInterval() {\n        if (this.#intervalCount === 0 && this.#pending === 0 && this.#intervalId) {\n            clearInterval(this.#intervalId);\n            this.#intervalId = undefined;\n        }\n        this.#intervalCount = this.#carryoverConcurrencyCount ? this.#pending : 0;\n        this.#processQueue();\n    }\n    /**\n    Executes all queued functions until it reaches the limit.\n    */\n    #processQueue() {\n        // eslint-disable-next-line no-empty\n        while (this.#tryToStartAnother()) { }\n    }\n    get concurrency() {\n        return this.#concurrency;\n    }\n    set concurrency(newConcurrency) {\n        if (!(typeof newConcurrency === 'number' && newConcurrency >= 1)) {\n            throw new TypeError(`Expected \\`concurrency\\` to be a number from 1 and up, got \\`${newConcurrency}\\` (${typeof newConcurrency})`);\n        }\n        this.#concurrency = newConcurrency;\n        this.#processQueue();\n    }\n    async #throwOnAbort(signal) {\n        return new Promise((_resolve, reject) => {\n            signal.addEventListener('abort', () => {\n                reject(signal.reason);\n            }, { once: true });\n        });\n    }\n    /**\n    Updates the priority of a promise function by its id, affecting its execution order. Requires a defined concurrency limit to take effect.\n\n    For example, this can be used to prioritize a promise function to run earlier.\n\n    ```js\n    import PQueue from 'p-queue';\n\n    const queue = new PQueue({concurrency: 1});\n\n    queue.add(async () => '\uD83E\uDD84', {priority: 1});\n    queue.add(async () => '\uD83E\uDD80', {priority: 0, id: '\uD83E\uDD80'});\n    queue.add(async () => '\uD83E\uDD84', {priority: 1});\n    queue.add(async () => '\uD83E\uDD84', {priority: 1});\n\n    queue.setPriority('\uD83E\uDD80', 2);\n    ```\n\n    In this case, the promise function with `id: '\uD83E\uDD80'` runs second.\n\n    You can also deprioritize a promise function to delay its execution:\n\n    ```js\n    import PQueue from 'p-queue';\n\n    const queue = new PQueue({concurrency: 1});\n\n    queue.add(async () => '\uD83E\uDD84', {priority: 1});\n    queue.add(async () => '\uD83E\uDD80', {priority: 1, id: '\uD83E\uDD80'});\n    queue.add(async () => '\uD83E\uDD84');\n    queue.add(async () => '\uD83E\uDD84', {priority: 0});\n\n    queue.setPriority('\uD83E\uDD80', -1);\n    ```\n    Here, the promise function with `id: '\uD83E\uDD80'` executes last.\n    */\n    setPriority(id, priority) {\n        this.#queue.setPriority(id, priority);\n    }\n    async add(function_, options = {}) {\n        // In case `id` is not defined.\n        options.id ??= (this.#idAssigner++).toString();\n        options = {\n            timeout: this.timeout,\n            throwOnTimeout: this.#throwOnTimeout,\n            ...options,\n        };\n        return new Promise((resolve, reject) => {\n            this.#queue.enqueue(async () => {\n                this.#pending++;\n                this.#intervalCount++;\n                try {\n                    options.signal?.throwIfAborted();\n                    let operation = function_({ signal: options.signal });\n                    if (options.timeout) {\n                        operation = pTimeout(Promise.resolve(operation), { milliseconds: options.timeout });\n                    }\n                    if (options.signal) {\n                        operation = Promise.race([operation, this.#throwOnAbort(options.signal)]);\n                    }\n                    const result = await operation;\n                    resolve(result);\n                    this.emit('completed', result);\n                }\n                catch (error) {\n                    if (error instanceof TimeoutError && !options.throwOnTimeout) {\n                        resolve();\n                        return;\n                    }\n                    reject(error);\n                    this.emit('error', error);\n                }\n                finally {\n                    this.#next();\n                }\n            }, options);\n            this.emit('add');\n            this.#tryToStartAnother();\n        });\n    }\n    async addAll(functions, options) {\n        return Promise.all(functions.map(async (function_) => this.add(function_, options)));\n    }\n    /**\n    Start (or resume) executing enqueued tasks within concurrency limit. No need to call this if queue is not paused (via `options.autoStart = false` or by `.pause()` method.)\n    */\n    start() {\n        if (!this.#isPaused) {\n            return this;\n        }\n        this.#isPaused = false;\n        this.#processQueue();\n        return this;\n    }\n    /**\n    Put queue execution on hold.\n    */\n    pause() {\n        this.#isPaused = true;\n    }\n    /**\n    Clear the queue.\n    */\n    clear() {\n        this.#queue = new this.#queueClass();\n    }\n    /**\n    Can be called multiple times. Useful if you for example add additional items at a later time.\n\n    @returns A promise that settles when the queue becomes empty.\n    */\n    async onEmpty() {\n        // Instantly resolve if the queue is empty\n        if (this.#queue.size === 0) {\n            return;\n        }\n        await this.#onEvent('empty');\n    }\n    /**\n    @returns A promise that settles when the queue size is less than the given limit: `queue.size < limit`.\n\n    If you want to avoid having the queue grow beyond a certain size you can `await queue.onSizeLessThan()` before adding a new item.\n\n    Note that this only limits the number of items waiting to start. There could still be up to `concurrency` jobs already running that this call does not include in its calculation.\n    */\n    async onSizeLessThan(limit) {\n        // Instantly resolve if the queue is empty.\n        if (this.#queue.size < limit) {\n            return;\n        }\n        await this.#onEvent('next', () => this.#queue.size < limit);\n    }\n    /**\n    The difference with `.onEmpty` is that `.onIdle` guarantees that all work from the queue has finished. `.onEmpty` merely signals that the queue is empty, but it could mean that some promises haven't completed yet.\n\n    @returns A promise that settles when the queue becomes empty, and all promises have completed; `queue.size === 0 && queue.pending === 0`.\n    */\n    async onIdle() {\n        // Instantly resolve if none pending and if nothing else is queued\n        if (this.#pending === 0 && this.#queue.size === 0) {\n            return;\n        }\n        await this.#onEvent('idle');\n    }\n    async #onEvent(event, filter) {\n        return new Promise(resolve => {\n            const listener = () => {\n                if (filter && !filter()) {\n                    return;\n                }\n                this.off(event, listener);\n                resolve();\n            };\n            this.on(event, listener);\n        });\n    }\n    /**\n    Size of the queue, the number of queued items waiting to run.\n    */\n    get size() {\n        return this.#queue.size;\n    }\n    /**\n    Size of the queue, filtered by the given options.\n\n    For example, this can be used to find the number of items remaining in the queue with a specific priority level.\n    */\n    sizeBy(options) {\n        // eslint-disable-next-line unicorn/no-array-callback-reference\n        return this.#queue.filter(options).length;\n    }\n    /**\n    Number of running items (no longer in the queue).\n    */\n    get pending() {\n        return this.#pending;\n    }\n    /**\n    Whether the queue is currently paused.\n    */\n    get isPaused() {\n        return this.#isPaused;\n    }\n}\n", "import * as dagPb from '@ipld/dag-pb'\nimport { UnixFS } from 'ipfs-unixfs'\nimport map from 'it-map'\nimport parallel from 'it-parallel'\nimport { pipe } from 'it-pipe'\nimport { pushable } from 'it-pushable'\nimport * as raw from 'multiformats/codecs/raw'\nimport PQueue from 'p-queue'\nimport { CustomProgressEvent } from 'progress-events'\nimport { NotUnixFSError, OverReadError, UnderReadError } from '../../../errors.js'\nimport extractDataFromBlock from '../../../utils/extract-data-from-block.js'\nimport validateOffsetAndLength from '../../../utils/validate-offset-and-length.js'\nimport type { ExporterOptions, UnixfsV1FileContent, UnixfsV1Resolver, ReadableStorage, ExportProgress, ExportWalk } from '../../../index.js'\nimport type { Pushable } from 'it-pushable'\n\nasync function walkDAG (blockstore: ReadableStorage, node: dagPb.PBNode | Uint8Array, queue: Pushable<Uint8Array>, streamPosition: bigint, start: bigint, end: bigint, options: ExporterOptions): Promise<void> {\n  // a `raw` node\n  if (node instanceof Uint8Array) {\n    const buf = extractDataFromBlock(node, streamPosition, start, end)\n\n    queue.push(buf)\n\n    return\n  }\n\n  if (node.Data == null) {\n    throw new NotUnixFSError('no data in PBNode')\n  }\n\n  let file: UnixFS\n\n  try {\n    file = UnixFS.unmarshal(node.Data)\n  } catch (err: any) {\n    throw new NotUnixFSError(err.message)\n  }\n\n  // might be a unixfs `raw` node or have data on intermediate nodes\n  if (file.data != null) {\n    const data = file.data\n    const buf = extractDataFromBlock(data, streamPosition, start, end)\n\n    queue.push(buf)\n\n    streamPosition += BigInt(buf.byteLength)\n  }\n\n  const childOps: Array<{ link: dagPb.PBLink, blockStart: bigint }> = []\n\n  if (node.Links.length !== file.blockSizes.length) {\n    throw new NotUnixFSError('Inconsistent block sizes and dag links')\n  }\n\n  for (let i = 0; i < node.Links.length; i++) {\n    const childLink = node.Links[i]\n    const childStart = streamPosition // inclusive\n    const childEnd = childStart + file.blockSizes[i] // exclusive\n\n    if ((start >= childStart && start < childEnd) || // child has offset byte\n        (end >= childStart && end <= childEnd) || // child has end byte\n        (start < childStart && end > childEnd)) { // child is between offset and end bytes\n      childOps.push({\n        link: childLink,\n        blockStart: streamPosition\n      })\n    }\n\n    streamPosition = childEnd\n\n    if (streamPosition > end) {\n      break\n    }\n  }\n\n  await pipe(\n    childOps,\n    (source) => map(source, (op) => {\n      return async () => {\n        const block = await blockstore.get(op.link.Hash, options)\n\n        return {\n          ...op,\n          block\n        }\n      }\n    }),\n    (source) => parallel(source, {\n      ordered: true,\n      concurrency: options.blockReadConcurrency\n    }),\n    async (source) => {\n      for await (const { link, block, blockStart } of source) {\n        let child: dagPb.PBNode | Uint8Array\n        switch (link.Hash.code) {\n          case dagPb.code:\n            child = dagPb.decode(block)\n            break\n          case raw.code:\n            child = block\n            break\n          default:\n            queue.end(new NotUnixFSError(`Unsupported codec: ${link.Hash.code}`))\n            return\n        }\n\n        // create a queue for this child - we use a queue instead of recursion\n        // to avoid overflowing the stack\n        const childQueue = new PQueue({\n          concurrency: 1\n        })\n        // if any of the child jobs error, end the read queue with the error\n        childQueue.on('error', error => {\n          queue.end(error)\n        })\n\n        // if the job rejects the 'error' event will be emitted on the child queue\n        void childQueue.add(async () => {\n          options.onProgress?.(new CustomProgressEvent<ExportWalk>('unixfs:exporter:walk:file', {\n            cid: link.Hash\n          }))\n\n          await walkDAG(blockstore, child, queue, blockStart, start, end, options)\n        })\n\n        // wait for this child to complete before moving on to the next\n        await childQueue.onIdle()\n      }\n    }\n  )\n\n  if (streamPosition >= end) {\n    queue.end()\n  }\n}\n\nconst fileContent: UnixfsV1Resolver = (cid, node, unixfs, path, resolve, depth, blockstore) => {\n  async function * yieldFileContent (options: ExporterOptions = {}): UnixfsV1FileContent {\n    const fileSize = unixfs.fileSize()\n\n    if (fileSize === undefined) {\n      throw new Error('File was a directory')\n    }\n\n    const {\n      start,\n      end\n    } = validateOffsetAndLength(fileSize, options.offset, options.length)\n\n    if (end === 0n) {\n      return\n    }\n\n    let read = 0n\n    const wanted = end - start\n    const queue = pushable()\n\n    options.onProgress?.(new CustomProgressEvent<ExportWalk>('unixfs:exporter:walk:file', {\n      cid\n    }))\n\n    void walkDAG(blockstore, node, queue, 0n, start, end, options)\n      .catch(err => {\n        queue.end(err)\n      })\n\n    for await (const buf of queue) {\n      if (buf == null) {\n        continue\n      }\n\n      read += BigInt(buf.byteLength)\n\n      if (read > wanted) {\n        queue.end()\n        throw new OverReadError('Read too many bytes - the file size reported by the UnixFS data in the root node may be incorrect')\n      }\n\n      if (read === wanted) {\n        queue.end()\n      }\n\n      options.onProgress?.(new CustomProgressEvent<ExportProgress>('unixfs:exporter:progress:unixfs:file', {\n        bytesRead: read,\n        totalBytes: wanted,\n        fileSize\n      }))\n\n      yield buf\n    }\n\n    if (read < wanted) {\n      throw new UnderReadError('Traversed entire DAG but did not read enough bytes')\n    }\n  }\n\n  return yieldFileContent\n}\n\nexport default fileContent\n", "import { decode } from '@ipld/dag-pb'\nimport { UnixFS } from 'ipfs-unixfs'\nimport map from 'it-map'\nimport parallel from 'it-parallel'\nimport { pipe } from 'it-pipe'\nimport { CustomProgressEvent } from 'progress-events'\nimport { NotUnixFSError } from '../../../errors.js'\nimport type { ExporterOptions, Resolve, UnixfsV1DirectoryContent, UnixfsV1Resolver, ReadableStorage, ExportWalk } from '../../../index.js'\nimport type { PBNode } from '@ipld/dag-pb'\n\nconst hamtShardedDirectoryContent: UnixfsV1Resolver = (cid, node, unixfs, path, resolve, depth, blockstore) => {\n  function yieldHamtDirectoryContent (options: ExporterOptions = {}): UnixfsV1DirectoryContent {\n    options.onProgress?.(new CustomProgressEvent<ExportWalk>('unixfs:exporter:walk:hamt-sharded-directory', {\n      cid\n    }))\n\n    return listDirectory(node, path, resolve, depth, blockstore, options)\n  }\n\n  return yieldHamtDirectoryContent\n}\n\nasync function * listDirectory (node: PBNode, path: string, resolve: Resolve, depth: number, blockstore: ReadableStorage, options: ExporterOptions): UnixfsV1DirectoryContent {\n  const links = node.Links\n\n  if (node.Data == null) {\n    throw new NotUnixFSError('no data in PBNode')\n  }\n\n  let dir: UnixFS\n  try {\n    dir = UnixFS.unmarshal(node.Data)\n  } catch (err: any) {\n    throw new NotUnixFSError(err.message)\n  }\n\n  if (dir.fanout == null) {\n    throw new NotUnixFSError('missing fanout')\n  }\n\n  const padLength = (dir.fanout - 1n).toString(16).length\n\n  const results = pipe(\n    links,\n    source => map(source, link => {\n      return async () => {\n        const name = link.Name != null ? link.Name.substring(padLength) : null\n\n        if (name != null && name !== '') {\n          const result = await resolve(link.Hash, name, `${path}/${name}`, [], depth + 1, blockstore, options)\n\n          return { entries: result.entry == null ? [] : [result.entry] }\n        } else {\n          // descend into subshard\n          const block = await blockstore.get(link.Hash, options)\n          node = decode(block)\n\n          options.onProgress?.(new CustomProgressEvent<ExportWalk>('unixfs:exporter:walk:hamt-sharded-directory', {\n            cid: link.Hash\n          }))\n\n          return { entries: listDirectory(node, path, resolve, depth, blockstore, options) }\n        }\n      }\n    }),\n    source => parallel(source, {\n      ordered: true,\n      concurrency: options.blockReadConcurrency\n    })\n  )\n\n  for await (const { entries } of results) {\n    yield * entries\n  }\n}\n\nexport default hamtShardedDirectoryContent\n", "import { decode } from '@ipld/dag-pb'\nimport { UnixFS } from 'ipfs-unixfs'\nimport { NotFoundError, NotUnixFSError } from '../../errors.js'\nimport findShardCid from '../../utils/find-cid-in-shard.js'\nimport contentDirectory from './content/directory.js'\nimport contentFile from './content/file.js'\nimport contentHamtShardedDirectory from './content/hamt-sharded-directory.js'\nimport type { Resolver, UnixfsV1Resolver } from '../../index.js'\nimport type { PBNode } from '@ipld/dag-pb'\nimport type { CID } from 'multiformats/cid'\n\nconst findLinkCid = (node: PBNode, name: string): CID | undefined => {\n  const link = node.Links.find(link => link.Name === name)\n\n  return link?.Hash\n}\n\nconst contentExporters: Record<string, UnixfsV1Resolver> = {\n  raw: contentFile,\n  file: contentFile,\n  directory: contentDirectory,\n  'hamt-sharded-directory': contentHamtShardedDirectory,\n  metadata: (cid, node, unixfs, path, resolve, depth, blockstore) => {\n    return () => []\n  },\n  symlink: (cid, node, unixfs, path, resolve, depth, blockstore) => {\n    return () => []\n  }\n}\n\n// @ts-expect-error types are wrong\nconst unixFsResolver: Resolver = async (cid, name, path, toResolve, resolve, depth, blockstore, options) => {\n  const block = await blockstore.get(cid, options)\n  const node = decode(block)\n  let unixfs\n  let next\n\n  if (name == null) {\n    name = cid.toString()\n  }\n\n  if (node.Data == null) {\n    throw new NotUnixFSError('no data in PBNode')\n  }\n\n  try {\n    unixfs = UnixFS.unmarshal(node.Data)\n  } catch (err: any) {\n    // non-UnixFS dag-pb node? It could happen.\n    throw new NotUnixFSError(err.message)\n  }\n\n  if (path == null) {\n    path = name\n  }\n\n  if (toResolve.length > 0) {\n    let linkCid\n\n    if (unixfs?.type === 'hamt-sharded-directory') {\n      // special case - unixfs v1 hamt shards\n      linkCid = await findShardCid(node, toResolve[0], blockstore)\n    } else {\n      linkCid = findLinkCid(node, toResolve[0])\n    }\n\n    if (linkCid == null) {\n      throw new NotFoundError('file does not exist')\n    }\n\n    // remove the path component we have resolved\n    const nextName = toResolve.shift()\n    const nextPath = `${path}/${nextName}`\n\n    next = {\n      cid: linkCid,\n      toResolve,\n      name: nextName ?? '',\n      path: nextPath\n    }\n  }\n\n  const content = contentExporters[unixfs.type](cid, node, unixfs, path, resolve, depth, blockstore)\n\n  if (content == null) {\n    throw new NotFoundError('could not find content exporter')\n  }\n\n  if (unixfs.isDirectory()) {\n    return {\n      entry: {\n        type: 'directory',\n        name,\n        path,\n        cid,\n        content,\n        unixfs,\n        depth,\n        node,\n        size: unixfs.fileSize()\n      },\n      next\n    }\n  }\n\n  return {\n    entry: {\n      type: 'file',\n      name,\n      path,\n      cid,\n      content,\n      unixfs,\n      depth,\n      node,\n      size: unixfs.fileSize()\n    },\n    next\n  }\n}\n\nexport default unixFsResolver\n", "import * as dagCbor from '@ipld/dag-cbor'\nimport * as dagJson from '@ipld/dag-json'\nimport * as dagPb from '@ipld/dag-pb'\nimport * as json from 'multiformats/codecs/json'\nimport * as raw from 'multiformats/codecs/raw'\nimport { identity } from 'multiformats/hashes/identity'\nimport { NoResolverError } from '../errors.js'\nimport dagCborResolver from './dag-cbor.js'\nimport dagJsonResolver from './dag-json.js'\nimport identifyResolver from './identity.js'\nimport jsonResolver from './json.js'\nimport rawResolver from './raw.js'\nimport dagPbResolver from './unixfs-v1/index.js'\nimport type { Resolve, Resolver } from '../index.js'\n\nconst resolvers: Record<number, Resolver> = {\n  [dagPb.code]: dagPbResolver,\n  [raw.code]: rawResolver,\n  [dagCbor.code]: dagCborResolver,\n  [dagJson.code]: dagJsonResolver,\n  [identity.code]: identifyResolver,\n  [json.code]: jsonResolver\n}\n\nconst resolve: Resolve = async (cid, name, path, toResolve, depth, blockstore, options) => {\n  const resolver = resolvers[cid.code]\n\n  if (resolver == null) {\n    throw new NoResolverError(`No resolver for code ${cid.code}`)\n  }\n\n  return resolver(cid, name, path, toResolve, resolve, depth, blockstore, options)\n}\n\nexport default resolve\n", "/**\n * @packageDocumentation\n *\n * The UnixFS Exporter provides a means to read DAGs from a blockstore given a CID.\n *\n * @example\n *\n * ```TypeScript\n * // import a file and export it again\n * import { importer } from 'ipfs-unixfs-importer'\n * import { exporter } from 'ipfs-unixfs-exporter'\n * import { MemoryBlockstore } from 'blockstore-core/memory'\n *\n * // Should contain the blocks we are trying to export\n * const blockstore = new MemoryBlockstore()\n * const files = []\n *\n * for await (const file of importer([{\n *   path: '/foo/bar.txt',\n *   content: new Uint8Array([0, 1, 2, 3])\n * }], blockstore)) {\n *   files.push(file)\n * }\n *\n * console.info(files[0].cid) // Qmbaz\n *\n * const entry = await exporter(files[0].cid, blockstore)\n *\n * if (entry.type !== 'file') {\n *   throw new Error('Unexpected entry type')\n * }\n *\n * console.info(entry.cid) // Qmqux\n * console.info(entry.path) // Qmbaz/foo/bar.txt\n * console.info(entry.name) // bar.txt\n * console.info(entry.unixfs.fileSize()) // 4\n *\n * // stream content from unixfs node\n * const size = entry.unixfs.fileSize()\n * const bytes = new Uint8Array(Number(size))\n * let offset = 0\n *\n * for await (const buf of entry.content()) {\n *   bytes.set(buf, offset)\n *   offset += buf.byteLength\n * }\n *\n * console.info(bytes) // 0, 1, 2, 3\n * ```\n */\n\nimport last from 'it-last'\nimport { CID } from 'multiformats/cid'\nimport { BadPathError, NotFoundError } from './errors.js'\nimport resolve from './resolvers/index.js'\nimport type { PBNode } from '@ipld/dag-pb'\nimport type { Bucket } from 'hamt-sharding'\nimport type { Blockstore } from 'interface-blockstore'\nimport type { UnixFS } from 'ipfs-unixfs'\nimport type { ProgressOptions, ProgressEvent } from 'progress-events'\n\nexport * from './errors.js'\n\nexport interface ExportProgress {\n  /**\n   * How many bytes of the file have been read\n   */\n  bytesRead: bigint\n\n  /**\n   * How many bytes of the file will be read - n.b. this may be\n   * smaller than `fileSize` if `offset`/`length` have been\n   * specified\n   */\n  totalBytes: bigint\n\n  /**\n   * The size of the file being read - n.b. this may be\n   * larger than `total` if `offset`/`length` has been\n   * specified\n   */\n  fileSize: bigint\n}\n\nexport interface ExportWalk {\n  cid: CID\n}\n\n/**\n * Progress events emitted by the exporter\n */\nexport type ExporterProgressEvents =\n  ProgressEvent<'unixfs:exporter:progress:unixfs:file', ExportProgress> |\n  ProgressEvent<'unixfs:exporter:progress:unixfs:raw', ExportProgress> |\n  ProgressEvent<'unixfs:exporter:progress:raw', ExportProgress> |\n  ProgressEvent<'unixfs:exporter:progress:identity', ExportProgress> |\n  ProgressEvent<'unixfs:exporter:walk:file', ExportWalk> |\n  ProgressEvent<'unixfs:exporter:walk:directory', ExportWalk> |\n  ProgressEvent<'unixfs:exporter:walk:hamt-sharded-directory', ExportWalk> |\n  ProgressEvent<'unixfs:exporter:walk:raw', ExportWalk>\n\nexport interface ExporterOptions extends ProgressOptions<ExporterProgressEvents> {\n  /**\n   * An optional offset to start reading at.\n   *\n   * If the CID resolves to a file this will be a byte offset within that file,\n   * otherwise if it's a directory it will be a directory entry offset within\n   * the directory listing. (default: undefined)\n   */\n  offset?: number\n\n  /**\n   * An optional length to read.\n   *\n   * If the CID resolves to a file this will be the number of bytes read from\n   * the file, otherwise if it's a directory it will be the number of directory\n   * entries read from the directory listing. (default: undefined)\n   */\n  length?: number\n\n  /**\n   * This signal can be used to abort any long-lived operations such as fetching\n   * blocks from the network. (default: undefined)\n   */\n  signal?: AbortSignal\n\n  /**\n   * When a DAG layer is encountered, all child nodes are loaded in parallel but\n   * processed as they arrive. This allows us to load sibling nodes in advance\n   * of yielding their bytes. Pass a value here to control the number of blocks\n   * loaded in parallel. If a strict depth-first traversal is required, this\n   * value should be set to `1`, otherwise the traversal order will tend to\n   * resemble a breadth-first fan-out and yield a have stable ordering.\n   * (default: undefined)\n   */\n  blockReadConcurrency?: number\n}\n\nexport interface Exportable<T> {\n  /**\n   * A disambiguator to allow TypeScript to work out the type of the entry.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * if (entry.type === 'file') {\n   *   // access UnixFSFile properties safely\n   * }\n   *\n   * if (entry.type === 'directory') {\n   *   // access UnixFSDirectory properties safely\n   * }\n   * ```\n   */\n  type: 'file' | 'directory' | 'object' | 'raw' | 'identity'\n\n  /**\n   * The name of the entry\n   */\n  name: string\n\n  /**\n   * The path of the entry within the DAG in which it was encountered\n   */\n  path: string\n\n  /**\n   * The CID of the entry\n   */\n  cid: CID\n\n  /**\n   * How far down the DAG the entry is\n   */\n  depth: number\n\n  /**\n   * The size of the entry\n   */\n  size: bigint\n\n  /**\n   * @example File content\n   *\n   * When `entry` is a file or a `raw` node, `offset` and/or `length` arguments can be passed to `entry.content()` to return slices of data:\n   *\n   * ```TypeScript\n   * const length = 5\n   * const data = new Uint8Array(length)\n   * let offset = 0\n   *\n   * for await (const chunk of entry.content({\n   *   offset: 0,\n   *   length\n   * })) {\n   *   data.set(chunk, offset)\n   *   offset += chunk.length\n   * }\n   *\n   * // `data` contains the first 5 bytes of the file\n   * return data\n   * ```\n   *\n   * @example Directory content\n   *\n   * If `entry` is a directory, passing `offset` and/or `length` to `entry.content()` will limit the number of files returned from the directory.\n   *\n   * ```TypeScript\n   * const entries = []\n   *\n   * for await (const entry of dir.content({\n   *   offset: 0,\n   *   length: 5\n   * })) {\n   *   entries.push(entry)\n   * }\n   *\n   * // `entries` contains the first 5 files/directories in the directory\n   * ```\n   */\n  content(options?: ExporterOptions): AsyncGenerator<T, void, unknown>\n}\n\n/**\n * If the entry is a file, `entry.content()` returns an async iterator that yields one or more Uint8Arrays containing the file content:\n *\n * ```TypeScript\n * if (entry.type === 'file') {\n *   for await (const chunk of entry.content()) {\n *     // chunk is a Buffer\n *   }\n * }\n * ```\n */\nexport interface UnixFSFile extends Exportable<Uint8Array> {\n  type: 'file'\n  unixfs: UnixFS\n  node: PBNode\n}\n\n/**\n * If the entry is a directory, `entry.content()` returns further `entry` objects:\n *\n * ```TypeScript\n * if (entry.type === 'directory') {\n *   for await (const entry of dir.content()) {\n *     console.info(entry.name)\n *   }\n * }\n * ```\n */\nexport interface UnixFSDirectory extends Exportable<UnixFSEntry> {\n  type: 'directory'\n  unixfs: UnixFS\n  node: PBNode\n}\n\n/**\n * Entries with a `dag-cbor` or `dag-json` codec {@link CID} return JavaScript object entries\n */\nexport interface ObjectNode extends Exportable<any> {\n  type: 'object'\n  node: Uint8Array\n}\n\n/**\n * Entries with a `raw` codec {@link CID} return raw entries.\n *\n * `entry.content()` returns an async iterator that yields a buffer containing the node content:\n *\n * ```TypeScript\n * for await (const chunk of entry.content()) {\n *   // chunk is a Buffer\n * }\n * ```\n *\n * Unless you an options object containing `offset` and `length` keys as an argument to `entry.content()`, `chunk` will be equal to `entry.node`.\n */\nexport interface RawNode extends Exportable<Uint8Array> {\n  type: 'raw'\n  node: Uint8Array\n}\n\n/**\n * Entries with a `identity` codec {@link CID} return identity entries.\n *\n * These are entries where the data payload is stored in the CID itself,\n * otherwise they are identical to {@link RawNode}s.\n */\nexport interface IdentityNode extends Exportable<Uint8Array> {\n  type: 'identity'\n  node: Uint8Array\n}\n\n/**\n * A UnixFSEntry is a representation of the types of node that can be\n * encountered in a DAG.\n */\nexport type UnixFSEntry = UnixFSFile | UnixFSDirectory | ObjectNode | RawNode | IdentityNode\n\nexport interface NextResult {\n  cid: CID\n  name: string\n  path: string\n  toResolve: string[]\n}\n\nexport interface ResolveResult {\n  entry: UnixFSEntry\n  next?: NextResult\n}\n\nexport interface Resolve { (cid: CID, name: string, path: string, toResolve: string[], depth: number, blockstore: ReadableStorage, options: ExporterOptions): Promise<ResolveResult> }\nexport interface Resolver { (cid: CID, name: string, path: string, toResolve: string[], resolve: Resolve, depth: number, blockstore: ReadableStorage, options: ExporterOptions): Promise<ResolveResult> }\n\nexport type UnixfsV1FileContent = AsyncIterable<Uint8Array> | Iterable<Uint8Array>\nexport type UnixfsV1DirectoryContent = AsyncIterable<UnixFSEntry> | Iterable<UnixFSEntry>\nexport type UnixfsV1Content = UnixfsV1FileContent | UnixfsV1DirectoryContent\nexport interface UnixfsV1Resolver { (cid: CID, node: PBNode, unixfs: UnixFS, path: string, resolve: Resolve, depth: number, blockstore: ReadableStorage): (options: ExporterOptions) => UnixfsV1Content }\n\nexport interface ShardTraversalContext {\n  hamtDepth: number\n  rootBucket: Bucket<boolean>\n  lastBucket: Bucket<boolean>\n}\n\n/**\n * A subset of the {@link Blockstore} interface that just contains the get\n * method.\n */\nexport type ReadableStorage = Pick<Blockstore, 'get'>\n\nconst toPathComponents = (path: string = ''): string[] => {\n  // split on / unless escaped with \\\n  return (path\n    .trim()\n    .match(/([^\\\\^/]|\\\\\\/)+/g) ?? [])\n    .filter(Boolean)\n}\n\nconst cidAndRest = (path: string | Uint8Array | CID): { cid: CID, toResolve: string[] } => {\n  if (path instanceof Uint8Array) {\n    return {\n      cid: CID.decode(path),\n      toResolve: []\n    }\n  }\n\n  const cid = CID.asCID(path)\n  if (cid != null) {\n    return {\n      cid,\n      toResolve: []\n    }\n  }\n\n  if (typeof path === 'string') {\n    if (path.indexOf('/ipfs/') === 0) {\n      path = path.substring(6)\n    }\n\n    const output = toPathComponents(path)\n\n    return {\n      cid: CID.parse(output[0]),\n      toResolve: output.slice(1)\n    }\n  }\n\n  throw new BadPathError(`Unknown path type ${path}`)\n}\n\n/**\n * Returns an async iterator that yields entries for all segments in a path\n *\n * @example\n *\n * ```TypeScript\n * import { walkPath } from 'ipfs-unixfs-exporter'\n *\n * const entries = []\n *\n * for await (const entry of walkPath('Qmfoo/foo/bar/baz.txt', blockstore)) {\n *   entries.push(entry)\n * }\n *\n * // entries contains 4x `entry` objects\n * ```\n */\nexport async function * walkPath (path: string | CID, blockstore: ReadableStorage, options: ExporterOptions = {}): AsyncGenerator<UnixFSEntry, void, any> {\n  let {\n    cid,\n    toResolve\n  } = cidAndRest(path)\n  let name = cid.toString()\n  let entryPath = name\n  const startingDepth = toResolve.length\n\n  while (true) {\n    const result = await resolve(cid, name, entryPath, toResolve, startingDepth, blockstore, options)\n\n    if (result.entry == null && result.next == null) {\n      throw new NotFoundError(`Could not resolve ${path}`)\n    }\n\n    if (result.entry != null) {\n      yield result.entry\n    }\n\n    if (result.next == null) {\n      return\n    }\n\n    // resolve further parts\n    toResolve = result.next.toResolve\n    cid = result.next.cid\n    name = result.next.name\n    entryPath = result.next.path\n  }\n}\n\n/**\n * Uses the given blockstore instance to fetch an IPFS node by a CID or path.\n *\n * Returns a {@link Promise} which resolves to a {@link UnixFSEntry}.\n *\n * @example\n *\n * ```typescript\n * import { exporter } from 'ipfs-unixfs-exporter'\n * import { CID } from 'multiformats/cid'\n *\n * const cid = CID.parse('QmFoo')\n *\n * const entry = await exporter(cid, blockstore, {\n *   signal: AbortSignal.timeout(50000)\n * })\n *\n * if (entry.type === 'file') {\n *   for await (const chunk of entry.content()) {\n *     // chunk is a Uint8Array\n *   }\n * }\n * ```\n */\nexport async function exporter (path: string | CID, blockstore: ReadableStorage, options: ExporterOptions = {}): Promise<UnixFSEntry> {\n  const result = await last(walkPath(path, blockstore, options))\n\n  if (result == null) {\n    throw new NotFoundError(`Could not resolve ${path}`)\n  }\n\n  return result\n}\n\n/**\n * Returns an async iterator that yields all entries beneath a given CID or IPFS\n * path, as well as the containing directory.\n *\n * @example\n *\n * ```typescript\n * import { recursive } from 'ipfs-unixfs-exporter'\n *\n * const entries = []\n *\n * for await (const child of recursive('Qmfoo/foo/bar', blockstore)) {\n *   entries.push(entry)\n * }\n *\n * // entries contains all children of the `Qmfoo/foo/bar` directory and it's children\n * ```\n */\nexport async function * recursive (path: string | CID, blockstore: ReadableStorage, options: ExporterOptions = {}): AsyncGenerator<UnixFSEntry, void, any> {\n  const node = await exporter(path, blockstore, options)\n\n  if (node == null) {\n    return\n  }\n\n  yield node\n\n  if (node.type === 'directory') {\n    for await (const child of recurse(node, options)) {\n      yield child\n    }\n  }\n\n  async function * recurse (node: UnixFSDirectory, options: ExporterOptions): AsyncGenerator<UnixFSEntry, void, any> {\n    for await (const file of node.content(options)) {\n      yield file\n\n      if (file instanceof Uint8Array) {\n        continue\n      }\n\n      if (file.type === 'directory') {\n        yield * recurse(file, options)\n      }\n    }\n  }\n}\n", "// Helpers.\nconst s = 1000;\nconst m = s * 60;\nconst h = m * 60;\nconst d = h * 24;\nconst w = d * 7;\nconst y = d * 365.25;\nfunction ms(value, options) {\n    try {\n        if (typeof value === 'string' && value.length > 0) {\n            return parse(value);\n        }\n        else if (typeof value === 'number' && isFinite(value)) {\n            return options?.long ? fmtLong(value) : fmtShort(value);\n        }\n        throw new Error('Value is not a string or number.');\n    }\n    catch (error) {\n        const message = isError(error)\n            ? `${error.message}. value=${JSON.stringify(value)}`\n            : 'An unknown error has occured.';\n        throw new Error(message);\n    }\n}\n/**\n * Parse the given `str` and return milliseconds.\n */\nfunction parse(str) {\n    str = String(str);\n    if (str.length > 100) {\n        throw new Error('Value exceeds the maximum length of 100 characters.');\n    }\n    const match = /^(-?(?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);\n    if (!match) {\n        return NaN;\n    }\n    const n = parseFloat(match[1]);\n    const type = (match[2] || 'ms').toLowerCase();\n    switch (type) {\n        case 'years':\n        case 'year':\n        case 'yrs':\n        case 'yr':\n        case 'y':\n            return n * y;\n        case 'weeks':\n        case 'week':\n        case 'w':\n            return n * w;\n        case 'days':\n        case 'day':\n        case 'd':\n            return n * d;\n        case 'hours':\n        case 'hour':\n        case 'hrs':\n        case 'hr':\n        case 'h':\n            return n * h;\n        case 'minutes':\n        case 'minute':\n        case 'mins':\n        case 'min':\n        case 'm':\n            return n * m;\n        case 'seconds':\n        case 'second':\n        case 'secs':\n        case 'sec':\n        case 's':\n            return n * s;\n        case 'milliseconds':\n        case 'millisecond':\n        case 'msecs':\n        case 'msec':\n        case 'ms':\n            return n;\n        default:\n            // This should never occur.\n            throw new Error(`The unit ${type} was matched, but no matching case exists.`);\n    }\n}\nexport default ms;\n/**\n * Short format for `ms`.\n */\nfunction fmtShort(ms) {\n    const msAbs = Math.abs(ms);\n    if (msAbs >= d) {\n        return `${Math.round(ms / d)}d`;\n    }\n    if (msAbs >= h) {\n        return `${Math.round(ms / h)}h`;\n    }\n    if (msAbs >= m) {\n        return `${Math.round(ms / m)}m`;\n    }\n    if (msAbs >= s) {\n        return `${Math.round(ms / s)}s`;\n    }\n    return `${ms}ms`;\n}\n/**\n * Long format for `ms`.\n */\nfunction fmtLong(ms) {\n    const msAbs = Math.abs(ms);\n    if (msAbs >= d) {\n        return plural(ms, msAbs, d, 'day');\n    }\n    if (msAbs >= h) {\n        return plural(ms, msAbs, h, 'hour');\n    }\n    if (msAbs >= m) {\n        return plural(ms, msAbs, m, 'minute');\n    }\n    if (msAbs >= s) {\n        return plural(ms, msAbs, s, 'second');\n    }\n    return `${ms} ms`;\n}\n/**\n * Pluralization helper.\n */\nfunction plural(ms, msAbs, n, name) {\n    const isPlural = msAbs >= n * 1.5;\n    return `${Math.round(ms / n)} ${name}${isPlural ? 's' : ''}`;\n}\n/**\n * A type guard for errors.\n */\nfunction isError(error) {\n    return typeof error === 'object' && error !== null && 'message' in error;\n}\n", "/* eslint-disable no-console */\n/* eslint-disable @typescript-eslint/strict-boolean-expressions */\n\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n */\nimport humanize from 'ms'\nimport type { Debug, Debugger } from './index.js'\n\nexport default function setup (env: any): Debug {\n  createDebug.debug = createDebug\n  createDebug.default = createDebug\n  createDebug.coerce = coerce\n  createDebug.disable = disable\n  createDebug.enable = enable\n  createDebug.enabled = enabled\n  createDebug.humanize = humanize\n  createDebug.destroy = destroy\n\n  Object.keys(env).forEach(key => {\n    // @ts-expect-error cannot use string to index type\n    createDebug[key] = env[key]\n  })\n\n  /**\n   * The currently active debug mode names, and names to skip.\n   */\n\n  createDebug.names = [] as any[]\n  createDebug.skips = [] as any[]\n\n  /**\n   * Map of special \"%n\" handling functions, for the debug \"format\" argument.\n   *\n   * Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n   */\n  createDebug.formatters = {} satisfies Record<string, any>\n\n  /**\n   * Selects a color for a debug namespace\n   *\n   * @param {string} namespace - The namespace string for the debug instance to be colored\n   * @returns {number | string} An ANSI color code for the given namespace\n   */\n  function selectColor (namespace: string): number | string {\n    let hash = 0\n\n    for (let i = 0; i < namespace.length; i++) {\n      hash = ((hash << 5) - hash) + namespace.charCodeAt(i)\n      hash |= 0 // Convert to 32bit integer\n    }\n\n    // @ts-expect-error colors is not in the types\n    return createDebug.colors[Math.abs(hash) % createDebug.colors.length]\n  }\n  createDebug.selectColor = selectColor\n\n  /**\n   * Create a debugger with the given `namespace`.\n   *\n   * @param {string} namespace\n   * @returns {Function}\n   */\n  function createDebug (namespace: string): Debugger {\n    let prevTime: any\n    let enableOverride: any = null\n    let namespacesCache: any\n    let enabledCache: any\n\n    function debug (...args: any[]): void {\n      // Disabled?\n      // @ts-expect-error enabled is not in the types\n      if (!debug.enabled) {\n        return\n      }\n\n      const self: any = debug\n\n      // Set `diff` timestamp\n      const curr = Number(new Date())\n      const ms = curr - (prevTime || curr)\n      self.diff = ms\n      self.prev = prevTime\n      self.curr = curr\n      prevTime = curr\n\n      args[0] = createDebug.coerce(args[0])\n\n      if (typeof args[0] !== 'string') {\n        // Anything else let's inspect with %O\n        args.unshift('%O')\n      }\n\n      // Apply any `formatters` transformations\n      let index = 0\n      args[0] = args[0].replace(/%([a-zA-Z%])/g, (match: any, format: any): any => {\n        // If we encounter an escaped % then don't increase the array index\n        if (match === '%%') {\n          return '%'\n        }\n        index++\n        // @ts-expect-error formatters is not in the types\n        const formatter = createDebug.formatters[format]\n        if (typeof formatter === 'function') {\n          const val = args[index]\n          match = formatter.call(self, val)\n\n          // Now we need to remove `args[index]` since it's inlined in the `format`\n          args.splice(index, 1)\n          index--\n        }\n        return match\n      })\n\n      // Apply env-specific formatting (colors, etc.)\n      // @ts-expect-error formatArgs is not in the types\n      createDebug.formatArgs.call(self, args)\n\n      // @ts-expect-error log is not in the types\n      const logFn = self.log || createDebug.log\n      logFn.apply(self, args)\n    }\n\n    debug.namespace = namespace\n    // @ts-expect-error useColors is not in the types\n    debug.useColors = createDebug.useColors()\n    debug.color = createDebug.selectColor(namespace)\n    debug.extend = extend\n    debug.destroy = createDebug.destroy // XXX Temporary. Will be removed in the next major release.\n\n    Object.defineProperty(debug, 'enabled', {\n      enumerable: true,\n      configurable: false,\n      get: () => {\n        if (enableOverride !== null) {\n          return enableOverride\n        }\n        // @ts-expect-error namespaces is not in the types\n        if (namespacesCache !== createDebug.namespaces) {\n          // @ts-expect-error namespaces is not in the types\n          namespacesCache = createDebug.namespaces\n          enabledCache = createDebug.enabled(namespace)\n        }\n\n        return enabledCache\n      },\n      set: v => {\n        enableOverride = v\n      }\n    })\n\n    // Env-specific initialization logic for debug instances\n    // @ts-expect-error init is not in the types\n    if (typeof createDebug.init === 'function') {\n      // @ts-expect-error init is not in the types\n      createDebug.init(debug)\n    }\n\n    // @ts-expect-error some properties are added dynamically\n    return debug\n  }\n\n  function extend (this: any, namespace: string, delimiter: string): any {\n    const newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace)\n    newDebug.log = this.log\n    return newDebug\n  }\n\n  /**\n   * Enables a debug mode by namespaces. This can include modes\n   * separated by a colon and wildcards.\n   *\n   * @param {string} namespaces\n   */\n  function enable (namespaces: string): void {\n    // @ts-expect-error save is not in the types\n    createDebug.save(namespaces)\n    // @ts-expect-error namespaces is not in the types\n    createDebug.namespaces = namespaces\n\n    createDebug.names = []\n    createDebug.skips = []\n\n    let i\n    const split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/)\n    const len = split.length\n\n    for (i = 0; i < len; i++) {\n      if (!split[i]) {\n        // ignore empty strings\n        continue\n      }\n\n      namespaces = split[i].replace(/\\*/g, '.*?')\n\n      if (namespaces[0] === '-') {\n        createDebug.skips.push(new RegExp('^' + namespaces.substr(1) + '$'))\n      } else {\n        createDebug.names.push(new RegExp('^' + namespaces + '$'))\n      }\n    }\n  }\n\n  /**\n   * Disable debug output.\n   *\n   * @returns {string} namespaces\n   */\n  function disable (): string {\n    const namespaces = [\n      ...createDebug.names.map(toNamespace),\n      ...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)\n    ].join(',')\n    createDebug.enable('')\n    return namespaces\n  }\n\n  /**\n   * Returns true if the given mode name is enabled, false otherwise.\n   *\n   * @param {string} name\n   * @returns {boolean}\n   */\n  function enabled (name: string): boolean {\n    if (name[name.length - 1] === '*') {\n      return true\n    }\n\n    let i\n    let len\n\n    for (i = 0, len = createDebug.skips.length; i < len; i++) {\n      if (createDebug.skips[i].test(name)) {\n        return false\n      }\n    }\n\n    for (i = 0, len = createDebug.names.length; i < len; i++) {\n      if (createDebug.names[i].test(name)) {\n        return true\n      }\n    }\n\n    return false\n  }\n\n  /**\n   * Convert regexp to namespace\n   */\n  function toNamespace (regexp: RegExp): string {\n    return regexp.toString()\n      .substring(2, regexp.toString().length - 2)\n      .replace(/\\.\\*\\?$/, '*')\n  }\n\n  /**\n   * Coerce `val`.\n   */\n  function coerce (val: any): any {\n    if (val instanceof Error) {\n      return val.stack ?? val.message\n    }\n    return val\n  }\n\n  /**\n   * XXX DO NOT USE. This is a temporary stub function.\n   * XXX It WILL be removed in the next major release.\n   */\n  function destroy (): void {\n    console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.')\n  }\n\n  // @ts-expect-error setupFormatters is not in the types\n  createDebug.setupFormatters(createDebug.formatters)\n\n  // @ts-expect-error load is not in the types\n  createDebug.enable(createDebug.load())\n\n  // @ts-expect-error some properties are added dynamically\n  return createDebug\n}\n", "/* eslint-disable no-console */\n/* eslint-disable @typescript-eslint/restrict-plus-operands */\n/* eslint-disable @typescript-eslint/strict-boolean-expressions */\n/* eslint-env browser */\n\n/**\n * This is the web browser implementation of `debug()`.\n */\nimport humanize from 'ms'\nimport setup from './common.js'\n\nconst storage = localstorage()\n\n/**\n * Colors.\n */\nconst colors = [\n  '#0000CC',\n  '#0000FF',\n  '#0033CC',\n  '#0033FF',\n  '#0066CC',\n  '#0066FF',\n  '#0099CC',\n  '#0099FF',\n  '#00CC00',\n  '#00CC33',\n  '#00CC66',\n  '#00CC99',\n  '#00CCCC',\n  '#00CCFF',\n  '#3300CC',\n  '#3300FF',\n  '#3333CC',\n  '#3333FF',\n  '#3366CC',\n  '#3366FF',\n  '#3399CC',\n  '#3399FF',\n  '#33CC00',\n  '#33CC33',\n  '#33CC66',\n  '#33CC99',\n  '#33CCCC',\n  '#33CCFF',\n  '#6600CC',\n  '#6600FF',\n  '#6633CC',\n  '#6633FF',\n  '#66CC00',\n  '#66CC33',\n  '#9900CC',\n  '#9900FF',\n  '#9933CC',\n  '#9933FF',\n  '#99CC00',\n  '#99CC33',\n  '#CC0000',\n  '#CC0033',\n  '#CC0066',\n  '#CC0099',\n  '#CC00CC',\n  '#CC00FF',\n  '#CC3300',\n  '#CC3333',\n  '#CC3366',\n  '#CC3399',\n  '#CC33CC',\n  '#CC33FF',\n  '#CC6600',\n  '#CC6633',\n  '#CC9900',\n  '#CC9933',\n  '#CCCC00',\n  '#CCCC33',\n  '#FF0000',\n  '#FF0033',\n  '#FF0066',\n  '#FF0099',\n  '#FF00CC',\n  '#FF00FF',\n  '#FF3300',\n  '#FF3333',\n  '#FF3366',\n  '#FF3399',\n  '#FF33CC',\n  '#FF33FF',\n  '#FF6600',\n  '#FF6633',\n  '#FF9900',\n  '#FF9933',\n  '#FFCC00',\n  '#FFCC33'\n]\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\n// eslint-disable-next-line complexity\nfunction useColors (): boolean {\n  // NB: In an Electron preload script, document will be defined but not fully\n  // initialized. Since we know we're in Chrome, we'll just detect this case\n  // explicitly\n  // @ts-expect-error window.process.type and window.process.__nwjs are not in the types\n  if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {\n    return true\n  }\n\n  // Internet Explorer and Edge do not support colors.\n  if (typeof navigator !== 'undefined' && (navigator.userAgent?.toLowerCase().match(/(edge|trident)\\/(\\d+)/) != null)) {\n    return false\n  }\n\n  // Is webkit? http://stackoverflow.com/a/16459606/376773\n  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n  // @ts-expect-error document.documentElement.style.WebkitAppearance is not in the types\n  return (typeof document !== 'undefined' && document.documentElement?.style?.WebkitAppearance) ||\n    // Is firebug? http://stackoverflow.com/a/398120/376773\n    // @ts-expect-error window.console.firebug and window.console.exception are not in the types\n    (typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||\n    // Is firefox >= v31?\n    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n    (typeof navigator !== 'undefined' && (navigator.userAgent?.toLowerCase().match(/firefox\\/(\\d+)/) != null) && parseInt(RegExp.$1, 10) >= 31) ||\n    // Double check webkit in userAgent just in case we are in a worker\n    (typeof navigator !== 'undefined' && navigator.userAgent?.toLowerCase().match(/applewebkit\\/(\\d+)/))\n}\n\n/**\n * Colorize log arguments if enabled.\n */\nfunction formatArgs (this: any, args: any[]): void {\n  args[0] = (this.useColors ? '%c' : '') +\n    this.namespace +\n    (this.useColors ? ' %c' : ' ') +\n    args[0] +\n    (this.useColors ? '%c ' : ' ') +\n    '+' + humanize(this.diff)\n\n  if (!this.useColors) {\n    return\n  }\n\n  const c = 'color: ' + this.color\n  args.splice(1, 0, c, 'color: inherit')\n\n  // The final \"%c\" is somewhat tricky, because there could be other\n  // arguments passed either before or after the %c, so we need to\n  // figure out the correct index to insert the CSS into\n  let index = 0\n  let lastC = 0\n  args[0].replace(/%[a-zA-Z%]/g, (match: string) => {\n    if (match === '%%') {\n      return\n    }\n    index++\n    if (match === '%c') {\n      // We only are interested in the *last* %c\n      // (the user may have provided their own)\n      lastC = index\n    }\n  })\n\n  args.splice(lastC, 0, c)\n}\n\n/**\n * Invokes `console.debug()` when available.\n * No-op when `console.debug` is not a \"function\".\n * If `console.debug` is not available, falls back\n * to `console.log`.\n */\nconst log = console.debug ?? console.log ?? (() => { })\n\n/**\n * Save `namespaces`.\n *\n * @param {string} namespaces\n */\nfunction save (namespaces: string): void {\n  try {\n    if (namespaces) {\n      storage?.setItem('debug', namespaces)\n    } else {\n      storage?.removeItem('debug')\n    }\n  } catch (error) {\n    // Swallow\n    // XXX (@Qix-) should we be logging these?\n  }\n}\n\n/**\n * Load `namespaces`.\n *\n * @returns {string} returns the previously persisted debug modes\n */\nfunction load (): string | null | undefined {\n  let r\n  try {\n    r = storage?.getItem('debug')\n  } catch (error) {\n    // Swallow\n    // XXX (@Qix-) should we be logging these?\n  }\n\n  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n  if (!r && typeof globalThis.process !== 'undefined' && 'env' in globalThis.process) {\n    r = globalThis.process.env.DEBUG\n  }\n\n  return r\n}\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n */\nfunction localstorage (): Storage | undefined {\n  try {\n    // TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context\n    // The Browser also has localStorage in the global context.\n    return localStorage\n  } catch (error) {\n    // Swallow\n    // XXX (@Qix-) should we be logging these?\n  }\n}\n\nfunction setupFormatters (formatters: any): void {\n  /**\n   * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n   */\n  formatters.j = function (v: any) {\n    try {\n      return JSON.stringify(v)\n    } catch (error: any) {\n      return '[UnexpectedJSONParseError]: ' + error.message\n    }\n  }\n}\n\nexport default setup({ formatArgs, save, load, useColors, setupFormatters, colors, storage, log })\n", "/**\n * @packageDocumentation\n *\n * This module is a fork of the [debug](https://www.npmjs.com/package/debug) module. It has been converted to TypeScript and the output is ESM.\n *\n * It is API compatible with no extra features or bug fixes, it should only be used if you want a 100% ESM application.\n *\n * ESM should be arriving in `debug@5.x.x` so this module can be retired after that.\n *\n * Please see [debug](https://www.npmjs.com/package/debug) for API details.\n */\n\n/**\n * Module dependencies.\n */\nimport weald from './node.js'\nimport type ms from 'ms'\n\nexport interface Debug {\n  (namespace: string): Debugger\n  coerce(val: any): any\n  disable(...args: string[]): string\n  enable(namespaces: string | boolean): void\n  enabled(namespaces: string): boolean\n  formatArgs(this: Debugger, args: any[]): void\n  log(...args: any[]): any\n  selectColor(namespace: string): string | number\n  humanize: typeof ms\n\n  names: RegExp[]\n  skips: RegExp[]\n\n  formatters: Formatters\n\n  inspectOpts?: {\n    hideDate?: boolean | number | null\n    colors?: boolean | number | null\n    depth?: boolean | number | null\n    showHidden?: boolean | number | null\n  }\n}\n\nexport type Formatters = Record<string, (v: any) => string>\n\nexport interface Debugger {\n  (formatter: any, ...args: any[]): void\n\n  color: string\n  diff: number\n  enabled: boolean\n  log(...args: any[]): any\n  namespace: string\n  destroy(): boolean\n  extend(namespace: string, delimiter?: string): Debugger\n}\n\nexport default weald\n", "/**\n * @packageDocumentation\n *\n * A logger for libp2p based on [weald](https://www.npmjs.com/package/weald), a TypeScript port of the venerable [debug](https://www.npmjs.com/package/debug) module.\n *\n * @example\n *\n * ```TypeScript\n * import { logger } from '@libp2p/logger'\n *\n * const log = logger('libp2p:my:component:name')\n *\n * try {\n *   // an operation\n *   log('something happened: %s', 'it was ok')\n * } catch (err) {\n *   log.error('something bad happened: %o', err)\n * }\n *\n * log('with this peer: %p', {})\n * log('and this base58btc: %b', Uint8Array.from([0, 1, 2, 3]))\n * log('and this base32: %t', Uint8Array.from([4, 5, 6, 7]))\n * ```\n *\n * ```console\n * $ DEBUG=libp2p:* node index.js\n * something happened: it was ok\n * something bad happened: <stack trace>\n * with this peer: 12D3Foo\n * with this base58btc: Qmfoo\n * with this base32: bafyfoo\n * ```\n */\n\nimport { base32 } from 'multiformats/bases/base32'\nimport { base58btc } from 'multiformats/bases/base58'\nimport { base64 } from 'multiformats/bases/base64'\nimport debug from 'weald'\nimport { truncatePeerId } from './utils.js'\nimport type { PeerId } from '@libp2p/interface'\nimport type { Multiaddr } from '@multiformats/multiaddr'\nimport type { Key } from 'interface-datastore'\nimport type { CID } from 'multiformats/cid'\n\n// Add a formatter for converting to a base58 string\ndebug.formatters.b = (v?: Uint8Array): string => {\n  return v == null ? 'undefined' : base58btc.baseEncode(v)\n}\n\n// Add a formatter for converting to a base32 string\ndebug.formatters.t = (v?: Uint8Array): string => {\n  return v == null ? 'undefined' : base32.baseEncode(v)\n}\n\n// Add a formatter for converting to a base64 string\ndebug.formatters.m = (v?: Uint8Array): string => {\n  return v == null ? 'undefined' : base64.baseEncode(v)\n}\n\n// Add a formatter for stringifying peer ids\ndebug.formatters.p = (v?: PeerId): string => {\n  return v == null ? 'undefined' : v.toString()\n}\n\n// Add a formatter for stringifying CIDs\ndebug.formatters.c = (v?: CID): string => {\n  return v == null ? 'undefined' : v.toString()\n}\n\n// Add a formatter for stringifying Datastore keys\ndebug.formatters.k = (v: Key): string => {\n  return v == null ? 'undefined' : v.toString()\n}\n\n// Add a formatter for stringifying Multiaddrs\ndebug.formatters.a = (v?: Multiaddr): string => {\n  return v == null ? 'undefined' : v.toString()\n}\n\n// Add a formatter for stringifying Errors\ndebug.formatters.e = (v?: Error): string => {\n  return v == null ? 'undefined' : notEmpty(v.stack) ?? notEmpty(v.message) ?? v.toString()\n}\n\nexport interface Logger {\n  (formatter: any, ...args: any[]): void\n  error(formatter: any, ...args: any[]): void\n  trace(formatter: any, ...args: any[]): void\n  enabled: boolean\n}\n\nexport interface ComponentLogger {\n  forComponent(name: string): Logger\n}\n\nfunction createDisabledLogger (namespace: string): debug.Debugger {\n  const logger = (): void => {}\n  logger.enabled = false\n  logger.color = ''\n  logger.diff = 0\n  logger.log = (): void => {}\n  logger.namespace = namespace\n  logger.destroy = () => true\n  logger.extend = () => logger\n\n  return logger\n}\n\nexport interface PeerLoggerOptions {\n  prefixLength: number\n  suffixLength: number\n}\n\n/**\n * Create a component logger that will prefix any log messages with a truncated\n * peer id.\n *\n * @example\n *\n * ```TypeScript\n * import { peerLogger } from '@libp2p/logger'\n * import { peerIdFromString } from '@libp2p/peer-id'\n *\n * const peerId = peerIdFromString('12D3FooBar')\n * const logger = peerLogger(peerId)\n *\n * const log = logger.forComponent('my-component')\n * log.info('hello world')\n * // logs \"12\u2026oBar:my-component hello world\"\n * ```\n */\nexport function peerLogger (peerId: PeerId, options: Partial<PeerLoggerOptions> = {}): ComponentLogger {\n  return prefixLogger(truncatePeerId(peerId, options))\n}\n\n/**\n * Create a component logger that will prefix any log messages with the passed\n * string.\n *\n * @example\n *\n * ```TypeScript\n * import { prefixLogger } from '@libp2p/logger'\n *\n * const logger = prefixLogger('my-node')\n *\n * const log = logger.forComponent('my-component')\n * log.info('hello world')\n * // logs \"my-node:my-component hello world\"\n * ```\n */\nexport function prefixLogger (prefix: string): ComponentLogger {\n  return {\n    forComponent (name: string) {\n      return logger(`${prefix}:${name}`)\n    }\n  }\n}\n\n/**\n * Create a component logger\n *\n * @example\n *\n * ```TypeScript\n * import { defaultLogger } from '@libp2p/logger'\n * import { peerIdFromString } from '@libp2p/peer-id'\n *\n * const logger = defaultLogger()\n *\n * const log = logger.forComponent('my-component')\n * log.info('hello world')\n * // logs \"my-component hello world\"\n * ```\n */\nexport function defaultLogger (): ComponentLogger {\n  return {\n    forComponent (name: string) {\n      return logger(name)\n    }\n  }\n}\n\n/**\n * Creates a logger for the passed component name.\n *\n * @example\n *\n * ```TypeScript\n * import { logger } from '@libp2p/logger'\n *\n * const log = logger('my-component')\n * log.info('hello world')\n * // logs \"my-component hello world\"\n * ```\n */\nexport function logger (name: string): Logger {\n  // trace logging is a no-op by default\n  let trace: debug.Debugger = createDisabledLogger(`${name}:trace`)\n\n  // look at all the debug names and see if trace logging has explicitly been enabled\n  if (debug.enabled(`${name}:trace`) && debug.names.map((r: any) => r.toString()).find((n: string) => n.includes(':trace')) != null) {\n    trace = debug(`${name}:trace`)\n  }\n\n  return Object.assign(debug(name), {\n    error: debug(`${name}:error`),\n    trace\n  })\n}\n\nexport function disable (): void {\n  debug.disable()\n}\n\nexport function enable (namespaces: string): void {\n  debug.enable(namespaces)\n}\n\nexport function enabled (namespaces: string): boolean {\n  return debug.enabled(namespaces)\n}\n\nfunction notEmpty (str?: string): string | undefined {\n  if (str == null) {\n    return\n  }\n\n  str = str.trim()\n\n  if (str.length === 0) {\n    return\n  }\n\n  return str\n}\n", "import * as dagPB from '@ipld/dag-pb'\nimport { logger } from '@libp2p/logger'\nimport { UnixFS } from 'ipfs-unixfs'\nimport { CID } from 'multiformats/cid'\nimport { sha256 } from 'multiformats/hashes/sha2'\n// @ts-expect-error no types\nimport SparseArray from 'sparse-array'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport { AlreadyExistsError, InvalidParametersError, InvalidPBNodeError } from '../../errors.js'\nimport { wrapHash } from './consumable-hash.js'\nimport { hamtBucketBits, hamtHashFn } from './hamt-constants.js'\nimport {\n  createShard,\n  recreateShardedDirectory,\n  toPrefix,\n  updateShardedDirectory\n} from './hamt-utils.js'\nimport { isOverShardThreshold } from './is-over-shard-threshold.js'\nimport type { Directory } from './cid-to-directory.js'\nimport type { GetStore, PutStore } from '../../unixfs.js'\nimport type { PBNode, PBLink } from '@ipld/dag-pb'\nimport type { AbortOptions } from '@libp2p/interface'\nimport type { ImportResult } from 'ipfs-unixfs-importer'\nimport type { Version } from 'multiformats/cid'\n\nconst log = logger('helia:unixfs:components:utils:add-link')\n\nexport interface AddLinkResult {\n  node: PBNode\n  cid: CID\n}\n\nexport interface AddLinkOptions extends AbortOptions {\n  allowOverwriting: boolean\n  shardSplitThresholdBytes: number\n  cidVersion: Version\n}\n\nexport async function addLink (parent: Directory, child: Required<PBLink>, blockstore: GetStore & PutStore, options: AddLinkOptions): Promise<AddLinkResult> {\n  if (parent.node.Data == null) {\n    throw new InvalidParametersError('Invalid parent passed to addLink')\n  }\n\n  const meta = UnixFS.unmarshal(parent.node.Data)\n\n  if (meta.type === 'hamt-sharded-directory') {\n    log('adding link to sharded directory')\n\n    return addToShardedDirectory(parent, child, blockstore, options)\n  }\n\n  log(`adding ${child.Name} (${child.Hash}) to regular directory`)\n\n  const result = await addToDirectory(parent, child, blockstore, options)\n\n  if (await isOverShardThreshold(result.node, blockstore, options.shardSplitThresholdBytes, options)) {\n    log('converting directory to sharded directory')\n\n    const converted = await convertToShardedDirectory(result, blockstore)\n    result.cid = converted.cid\n    result.node = dagPB.decode(await blockstore.get(converted.cid, options))\n  }\n\n  return result\n}\n\nconst convertToShardedDirectory = async (parent: Directory, blockstore: PutStore): Promise<ImportResult> => {\n  if (parent.node.Data == null) {\n    throw new InvalidParametersError('Invalid parent passed to convertToShardedDirectory')\n  }\n\n  const unixfs = UnixFS.unmarshal(parent.node.Data)\n\n  const result = await createShard(blockstore, parent.node.Links.map(link => ({\n    name: (link.Name ?? ''),\n    size: BigInt(link.Tsize ?? 0),\n    cid: link.Hash\n  })), {\n    mode: unixfs.mode,\n    mtime: unixfs.mtime,\n    cidVersion: parent.cid.version\n  })\n\n  log(`converted directory to sharded directory ${result.cid}`)\n\n  return result\n}\n\nconst addToDirectory = async (parent: Directory, child: PBLink, blockstore: PutStore, options: AddLinkOptions): Promise<AddLinkResult> => {\n  // Remove existing link if it exists\n  const parentLinks = parent.node.Links.filter((link) => {\n    const matches = link.Name === child.Name\n\n    if (matches && !options.allowOverwriting) {\n      throw new AlreadyExistsError()\n    }\n\n    return !matches\n  })\n  parentLinks.push(child)\n\n  if (parent.node.Data == null) {\n    throw new InvalidPBNodeError('Parent node with no data passed to addToDirectory')\n  }\n\n  const node = UnixFS.unmarshal(parent.node.Data)\n\n  let data\n  if (node.mtime != null) {\n    // Update mtime if previously set\n    const ms = Date.now()\n    const secs = Math.floor(ms / 1000)\n\n    node.mtime = {\n      secs: BigInt(secs),\n      nsecs: (ms - (secs * 1000)) * 1000\n    }\n\n    data = node.marshal()\n  } else {\n    data = parent.node.Data\n  }\n  parent.node = dagPB.prepare({\n    Data: data,\n    Links: parentLinks\n  })\n\n  // Persist the new parent PbNode\n  const buf = dagPB.encode(parent.node)\n  const hash = await sha256.digest(buf)\n  const cid = CID.create(parent.cid.version, dagPB.code, hash)\n\n  await blockstore.put(cid, buf)\n\n  return {\n    node: parent.node,\n    cid\n  }\n}\n\nconst addToShardedDirectory = async (parent: Directory, child: Required<PBLink>, blockstore: GetStore & PutStore, options: AddLinkOptions): Promise<AddLinkResult> => {\n  const { path, hash } = await recreateShardedDirectory(parent.cid, child.Name, blockstore, options)\n  const finalSegment = path[path.length - 1]\n\n  if (finalSegment == null) {\n    throw new Error('Invalid HAMT, could not generate path')\n  }\n\n  // find the next prefix\n  // const index = await hash.take(hamtBucketBits)\n  const prefix = finalSegment.prefix\n  const index = parseInt(prefix, 16)\n\n  log('next prefix for %s is %s', child.Name, prefix)\n\n  const linkName = `${prefix}${child.Name}`\n  const existingLink = finalSegment.node.Links.find(l => (l.Name ?? '').startsWith(prefix))\n\n  if (existingLink != null) {\n    log('link %s was present in shard', linkName)\n    // link is already present in shard\n\n    if (existingLink.Name === linkName) {\n      // file with same name is already present in shard\n      if (!options.allowOverwriting) {\n        throw new AlreadyExistsError()\n      }\n\n      log('overwriting %s in sub-shard', child.Name)\n      finalSegment.node.Links = finalSegment.node.Links.filter(l => l.Name !== linkName)\n      finalSegment.node.Links.push({\n        Name: linkName,\n        Hash: child.Hash,\n        Tsize: child.Tsize\n      })\n    } else if (existingLink.Name?.length === 2) {\n      throw new Error('Existing link was sub-shard?!')\n    } else {\n      // conflict, add a new HAMT segment\n      log('prefix %s already exists, creating new sub-shard', prefix)\n      // find the sibling we are going to replace\n      const index = finalSegment.node.Links.findIndex(l => l.Name?.startsWith(prefix))\n      const sibling = finalSegment.node.Links.splice(index, 1)[0]\n\n      // give the sibling a new HAMT prefix\n      const siblingName = (sibling.Name ?? '').substring(2)\n      const wrapped = wrapHash(hamtHashFn)\n      const siblingHash = wrapped(uint8ArrayFromString(siblingName))\n\n      // discard hash bits until we reach the sub-shard depth\n      for (let i = 0; i < path.length; i++) {\n        await siblingHash.take(hamtBucketBits)\n      }\n\n      while (true) {\n        const siblingIndex = await siblingHash.take(hamtBucketBits)\n        const siblingPrefix = toPrefix(siblingIndex)\n        sibling.Name = `${siblingPrefix}${siblingName}`\n\n        // calculate the target file's HAMT prefix in the new sub-shard\n        const newIndex = await hash.take(hamtBucketBits)\n        const newPrefix = toPrefix(newIndex)\n\n        if (siblingPrefix === newPrefix) {\n          // the two sibling names have caused another conflict - add an intermediate node to\n          // the HAMT and try again\n\n          // create the child locations\n          const children = new SparseArray()\n          children.set(newIndex, true)\n\n          path.push({\n            prefix: newPrefix,\n            children,\n            node: {\n              Links: []\n            }\n          })\n\n          continue\n        }\n\n        // create the child locations\n        const children = new SparseArray()\n        children.set(newIndex, true)\n        children.set(siblingIndex, true)\n\n        // add our new segment\n        path.push({\n          prefix,\n          children,\n          node: {\n            Links: [\n              sibling, {\n                Name: `${newPrefix}${child.Name}`,\n                Hash: child.Hash,\n                Tsize: child.Tsize\n              }\n            ]\n          }\n        })\n\n        break\n      }\n    }\n  } else {\n    log('link %s was not present in sub-shard', linkName)\n\n    // add new link to shard\n    child.Name = linkName\n    finalSegment.node.Links.push(child)\n    finalSegment.children.set(index, true)\n\n    log('adding %s to existing sub-shard', linkName)\n  }\n\n  return updateShardedDirectory(path, blockstore, options)\n}\n", "import { concat as uint8ArrayConcat } from 'uint8arrays/concat'\n\nexport function wrapHash (hashFn: (value: Uint8Array) => Promise<Uint8Array>): (value: InfiniteHash | Uint8Array) => InfiniteHash {\n  function hashing (value: InfiniteHash | Uint8Array): InfiniteHash {\n    if (value instanceof InfiniteHash) {\n      // already a hash. return it\n      return value\n    } else {\n      return new InfiniteHash(value, hashFn)\n    }\n  }\n\n  return hashing\n}\n\nexport class InfiniteHash {\n  _value: Uint8Array\n  _hashFn: (value: Uint8Array) => Promise<Uint8Array>\n  _depth: number\n  _availableBits: number\n  _currentBufferIndex: number\n  _buffers: ConsumableBuffer[]\n\n  constructor (value: Uint8Array, hashFn: (value: Uint8Array) => Promise<Uint8Array>) {\n    if (!(value instanceof Uint8Array)) {\n      throw new Error('can only hash Uint8Arrays')\n    }\n\n    this._value = value\n    this._hashFn = hashFn\n    this._depth = -1\n    this._availableBits = 0\n    this._currentBufferIndex = 0\n    this._buffers = []\n  }\n\n  async take (bits: number): Promise<number> {\n    let pendingBits = bits\n\n    while (this._availableBits < pendingBits) {\n      await this._produceMoreBits()\n    }\n\n    let result = 0\n\n    while (pendingBits > 0) {\n      const hash = this._buffers[this._currentBufferIndex]\n      const available = Math.min(hash.availableBits(), pendingBits)\n      const took = hash.take(available)\n      result = (result << available) + took\n      pendingBits -= available\n      this._availableBits -= available\n\n      if (hash.availableBits() === 0) {\n        this._currentBufferIndex++\n      }\n    }\n\n    return result\n  }\n\n  untake (bits: number): void {\n    let pendingBits = bits\n\n    while (pendingBits > 0) {\n      const hash = this._buffers[this._currentBufferIndex]\n      const availableForUntake = Math.min(hash.totalBits() - hash.availableBits(), pendingBits)\n      hash.untake(availableForUntake)\n      pendingBits -= availableForUntake\n      this._availableBits += availableForUntake\n\n      if (this._currentBufferIndex > 0 && hash.totalBits() === hash.availableBits()) {\n        this._depth--\n        this._currentBufferIndex--\n      }\n    }\n  }\n\n  async _produceMoreBits (): Promise<void> {\n    this._depth++\n\n    const value = this._depth > 0 ? uint8ArrayConcat([this._value, Uint8Array.from([this._depth])]) : this._value\n    const hashValue = await this._hashFn(value)\n    const buffer = new ConsumableBuffer(hashValue)\n\n    this._buffers.push(buffer)\n    this._availableBits += buffer.availableBits()\n  }\n}\n\nconst START_MASKS = [\n  0b11111111,\n  0b11111110,\n  0b11111100,\n  0b11111000,\n  0b11110000,\n  0b11100000,\n  0b11000000,\n  0b10000000\n]\n\nconst STOP_MASKS = [\n  0b00000001,\n  0b00000011,\n  0b00000111,\n  0b00001111,\n  0b00011111,\n  0b00111111,\n  0b01111111,\n  0b11111111\n]\n\nexport class ConsumableBuffer {\n  _value: Uint8Array\n  _currentBytePos: number\n  _currentBitPos: number\n\n  constructor (value: Uint8Array) {\n    this._value = value\n    this._currentBytePos = value.length - 1\n    this._currentBitPos = 7\n  }\n\n  availableBits (): number {\n    return this._currentBitPos + 1 + this._currentBytePos * 8\n  }\n\n  totalBits (): number {\n    return this._value.length * 8\n  }\n\n  take (bits: number): number {\n    let pendingBits = bits\n    let result = 0\n    while (pendingBits > 0 && this._haveBits()) {\n      const byte = this._value[this._currentBytePos]\n      const availableBits = this._currentBitPos + 1\n      const taking = Math.min(availableBits, pendingBits)\n      const value = byteBitsToInt(byte, availableBits - taking, taking)\n      result = (result << taking) + value\n\n      pendingBits -= taking\n\n      this._currentBitPos -= taking\n      if (this._currentBitPos < 0) {\n        this._currentBitPos = 7\n        this._currentBytePos--\n      }\n    }\n\n    return result\n  }\n\n  untake (bits: number): void {\n    this._currentBitPos += bits\n    while (this._currentBitPos > 7) {\n      this._currentBitPos -= 8\n      this._currentBytePos += 1\n    }\n  }\n\n  _haveBits (): boolean {\n    return this._currentBytePos >= 0\n  }\n}\n\nfunction byteBitsToInt (byte: number, start: number, length: number): number {\n  const mask = maskFor(start, length)\n  return (byte & mask) >>> start\n}\n\nfunction maskFor (start: number, length: number): number {\n  return START_MASKS[start] & STOP_MASKS[Math.min(length + start - 1, 7)]\n}\n", "import { murmur3128 } from '@multiformats/murmur3'\n\nexport const hamtHashCode = BigInt(murmur3128.code)\nexport const hamtBucketBits = 8\n\nexport async function hamtHashFn (buf: Uint8Array): Promise<Uint8Array> {\n  return (await murmur3128.encode(buf))\n    // Murmur3 outputs 128 bit but, accidentally, IPFS Go's\n    // implementation only uses the first 64, so we must do the same\n    // for parity..\n    .subarray(0, 8)\n    // Invert buffer because that's how Go impl does it\n    .reverse()\n}\n", "import * as dagPB from '@ipld/dag-pb'\nimport { logger } from '@libp2p/logger'\nimport { UnixFS } from 'ipfs-unixfs'\nimport last from 'it-last'\n// @ts-expect-error no types\nimport SparseArray from 'sparse-array'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport { wrapHash } from './consumable-hash.js'\nimport { DirSharded } from './dir-sharded.js'\nimport {\n  hamtHashCode,\n  hamtHashFn,\n  hamtBucketBits\n} from './hamt-constants.js'\nimport { persist } from './persist.js'\nimport type { InfiniteHash } from './consumable-hash.js'\nimport type { PersistOptions } from './persist.js'\nimport type { GetStore, PutStore } from '../../unixfs.js'\nimport type { AbortOptions } from '@libp2p/interface'\nimport type { Blockstore } from 'interface-blockstore'\nimport type { Mtime } from 'ipfs-unixfs'\nimport type { ImportResult } from 'ipfs-unixfs-importer'\nimport type { CID, Version } from 'multiformats/cid'\n\nconst log = logger('helia:unixfs:commands:utils:hamt-utils')\n\nexport interface UpdateHamtDirectoryOptions extends AbortOptions {\n  cidVersion: Version\n}\n\nexport const toPrefix = (position: number): string => {\n  return position\n    .toString(16)\n    .toUpperCase()\n    .padStart(2, '0')\n    .substring(0, 2)\n}\n\nexport interface CreateShardOptions {\n  mtime?: Mtime\n  mode?: number\n  cidVersion: Version\n}\n\nexport const createShard = async (blockstore: PutStore, contents: Array<{ name: string, size: bigint, cid: CID }>, options: CreateShardOptions): Promise<ImportResult> => {\n  const shard = new DirSharded({\n    root: true,\n    dir: true,\n    parent: undefined,\n    parentKey: undefined,\n    path: '',\n    dirty: true,\n    flat: false,\n    mtime: options.mtime,\n    mode: options.mode\n  }, options)\n\n  for (let i = 0; i < contents.length; i++) {\n    await shard._bucket.put(contents[i].name, {\n      size: contents[i].size,\n      cid: contents[i].cid\n    })\n  }\n\n  const res = await last(shard.flush(blockstore))\n\n  if (res == null) {\n    throw new Error('Flushing shard yielded no result')\n  }\n\n  return res\n}\n\nexport interface HAMTPath {\n  prefix: string\n  children: SparseArray\n  node: dagPB.PBNode\n}\n\nexport const updateShardedDirectory = async (path: HAMTPath[], blockstore: GetStore & PutStore, options: PersistOptions): Promise<{ cid: CID, node: dagPB.PBNode }> => {\n  // persist any metadata on the shard root\n  const shardRoot = UnixFS.unmarshal(path[0].node.Data ?? new Uint8Array(0))\n\n  // this is always the same\n  const fanout = BigInt(Math.pow(2, hamtBucketBits))\n\n  // start from the leaf and ascend to the root\n  path.reverse()\n\n  let cid: CID | undefined\n  let node: dagPB.PBNode | undefined\n\n  for (let i = 0; i < path.length; i++) {\n    const isRoot = i === path.length - 1\n    const segment = path[i]\n\n    // go-ipfs uses little endian, that's why we have to\n    // reverse the bit field before storing it\n    const data = Uint8Array.from(segment.children.bitField().reverse())\n    const dir = new UnixFS({\n      type: 'hamt-sharded-directory',\n      data,\n      fanout,\n      hashType: hamtHashCode\n    })\n\n    if (isRoot) {\n      dir.mtime = shardRoot.mtime\n      dir.mode = shardRoot.mode\n    }\n\n    node = {\n      Data: dir.marshal(),\n      Links: segment.node.Links\n    }\n\n    const block = dagPB.encode(dagPB.prepare(node))\n\n    cid = await persist(block, blockstore, options)\n\n    if (!isRoot) {\n      // update link in parent sub-shard\n      const nextSegment = path[i + 1]\n\n      if (nextSegment == null) {\n        throw new Error('Was not operating on shard root but also had no parent?')\n      }\n\n      log('updating link in parent sub-shard with prefix %s', nextSegment.prefix)\n\n      nextSegment.node.Links = nextSegment.node.Links.filter(l => l.Name !== nextSegment.prefix)\n      nextSegment.node.Links.push({\n        Name: nextSegment.prefix,\n        Hash: cid,\n        Tsize: segment.node.Links.reduce((acc, curr) => acc + (curr.Tsize ?? 0), block.byteLength)\n      })\n    }\n  }\n\n  if (cid == null || node == null) {\n    throw new Error('Noting persisted')\n  }\n\n  return { cid, node }\n}\n\nexport const recreateShardedDirectory = async (cid: CID, fileName: string, blockstore: Pick<Blockstore, 'get'>, options: AbortOptions): Promise<{ path: HAMTPath[], hash: InfiniteHash }> => {\n  const wrapped = wrapHash(hamtHashFn)\n  const hash = wrapped(uint8ArrayFromString(fileName))\n  const path: HAMTPath[] = []\n\n  // descend the HAMT, loading each layer as we head towards the target child\n  while (true) {\n    const block = await blockstore.get(cid, options)\n    const node = dagPB.decode(block)\n    const children = new SparseArray()\n    const index = await hash.take(hamtBucketBits)\n    const prefix = toPrefix(index)\n\n    path.push({\n      prefix,\n      children,\n      node\n    })\n\n    let childLink: dagPB.PBLink | undefined\n\n    // update sparsearray child layout - the bitfield is used as the data field for the\n    // intermediate DAG node so this is required to generate consistent hashes\n    for (const link of node.Links) {\n      const linkName = link.Name ?? ''\n\n      if (linkName.length < 2) {\n        throw new Error('Invalid HAMT - link name was too short')\n      }\n\n      const position = parseInt(linkName.substring(0, 2), 16)\n      children.set(position, true)\n\n      // we found the child we are looking for\n      if (linkName.startsWith(prefix)) {\n        childLink = link\n      }\n    }\n\n    if (childLink == null) {\n      log('no link found with prefix %s for %s', prefix, fileName)\n      // hash.untake(hamtBucketBits)\n      break\n    }\n\n    const linkName = childLink.Name ?? ''\n\n    if (linkName.length < 2) {\n      throw new Error('Invalid HAMT - link name was too short')\n    }\n\n    if (linkName.length === 2) {\n      // found sub-shard\n      cid = childLink.Hash\n      log('descend into sub-shard with prefix %s', linkName)\n\n      continue\n    }\n\n    break\n  }\n\n  return { path, hash }\n}\n", "import * as dagPb from '@ipld/dag-pb'\nimport { CID } from 'multiformats/cid'\nimport { sha256 } from 'multiformats/hashes/sha2'\nimport type { PutStore } from '../../unixfs.js'\nimport type { Version as CIDVersion } from 'multiformats/cid'\nimport type { BlockCodec } from 'multiformats/codecs/interface'\n\nexport interface PersistOptions {\n  codec?: BlockCodec<any, any>\n  cidVersion: CIDVersion\n  signal?: AbortSignal\n}\n\nexport const persist = async (buffer: Uint8Array, blockstore: PutStore, options: PersistOptions): Promise<CID> => {\n  if (options.codec == null) {\n    options.codec = dagPb\n  }\n\n  const multihash = await sha256.digest(buffer)\n  const cid = CID.create(options.cidVersion, options.codec.code, multihash)\n\n  await blockstore.put(cid, buffer, {\n    ...options,\n    signal: options.signal\n  })\n\n  return cid\n}\n", "import { encode, prepare } from '@ipld/dag-pb'\nimport { createHAMT, Bucket } from 'hamt-sharding'\nimport { UnixFS } from 'ipfs-unixfs'\nimport { CID } from 'multiformats/cid'\nimport {\n  hamtHashCode,\n  hamtHashFn\n} from './hamt-constants.js'\nimport { persist } from './persist.js'\nimport type { PersistOptions } from './persist.js'\nimport type { PutStore } from '../../unixfs.js'\nimport type { PBLink } from '@ipld/dag-pb'\nimport type { BucketChild } from 'hamt-sharding'\nimport type { Mtime } from 'ipfs-unixfs'\n\ninterface InProgressImportResult extends ImportResult {\n  single?: boolean\n  originalPath?: string\n}\n\ninterface ImportResult {\n  cid: CID\n  size: bigint\n  path?: string\n  unixfs?: UnixFS\n}\n\ninterface DirProps {\n  root: boolean\n  dir: boolean\n  path: string\n  dirty: boolean\n  flat: boolean\n  parent?: Dir\n  parentKey?: string\n  unixfs?: UnixFS\n  mode?: number\n  mtime?: Mtime\n}\n\nabstract class Dir {\n  public options: PersistOptions\n  public root: boolean\n  public dir: boolean\n  public path: string\n  public dirty: boolean\n  public flat: boolean\n  public parent?: Dir\n  public parentKey?: string\n  public unixfs?: UnixFS\n  public mode?: number\n  public mtime?: Mtime\n  public cid?: CID\n  public size?: number\n  public nodeSize?: number\n\n  constructor (props: DirProps, options: PersistOptions) {\n    this.options = options ?? {}\n\n    this.root = props.root\n    this.dir = props.dir\n    this.path = props.path\n    this.dirty = props.dirty\n    this.flat = props.flat\n    this.parent = props.parent\n    this.parentKey = props.parentKey\n    this.unixfs = props.unixfs\n    this.mode = props.mode\n    this.mtime = props.mtime\n  }\n\n  abstract put (name: string, value: InProgressImportResult | Dir): Promise<void>\n  abstract get (name: string): Promise<InProgressImportResult | Dir | undefined>\n  abstract eachChildSeries (): AsyncIterable<{ key: string, child: InProgressImportResult | Dir }>\n  abstract flush (blockstore: PutStore): AsyncGenerator<ImportResult>\n  abstract estimateNodeSize (): number\n  abstract childCount (): number\n}\n\nexport class DirSharded extends Dir {\n  public _bucket: Bucket<InProgressImportResult | Dir>\n\n  constructor (props: DirProps, options: PersistOptions) {\n    super(props, options)\n\n    this._bucket = createHAMT({\n      hashFn: hamtHashFn,\n      bits: 8\n    })\n  }\n\n  async put (name: string, value: InProgressImportResult | Dir): Promise<void> {\n    this.cid = undefined\n    this.size = undefined\n    this.nodeSize = undefined\n\n    await this._bucket.put(name, value)\n  }\n\n  async get (name: string): Promise<InProgressImportResult | Dir | undefined> {\n    return this._bucket.get(name)\n  }\n\n  childCount (): number {\n    return this._bucket.leafCount()\n  }\n\n  directChildrenCount (): number {\n    return this._bucket.childrenCount()\n  }\n\n  onlyChild (): Bucket<InProgressImportResult | Dir> | BucketChild<InProgressImportResult | Dir> {\n    return this._bucket.onlyChild()\n  }\n\n  async * eachChildSeries (): AsyncGenerator<{ key: string, child: InProgressImportResult | Dir }> {\n    for (const { key, value } of this._bucket.eachLeafSeries()) {\n      yield {\n        key,\n        child: value\n      }\n    }\n  }\n\n  estimateNodeSize (): number {\n    if (this.nodeSize !== undefined) {\n      return this.nodeSize\n    }\n\n    this.nodeSize = calculateSize(this._bucket, this, this.options)\n\n    return this.nodeSize\n  }\n\n  async * flush (blockstore: PutStore): AsyncGenerator<ImportResult> {\n    for await (const entry of flush(this._bucket, blockstore, this, this.options)) {\n      yield {\n        ...entry,\n        path: this.path\n      }\n    }\n  }\n}\n\nasync function * flush (bucket: Bucket<Dir | InProgressImportResult>, blockstore: PutStore, shardRoot: DirSharded | null, options: PersistOptions): AsyncIterable<ImportResult> {\n  const children = bucket._children\n  const links: PBLink[] = []\n  let childrenSize = 0n\n\n  for (let i = 0; i < children.length; i++) {\n    const child = children.get(i)\n\n    if (child == null) {\n      continue\n    }\n\n    const labelPrefix = i.toString(16).toUpperCase().padStart(2, '0')\n\n    if (child instanceof Bucket) {\n      let shard\n\n      for await (const subShard of flush(child, blockstore, null, options)) {\n        shard = subShard\n      }\n\n      if (shard == null) {\n        throw new Error('Could not flush sharded directory, no sub-shard found')\n      }\n\n      links.push({\n        Name: labelPrefix,\n        Tsize: Number(shard.size),\n        Hash: shard.cid\n      })\n      childrenSize += shard.size\n    } else if (isDir(child.value)) {\n      const dir = child.value\n      let flushedDir: ImportResult | undefined\n\n      for await (const entry of dir.flush(blockstore)) {\n        flushedDir = entry\n\n        yield flushedDir\n      }\n\n      if (flushedDir == null) {\n        throw new Error('Did not flush dir')\n      }\n\n      const label = labelPrefix + child.key\n      links.push({\n        Name: label,\n        Tsize: Number(flushedDir.size),\n        Hash: flushedDir.cid\n      })\n\n      childrenSize += flushedDir.size\n    } else {\n      const value = child.value\n\n      if (value.cid == null) {\n        continue\n      }\n\n      const label = labelPrefix + child.key\n      const size = value.size\n\n      links.push({\n        Name: label,\n        Tsize: Number(size),\n        Hash: value.cid\n      })\n      childrenSize += BigInt(size ?? 0)\n    }\n  }\n\n  // go-ipfs uses little endian, that's why we have to\n  // reverse the bit field before storing it\n  const data = Uint8Array.from(children.bitField().reverse())\n  const dir = new UnixFS({\n    type: 'hamt-sharded-directory',\n    data,\n    fanout: BigInt(bucket.tableSize()),\n    hashType: hamtHashCode,\n    mtime: shardRoot?.mtime,\n    mode: shardRoot?.mode\n  })\n\n  const node = {\n    Data: dir.marshal(),\n    Links: links\n  }\n  const buffer = encode(prepare(node))\n  const cid = await persist(buffer, blockstore, options)\n  const size = BigInt(buffer.byteLength) + childrenSize\n\n  yield {\n    cid,\n    unixfs: dir,\n    size\n  }\n}\n\nfunction isDir (obj: any): obj is Dir {\n  return typeof obj.flush === 'function'\n}\n\nfunction calculateSize (bucket: Bucket<any>, shardRoot: DirSharded | null, options: PersistOptions): number {\n  const children = bucket._children\n  const links: PBLink[] = []\n\n  for (let i = 0; i < children.length; i++) {\n    const child = children.get(i)\n\n    if (child == null) {\n      continue\n    }\n\n    const labelPrefix = i.toString(16).toUpperCase().padStart(2, '0')\n\n    if (child instanceof Bucket) {\n      const size = calculateSize(child, null, options)\n\n      links.push({\n        Name: labelPrefix,\n        Tsize: Number(size),\n        Hash: options.cidVersion === 0 ? CID_V0 : CID_V1\n      })\n    } else if (typeof child.value.flush === 'function') {\n      const dir = child.value\n      const size = dir.nodeSize()\n\n      links.push({\n        Name: labelPrefix + child.key,\n        Tsize: Number(size),\n        Hash: options.cidVersion === 0 ? CID_V0 : CID_V1\n      })\n    } else {\n      const value = child.value\n\n      if (value.cid == null) {\n        continue\n      }\n\n      const label = labelPrefix + child.key\n      const size = value.size\n\n      links.push({\n        Name: label,\n        Tsize: Number(size),\n        Hash: value.cid\n      })\n    }\n  }\n\n  // go-ipfs uses little endian, that's why we have to\n  // reverse the bit field before storing it\n  const data = Uint8Array.from(children.bitField().reverse())\n  const dir = new UnixFS({\n    type: 'hamt-sharded-directory',\n    data,\n    fanout: BigInt(bucket.tableSize()),\n    hashType: hamtHashCode,\n    mtime: shardRoot?.mtime,\n    mode: shardRoot?.mode\n  })\n\n  const buffer = encode(prepare({\n    Data: dir.marshal(),\n    Links: links\n  }))\n\n  return buffer.length\n}\n\n// we use these to calculate the node size to use as a check for whether a directory\n// should be sharded or not. Since CIDs have a constant length and We're only\n// interested in the data length and not the actual content identifier we can use\n// any old CID instead of having to hash the data which is expensive.\nexport const CID_V0 = CID.parse('QmUNLLsPACCz1vLxQVkXqqLX5R1X345qqfHbsf67hvA3Nn')\nexport const CID_V1 = CID.parse('zdj7WbTaiJT1fgatdet9Ei9iDB5hdCxkbVyhyh8YTUnXMiwYi')\n", "import * as dagPb from '@ipld/dag-pb'\nimport { UnixFS } from 'ipfs-unixfs'\nimport { CID_V0, CID_V1 } from './dir-sharded.js'\nimport type { GetStore } from '../../unixfs.js'\nimport type { PBNode } from '@ipld/dag-pb'\nimport type { AbortOptions } from '@libp2p/interface'\n\n/**\n * Estimate node size only based on DAGLink name and CID byte lengths\n * https://github.com/ipfs/go-unixfsnode/blob/37b47f1f917f1b2f54c207682f38886e49896ef9/data/builder/directory.go#L81-L96\n *\n * If the node is a hamt sharded directory the calculation is based on if it was a regular directory.\n */\nexport async function isOverShardThreshold (node: PBNode, blockstore: GetStore, threshold: number, options: AbortOptions): Promise<boolean> {\n  if (node.Data == null) {\n    throw new Error('DagPB node had no data')\n  }\n\n  const unixfs = UnixFS.unmarshal(node.Data)\n  let size: number\n\n  if (unixfs.type === 'directory') {\n    size = estimateNodeSize(node)\n  } else if (unixfs.type === 'hamt-sharded-directory') {\n    size = await estimateShardSize(node, 0, threshold, blockstore, options)\n  } else {\n    throw new Error('Can only estimate the size of directories or shards')\n  }\n\n  return size > threshold\n}\n\nfunction estimateNodeSize (node: PBNode): number {\n  let size = 0\n\n  // estimate size only based on DAGLink name and CID byte lengths\n  // https://github.com/ipfs/go-unixfsnode/blob/37b47f1f917f1b2f54c207682f38886e49896ef9/data/builder/directory.go#L81-L96\n  for (const link of node.Links) {\n    size += (link.Name ?? '').length\n    size += link.Hash.version === 1 ? CID_V1.bytes.byteLength : CID_V0.bytes.byteLength\n  }\n\n  return size\n}\n\nasync function estimateShardSize (node: PBNode, current: number, max: number, blockstore: GetStore, options: AbortOptions): Promise<number> {\n  if (current > max) {\n    return max\n  }\n\n  if (node.Data == null) {\n    return current\n  }\n\n  const unixfs = UnixFS.unmarshal(node.Data)\n\n  if (!unixfs.isDirectory()) {\n    return current\n  }\n\n  for (const link of node.Links) {\n    let name = link.Name ?? ''\n\n    // remove hamt hash prefix from name\n    name = name.substring(2)\n\n    current += name.length\n    current += link.Hash.bytes.byteLength\n\n    if (link.Hash.code === dagPb.code) {\n      const block = await blockstore.get(link.Hash, options)\n      const node = dagPb.decode(block)\n\n      current += await estimateShardSize(node, current, max, blockstore, options)\n    }\n  }\n\n  return current\n}\n", "import { exporter } from 'ipfs-unixfs-exporter'\nimport { NotADirectoryError } from '../../errors.js'\nimport type { GetStore } from '../../unixfs.js'\nimport type { PBNode } from '@ipld/dag-pb'\nimport type { ExporterOptions } from 'ipfs-unixfs-exporter'\nimport type { CID } from 'multiformats/cid'\n\nexport interface Directory {\n  cid: CID\n  node: PBNode\n}\n\nexport async function cidToDirectory (cid: CID, blockstore: GetStore, options: ExporterOptions = {}): Promise<Directory> {\n  const entry = await exporter(cid, blockstore, options)\n\n  if (entry.type !== 'directory') {\n    throw new NotADirectoryError(`${cid.toString()} was not a UnixFS directory`)\n  }\n\n  return {\n    cid,\n    node: entry.node\n  }\n}\n", "import * as dagPb from '@ipld/dag-pb'\nimport { exporter } from 'ipfs-unixfs-exporter'\nimport { NotUnixFSError } from '../../errors.js'\nimport type { GetStore } from '../../unixfs.js'\nimport type { PBNode, PBLink } from '@ipld/dag-pb'\nimport type { ExporterOptions } from 'ipfs-unixfs-exporter'\nimport type { CID } from 'multiformats/cid'\n\nexport async function cidToPBLink (cid: CID, name: string, blockstore: GetStore, options?: ExporterOptions): Promise<Required<PBLink>> {\n  const sourceEntry = await exporter(cid, blockstore, options)\n\n  if (sourceEntry.type !== 'directory' && sourceEntry.type !== 'file' && sourceEntry.type !== 'raw') {\n    throw new NotUnixFSError(`${cid.toString()} was not a UnixFS node`)\n  }\n\n  return {\n    Name: name,\n    Tsize: sourceEntry.node instanceof Uint8Array ? sourceEntry.node.byteLength : dagNodeTsize(sourceEntry.node),\n    Hash: cid\n  }\n}\n\nfunction dagNodeTsize (node: PBNode): number {\n  const linkSizes = node.Links.reduce((acc, curr) => acc + (curr.Tsize ?? 0), 0)\n\n  return dagPb.encode(node).byteLength + linkSizes\n}\n", "import { logger } from '@libp2p/logger'\nimport { walkPath } from 'ipfs-unixfs-exporter'\nimport all from 'it-all'\nimport { DoesNotExistError } from '../../errors.js'\nimport { addLink } from './add-link.js'\nimport { cidToDirectory } from './cid-to-directory.js'\nimport { cidToPBLink } from './cid-to-pblink.js'\nimport type { GetStore, PutStore } from '../../unixfs.js'\nimport type { AbortOptions } from '@libp2p/interface'\nimport type { CID } from 'multiformats/cid'\n\nconst log = logger('helia:unixfs:components:utils:resolve')\n\nexport interface Segment {\n  name: string\n  cid: CID\n  size: bigint\n}\n\nexport interface ResolveResult {\n  /**\n   * The CID at the end of the path\n   */\n  cid: CID\n\n  path?: string\n\n  /**\n   * If present, these are the CIDs and path segments that were traversed through to reach the final CID\n   *\n   * If not present, there was no path passed or the path was an empty string\n   */\n  segments?: Segment[]\n}\n\nexport async function resolve (cid: CID, path: string | undefined, blockstore: GetStore, options: AbortOptions): Promise<ResolveResult> {\n  if (path == null || path === '') {\n    return { cid }\n  }\n\n  const p = `/ipfs/${cid}${path == null ? '' : `/${path}`}`\n  const segments = await all(walkPath(p, blockstore, options))\n\n  if (segments.length === 0) {\n    throw new DoesNotExistError('Could not find path in directory')\n  }\n\n  log('resolved %s to %c', path, cid)\n\n  return {\n    cid: segments[segments.length - 1].cid,\n    path,\n    segments\n  }\n}\n\nexport interface UpdatePathCidsOptions extends AbortOptions {\n  shardSplitThresholdBytes: number\n}\n\n/**\n * Where we have descended into a DAG to update a child node, ascend up the DAG creating\n * new hashes and blocks for the changed content\n */\nexport async function updatePathCids (cid: CID, result: ResolveResult, blockstore: PutStore & GetStore, options: UpdatePathCidsOptions): Promise<CID> {\n  if (result.segments == null || result.segments.length === 0) {\n    return cid\n  }\n\n  let child = result.segments.pop()\n\n  if (child == null) {\n    throw new Error('Insufficient segments')\n  }\n\n  child.cid = cid\n\n  result.segments.reverse()\n\n  for (const parent of result.segments) {\n    const [\n      directory,\n      pblink\n    ] = await Promise.all([\n      cidToDirectory(parent.cid, blockstore, options),\n      cidToPBLink(child.cid, child.name, blockstore, options)\n    ])\n\n    const result = await addLink(directory, pblink, blockstore, {\n      ...options,\n      allowOverwriting: true,\n      cidVersion: cid.version\n    })\n\n    cid = result.cid\n    parent.cid = cid\n    child = parent\n  }\n\n  return cid\n}\n", "import { mergeOptions as mergeOpts } from '@libp2p/utils/merge-options'\nimport { exporter } from 'ipfs-unixfs-exporter'\nimport { NoContentError, NotAFileError } from '../errors.js'\nimport { resolve } from './utils/resolve.js'\nimport type { CatOptions } from '../index.js'\nimport type { GetStore } from '../unixfs.js'\nimport type { CID } from 'multiformats/cid'\n\nconst mergeOptions = mergeOpts.bind({ ignoreUndefined: true })\n\nconst defaultOptions: CatOptions = {\n\n}\n\nexport async function * cat (cid: CID, blockstore: GetStore, options: Partial<CatOptions> = {}): AsyncIterable<Uint8Array> {\n  const opts: CatOptions = mergeOptions(defaultOptions, options)\n  const resolved = await resolve(cid, opts.path, blockstore, opts)\n  const result = await exporter(resolved.cid, blockstore, opts)\n\n  if (result.type !== 'file' && result.type !== 'raw') {\n    throw new NotAFileError()\n  }\n\n  if (result.content == null) {\n    throw new NoContentError()\n  }\n\n  yield * result.content(opts)\n}\n", "import * as dagPB from '@ipld/dag-pb'\nimport { logger } from '@libp2p/logger'\nimport { mergeOptions as mergeOpts } from '@libp2p/utils/merge-options'\nimport { UnixFS } from 'ipfs-unixfs'\nimport { recursive } from 'ipfs-unixfs-exporter'\nimport { importer } from 'ipfs-unixfs-importer'\nimport last from 'it-last'\nimport { pipe } from 'it-pipe'\nimport { CID } from 'multiformats/cid'\nimport * as raw from 'multiformats/codecs/raw'\nimport { sha256 } from 'multiformats/hashes/sha2'\nimport { InvalidPBNodeError, NotUnixFSError, UnknownError } from '../errors.js'\nimport { SHARD_SPLIT_THRESHOLD_BYTES } from './utils/constants.js'\nimport { persist } from './utils/persist.js'\nimport { resolve, updatePathCids } from './utils/resolve.js'\nimport type { ChmodOptions } from '../index.js'\nimport type { GetStore, PutStore } from '../unixfs.js'\nimport type { PBNode, PBLink } from '@ipld/dag-pb'\n\nconst mergeOptions = mergeOpts.bind({ ignoreUndefined: true })\nconst log = logger('helia:unixfs:chmod')\n\nconst defaultOptions: ChmodOptions = {\n  recursive: false,\n  shardSplitThresholdBytes: SHARD_SPLIT_THRESHOLD_BYTES\n}\n\nexport async function chmod (cid: CID, mode: number, blockstore: PutStore & GetStore, options: Partial<ChmodOptions> = {}): Promise<CID> {\n  const opts: ChmodOptions = mergeOptions(defaultOptions, options)\n  const resolved = await resolve(cid, opts.path, blockstore, options)\n\n  log('chmod %c %d', resolved.cid, mode)\n\n  if (opts.recursive) {\n    // recursively export from root CID, change perms of each entry then reimport\n    // but do not reimport files, only manipulate dag-pb nodes\n    const root = await pipe(\n      async function * () {\n        for await (const entry of recursive(resolved.cid, blockstore, options)) {\n          let metadata: UnixFS\n          let links: PBLink[] = []\n\n          if (entry.type === 'raw') {\n            // convert to UnixFS\n            metadata = new UnixFS({ type: 'file', data: entry.node })\n          } else if (entry.type === 'file' || entry.type === 'directory') {\n            metadata = entry.unixfs\n            links = entry.node.Links\n          } else {\n            throw new NotUnixFSError()\n          }\n\n          metadata.mode = mode\n\n          const node = {\n            Data: metadata.marshal(),\n            Links: links\n          }\n\n          yield {\n            path: entry.path,\n            content: node\n          }\n        }\n      },\n      // @ts-expect-error cannot combine progress types\n      (source) => importer(source, blockstore, {\n        ...opts,\n        dagBuilder: async function * (source, block) {\n          for await (const entry of source) {\n            yield async function () {\n              // @ts-expect-error cannot derive type\n              const node: PBNode = entry.content\n\n              const buf = dagPB.encode(node)\n              const updatedCid = await persist(buf, block, {\n                ...opts,\n                cidVersion: cid.version\n              })\n\n              if (node.Data == null) {\n                throw new InvalidPBNodeError(`${updatedCid} had no data`)\n              }\n\n              const unixfs = UnixFS.unmarshal(node.Data)\n\n              return {\n                cid: updatedCid,\n                size: BigInt(buf.length),\n                path: entry.path,\n                unixfs\n              }\n            }\n          }\n        }\n      }),\n      async (nodes) => last(nodes)\n    )\n\n    if (root == null) {\n      throw new UnknownError(`Could not chmod ${resolved.cid.toString()}`)\n    }\n\n    return updatePathCids(root.cid, resolved, blockstore, opts)\n  }\n\n  const block = await blockstore.get(resolved.cid, options)\n  let metadata: UnixFS\n  let links: PBLink[] = []\n\n  if (resolved.cid.code === raw.code) {\n    // convert to UnixFS\n    metadata = new UnixFS({ type: 'file', data: block })\n  } else {\n    const node = dagPB.decode(block)\n\n    if (node.Data == null) {\n      throw new InvalidPBNodeError(`${resolved.cid.toString()} had no data`)\n    }\n\n    links = node.Links\n    metadata = UnixFS.unmarshal(node.Data)\n  }\n\n  metadata.mode = mode\n  const updatedBlock = dagPB.encode({\n    Data: metadata.marshal(),\n    Links: links\n  })\n\n  const hash = await sha256.digest(updatedBlock)\n  const updatedCid = CID.create(resolved.cid.version, dagPB.code, hash)\n\n  await blockstore.put(updatedCid, updatedBlock)\n\n  return updatePathCids(updatedCid, resolved, blockstore, opts)\n}\n", "import { logger } from '@libp2p/logger'\nimport { mergeOptions as mergeOpts } from '@libp2p/utils/merge-options'\nimport { InvalidParametersError } from '../errors.js'\nimport { addLink } from './utils/add-link.js'\nimport { cidToDirectory } from './utils/cid-to-directory.js'\nimport { cidToPBLink } from './utils/cid-to-pblink.js'\nimport { SHARD_SPLIT_THRESHOLD_BYTES } from './utils/constants.js'\nimport type { CpOptions } from '../index.js'\nimport type { GetStore, PutStore } from '../unixfs.js'\nimport type { CID } from 'multiformats/cid'\n\nconst mergeOptions = mergeOpts.bind({ ignoreUndefined: true })\nconst log = logger('helia:unixfs:cp')\n\nconst defaultOptions: CpOptions = {\n  force: false,\n  shardSplitThresholdBytes: SHARD_SPLIT_THRESHOLD_BYTES\n}\n\nexport async function cp (source: CID, target: CID, name: string, blockstore: GetStore & PutStore, options: Partial<CpOptions> = {}): Promise<CID> {\n  const opts: CpOptions = mergeOptions(defaultOptions, options)\n\n  if (name.includes('/')) {\n    throw new InvalidParametersError('Name must not have slashes')\n  }\n\n  const [\n    directory,\n    pblink\n  ] = await Promise.all([\n    cidToDirectory(target, blockstore, opts),\n    cidToPBLink(source, name, blockstore, opts)\n  ])\n\n  log('Adding %c as \"%s\" to %c', source, name, target)\n\n  const result = await addLink(directory, pblink, blockstore, {\n    allowOverwriting: opts.force,\n    cidVersion: target.version,\n    ...opts\n  })\n\n  return result.cid\n}\n", "import { mergeOptions as mergeOpts } from '@libp2p/utils/merge-options'\nimport { exporter } from 'ipfs-unixfs-exporter'\nimport { NoContentError, NotADirectoryError } from '../errors.js'\nimport { resolve } from './utils/resolve.js'\nimport type { LsOptions } from '../index.js'\nimport type { GetStore } from '../unixfs.js'\nimport type { UnixFSEntry } from 'ipfs-unixfs-exporter'\nimport type { CID } from 'multiformats/cid'\n\nconst mergeOptions = mergeOpts.bind({ ignoreUndefined: true })\n\nconst defaultOptions: LsOptions = {\n\n}\n\nexport async function * ls (cid: CID, blockstore: GetStore, options: Partial<LsOptions> = {}): AsyncIterable<UnixFSEntry> {\n  const opts: LsOptions = mergeOptions(defaultOptions, options)\n  const resolved = await resolve(cid, opts.path, blockstore, opts)\n  const result = await exporter(resolved.cid, blockstore)\n\n  if (result.type === 'file' || result.type === 'raw') {\n    yield result\n    return\n  }\n\n  if (result.content == null) {\n    throw new NoContentError()\n  }\n\n  if (result.type !== 'directory') {\n    throw new NotADirectoryError()\n  }\n\n  yield * result.content({\n    offset: options.offset,\n    length: options.length\n  })\n}\n", "import * as dagPB from '@ipld/dag-pb'\nimport { logger } from '@libp2p/logger'\nimport { mergeOptions as mergeOpts } from '@libp2p/utils/merge-options'\nimport { UnixFS } from 'ipfs-unixfs'\nimport { exporter } from 'ipfs-unixfs-exporter'\nimport { CID } from 'multiformats/cid'\nimport { sha256 } from 'multiformats/hashes/sha2'\nimport { InvalidParametersError, NotADirectoryError } from '../errors.js'\nimport { addLink } from './utils/add-link.js'\nimport { cidToDirectory } from './utils/cid-to-directory.js'\nimport { cidToPBLink } from './utils/cid-to-pblink.js'\nimport { SHARD_SPLIT_THRESHOLD_BYTES } from './utils/constants.js'\nimport type { MkdirOptions } from '../index.js'\nimport type { GetStore, PutStore } from '../unixfs.js'\n\nconst mergeOptions = mergeOpts.bind({ ignoreUndefined: true })\nconst log = logger('helia:unixfs:mkdir')\n\nconst defaultOptions: MkdirOptions = {\n  cidVersion: 1,\n  force: false,\n  shardSplitThresholdBytes: SHARD_SPLIT_THRESHOLD_BYTES\n}\n\nexport async function mkdir (parentCid: CID, dirname: string, blockstore: GetStore & PutStore, options: Partial<MkdirOptions> = {}): Promise<CID> {\n  const opts: MkdirOptions = mergeOptions(defaultOptions, options)\n\n  if (dirname.includes('/')) {\n    throw new InvalidParametersError('Path must not have slashes')\n  }\n\n  const entry = await exporter(parentCid, blockstore, options)\n\n  if (entry.type !== 'directory') {\n    throw new NotADirectoryError(`${parentCid.toString()} was not a UnixFS directory`)\n  }\n\n  log('creating %s', dirname)\n\n  const metadata = new UnixFS({\n    type: 'directory',\n    mode: opts.mode,\n    mtime: opts.mtime\n  })\n\n  // Persist the new parent PBNode\n  const node = {\n    Data: metadata.marshal(),\n    Links: []\n  }\n  const buf = dagPB.encode(node)\n  const hash = await sha256.digest(buf)\n  const emptyDirCid = CID.create(opts.cidVersion, dagPB.code, hash)\n\n  await blockstore.put(emptyDirCid, buf)\n\n  const [\n    directory,\n    pblink\n  ] = await Promise.all([\n    cidToDirectory(parentCid, blockstore, opts),\n    cidToPBLink(emptyDirCid, dirname, blockstore, opts)\n  ])\n\n  log('adding empty dir called %s to %c', dirname, parentCid)\n\n  const result = await addLink(directory, pblink, blockstore, {\n    ...opts,\n    allowOverwriting: opts.force\n  })\n\n  return result.cid\n}\n", "import * as dagPB from '@ipld/dag-pb'\nimport { logger } from '@libp2p/logger'\nimport { UnixFS } from 'ipfs-unixfs'\nimport { exporter } from 'ipfs-unixfs-exporter'\nimport { InvalidParametersError, InvalidPBNodeError } from '../../errors.js'\nimport {\n  recreateShardedDirectory,\n\n  updateShardedDirectory\n} from './hamt-utils.js'\nimport { isOverShardThreshold } from './is-over-shard-threshold.js'\nimport { persist } from './persist.js'\nimport type { Directory } from './cid-to-directory.js'\nimport type { UpdateHamtDirectoryOptions } from './hamt-utils.js'\nimport type { GetStore, PutStore } from '../../unixfs.js'\nimport type { PBNode } from '@ipld/dag-pb'\nimport type { AbortOptions } from '@libp2p/interface'\nimport type { CID, Version } from 'multiformats/cid'\n\nconst log = logger('helia:unixfs:utils:remove-link')\n\nexport interface RmLinkOptions extends AbortOptions {\n  shardSplitThresholdBytes: number\n  cidVersion: Version\n}\n\nexport interface RemoveLinkResult {\n  node: PBNode\n  cid: CID\n}\n\nexport async function removeLink (parent: Directory, name: string, blockstore: PutStore & GetStore, options: RmLinkOptions): Promise<RemoveLinkResult> {\n  if (parent.node.Data == null) {\n    throw new InvalidPBNodeError('Parent node had no data')\n  }\n\n  const meta = UnixFS.unmarshal(parent.node.Data)\n\n  if (meta.type === 'hamt-sharded-directory') {\n    log(`removing ${name} from sharded directory`)\n\n    const result = await removeFromShardedDirectory(parent, name, blockstore, options)\n\n    if (!(await isOverShardThreshold(result.node, blockstore, options.shardSplitThresholdBytes, options))) {\n      log('converting shard to flat directory %c', parent.cid)\n\n      return convertToFlatDirectory(result, blockstore, options)\n    }\n\n    return result\n  }\n\n  log(`removing link ${name} regular directory`)\n\n  return removeFromDirectory(parent, name, blockstore, options)\n}\n\nconst removeFromDirectory = async (parent: Directory, name: string, blockstore: PutStore & GetStore, options: AbortOptions): Promise<RemoveLinkResult> => {\n  // Remove existing link if it exists\n  parent.node.Links = parent.node.Links.filter((link) => {\n    return link.Name !== name\n  })\n\n  const parentBlock = dagPB.encode(parent.node)\n  const parentCid = await persist(parentBlock, blockstore, {\n    ...options,\n    cidVersion: parent.cid.version\n  })\n\n  log(`Updated regular directory ${parentCid}`)\n\n  return {\n    node: parent.node,\n    cid: parentCid\n  }\n}\n\nconst removeFromShardedDirectory = async (parent: Directory, name: string, blockstore: PutStore & GetStore, options: UpdateHamtDirectoryOptions): Promise<{ cid: CID, node: PBNode }> => {\n  const { path } = await recreateShardedDirectory(parent.cid, name, blockstore, options)\n  const finalSegment = path[path.length - 1]\n\n  if (finalSegment == null) {\n    throw new Error('Invalid HAMT, could not generate path')\n  }\n\n  const linkName = finalSegment.node.Links.filter(l => (l.Name ?? '').substring(2) === name).map(l => l.Name).pop()\n\n  if (linkName == null) {\n    throw new Error('File not found')\n  }\n\n  const prefix = linkName.substring(0, 2)\n  const index = parseInt(prefix, 16)\n\n  // remove the file from the shard\n  finalSegment.node.Links = finalSegment.node.Links.filter(link => link.Name !== linkName)\n  finalSegment.children.unset(index)\n\n  if (finalSegment.node.Links.length === 1) {\n    // replace the sub-shard with the last remaining file in the parent\n    while (true) {\n      if (path.length === 1) {\n        break\n      }\n\n      const segment = path[path.length - 1]\n\n      if (segment == null || segment.node.Links.length > 1) {\n        break\n      }\n\n      // remove final segment\n      path.pop()\n\n      const nextSegment = path[path.length - 1]\n\n      if (nextSegment == null) {\n        break\n      }\n\n      const link = segment.node.Links[0]\n\n      nextSegment.node.Links = nextSegment.node.Links.filter(l => !(l.Name ?? '').startsWith(nextSegment.prefix))\n      nextSegment.node.Links.push({\n        Hash: link.Hash,\n        Name: `${nextSegment.prefix}${(link.Name ?? '').substring(2)}`,\n        Tsize: link.Tsize\n      })\n    }\n  }\n\n  return updateShardedDirectory(path, blockstore, options)\n}\n\nconst convertToFlatDirectory = async (parent: Directory, blockstore: PutStore & GetStore, options: RmLinkOptions): Promise<RemoveLinkResult> => {\n  if (parent.node.Data == null) {\n    throw new InvalidParametersError('Invalid parent passed to convertToFlatDirectory')\n  }\n\n  const rootNode: PBNode = {\n    Links: []\n  }\n  const dir = await exporter(parent.cid, blockstore)\n\n  if (dir.type !== 'directory') {\n    throw new Error('Unexpected node type')\n  }\n\n  for await (const entry of dir.content()) {\n    let tsize = 0\n\n    if (entry.node instanceof Uint8Array) {\n      tsize = entry.node.byteLength\n    } else {\n      tsize = dagPB.encode(entry.node).length\n    }\n\n    rootNode.Links.push({\n      Hash: entry.cid,\n      Name: entry.name,\n      Tsize: tsize\n    })\n  }\n\n  // copy mode/mtime over if set\n  const oldUnixfs = UnixFS.unmarshal(parent.node.Data)\n  rootNode.Data = new UnixFS({ type: 'directory', mode: oldUnixfs.mode, mtime: oldUnixfs.mtime }).marshal()\n  const block = dagPB.encode(dagPB.prepare(rootNode))\n\n  const cid = await persist(block, blockstore, {\n    codec: dagPB,\n    cidVersion: parent.cid.version,\n    signal: options.signal\n  })\n\n  return {\n    cid,\n    node: rootNode\n  }\n}\n", "import { logger } from '@libp2p/logger'\nimport { mergeOptions as mergeOpts } from '@libp2p/utils/merge-options'\nimport { InvalidParametersError } from '../errors.js'\nimport { cidToDirectory } from './utils/cid-to-directory.js'\nimport { SHARD_SPLIT_THRESHOLD_BYTES } from './utils/constants.js'\nimport { removeLink } from './utils/remove-link.js'\nimport type { RmOptions } from '../index.js'\nimport type { GetStore, PutStore } from '../unixfs.js'\nimport type { CID } from 'multiformats/cid'\n\nconst mergeOptions = mergeOpts.bind({ ignoreUndefined: true })\nconst log = logger('helia:unixfs:rm')\n\nconst defaultOptions: RmOptions = {\n  shardSplitThresholdBytes: SHARD_SPLIT_THRESHOLD_BYTES\n}\n\nexport async function rm (target: CID, name: string, blockstore: GetStore & PutStore, options: Partial<RmOptions> = {}): Promise<CID> {\n  const opts: RmOptions = mergeOptions(defaultOptions, options)\n\n  if (name.includes('/')) {\n    throw new InvalidParametersError('Name must not have slashes')\n  }\n\n  const directory = await cidToDirectory(target, blockstore, opts)\n\n  log('Removing %s from %c', name, target)\n\n  const result = await removeLink(directory, name, blockstore, {\n    ...opts,\n    cidVersion: target.version\n  })\n\n  return result.cid\n}\n", "// FNV_PRIMES and FNV_OFFSETS from\n// http://www.isthe.com/chongo/tech/comp/fnv/index.html#FNV-param\n\nconst FNV_PRIMES = {\n\t32: 16_777_619n,\n\t64: 1_099_511_628_211n,\n\t128: 309_485_009_821_345_068_724_781_371n,\n\t256: 374_144_419_156_711_147_060_143_317_175_368_453_031_918_731_002_211n,\n\t512: 35_835_915_874_844_867_368_919_076_489_095_108_449_946_327_955_754_392_558_399_825_615_420_669_938_882_575_126_094_039_892_345_713_852_759n,\n\t1024: 5_016_456_510_113_118_655_434_598_811_035_278_955_030_765_345_404_790_744_303_017_523_831_112_055_108_147_451_509_157_692_220_295_382_716_162_651_878_526_895_249_385_292_291_816_524_375_083_746_691_371_804_094_271_873_160_484_737_966_720_260_389_217_684_476_157_468_082_573n,\n};\n\nconst FNV_OFFSETS = {\n\t32: 2_166_136_261n,\n\t64: 14_695_981_039_346_656_037n,\n\t128: 144_066_263_297_769_815_596_495_629_667_062_367_629n,\n\t256: 100_029_257_958_052_580_907_070_968_620_625_704_837_092_796_014_241_193_945_225_284_501_741_471_925_557n,\n\t512: 9_659_303_129_496_669_498_009_435_400_716_310_466_090_418_745_672_637_896_108_374_329_434_462_657_994_582_932_197_716_438_449_813_051_892_206_539_805_784_495_328_239_340_083_876_191_928_701_583_869_517_785n,\n\t1024: 14_197_795_064_947_621_068_722_070_641_403_218_320_880_622_795_441_933_960_878_474_914_617_582_723_252_296_732_303_717_722_150_864_096_521_202_355_549_365_628_174_669_108_571_814_760_471_015_076_148_029_755_969_804_077_320_157_692_458_563_003_215_304_957_150_157_403_644_460_363_550_505_412_711_285_966_361_610_267_868_082_893_823_963_790_439_336_411_086_884_584_107_735_010_676_915n,\n};\n\nconst cachedEncoder = new globalThis.TextEncoder();\n\nfunction fnv1aUint8Array(uint8Array, size) {\n\tconst fnvPrime = FNV_PRIMES[size];\n\tlet hash = FNV_OFFSETS[size];\n\n\t// eslint-disable-next-line unicorn/no-for-loop -- This is a performance-sensitive loop\n\tfor (let index = 0; index < uint8Array.length; index++) {\n\t\thash ^= BigInt(uint8Array[index]);\n\t\thash = BigInt.asUintN(size, hash * fnvPrime);\n\t}\n\n\treturn hash;\n}\n\nfunction fnv1aEncodeInto(string, size, utf8Buffer) {\n\tif (utf8Buffer.length === 0) {\n\t\tthrow new Error('The `utf8Buffer` option must have a length greater than zero');\n\t}\n\n\tconst fnvPrime = FNV_PRIMES[size];\n\tlet hash = FNV_OFFSETS[size];\n\tlet remaining = string;\n\n\twhile (remaining.length > 0) {\n\t\tconst result = cachedEncoder.encodeInto(remaining, utf8Buffer);\n\t\tremaining = remaining.slice(result.read);\n\t\tfor (let index = 0; index < result.written; index++) {\n\t\t\thash ^= BigInt(utf8Buffer[index]);\n\t\t\thash = BigInt.asUintN(size, hash * fnvPrime);\n\t\t}\n\t}\n\n\treturn hash;\n}\n\nexport default function fnv1a(value, {size = 32, utf8Buffer} = {}) {\n\tif (!FNV_PRIMES[size]) {\n\t\tthrow new Error('The `size` option must be one of 32, 64, 128, 256, 512, or 1024');\n\t}\n\n\tif (typeof value === 'string') {\n\t\tif (utf8Buffer) {\n\t\t\treturn fnv1aEncodeInto(value, size, utf8Buffer);\n\t\t}\n\n\t\tvalue = cachedEncoder.encode(value);\n\t}\n\n\treturn fnv1aUint8Array(value, size);\n}\n", "import fnv1aHash from '@sindresorhus/fnv1a'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\n\nexport interface Hash {\n  hash(input: Uint8Array, seed: number): number\n  hashV(input: Uint8Array, seed: number): Uint8Array\n}\n\nexport const fnv1a: Hash = {\n  hash: (input) => {\n    return Number(fnv1aHash(input, {\n      size: 32\n    }))\n  },\n  hashV: (input, seed) => {\n    return numberToBuffer(fnv1a.hash(input, seed))\n  }\n}\n\nexport function numberToBuffer (num: bigint | number): Uint8Array {\n  let hex = num.toString(16)\n\n  if (hex.length % 2 === 1) {\n    hex = `0${hex}`\n  }\n\n  return uint8ArrayFromString(hex, 'base16')\n}\n", "import { alloc as uint8ArrayAlloc } from 'uint8arrays/alloc'\nimport { equals as uint8ArrayEquals } from 'uint8arrays/equals'\nimport type { Hash } from './hashes.js'\n\nexport const MAX_FINGERPRINT_SIZE = 64\n\nexport class Fingerprint {\n  private readonly fp: Uint8Array\n  private readonly h: Hash\n  private readonly seed: number\n\n  constructor (buf: Uint8Array, hash: Hash, seed: number, fingerprintSize: number = 2) {\n    if (fingerprintSize > MAX_FINGERPRINT_SIZE) {\n      throw new TypeError('Invalid Fingerprint Size')\n    }\n\n    const fnv = hash.hashV(buf, seed)\n    const fp = uint8ArrayAlloc(fingerprintSize)\n\n    for (let i = 0; i < fp.length; i++) {\n      fp[i] = fnv[i]\n    }\n\n    if (fp.length === 0) {\n      fp[0] = 7\n    }\n\n    this.fp = fp\n    this.h = hash\n    this.seed = seed\n  }\n\n  hash (): number {\n    return this.h.hash(this.fp, this.seed)\n  }\n\n  equals (other?: any): boolean {\n    if (!(other?.fp instanceof Uint8Array)) {\n      return false\n    }\n\n    return uint8ArrayEquals(this.fp, other.fp)\n  }\n}\n", "export function getRandomInt (min: number, max: number): number {\n  return Math.floor(Math.random() * (max - min)) + min\n}\n", "import { Fingerprint } from './fingerprint.js'\nimport { getRandomInt } from './utils.js'\n\nexport class Bucket {\n  private readonly contents: Array<Fingerprint | null>\n\n  constructor (size: number) {\n    this.contents = new Array(size).fill(null)\n  }\n\n  has (fingerprint: Fingerprint): boolean {\n    if (!(fingerprint instanceof Fingerprint)) {\n      throw new TypeError('Invalid Fingerprint')\n    }\n\n    return this.contents.some((fp) => {\n      return fingerprint.equals(fp)\n    })\n  }\n\n  add (fingerprint: Fingerprint): boolean {\n    if (!(fingerprint instanceof Fingerprint)) {\n      throw new TypeError('Invalid Fingerprint')\n    }\n\n    for (let i = 0; i < this.contents.length; i++) {\n      if (this.contents[i] == null) {\n        this.contents[i] = fingerprint\n        return true\n      }\n    }\n\n    return true\n  }\n\n  swap (fingerprint: Fingerprint): Fingerprint | null {\n    if (!(fingerprint instanceof Fingerprint)) {\n      throw new TypeError('Invalid Fingerprint')\n    }\n\n    const i = getRandomInt(0, this.contents.length - 1)\n    const current = this.contents[i]\n    this.contents[i] = fingerprint\n\n    return current\n  }\n\n  remove (fingerprint: Fingerprint): boolean {\n    if (!(fingerprint instanceof Fingerprint)) {\n      throw new TypeError('Invalid Fingerprint')\n    }\n\n    const found = this.contents.findIndex((fp) => {\n      return fingerprint.equals(fp)\n    })\n\n    if (found > -1) {\n      this.contents[found] = null\n      return true\n    } else {\n      return false\n    }\n  }\n}\n", "import { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport { Bucket } from './bucket.js'\nimport { Fingerprint, MAX_FINGERPRINT_SIZE } from './fingerprint.js'\nimport { fnv1a } from './hashes.js'\nimport { getRandomInt } from './utils.js'\nimport type { Hash } from './hashes.js'\nimport type { Filter } from './index.js'\n\nconst maxCuckooCount = 500\n\nexport interface CuckooFilterInit {\n  /**\n   * How many items the filter is expected to contain\n   */\n  filterSize: number\n\n  /**\n   * How many items to put in each bucket\n   */\n  bucketSize?: number\n\n  /**\n   * How many bytes the fingerprint is expected to be\n   */\n  fingerprintSize?: number\n\n  /**\n   * A non-cryptographic hash implementation\n   */\n  hash?: Hash\n\n  /**\n   * A number used to seed the hash\n   */\n  seed?: number\n}\n\nexport class CuckooFilter implements Filter {\n  private readonly bucketSize: number\n  private readonly filterSize: number\n  private readonly fingerprintSize: number\n  private readonly buckets: Bucket[]\n  public count: number\n  private readonly hash: Hash\n  private readonly seed: number\n\n  constructor (init: CuckooFilterInit) {\n    this.filterSize = init.filterSize\n    this.bucketSize = init.bucketSize ?? 4\n    this.fingerprintSize = init.fingerprintSize ?? 2\n    this.count = 0\n    this.buckets = []\n    this.hash = init.hash ?? fnv1a\n    this.seed = init.seed ?? getRandomInt(0, Math.pow(2, 10))\n  }\n\n  add (item: Uint8Array | string): boolean {\n    if (typeof item === 'string') {\n      item = uint8ArrayFromString(item)\n    }\n\n    const fingerprint = new Fingerprint(item, this.hash, this.seed, this.fingerprintSize)\n    const j = this.hash.hash(item, this.seed) % this.filterSize\n    const k = (j ^ fingerprint.hash()) % this.filterSize\n\n    if (this.buckets[j] == null) {\n      this.buckets[j] = new Bucket(this.bucketSize)\n    }\n\n    if (this.buckets[k] == null) {\n      this.buckets[k] = new Bucket(this.bucketSize)\n    }\n\n    if (this.buckets[j].add(fingerprint) || this.buckets[k].add(fingerprint)) {\n      this.count++\n      return true\n    }\n\n    const rand = [j, k]\n    let i = rand[getRandomInt(0, rand.length - 1)]\n\n    if (this.buckets[i] == null) {\n      this.buckets[i] = new Bucket(this.bucketSize)\n    }\n\n    for (let n = 0; n < maxCuckooCount; n++) {\n      const swapped = this.buckets[i].swap(fingerprint)\n\n      if (swapped == null) {\n        continue\n      }\n\n      i = (i ^ swapped.hash()) % this.filterSize\n\n      if (this.buckets[i] == null) {\n        this.buckets[i] = new Bucket(this.bucketSize)\n      }\n\n      if (this.buckets[i].add(swapped)) {\n        this.count++\n\n        return true\n      } else {\n        continue\n      }\n    }\n\n    return false\n  }\n\n  has (item: Uint8Array | string): boolean {\n    if (typeof item === 'string') {\n      item = uint8ArrayFromString(item)\n    }\n\n    const fingerprint = new Fingerprint(item, this.hash, this.seed, this.fingerprintSize)\n    const j = this.hash.hash(item, this.seed) % this.filterSize\n    const inJ = this.buckets[j]?.has(fingerprint) ?? false\n\n    if (inJ) {\n      return inJ\n    }\n\n    const k = (j ^ fingerprint.hash()) % this.filterSize\n\n    return this.buckets[k]?.has(fingerprint) ?? false\n  }\n\n  remove (item: Uint8Array | string): boolean {\n    if (typeof item === 'string') {\n      item = uint8ArrayFromString(item)\n    }\n\n    const fingerprint = new Fingerprint(item, this.hash, this.seed, this.fingerprintSize)\n    const j = this.hash.hash(item, this.seed) % this.filterSize\n    const inJ = this.buckets[j]?.remove(fingerprint) ?? false\n\n    if (inJ) {\n      this.count--\n      return inJ\n    }\n\n    const k = (j ^ fingerprint.hash()) % this.filterSize\n    const inK = this.buckets[k]?.remove(fingerprint) ?? false\n\n    if (inK) {\n      this.count--\n    }\n\n    return inK\n  }\n\n  get reliable (): boolean {\n    return Math.floor(100 * (this.count / this.filterSize)) <= 90\n  }\n}\n\n// max load constants, defined in the cuckoo paper\nconst MAX_LOAD = {\n  1: 0.5,\n  2: 0.84,\n  4: 0.95,\n  8: 0.98\n}\n\nfunction calculateBucketSize (errorRate: number = 0.001): 2 | 4 | 8 {\n  if (errorRate > 0.002) {\n    return 2\n  }\n\n  if (errorRate > 0.00001) {\n    return 4\n  }\n\n  return 8\n}\n\nexport function optimize (maxItems: number, errorRate: number = 0.001): CuckooFilterInit {\n  // https://www.eecs.harvard.edu/~michaelm/postscripts/cuckoo-conext2014.pdf\n  // Section 5.1 Optimal Bucket Size\n  const bucketSize = calculateBucketSize(errorRate)\n  const load = MAX_LOAD[bucketSize]\n\n  // https://stackoverflow.com/questions/57555236/how-to-size-a-cuckoo-filter/57617208#57617208\n  const filterSize = Math.round(maxItems / load)\n  const fingerprintSize = Math.min(Math.ceil(Math.log2(1 / errorRate) + Math.log2(2 * bucketSize)), MAX_FINGERPRINT_SIZE)\n\n  return {\n    filterSize,\n    bucketSize,\n    fingerprintSize\n  }\n}\n\nexport function createCuckooFilter (maxItems: number, errorRate: number = 0.005): Filter {\n  const opts = optimize(maxItems, errorRate)\n  return new CuckooFilter(opts)\n}\n", "import { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport { CuckooFilter, optimize } from './cuckoo-filter.js'\nimport { fnv1a } from './hashes.js'\nimport { getRandomInt } from './utils.js'\nimport type { CuckooFilterInit } from './cuckoo-filter.js'\nimport type { Hash } from './hashes.js'\nimport type { Filter } from './index.js'\n\nexport interface ScalableCuckooFilterInit extends CuckooFilterInit {\n  /**\n   * A number to multiply maxItems by when adding new sub-filters\n   */\n  scale?: number\n}\n\nexport class ScalableCuckooFilter implements Filter {\n  private readonly filterSize: number\n  private readonly bucketSize: number\n  private readonly fingerprintSize: number\n  private readonly scale: number\n  private readonly filterSeries: CuckooFilter[]\n  private readonly hash: Hash\n  private readonly seed: number\n\n  constructor (init: ScalableCuckooFilterInit) {\n    this.bucketSize = init.bucketSize ?? 4\n    this.filterSize = init.filterSize ?? (1 << 18) / this.bucketSize\n    this.fingerprintSize = init.fingerprintSize ?? 2\n    this.scale = init.scale ?? 2\n    this.hash = init.hash ?? fnv1a\n    this.seed = init.seed ?? getRandomInt(0, Math.pow(2, 10))\n    this.filterSeries = [\n      new CuckooFilter({\n        filterSize: this.filterSize,\n        bucketSize: this.bucketSize,\n        fingerprintSize: this.fingerprintSize,\n        hash: this.hash,\n        seed: this.seed\n      })\n    ]\n  }\n\n  add (item: Uint8Array | string): boolean {\n    if (typeof item === 'string') {\n      item = uint8ArrayFromString(item)\n    }\n\n    if (this.has(item)) {\n      return true\n    }\n\n    let current = this.filterSeries.find((cuckoo) => {\n      return cuckoo.reliable\n    })\n\n    if (current == null) {\n      const curSize = this.filterSize * Math.pow(this.scale, this.filterSeries.length)\n\n      current = new CuckooFilter({\n        filterSize: curSize,\n        bucketSize: this.bucketSize,\n        fingerprintSize: this.fingerprintSize,\n        hash: this.hash,\n        seed: this.seed\n      })\n\n      this.filterSeries.push(current)\n    }\n\n    return current.add(item)\n  }\n\n  has (item: Uint8Array | string): boolean {\n    if (typeof item === 'string') {\n      item = uint8ArrayFromString(item)\n    }\n\n    for (let i = 0; i < this.filterSeries.length; i++) {\n      if (this.filterSeries[i].has(item)) {\n        return true\n      }\n    }\n\n    return false\n  }\n\n  remove (item: Uint8Array | string): boolean {\n    if (typeof item === 'string') {\n      item = uint8ArrayFromString(item)\n    }\n\n    for (let i = 0; i < this.filterSeries.length; i++) {\n      if (this.filterSeries[i].remove(item)) {\n        return true\n      }\n    }\n\n    return false\n  }\n\n  get count (): number {\n    return this.filterSeries.reduce((acc, curr) => {\n      return acc + curr.count\n    }, 0)\n  }\n}\n\nexport function createScalableCuckooFilter (maxItems: number, errorRate: number = 0.001, options?: Pick<ScalableCuckooFilterInit, 'hash' | 'seed' | 'scale'>): Filter {\n  return new ScalableCuckooFilter({\n    ...optimize(maxItems, errorRate),\n    ...(options ?? {})\n  })\n}\n", "import * as dagPb from '@ipld/dag-pb'\nimport { logger } from '@libp2p/logger'\nimport { ScalableCuckooFilter } from '@libp2p/utils/filters'\nimport { mergeOptions as mergeOpts } from '@libp2p/utils/merge-options'\nimport { UnixFS } from 'ipfs-unixfs'\nimport { exporter } from 'ipfs-unixfs-exporter'\nimport * as raw from 'multiformats/codecs/raw'\nimport { InvalidPBNodeError, NotUnixFSError, UnknownError } from '../errors.js'\nimport { resolve } from './utils/resolve.js'\nimport type { ExtendedStatOptions, ExtendedDirectoryStats, ExtendedFileStats, StatOptions, DirectoryStats, FileStats, RawStats, ExtendedRawStats } from '../index.js'\nimport type { GetStore, HasStore } from '../unixfs.js'\nimport type { Filter } from '@libp2p/utils/filters'\nimport type { RawNode, UnixFSDirectory, UnixFSFile } from 'ipfs-unixfs-exporter'\nimport type { CID } from 'multiformats/cid'\n\n// https://github.com/ipfs/specs/blob/main/UNIXFS.md#metadata\nconst DEFAULT_DIR_MODE = 0x755\nconst DEFAULT_FILE_MODE = 0x644\n\nconst mergeOptions = mergeOpts.bind({ ignoreUndefined: true })\nconst log = logger('helia:unixfs:stat')\n\nconst defaultOptions: StatOptions = {\n\n}\n\nexport async function stat (cid: CID, blockstore: GetStore & HasStore, options?: StatOptions): Promise<FileStats | DirectoryStats | RawStats>\nexport async function stat (cid: CID, blockstore: GetStore & HasStore, options?: ExtendedStatOptions): Promise<ExtendedFileStats | ExtendedDirectoryStats | ExtendedRawStats>\nexport async function stat (cid: CID, blockstore: GetStore & HasStore, options: Partial<ExtendedStatOptions> = {}): Promise<any> {\n  const opts: StatOptions = mergeOptions(defaultOptions, options)\n  const resolved = await resolve(cid, options.path, blockstore, opts)\n\n  log('stat %c', resolved.cid)\n\n  const result = await exporter(resolved.cid, blockstore, opts)\n\n  if (result.type === 'raw') {\n    if (options.extended === true) {\n      return createExtendedRawStats(result)\n    }\n\n    return createRawStats(result)\n  } else if (result.type === 'file' || result.type === 'directory') {\n    if (options.extended === true) {\n      return createExtendedStats(result, blockstore, options.filter ?? new ScalableCuckooFilter({ filterSize: 1024 }), options)\n    }\n\n    return createStats(result)\n  }\n\n  throw new NotUnixFSError()\n}\n\nfunction createStats (entry: UnixFSFile | UnixFSDirectory): FileStats | DirectoryStats {\n  return {\n    type: entry.type,\n    cid: entry.cid,\n    unixfs: entry.unixfs,\n    mode: entry.unixfs.mode ?? (entry.unixfs.isDirectory() ? DEFAULT_DIR_MODE : DEFAULT_FILE_MODE),\n    mtime: entry.unixfs.mtime,\n    size: entry.unixfs.fileSize()\n  }\n}\n\nasync function createExtendedStats (entry: UnixFSFile | UnixFSDirectory, blockstore: GetStore & HasStore, filter: Filter, options: StatOptions): Promise<ExtendedFileStats | ExtendedDirectoryStats> {\n  const stats = await inspectDag(entry.cid, blockstore, false, filter, options)\n\n  return {\n    type: entry.type,\n    cid: entry.cid,\n    unixfs: entry.unixfs,\n    size: entry.unixfs.isDirectory() ? stats.dirSize : entry.unixfs.fileSize(),\n    mode: entry.unixfs.mode ?? (entry.unixfs.isDirectory() ? DEFAULT_DIR_MODE : DEFAULT_FILE_MODE),\n    mtime: entry.unixfs.mtime,\n    localSize: stats.localSize,\n    dagSize: stats.dagSize,\n    deduplicatedDagSize: stats.deduplicatedDagSize,\n    blocks: stats.blocks,\n    uniqueBlocks: stats.uniqueBlocks\n  }\n}\n\nfunction createRawStats (entry: RawNode): RawStats {\n  return {\n    type: entry.type,\n    cid: entry.cid,\n    unixfs: undefined,\n    mode: DEFAULT_FILE_MODE,\n    mtime: undefined,\n    size: BigInt(entry.node.byteLength)\n  }\n}\n\nfunction createExtendedRawStats (entry: RawNode): ExtendedRawStats {\n  return {\n    type: entry.type,\n    cid: entry.cid,\n    unixfs: undefined,\n    mode: DEFAULT_FILE_MODE,\n    mtime: undefined,\n    size: BigInt(entry.node.byteLength),\n    localSize: BigInt(entry.node.byteLength),\n    dagSize: BigInt(entry.node.byteLength),\n    deduplicatedDagSize: BigInt(entry.node.byteLength),\n    blocks: 1n,\n    uniqueBlocks: 1n\n  }\n}\n\ninterface InspectDagResults {\n  dirSize: bigint\n  localSize: bigint\n  dagSize: bigint\n  deduplicatedDagSize: bigint\n  blocks: bigint\n  uniqueBlocks: bigint\n}\n\nasync function inspectDag (cid: CID, blockstore: GetStore & HasStore, isFile: boolean, filter: Filter, options: StatOptions): Promise<InspectDagResults> {\n  const results: InspectDagResults = {\n    dirSize: 0n,\n    localSize: 0n,\n    dagSize: 0n,\n    deduplicatedDagSize: 0n,\n    blocks: 0n,\n    uniqueBlocks: 0n\n  }\n\n  try {\n    const alreadyTraversed = filter.has(cid.bytes)\n    filter.add(cid.bytes)\n\n    const block = await blockstore.get(cid, options)\n    results.blocks++\n    results.dagSize += BigInt(block.byteLength)\n\n    if (!alreadyTraversed) {\n      results.uniqueBlocks++\n      results.deduplicatedDagSize += BigInt(block.byteLength)\n    }\n\n    if (cid.code === raw.code) {\n      results.localSize += BigInt(block.byteLength)\n\n      if (isFile) {\n        results.dirSize += BigInt(block.byteLength)\n      }\n    } else if (cid.code === dagPb.code) {\n      const pbNode = dagPb.decode(block)\n\n      let unixfs: UnixFS | undefined\n\n      if (pbNode.Data != null) {\n        unixfs = UnixFS.unmarshal(pbNode.Data)\n      }\n\n      if (pbNode.Links.length > 0) {\n        // intermediate node\n        for (const link of pbNode.Links) {\n          const linkResult = await inspectDag(link.Hash, blockstore, linkIsFile(link, unixfs), filter, options)\n\n          results.localSize += linkResult.localSize\n          results.dagSize += linkResult.dagSize\n          results.deduplicatedDagSize += linkResult.deduplicatedDagSize\n          results.blocks += linkResult.blocks\n          results.uniqueBlocks += linkResult.uniqueBlocks\n          results.dirSize += linkResult.dirSize\n        }\n\n        // multi-block file node\n        if (isFile && unixfs != null) {\n          results.dirSize += unixfs.fileSize()\n        }\n      } else {\n        if (unixfs == null) {\n          throw new InvalidPBNodeError(`PBNode ${cid.toString()} had no data`)\n        }\n\n        // multi-block file leaf node\n        if (unixfs.data != null) {\n          results.localSize += BigInt(unixfs.data.byteLength ?? 0)\n        }\n\n        // single-block file node\n        if (isFile) {\n          results.dirSize += unixfs.fileSize()\n        }\n      }\n    } else {\n      throw new UnknownError(`${cid.toString()} was neither DAG_PB nor RAW`)\n    }\n  } catch (err: any) {\n    if (err.name !== 'NotFoundError' || options.offline !== true) {\n      throw err\n    }\n  }\n\n  return results\n}\n\nfunction linkIsFile (link: dagPb.PBLink, parent?: UnixFS): boolean {\n  if (parent == null) {\n    return false\n  }\n\n  const name = link.Name\n\n  if (name == null) {\n    return false\n  }\n\n  if (parent.type === 'directory') {\n    return true\n  } else if (parent.type === 'hamt-sharded-directory' && name.length > 2) {\n    return true\n  }\n\n  return false\n}\n", "import * as dagPB from '@ipld/dag-pb'\nimport { logger } from '@libp2p/logger'\nimport { mergeOptions as mergeOpts } from '@libp2p/utils/merge-options'\nimport { UnixFS } from 'ipfs-unixfs'\nimport { recursive } from 'ipfs-unixfs-exporter'\nimport { importer } from 'ipfs-unixfs-importer'\nimport last from 'it-last'\nimport { pipe } from 'it-pipe'\nimport { CID } from 'multiformats/cid'\nimport * as raw from 'multiformats/codecs/raw'\nimport { sha256 } from 'multiformats/hashes/sha2'\nimport { InvalidPBNodeError, NotUnixFSError, UnknownError } from '../errors.js'\nimport { SHARD_SPLIT_THRESHOLD_BYTES } from './utils/constants.js'\nimport { persist } from './utils/persist.js'\nimport { resolve, updatePathCids } from './utils/resolve.js'\nimport type { TouchOptions } from '../index.js'\nimport type { GetStore, PutStore } from '../unixfs.js'\nimport type { PBNode, PBLink } from '@ipld/dag-pb'\n\nconst mergeOptions = mergeOpts.bind({ ignoreUndefined: true })\nconst log = logger('helia:unixfs:touch')\n\nconst defaultOptions: TouchOptions = {\n  recursive: false,\n  shardSplitThresholdBytes: SHARD_SPLIT_THRESHOLD_BYTES\n}\n\nexport async function touch (cid: CID, blockstore: GetStore & PutStore, options: Partial<TouchOptions> = {}): Promise<CID> {\n  const opts: TouchOptions = mergeOptions(defaultOptions, options)\n  const resolved = await resolve(cid, opts.path, blockstore, opts)\n  const mtime = opts.mtime ?? {\n    secs: BigInt(Math.round(Date.now() / 1000)),\n    nsecs: 0\n  }\n\n  log('touch %c %o', resolved.cid, mtime)\n\n  if (opts.recursive) {\n    // recursively export from root CID, change perms of each entry then reimport\n    // but do not reimport files, only manipulate dag-pb nodes\n    const root = await pipe(\n      async function * () {\n        for await (const entry of recursive(resolved.cid, blockstore)) {\n          let metadata: UnixFS\n          let links: PBLink[]\n\n          if (entry.type === 'raw') {\n            metadata = new UnixFS({ data: entry.node })\n            links = []\n          } else if (entry.type === 'file' || entry.type === 'directory') {\n            metadata = entry.unixfs\n            links = entry.node.Links\n          } else {\n            throw new NotUnixFSError()\n          }\n\n          metadata.mtime = mtime\n\n          const node = {\n            Data: metadata.marshal(),\n            Links: links\n          }\n\n          yield {\n            path: entry.path,\n            content: node\n          }\n        }\n      },\n      // @ts-expect-error blockstore types are incompatible\n      (source) => importer(source, blockstore, {\n        ...opts,\n        dagBuilder: async function * (source, block) {\n          for await (const entry of source) {\n            yield async function () {\n              // @ts-expect-error cannot derive type\n              const node: PBNode = entry.content\n\n              const buf = dagPB.encode(node)\n              const updatedCid = await persist(buf, block, {\n                ...opts,\n                cidVersion: cid.version\n              })\n\n              if (node.Data == null) {\n                throw new InvalidPBNodeError(`${updatedCid} had no data`)\n              }\n\n              const unixfs = UnixFS.unmarshal(node.Data)\n\n              return {\n                cid: updatedCid,\n                size: BigInt(buf.length),\n                path: entry.path,\n                unixfs\n              }\n            }\n          }\n        }\n      }),\n      async (nodes) => last(nodes)\n    )\n\n    if (root == null) {\n      throw new UnknownError(`Could not chmod ${resolved.cid.toString()}`)\n    }\n\n    return updatePathCids(root.cid, resolved, blockstore, opts)\n  }\n\n  const block = await blockstore.get(resolved.cid, options)\n  let metadata: UnixFS\n  let links: PBLink[] = []\n\n  if (resolved.cid.code === raw.code) {\n    metadata = new UnixFS({ data: block })\n  } else {\n    const node = dagPB.decode(block)\n    links = node.Links\n\n    if (node.Data == null) {\n      throw new InvalidPBNodeError(`${resolved.cid.toString()} had no data`)\n    }\n\n    metadata = UnixFS.unmarshal(node.Data)\n  }\n\n  metadata.mtime = mtime\n  const updatedBlock = dagPB.encode({\n    Data: metadata.marshal(),\n    Links: links\n  })\n\n  const hash = await sha256.digest(updatedBlock)\n  const updatedCid = CID.create(resolved.cid.version, dagPB.code, hash)\n\n  await blockstore.put(updatedCid, updatedBlock)\n\n  return updatePathCids(updatedCid, resolved, blockstore, opts)\n}\n", "import { addAll, addBytes, addByteStream, addDirectory, addFile } from './commands/add.js'\nimport { cat } from './commands/cat.js'\nimport { chmod } from './commands/chmod.js'\nimport { cp } from './commands/cp.js'\nimport { ls } from './commands/ls.js'\nimport { mkdir } from './commands/mkdir.js'\nimport { rm } from './commands/rm.js'\nimport { stat } from './commands/stat.js'\nimport { touch } from './commands/touch.js'\nimport type { AddOptions, CatOptions, ChmodOptions, CpOptions, ExtendedStatOptions, ExtendedDirectoryStats, ExtendedFileStats, FileCandidate, LsOptions, MkdirOptions, RmOptions, StatOptions, TouchOptions, UnixFSComponents, DirectoryStats, FileStats, UnixFS as UnixFSInterface, RawStats, ExtendedRawStats } from './index.js'\nimport type { Blockstore } from 'interface-blockstore'\nimport type { UnixFSEntry } from 'ipfs-unixfs-exporter'\nimport type { ByteStream, DirectoryCandidate, ImportCandidateStream, ImportResult } from 'ipfs-unixfs-importer'\nimport type { CID } from 'multiformats/cid'\n\nexport type PutStore = Pick<Blockstore, 'put'>\nexport type GetStore = Pick<Blockstore, 'get'>\nexport type HasStore = Pick<Blockstore, 'has'>\n\nexport class UnixFS implements UnixFSInterface {\n  private readonly components: UnixFSComponents\n\n  constructor (components: UnixFSComponents) {\n    this.components = components\n  }\n\n  async * addAll (source: ImportCandidateStream, options: Partial<AddOptions> = {}): AsyncIterable<ImportResult> {\n    yield * addAll(source, this.components.blockstore, options)\n  }\n\n  async addBytes (bytes: Uint8Array, options: Partial<AddOptions> = {}): Promise<CID> {\n    return addBytes(bytes, this.components.blockstore, options)\n  }\n\n  async addByteStream (bytes: ByteStream, options: Partial<AddOptions> = {}): Promise<CID> {\n    return addByteStream(bytes, this.components.blockstore, options)\n  }\n\n  async addFile (file: FileCandidate, options: Partial<AddOptions> = {}): Promise<CID> {\n    return addFile(file, this.components.blockstore, options)\n  }\n\n  async addDirectory (dir: Partial<DirectoryCandidate> = {}, options: Partial<AddOptions> = {}): Promise<CID> {\n    return addDirectory(dir, this.components.blockstore, options)\n  }\n\n  async * cat (cid: CID, options: Partial<CatOptions> = {}): AsyncIterable<Uint8Array> {\n    yield * cat(cid, this.components.blockstore, options)\n  }\n\n  async chmod (cid: CID, mode: number, options: Partial<ChmodOptions> = {}): Promise<CID> {\n    return chmod(cid, mode, this.components.blockstore, options)\n  }\n\n  async cp (source: CID, target: CID, name: string, options: Partial<CpOptions> = {}): Promise<CID> {\n    return cp(source, target, name, this.components.blockstore, options)\n  }\n\n  async * ls (cid: CID, options: Partial<LsOptions> = {}): AsyncIterable<UnixFSEntry> {\n    yield * ls(cid, this.components.blockstore, options)\n  }\n\n  async mkdir (cid: CID, dirname: string, options: Partial<MkdirOptions> = {}): Promise<CID> {\n    return mkdir(cid, dirname, this.components.blockstore, options)\n  }\n\n  async rm (cid: CID, path: string, options: Partial<RmOptions> = {}): Promise<CID> {\n    return rm(cid, path, this.components.blockstore, options)\n  }\n\n  async stat (cid: CID, options?: StatOptions): Promise<FileStats | DirectoryStats | RawStats>\n  async stat (cid: CID, options?: ExtendedStatOptions): Promise<ExtendedFileStats | ExtendedDirectoryStats | ExtendedRawStats>\n  async stat (cid: CID, options: Partial<StatOptions> = {}): Promise<FileStats | DirectoryStats | RawStats> {\n    return stat(cid, this.components.blockstore, options)\n  }\n\n  async touch (cid: CID, options: Partial<TouchOptions> = {}): Promise<CID> {\n    return touch(cid, this.components.blockstore, options)\n  }\n}\n", "// eslint-disable-next-line require-yield\nexport async function * globSource (): AsyncGenerator<any> {\n  throw new Error('Not supported in browsers')\n}\n", "import { UnknownError } from '../errors.js'\nimport type { FileCandidate } from '../index.js'\n\n/**\n * Import a file directly from a URL. The path of the file will be the path\n * section of the URL.\n *\n * @example\n *\n * ```ts\n * import { unixfs, urlSource } from '@helia/unixfs'\n * import { createHelia } from 'helia'\n *\n * const helia = await createHelia()\n * const fs = unixfs(helia)\n *\n * const cid = await fs.addFile(urlSource('http://example.com/path/to/file.html))\n * const stat = await fs.stat(cid)\n *\n * console.info(stat)\n * // { cid: CID(...), type: 'directory', ... }\n *\n * for await (const entry of fs.ls(cid)) {\n *   console.info(entry)\n *   // { type: 'file', name: 'file.html', cid: CID(...), ... }\n * }\n * ```\n */\nexport function urlSource (url: URL | string, options?: RequestInit): FileCandidate<AsyncGenerator<Uint8Array, void, unknown>> {\n  url = new URL(url)\n\n  return {\n    path: decodeURIComponent(new URL(url).pathname.split('/').pop() ?? ''),\n    content: readURLContent(url, options)\n  }\n}\n\n/**\n * Import a file directly from a URL ignoring the file name or any containing\n * directory.\n *\n * @example\n *\n * ```ts\n * import { unixfs, urlByteSource } from '@helia/unixfs'\n * import { createHelia } from 'helia'\n *\n * const helia = await createHelia()\n * const fs = unixfs(helia)\n *\n * const cid = await fs.addByteSource(urlByteSource('http://example.com/path/to/file.html))\n * const stat = await fs.stat(cid)\n *\n * console.info(stat)\n * // { type: 'file', cid: CID(...), ... }\n * ```\n */\nexport function urlByteSource (url: URL | string, options?: RequestInit): AsyncGenerator<Uint8Array, void, unknown> {\n  url = new URL(url)\n\n  return readURLContent(url, options)\n}\n\nasync function * readURLContent (url: URL, options?: RequestInit): AsyncGenerator<Uint8Array, void, unknown> {\n  const response = await globalThis.fetch(url, options)\n\n  if (response.body == null) {\n    throw new UnknownError('HTTP response did not have a body')\n  }\n\n  const reader = response.body.getReader()\n\n  try {\n    while (true) {\n      const { done, value } = await reader.read()\n\n      if (done) {\n        return\n      }\n\n      if (value != null) {\n        yield value\n      }\n    }\n  } finally {\n    reader.releaseLock()\n  }\n}\n"],
  "mappings": "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",
  "names": ["require_murmurHash3js", "__commonJSMin", "exports", "module", "root", "undefined", "library", "_validBytes", "bytes", "i", "_x86Multiply", "m", "n", "_x86Rotl", "_x86Fmix", "h", "_x64Add", "o", "_x64Multiply", "_x64Rotl", "_x64LeftShift", "_x64Xor", "_x64Fmix", "seed", "remainder", "blocks", "h1", "k1", "c1", "c2", "h2", "h3", "h4", "k2", "k3", "k4", "c3", "c4", "require_murmurhash3js_revisited", "__commonJSMin", "exports", "module", "require_sparse_array", "__commonJSMin", "exports", "module", "index", "value", "pos", "needsSort", "last", "iterator", "i", "mapped", "reducer", "initialValue", "acc", "finder", "found", "noCreate", "bytePos", "byte", "bitPos", "previousPopCount", "popCountReduce", "mask", "bytePopCount", "popCount", "targetLength", "data", "elem", "randomIndex", "sortInternal", "bytes", "pendingBitsForResultingByte", "pendingBitsForNewByte", "resultingByte", "newByte", "pending", "usingBits", "masked", "valueOnly", "count", "_v", "v", "a", "b", "require_eventemitter3", "__commonJSMin", "exports", "module", "has", "prefix", "Events", "EE", "fn", "context", "once", "addListener", "emitter", "event", "listener", "evt", "clearEvent", "EventEmitter", "names", "events", "name", "handlers", "l", "ee", "listeners", "a1", "a2", "a3", "a4", "a5", "len", "args", "i", "length", "j", "index_exports", "__export", "globSource", "unixfs", "urlSource", "isAsyncIterable", "thing", "first", "source", "entry", "src_default", "isAsyncIterable", "thing", "batch", "source", "size", "things", "src_default", "parallelBatch", "source", "size", "tasks", "src_default", "things", "p", "value", "err", "result", "alloc", "size", "allocUnsafe", "concat", "arrays", "length", "acc", "curr", "output", "allocUnsafe", "offset", "arr", "equals", "a", "b", "i", "symbol", "findBufAndOffset", "bufs", "index", "offset", "buf", "bufEnd", "isUint8ArrayList", "value", "Uint8ArrayList", "_Uint8ArrayList", "data", "length", "res", "i", "bytes", "beginInclusive", "endExclusive", "concat", "list", "bufStart", "sliceStartInBuf", "sliceEndsInBuf", "start", "search", "needle", "M", "radix", "rightmostPositions", "c", "j", "right", "lastIndex", "lastPatIndex", "skip", "char", "byteOffset", "allocUnsafe", "littleEndian", "alloc", "other", "equals", "acc", "curr", "DEFAULT_CHUNK_SIZE", "fixedSize", "options", "chunkSize", "source", "list", "Uint8ArrayList", "currentLength", "emitted", "buffer", "newBl", "src_exports", "__export", "code", "createLink", "createNode", "decode", "encode", "name", "prepare", "validate", "base32_exports", "__export", "base32", "base32hex", "base32hexpad", "base32hexpadupper", "base32hexupper", "base32pad", "base32padupper", "base32upper", "base32z", "bytes_exports", "__export", "coerce", "empty", "equals", "fromHex", "fromString", "isBinary", "toHex", "toString", "d", "hex", "byte", "hexes", "b", "aa", "bb", "ii", "o", "str", "base", "ALPHABET", "name", "BASE_MAP", "j", "x", "xc", "BASE", "LEADER", "FACTOR", "iFACTOR", "encode", "source", "zeroes", "length", "pbegin", "pend", "size", "b58", "carry", "i", "it1", "it2", "str", "decodeUnsafe", "psz", "b256", "it3", "it4", "vch", "decode", "string", "buffer", "src", "_brrp__multiformats_scope_baseX", "base_x_default", "Encoder", "name", "prefix", "baseEncode", "bytes", "Decoder", "baseDecode", "prefixCodePoint", "text", "decoder", "or", "ComposedDecoder", "decoders", "input", "left", "right", "Codec", "from", "encode", "decode", "baseX", "alphabet", "base_x_default", "coerce", "string", "alphabetIdx", "bitsPerChar", "end", "out", "bits", "buffer", "written", "i", "value", "data", "pad", "mask", "createAlphabetIdx", "rfc4648", "base32", "rfc4648", "base32upper", "base32pad", "base32padupper", "base32hex", "base32hexupper", "base32hexpad", "base32hexpadupper", "base32z", "base36_exports", "__export", "base36", "base36upper", "base36", "baseX", "base36upper", "base58_exports", "__export", "base58btc", "base58flickr", "base58btc", "baseX", "base58flickr", "encode_1", "encode", "MSB", "REST", "MSBALL", "INT", "num", "out", "offset", "oldOffset", "decode", "read", "MSB$1", "REST$1", "buf", "res", "shift", "counter", "b", "l", "N1", "N2", "N3", "N4", "N5", "N6", "N7", "N8", "N9", "length", "value", "varint", "_brrp_varint", "varint_default", "decode", "data", "offset", "varint_default", "encodeTo", "int", "target", "encodingLength", "create", "code", "digest", "size", "sizeOffset", "encodingLength", "digestOffset", "bytes", "encodeTo", "Digest", "decode", "multihash", "coerce", "equals", "a", "b", "data", "format", "link", "base", "bytes", "version", "toStringV0", "baseCache", "base58btc", "toStringV1", "base32", "cache", "baseCache", "cid", "CID", "_CID", "version", "code", "multihash", "bytes", "DAG_PB_CODE", "SHA_256_CODE", "digest", "create", "other", "self", "unknown", "equals", "base", "format", "input", "value", "encodeCID", "cidSymbol", "decode", "remainder", "specs", "prefixSize", "multihashBytes", "coerce", "digestBytes", "Digest", "initialBytes", "offset", "next", "i", "length", "codec", "multihashCode", "digestSize", "size", "multihashSize", "source", "prefix", "parseCIDtoBytes", "decoder", "base58btc", "base32", "base36", "toStringV0", "toStringV1", "codeOffset", "encodingLength", "hashOffset", "encodeTo", "textDecoder", "decodeVarint", "bytes", "offset", "v", "shift", "b", "decodeBytes", "byteLen", "postOffset", "decodeKey", "index", "wire", "decodeLink", "link", "l", "wireType", "fieldNum", "byts", "decodeNode", "links", "linksBeforeData", "data", "node", "textEncoder", "maxInt32", "maxUInt32", "encodeLink", "link", "bytes", "i", "encodeVarint", "nameBytes", "encodeNode", "node", "size", "sizeNode", "index", "sizeLink", "n", "l", "sov", "offset", "v", "base", "x", "len64", "len8tab", "pbNodeProperties", "pbLinkProperties", "textEncoder", "linkComparator", "a", "b", "abuf", "bbuf", "x", "y", "i", "len", "hasOnlyProperties", "node", "properties", "p", "asLink", "link", "Hash", "CID", "pbl", "cid", "e", "prepare", "pbn", "validate", "createNode", "data", "links", "createLink", "name", "size", "toByteView", "buf", "name", "code", "encode", "node", "validate", "pbn", "l", "link", "encodeNode", "decode", "bytes", "buf", "toByteView", "decodeNode", "CID", "InvalidTypeError", "_InvalidTypeError", "message", "InvalidUnixFSMessageError", "_InvalidUnixFSMessageError", "N1", "N2", "N3", "N4", "N5", "N6", "N7", "MSB", "REST", "encodingLength", "value", "encodeUint8Array", "buf", "offset", "decodeUint8Array", "buf", "offset", "b", "res", "REST", "MSB", "N4", "N5", "N6", "N7", "f32", "f8b", "writeFloatLE", "val", "buf", "pos", "readFloatLE", "buf", "pos", "f8b", "f32", "f64", "d8b", "writeDoubleLE", "val", "buf", "pos", "readDoubleLE", "buf", "pos", "d8b", "f64", "MAX_SAFE_NUMBER_INTEGER", "MIN_SAFE_NUMBER_INTEGER", "LongBits", "_LongBits", "lo", "hi", "unsigned", "mask", "part0", "part1", "part2", "value", "zero", "negative", "TWO_32", "sign", "length", "string", "len", "c", "i", "read", "buffer", "start", "end", "parts", "chunk", "t", "write", "offset", "c1", "c2", "indexOutOfRange", "reader", "writeLength", "readFixed32End", "buf", "end", "Uint8ArrayReader", "buffer", "value", "readFloatLE", "readDoubleLE", "length", "start", "bytes", "read", "wireType", "bits", "LongBits", "i", "lo", "hi", "decodeUint8Array", "encodingLength", "createReader", "decodeMessage", "buf", "codec", "opts", "reader", "createReader", "base10_exports", "__export", "base10", "base10", "baseX", "base16_exports", "__export", "base16", "base16upper", "base16", "rfc4648", "base16upper", "base2_exports", "__export", "base2", "base2", "rfc4648", "base256emoji_exports", "__export", "base256emoji", "alphabet", "alphabetBytesToChars", "p", "c", "i", "alphabetCharsToBytes", "codePoint", "encode", "data", "decode", "str", "byts", "char", "byt", "base256emoji", "from", "base64_exports", "__export", "base64", "base64pad", "base64url", "base64urlpad", "base64", "rfc4648", "base64pad", "base64url", "base64urlpad", "base8_exports", "__export", "base8", "base8", "rfc4648", "identity_exports", "__export", "identity", "identity", "from", "buf", "toString", "str", "fromString", "textEncoder", "textDecoder", "code", "decode", "data", "textDecoder", "raw_exports", "__export", "code", "decode", "encode", "name", "name", "code", "encode", "node", "coerce", "decode", "data", "identity_exports", "__export", "identity", "code", "name", "encode", "coerce", "digest", "input", "create", "identity", "sha2_browser_exports", "__export", "sha256", "sha512", "from", "name", "code", "encode", "Hasher", "input", "result", "create", "digest", "sha", "name", "data", "sha256", "from", "sha512", "bases", "identity_exports", "base2_exports", "base8_exports", "base10_exports", "base16_exports", "base32_exports", "base36_exports", "base58_exports", "base64_exports", "base256emoji_exports", "hashes", "sha2_browser_exports", "createCodec", "name", "prefix", "encode", "decode", "string", "buf", "str", "ascii", "i", "allocUnsafe", "BASES", "bases", "bases_default", "fromString", "string", "encoding", "base", "bases_default", "pool", "size", "SIZE", "MAX", "slab", "offset", "allocUnsafe", "buf", "Op", "fn", "len", "val", "noop", "State", "writer", "bufferPool", "pool", "alloc", "size", "allocUnsafe", "Uint8ArrayWriter", "value", "VarintOp", "writeVarint64", "LongBits", "bits", "encodeUint8Array", "encodingLength", "writeByte", "writeFixed32", "writeFloatLE", "writeDoubleLE", "writeBytes", "length", "write", "head", "tail", "buf", "pos", "writeVarint32", "writeBytesBuffer", "writeStringBuffer", "fromString", "createWriter", "encodeMessage", "message", "codec", "w", "createWriter", "CODEC_TYPES", "createCodec", "name", "type", "encode", "decode", "enumeration", "v", "findValue", "val", "encode", "writer", "enumValue", "decode", "reader", "createCodec", "CODEC_TYPES", "message", "encode", "decode", "createCodec", "CODEC_TYPES", "Data", "DataType", "__DataTypeValues", "enumeration", "_codec", "message", "obj", "w", "opts", "value", "UnixTime", "reader", "length", "end", "tag", "encodeMessage", "buf", "decodeMessage", "Metadata", "types", "dirTypes", "DEFAULT_FILE_MODE", "DEFAULT_DIRECTORY_MODE", "MAX_FANOUT", "UnixFS", "_UnixFS", "marshaled", "message", "Data", "InvalidUnixFSMessageError", "data", "options", "type", "blockSizes", "hashType", "fanout", "mtime", "mode", "InvalidTypeError", "size", "index", "sum", "CustomProgressEvent", "type", "detail", "persist", "buffer", "blockstore", "options", "src_exports", "multihash", "sha256", "cid", "CID", "defaultBufferImporter", "options", "file", "blockstore", "bytesWritten", "block", "unixfs", "opts", "src_exports", "raw_exports", "UnixFS", "encode", "cid", "persist", "CustomProgressEvent", "InvalidParametersError", "_InvalidParametersError", "message", "InvalidContentError", "_InvalidContentError", "message", "defaultDirBuilder", "dir", "blockstore", "options", "unixfs", "UnixFS", "block", "encode", "prepare", "cid", "persist", "path", "buildFileBatch", "file", "blockstore", "options", "count", "previous", "entry", "parallelBatch", "isSingleBlockImport", "result", "reduce", "leaves", "leaf", "node", "UnixFS", "encode", "prepare", "persist", "CustomProgressEvent", "f", "links", "code", "block", "cid", "acc", "curr", "defaultFileBuilder", "isIterable", "thing", "isAsyncIterable", "contentAsAsyncIterable", "content", "InvalidContentError", "defaultDagBuilder", "options", "source", "blockstore", "entry", "originalPath", "path", "isFileCandidate", "file", "bytesRead", "chunk", "currentChunkSize", "CustomProgressEvent", "fileBuilder", "defaultFileBuilder", "dir", "dirBuilder", "defaultDirBuilder", "defaultChunkValidator", "source", "content", "InvalidContentError", "fromString", "DEFAULT_MAX_CHILDREN_PER_NODE", "balanced", "options", "maxChildrenPerNode", "balancedLayout", "source", "reduce", "roots", "chunked", "src_default", "isAsyncIterable", "thing", "all", "source", "arr", "entry", "src_default", "Dir", "props", "options", "CID_V0", "CID", "CID_V1", "DirFlat", "Dir", "props", "options", "name", "value", "key", "child", "CID_V1", "CID_V0", "block", "links", "result", "entry", "unixfs", "UnixFS", "node", "buffer", "encode", "prepare", "cid", "persist", "size", "acc", "curr", "import_murmurhash3js_revisited", "fromNumberTo32BitBuf", "number", "bytes", "i", "murmur332", "from", "input", "mur", "murmur3128", "bytes_exports", "murmur364", "import_sparse_array", "Bucket", "_Bucket", "options", "parent", "posAtParent", "SparseArray", "key", "value", "place", "child", "acc", "children", "map", "reduce", "index", "asyncMap", "asyncReduce", "asyncTransformBucket", "mapNode", "reduceNodes", "result", "hashValue", "fromString", "bucket", "newPlace", "pos", "object", "onlyChild", "exists", "hash", "o", "node", "_", "nodes", "output", "mappedChildren", "START_MASKS", "STOP_MASKS", "ConsumableBuffer", "value", "bits", "pendingBits", "result", "byte", "availableBits", "taking", "byteBitsToInt", "start", "length", "mask", "maskFor", "wrapHash", "hashFn", "hashing", "value", "InfiniteHash", "bits", "pendingBits", "result", "hash", "available", "took", "availableForUntake", "concat", "hashValue", "buffer", "ConsumableBuffer", "createHAMT", "options", "bucketOptions", "wrapHash", "Bucket", "hamtHashFn", "buf", "murmur3128", "HAMT_HASH_CODE", "DEFAULT_FANOUT_BITS", "DirSharded", "Dir", "props", "options", "createHAMT", "name", "value", "key", "calculateSize", "blockstore", "entry", "flush", "dir_sharded_default", "bucket", "shardRoot", "children", "padLength", "links", "childrenSize", "i", "child", "labelPrefix", "Bucket", "shard", "subShard", "isDir", "dir", "flushedDir", "label", "size", "data", "UnixFS", "node", "buffer", "encode", "prepare", "cid", "persist", "obj", "CID_V0", "CID_V1", "flatToShard", "child", "dir", "threshold", "options", "newDir", "DirFlat", "convertToShard", "parent", "oldDir", "dir_sharded_default", "key", "toPathComponents", "path", "addToTree", "elem", "tree", "options", "pathElems", "toPathComponents", "lastIndex", "parent", "currentPath", "i", "pathElem", "last", "flatToShard", "dir", "Dir", "DirFlat", "flushAndYield", "blockstore", "defaultTreeBuilder", "source", "block", "rootDir", "singleRoot", "entry", "unwrapped", "importer", "source", "blockstore", "options", "candidates", "wrapWithDirectory", "shardSplitThresholdBytes", "shardFanoutBits", "cidVersion", "rawLeaves", "leafType", "fileImportConcurrency", "blockWriteConcurrency", "reduceSingleLeafToSelf", "chunker", "fixedSize", "chunkValidator", "defaultChunkValidator", "buildDag", "defaultDagBuilder", "balanced", "defaultBufferImporter", "buildTree", "defaultTreeBuilder", "entry", "parallelBatch", "importFile", "content", "result", "src_default", "InvalidParametersError", "importBytes", "buf", "blockstore", "options", "importFile", "importByteStream", "bufs", "isAsyncIterable", "thing", "last", "source", "res", "entry", "src_default", "UnixFSError", "message", "name", "code", "NotUnixFSError", "InvalidPBNodeError", "UnknownError", "AlreadyExistsError", "DoesNotExistError", "NoContentError", "NotAFileError", "NotADirectoryError", "InvalidParametersError", "defaultImporterSettings", "balanced", "fixedSize", "addAll", "source", "blockstore", "options", "importer", "addBytes", "bytes", "cid", "importBytes", "addByteStream", "importByteStream", "addFile", "file", "InvalidParametersError", "result", "src_default", "addDirectory", "dir", "isPlainObject", "value", "prototype", "hasOwnProperty", "propertyIsEnumerable", "defineProperty", "object", "name", "value", "globalThis", "defaultMergeOptions", "getEnumerableOwnPropertyKeys", "keys", "key", "symbols", "symbol", "clone", "cloneArray", "isPlainObject", "cloneOptionObject", "array", "result", "mergeKeys", "merged", "source", "config", "merge", "concatArrays", "resultIndex", "indices", "k", "mergeOptions", "options", "option", "BadPathError", "_BadPathError", "message", "NotFoundError", "_NotFoundError", "NoResolverError", "_NoResolverError", "NotUnixFSError", "_NotUnixFSError", "OverReadError", "_OverReadError", "UnderReadError", "_UnderReadError", "NoPropError", "_NoPropError", "InvalidParametersError", "_InvalidParametersError", "typeofs", "objectTypeNames", "is", "value", "typeOf", "isBuffer", "objectType", "getObjectType", "objectTypeName", "Type", "major", "name", "terminal", "typ", "Token", "type", "value", "encodedLength", "useBuffer", "textDecoder", "textEncoder", "isBuffer", "buf", "asU8A", "toString", "bytes", "start", "end", "utf8Slice", "fromString", "string", "utf8ToBytes", "slice", "useBuffer", "bytes", "start", "end", "isBuffer", "concat", "chunks", "length", "c", "asU8A", "out", "off", "b", "alloc", "size", "compare", "b1", "b2", "isBuffer", "i", "utf8ToBytes", "str", "out", "p", "c", "utf8Slice", "buf", "offset", "end", "res", "firstByte", "codePoint", "bytesPerSequence", "secondByte", "thirdByte", "fourthByte", "tempCodePoint", "decodeCodePointsArray", "MAX_ARGUMENTS_LENGTH", "codePoints", "len", "defaultChunkSize", "Bl", "chunkSize", "bytes", "topChunk", "chunkPos", "alloc", "reset", "byts", "chunk", "slice", "concat", "decodeErrPrefix", "encodeErrPrefix", "uintMinorPrefixBytes", "assertEnoughData", "data", "pos", "need", "uintBoundaries", "readUint8", "data", "offset", "options", "assertEnoughData", "value", "decodeErrPrefix", "readUint16", "readUint32", "readUint64", "hi", "lo", "decodeUint8", "pos", "_minor", "Token", "Type", "decodeUint16", "decodeUint32", "decodeUint64", "encodeUint", "buf", "token", "encodeUintValue", "major", "uint", "nuint", "buint", "set", "tok1", "tok2", "decodeNegint8", "data", "pos", "_minor", "options", "Token", "Type", "readUint8", "decodeNegint16", "readUint16", "decodeNegint32", "readUint32", "neg1b", "pos1b", "decodeNegint64", "int", "readUint64", "value", "decodeErrPrefix", "encodeNegint", "buf", "token", "negint", "unsigned", "encodeUintValue", "uintBoundaries", "tok1", "tok2", "toToken", "data", "pos", "prefix", "length", "assertEnoughData", "buf", "slice", "Token", "Type", "decodeBytesCompact", "minor", "_options", "decodeBytes8", "_minor", "options", "readUint8", "decodeBytes16", "readUint16", "decodeBytes32", "readUint32", "decodeBytes64", "l", "readUint64", "decodeErrPrefix", "tokenBytes", "token", "fromString", "encodeBytes", "bytes", "encodeUintValue", "tok1", "tok2", "compareBytes", "b1", "b2", "compare", "toToken", "data", "pos", "prefix", "length", "options", "totLength", "assertEnoughData", "tok", "Token", "Type", "toString", "slice", "decodeStringCompact", "minor", "decodeString8", "_minor", "readUint8", "decodeString16", "readUint16", "decodeString32", "readUint32", "decodeString64", "l", "readUint64", "decodeErrPrefix", "encodeString", "encodeBytes", "toToken", "_data", "_pos", "prefix", "length", "Token", "Type", "decodeArrayCompact", "data", "pos", "minor", "_options", "decodeArray8", "_minor", "options", "readUint8", "decodeArray16", "readUint16", "decodeArray32", "readUint32", "decodeArray64", "l", "readUint64", "decodeErrPrefix", "decodeArrayIndefinite", "encodeArray", "buf", "token", "encodeUintValue", "encodeUint", "toToken", "_data", "_pos", "prefix", "length", "Token", "Type", "decodeMapCompact", "data", "pos", "minor", "_options", "decodeMap8", "_minor", "options", "readUint8", "decodeMap16", "readUint16", "decodeMap32", "readUint32", "decodeMap64", "l", "readUint64", "decodeErrPrefix", "decodeMapIndefinite", "encodeMap", "buf", "token", "encodeUintValue", "encodeUint", "decodeTagCompact", "_data", "_pos", "minor", "_options", "Token", "Type", "decodeTag8", "data", "pos", "_minor", "options", "readUint8", "decodeTag16", "readUint16", "decodeTag32", "readUint32", "decodeTag64", "readUint64", "encodeTag", "buf", "token", "encodeUintValue", "encodeUint", "MINOR_FALSE", "MINOR_TRUE", "MINOR_NULL", "MINOR_UNDEFINED", "decodeUndefined", "_data", "_pos", "_minor", "options", "decodeErrPrefix", "Token", "Type", "decodeBreak", "createToken", "value", "bytes", "decodeFloat16", "data", "pos", "readFloat16", "decodeFloat32", "readFloat32", "decodeFloat64", "readFloat64", "encodeFloat", "buf", "token", "float", "decoded", "success", "encodeFloat16", "ui8a", "encodeFloat32", "encodeFloat64", "buffer", "dataView", "inp", "valu32", "exponent", "mantissa", "logicalExponent", "half", "exp", "mant", "val", "offset", "encodeUint", "invalidMinor", "data", "pos", "minor", "decodeErrPrefix", "errorer", "msg", "jump", "i", "decodeUint8", "decodeUint16", "decodeUint32", "decodeUint64", "decodeNegint8", "decodeNegint16", "decodeNegint32", "decodeNegint64", "decodeBytesCompact", "decodeBytes8", "decodeBytes16", "decodeBytes32", "decodeBytes64", "decodeStringCompact", "decodeString8", "decodeString16", "decodeString32", "decodeString64", "decodeArrayCompact", "decodeArray8", "decodeArray16", "decodeArray32", "decodeArray64", "decodeArrayIndefinite", "decodeMapCompact", "decodeMap8", "decodeMap16", "decodeMap32", "decodeMap64", "decodeMapIndefinite", "decodeTagCompact", "decodeTag8", "decodeTag16", "decodeTag32", "decodeTag64", "decodeUndefined", "decodeFloat16", "decodeFloat32", "decodeFloat64", "decodeBreak", "quick", "Token", "Type", "makeCborEncoders", "encoders", "Type", "encodeUint", "encodeNegint", "encodeBytes", "encodeString", "encodeArray", "encodeMap", "encodeTag", "encodeFloat", "cborEncoders", "buf", "Bl", "Ref", "_Ref", "obj", "parent", "p", "stack", "encodeErrPrefix", "simpleTokens", "Token", "typeEncoders", "_typ", "_options", "_refStack", "_obj", "options", "refStack", "entries", "i", "e", "objectToTokens", "typ", "isMap", "keys", "length", "key", "sortMapEntries", "is", "customTypeEncoder", "tokens", "typeEncoder", "defaultDecodeOptions", "Tokeniser", "data", "options", "byt", "token", "quick", "decoder", "jump", "decodeErrPrefix", "minor", "DONE", "BREAK", "tokenToArray", "tokeniser", "arr", "value", "tokensToObject", "tokenToMap", "useMaps", "obj", "m", "i", "key", "Type", "tagged", "decodeFirst", "decoded", "decode", "remainder", "CID_CBOR_TAG", "toByteView", "buf", "cidEncoder", "obj", "cid", "CID", "bytes", "Token", "Type", "undefinedEncoder", "numberEncoder", "num", "_encodeOptions", "encodeOptions", "cidDecoder", "_decodeOptions", "decodeOptions", "code", "decode", "data", "toByteView", "_decodeOptions", "JSONEncoder", "buf", "recurs", "Type", "token", "is", "isa", "i", "_buf", "_token", "encodeErrPrefix", "byts", "fromString", "asU8A", "dp", "Tokenizer", "data", "options", "c", "str", "decodeErrPrefix", "i", "startPos", "negative", "float", "swallow", "chars", "ch", "Token", "Type", "numStr", "num", "l", "readu4", "u4", "readUtf8Char", "firstByte", "codePoint", "bytesPerSequence", "secondByte", "thirdByte", "fourthByte", "tempCodePoint", "ch1", "decodeCodePointsArray", "token", "decode", "toByteView", "buf", "DagJsonTokenizer", "Tokenizer", "data", "options", "token", "Type", "keyToken", "valueToken", "Token", "innerKeyToken", "innerValueToken", "i", "bytes", "base64", "decodeOptions", "CID", "code", "decode", "data", "buf", "toByteView", "options", "decodeOptions", "DagJsonTokenizer", "utf8Decoder", "utf8Encoder", "resolveObjectPath", "object", "block", "cid", "name", "path", "toResolve", "depth", "subObject", "subPath", "prop", "subObjectCid", "CID", "NoPropError", "resolve", "cid", "name", "path", "toResolve", "depth", "blockstore", "options", "block", "object", "decode", "resolveObjectPath", "dag_cbor_default", "resolve", "cid", "name", "path", "toResolve", "depth", "blockstore", "options", "block", "object", "decode", "resolveObjectPath", "dag_json_default", "extractDataFromBlock", "block", "blockStart", "requestedStart", "requestedEnd", "blockLength", "blockEnd", "extract_data_from_block_default", "validateOffsetAndLength", "size", "offset", "length", "fileSize", "start", "end", "InvalidParametersError", "validate_offset_and_length_default", "rawContent", "node", "contentGenerator", "options", "start", "end", "validate_offset_and_length_default", "buf", "extract_data_from_block_default", "CustomProgressEvent", "resolve", "cid", "name", "path", "toResolve", "depth", "blockstore", "NotFoundError", "decode", "identity_default", "resolve", "cid", "name", "path", "toResolve", "depth", "blockstore", "options", "block", "object", "decode", "resolveObjectPath", "json_default", "rawContent", "node", "contentGenerator", "options", "start", "end", "validate_offset_and_length_default", "buf", "extract_data_from_block_default", "CustomProgressEvent", "resolve", "cid", "name", "path", "toResolve", "depth", "blockstore", "NotFoundError", "block", "raw_default", "hashFn", "buf", "murmur3128", "addLinksToHamtBucket", "links", "bucket", "rootBucket", "padLength", "link", "pos", "Bucket", "toPrefix", "position", "toBucketPath", "path", "findShardCid", "node", "name", "blockstore", "context", "options", "NotUnixFSError", "dir", "UnixFS", "err", "createHAMT", "prefix", "bucketPath", "entryPrefix", "entryName", "block", "decode", "find_cid_in_shard_default", "peekable", "iterable", "iterator", "symbol", "queue", "value", "src_default", "isAsyncIterable", "thing", "filter", "source", "fn", "index", "entry", "peekable", "src_default", "value", "done", "res", "func", "isAsyncIterable", "thing", "map", "source", "func", "index", "val", "peekable", "src_default", "value", "done", "res", "fn", "pDefer", "deferred", "resolve", "reject", "CustomEvent", "parallel", "source", "options", "concurrency", "ordered", "emitter", "ops", "slotAvailable", "pDefer", "resultAvailable", "sourceFinished", "sourceErr", "opErred", "task", "op", "result", "err", "valuesAvailable", "yieldOrderedValues", "yieldUnOrderedValues", "i", "FixedFIFO", "hwm", "data", "last", "FIFO", "options", "obj", "val", "prev", "next", "AbortError", "message", "code", "pushable", "options", "_pushable", "buffer", "next", "_pushable", "getNext", "options", "onEnd", "buffer", "FIFO", "pushable", "onNext", "ended", "drain", "pDefer", "waitNext", "resolve", "reject", "next", "err", "bufferNext", "bufferError", "push", "value", "end", "_return", "_throw", "signal", "cancel", "listener", "AbortError", "opts", "AbortError", "message", "code", "name", "raceSignal", "promise", "signal", "opts", "listener", "error", "resolve", "reject", "QueuelessPushable", "pDefer", "nextResult", "err", "result", "value", "options", "raceSignal", "queuelessPushable", "isAsyncIterable", "thing", "addAllToPushable", "sources", "output", "signal", "source", "item", "err", "mergeSources", "controller", "queuelessPushable", "mergeSyncSources", "syncSources", "merge", "src_default", "pipe", "first", "rest", "isDuplex", "duplex", "isIterable", "isAsyncIterable", "source", "fns", "i", "duplexPipelineFn", "rawPipe", "res", "obj", "p", "stream", "pushable", "err", "sourceWrap", "src_default", "directoryContent", "cid", "node", "unixfs", "path", "resolve", "depth", "blockstore", "yieldDirectoryContent", "options", "offset", "length", "links", "CustomProgressEvent", "pipe", "source", "src_default", "link", "linkName", "linkPath", "parallel", "entry", "directory_default", "import_index", "TimeoutError", "message", "AbortError", "getDOMException", "errorMessage", "getAbortedReason", "signal", "reason", "pTimeout", "promise", "options", "milliseconds", "fallback", "customTimers", "timer", "abortHandler", "cancelablePromise", "resolve", "reject", "timeoutError", "error", "lowerBound", "array", "value", "comparator", "first", "count", "step", "it", "PriorityQueue", "#queue", "run", "options", "element", "index", "lowerBound", "a", "b", "id", "priority", "item", "PQueue", "EventEmitter", "#carryoverConcurrencyCount", "#isIntervalIgnored", "#intervalCount", "#intervalCap", "#interval", "#intervalEnd", "#intervalId", "#timeoutId", "#queue", "#queueClass", "#pending", "#concurrency", "#isPaused", "#throwOnTimeout", "#idAssigner", "options", "PriorityQueue", "#doesIntervalAllowAnother", "#doesConcurrentAllowAnother", "#next", "#tryToStartAnother", "#onResumeInterval", "#onInterval", "#initializeIntervalIfNeeded", "#isIntervalPaused", "now", "delay", "canInitializeInterval", "job", "#processQueue", "newConcurrency", "#throwOnAbort", "signal", "_resolve", "reject", "id", "priority", "function_", "resolve", "operation", "pTimeout", "result", "error", "TimeoutError", "functions", "#onEvent", "limit", "event", "filter", "listener", "walkDAG", "blockstore", "node", "queue", "streamPosition", "start", "end", "options", "buf", "extract_data_from_block_default", "NotUnixFSError", "file", "UnixFS", "err", "data", "childOps", "i", "childLink", "childStart", "childEnd", "pipe", "source", "src_default", "op", "block", "parallel", "link", "blockStart", "child", "code", "decode", "childQueue", "PQueue", "error", "CustomProgressEvent", "fileContent", "cid", "unixfs", "path", "resolve", "depth", "yieldFileContent", "fileSize", "validate_offset_and_length_default", "read", "wanted", "pushable", "OverReadError", "UnderReadError", "file_default", "hamtShardedDirectoryContent", "cid", "node", "unixfs", "path", "resolve", "depth", "blockstore", "yieldHamtDirectoryContent", "options", "CustomProgressEvent", "listDirectory", "links", "NotUnixFSError", "dir", "UnixFS", "err", "padLength", "results", "pipe", "source", "src_default", "link", "name", "result", "block", "decode", "parallel", "entries", "hamt_sharded_directory_default", "findLinkCid", "node", "name", "link", "contentExporters", "file_default", "directory_default", "hamt_sharded_directory_default", "cid", "unixfs", "path", "resolve", "depth", "blockstore", "unixFsResolver", "toResolve", "options", "block", "decode", "next", "NotUnixFSError", "UnixFS", "err", "linkCid", "find_cid_in_shard_default", "NotFoundError", "nextName", "nextPath", "content", "unixfs_v1_default", "resolvers", "code", "unixfs_v1_default", "raw_default", "dag_cbor_default", "dag_json_default", "identity", "identity_default", "json_default", "resolve", "cid", "name", "path", "toResolve", "depth", "blockstore", "options", "resolver", "NoResolverError", "resolvers_default", "toPathComponents", "path", "cidAndRest", "CID", "cid", "output", "BadPathError", "walkPath", "blockstore", "options", "toResolve", "name", "entryPath", "startingDepth", "result", "resolvers_default", "NotFoundError", "exporter", "src_default", "recursive", "node", "child", "recurse", "file", "ms", "value", "options", "parse", "fmtLong", "fmtShort", "error", "message", "isError", "str", "match", "n", "type", "dist_default", "msAbs", "plural", "name", "isPlural", "setup", "env", "createDebug", "coerce", "disable", "enable", "enabled", "dist_default", "destroy", "key", "selectColor", "namespace", "hash", "i", "prevTime", "enableOverride", "namespacesCache", "enabledCache", "debug", "args", "self", "curr", "ms", "index", "match", "format", "formatter", "val", "extend", "v", "delimiter", "newDebug", "namespaces", "split", "len", "toNamespace", "name", "regexp", "storage", "localstorage", "colors", "useColors", "formatArgs", "args", "dist_default", "c", "index", "lastC", "match", "log", "save", "namespaces", "load", "setupFormatters", "formatters", "v", "error", "browser_default", "setup", "src_default", "browser_default", "src_default", "v", "base58btc", "base32", "base64", "notEmpty", "createDisabledLogger", "namespace", "logger", "logger", "name", "trace", "createDisabledLogger", "src_default", "r", "n", "notEmpty", "str", "import_sparse_array", "wrapHash", "hashFn", "hashing", "value", "InfiniteHash", "bits", "pendingBits", "result", "hash", "available", "took", "availableForUntake", "concat", "hashValue", "buffer", "ConsumableBuffer", "START_MASKS", "STOP_MASKS", "byte", "availableBits", "taking", "byteBitsToInt", "start", "length", "mask", "maskFor", "hamtHashCode", "murmur3128", "hamtBucketBits", "hamtHashFn", "buf", "import_sparse_array", "persist", "buffer", "blockstore", "options", "src_exports", "multihash", "sha256", "cid", "CID", "Dir", "props", "options", "DirSharded", "createHAMT", "hamtHashFn", "name", "value", "key", "calculateSize", "blockstore", "entry", "flush", "bucket", "shardRoot", "children", "links", "childrenSize", "i", "child", "labelPrefix", "Bucket", "shard", "subShard", "isDir", "dir", "flushedDir", "label", "size", "data", "UnixFS", "hamtHashCode", "node", "buffer", "encode", "prepare", "cid", "persist", "obj", "CID_V0", "CID_V1", "CID", "log", "logger", "toPrefix", "position", "createShard", "blockstore", "contents", "options", "shard", "DirSharded", "i", "res", "src_default", "updateShardedDirectory", "path", "shardRoot", "UnixFS", "fanout", "hamtBucketBits", "cid", "node", "isRoot", "segment", "data", "dir", "hamtHashCode", "block", "encode", "prepare", "persist", "nextSegment", "l", "acc", "curr", "recreateShardedDirectory", "fileName", "hash", "wrapHash", "hamtHashFn", "fromString", "decode", "children", "SparseArray", "index", "prefix", "childLink", "link", "linkName", "isOverShardThreshold", "node", "blockstore", "threshold", "options", "unixfs", "UnixFS", "size", "estimateNodeSize", "estimateShardSize", "link", "CID_V1", "CID_V0", "current", "max", "name", "code", "block", "decode", "log", "logger", "addLink", "parent", "child", "blockstore", "options", "InvalidParametersError", "UnixFS", "addToShardedDirectory", "result", "addToDirectory", "isOverShardThreshold", "converted", "convertToShardedDirectory", "decode", "unixfs", "createShard", "link", "parentLinks", "matches", "AlreadyExistsError", "InvalidPBNodeError", "node", "data", "ms", "secs", "prepare", "buf", "encode", "hash", "sha256", "cid", "CID", "code", "path", "recreateShardedDirectory", "finalSegment", "prefix", "index", "linkName", "existingLink", "l", "sibling", "siblingName", "siblingHash", "wrapHash", "hamtHashFn", "fromString", "i", "hamtBucketBits", "siblingIndex", "siblingPrefix", "toPrefix", "newIndex", "newPrefix", "children", "SparseArray", "updateShardedDirectory", "cidToDirectory", "cid", "blockstore", "options", "entry", "exporter", "NotADirectoryError", "cidToPBLink", "cid", "name", "blockstore", "options", "sourceEntry", "exporter", "NotUnixFSError", "dagNodeTsize", "node", "linkSizes", "acc", "curr", "encode", "log", "logger", "resolve", "cid", "path", "blockstore", "options", "p", "segments", "src_default", "walkPath", "DoesNotExistError", "updatePathCids", "result", "child", "parent", "directory", "pblink", "cidToDirectory", "cidToPBLink", "addLink", "mergeOptions", "defaultOptions", "cat", "cid", "blockstore", "options", "opts", "resolved", "resolve", "result", "exporter", "NotAFileError", "NoContentError", "mergeOptions", "log", "logger", "defaultOptions", "chmod", "cid", "mode", "blockstore", "options", "opts", "resolved", "resolve", "root", "pipe", "entry", "recursive", "metadata", "links", "UnixFS", "NotUnixFSError", "node", "source", "importer", "block", "buf", "encode", "updatedCid", "persist", "InvalidPBNodeError", "unixfs", "nodes", "src_default", "UnknownError", "updatePathCids", "code", "decode", "updatedBlock", "hash", "sha256", "CID", "mergeOptions", "log", "logger", "defaultOptions", "cp", "source", "target", "name", "blockstore", "options", "opts", "InvalidParametersError", "directory", "pblink", "cidToDirectory", "cidToPBLink", "addLink", "mergeOptions", "defaultOptions", "ls", "cid", "blockstore", "options", "opts", "resolved", "resolve", "result", "exporter", "NoContentError", "NotADirectoryError", "mergeOptions", "log", "logger", "defaultOptions", "mkdir", "parentCid", "dirname", "blockstore", "options", "opts", "InvalidParametersError", "exporter", "NotADirectoryError", "node", "UnixFS", "buf", "encode", "hash", "sha256", "emptyDirCid", "CID", "code", "directory", "pblink", "cidToDirectory", "cidToPBLink", "addLink", "log", "logger", "removeLink", "parent", "name", "blockstore", "options", "InvalidPBNodeError", "UnixFS", "result", "removeFromShardedDirectory", "isOverShardThreshold", "convertToFlatDirectory", "removeFromDirectory", "link", "parentBlock", "encode", "parentCid", "persist", "path", "recreateShardedDirectory", "finalSegment", "linkName", "l", "prefix", "index", "segment", "nextSegment", "updateShardedDirectory", "InvalidParametersError", "rootNode", "dir", "exporter", "entry", "tsize", "oldUnixfs", "block", "prepare", "src_exports", "mergeOptions", "log", "logger", "defaultOptions", "rm", "target", "name", "blockstore", "options", "opts", "InvalidParametersError", "directory", "cidToDirectory", "removeLink", "FNV_PRIMES", "FNV_OFFSETS", "cachedEncoder", "fnv1aUint8Array", "uint8Array", "size", "fnvPrime", "hash", "index", "fnv1aEncodeInto", "string", "utf8Buffer", "remaining", "result", "fnv1a", "value", "fnv1a", "input", "seed", "numberToBuffer", "num", "hex", "fromString", "MAX_FINGERPRINT_SIZE", "Fingerprint", "buf", "hash", "seed", "fingerprintSize", "fnv", "fp", "alloc", "i", "other", "equals", "getRandomInt", "min", "max", "Bucket", "size", "fingerprint", "Fingerprint", "fp", "i", "getRandomInt", "current", "found", "maxCuckooCount", "CuckooFilter", "init", "fnv1a", "getRandomInt", "item", "fromString", "fingerprint", "Fingerprint", "j", "k", "Bucket", "rand", "i", "n", "swapped", "inJ", "inK", "ScalableCuckooFilter", "init", "fnv1a", "getRandomInt", "CuckooFilter", "item", "fromString", "current", "cuckoo", "curSize", "i", "acc", "curr", "DEFAULT_DIR_MODE", "DEFAULT_FILE_MODE", "mergeOptions", "log", "logger", "defaultOptions", "stat", "cid", "blockstore", "options", "opts", "resolved", "resolve", "result", "exporter", "createExtendedRawStats", "createRawStats", "createExtendedStats", "ScalableCuckooFilter", "createStats", "NotUnixFSError", "entry", "filter", "stats", "inspectDag", "isFile", "results", "alreadyTraversed", "block", "code", "pbNode", "decode", "unixfs", "UnixFS", "link", "linkResult", "linkIsFile", "InvalidPBNodeError", "UnknownError", "err", "parent", "name", "mergeOptions", "log", "logger", "defaultOptions", "touch", "cid", "blockstore", "options", "opts", "resolved", "resolve", "mtime", "root", "pipe", "entry", "recursive", "metadata", "links", "UnixFS", "NotUnixFSError", "node", "source", "importer", "block", "buf", "encode", "updatedCid", "persist", "InvalidPBNodeError", "unixfs", "nodes", "src_default", "UnknownError", "updatePathCids", "code", "decode", "updatedBlock", "hash", "sha256", "CID", "UnixFS", "components", "source", "options", "addAll", "bytes", "addBytes", "addByteStream", "file", "addFile", "dir", "addDirectory", "cid", "cat", "mode", "chmod", "target", "name", "cp", "ls", "dirname", "mkdir", "path", "rm", "stat", "touch", "globSource", "urlSource", "url", "options", "readURLContent", "readURLContent", "url", "options", "response", "UnknownError", "reader", "done", "value", "unixfs", "helia", "UnixFS"]
}
