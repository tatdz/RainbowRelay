import { AbstractSession } from '@helia/utils';
import { isPeerId } from '@libp2p/interface';
import { multiaddrToUri } from '@multiformats/multiaddr-to-uri';
import { TrustlessGateway } from './trustless-gateway.js';
import { filterNonHTTPMultiaddrs, findHttpGatewayProviders } from './utils.js';
import { DEFAULT_ALLOW_INSECURE, DEFAULT_ALLOW_LOCAL } from './index.js';
class TrustlessGatewaySession extends AbstractSession {
    routing;
    allowInsecure;
    allowLocal;
    transformRequestInit;
    constructor(components, init) {
        super(components, {
            ...init,
            name: 'helia:trustless-gateway:session'
        });
        this.routing = components.routing;
        this.allowInsecure = init.allowInsecure ?? DEFAULT_ALLOW_INSECURE;
        this.allowLocal = init.allowLocal ?? DEFAULT_ALLOW_LOCAL;
        this.transformRequestInit = init.transformRequestInit;
    }
    async queryProvider(cid, provider, options) {
        this.log('fetching BLOCK for %c from %s', cid, provider.url);
        const block = await provider.getRawBlock(cid, options);
        this.log.trace('got block for %c from %s', cid, provider.url);
        await options.validateFn?.(block);
        return block;
    }
    async *findNewProviders(cid, options = {}) {
        yield* findHttpGatewayProviders(cid, this.routing, this.logger, this.allowInsecure, this.allowLocal, { ...options, transformRequestInit: this.transformRequestInit });
    }
    toEvictionKey(provider) {
        return provider.url.toString();
    }
    equals(providerA, providerB) {
        return providerA.url.toString() === providerB.url.toString();
    }
    async convertToProvider(provider, options) {
        if (isPeerId(provider)) {
            return;
        }
        const httpAddresses = filterNonHTTPMultiaddrs(Array.isArray(provider) ? provider : [provider], this.allowInsecure, this.allowLocal);
        if (httpAddresses.length === 0) {
            return;
        }
        // take first address?
        // /ip4/x.x.x.x/tcp/31337/http
        // /ip4/x.x.x.x/tcp/31337/https
        // etc
        const uri = multiaddrToUri(httpAddresses[0]);
        return new TrustlessGateway(uri, {
            logger: this.logger,
            transformRequestInit: this.transformRequestInit
        });
    }
}
export function createTrustlessGatewaySession(components, init) {
    return new TrustlessGatewaySession(components, init);
}
//# sourceMappingURL=session.js.map