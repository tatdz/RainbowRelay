{
  "version": 3,
  "sources": ["../src/index.ts", "../src/blocks.ts", "../src/errors.ts"],
  "sourcesContent": ["/**\n * @packageDocumentation\n *\n * The API defined by a {@link Helia} node\n *\n * @example\n *\n * ```typescript\n * import type { Helia } from '@helia/interface'\n *\n * export function doSomething(helia: Helia) {\n *   // use helia node functions here\n * }\n * ```\n */\n\nimport type { Blocks } from './blocks.js'\nimport type { Pins } from './pins.js'\nimport type { Routing } from './routing.js'\nimport type { AbortOptions, ComponentLogger, Libp2p, Metrics } from '@libp2p/interface'\nimport type { DNS } from '@multiformats/dns'\nimport type { Datastore } from 'interface-datastore'\nimport type { Await } from 'interface-store'\nimport type { BlockCodec, MultihashHasher } from 'multiformats'\nimport type { CID } from 'multiformats/cid'\nimport type { ProgressEvent, ProgressOptions } from 'progress-events'\n\nexport type { Await, AwaitIterable } from 'interface-store'\n\nexport interface CodecLoader {\n  <T = any, Code extends number = any>(code: Code): Await<BlockCodec<Code, T>>\n}\n\nexport interface HasherLoader {\n  (code: number): Await<MultihashHasher>\n}\n\n/**\n * The API presented by a Helia node\n */\nexport interface Helia<T extends Libp2p = Libp2p> {\n  /**\n   * The libp2p instance\n   */\n  libp2p: T\n\n  /**\n   * Where the blocks are stored\n   */\n  blockstore: Blocks\n\n  /**\n   * A key/value store\n   */\n  datastore: Datastore\n\n  /**\n   * Pinning operations for blocks in the blockstore\n   */\n  pins: Pins\n\n  /**\n   * A logging component that can be reused by consumers\n   */\n  logger: ComponentLogger\n\n  /**\n   * The routing component allows performing operations such as looking up\n   * content providers, information about peers, etc.\n   */\n  routing: Routing\n\n  /**\n   * The DNS property can be used to perform lookups of various record types and\n   * will use a resolver appropriate to the current platform.\n   */\n  dns: DNS\n\n  /**\n   * A metrics object that can be used to collected arbitrary stats about node\n   * usage.\n   */\n  metrics?: Metrics\n\n  /**\n   * Starts the Helia node\n   */\n  start(): Promise<void>\n\n  /**\n   * Stops the Helia node\n   */\n  stop(): Promise<void>\n\n  /**\n   * Remove any unpinned blocks from the blockstore\n   */\n  gc(options?: GCOptions): Promise<void>\n\n  /**\n   * Load an IPLD codec. Implementations may return a promise if, for example,\n   * the codec is being fetched from the network.\n   */\n  getCodec: CodecLoader\n\n  /**\n   * Hashers can be used to hash a piece of data with the specified hashing\n   * algorithm. Implementations may return a promise if, for example,\n   * the hasher is being fetched from the network.\n   */\n  getHasher: HasherLoader\n}\n\nexport type GcEvents =\n  ProgressEvent<'helia:gc:deleted', CID> |\n  ProgressEvent<'helia:gc:error', Error>\n\nexport interface GCOptions extends AbortOptions, ProgressOptions<GcEvents> {\n\n}\n\nexport * from './blocks.js'\nexport * from './errors.js'\nexport * from './pins.js'\nexport * from './routing.js'\n", "import type { PeerId } from '@libp2p/interface'\nimport type { Multiaddr } from '@multiformats/multiaddr'\nimport type { Blockstore } from 'interface-blockstore'\nimport type { AbortOptions } from 'interface-store'\nimport type { CID } from 'multiformats/cid'\nimport type { ProgressEvent, ProgressOptions } from 'progress-events'\n\nexport interface Pair {\n  cid: CID\n  block: Uint8Array\n}\n\nexport interface ProviderOptions {\n  /**\n   * An optional list of peers known to host at least the root block of the DAG\n   * that will be fetched.\n   *\n   * If this list is omitted, or if the peers cannot supply the root or any\n   * child blocks, a `findProviders` routing query will be run to find peers\n   * that can supply the blocks.\n   */\n  providers?: Array<PeerId | Multiaddr | Multiaddr[]>\n}\n\nexport type HasBlockProgressEvents =\n  ProgressEvent<'blocks:put:duplicate', CID> |\n  ProgressEvent<'blocks:put:providers:notify', CID> |\n  ProgressEvent<'blocks:put:blockstore:put', CID>\n\nexport type PutBlockProgressEvents =\n  ProgressEvent<'blocks:put:duplicate', CID> |\n  ProgressEvent<'blocks:put:providers:notify', CID> |\n  ProgressEvent<'blocks:put:blockstore:put', CID>\n\nexport type PutManyBlocksProgressEvents =\n  ProgressEvent<'blocks:put-many:duplicate', CID> |\n  ProgressEvent<'blocks:put-many:providers:notify', CID> |\n  ProgressEvent<'blocks:put-many:blockstore:put-many'>\n\nexport type GetBlockProgressEvents =\n  ProgressEvent<'blocks:get:providers:want', CID> |\n  ProgressEvent<'blocks:get:blockstore:get', CID> |\n  ProgressEvent<'blocks:get:blockstore:put', CID>\n\nexport type GetManyBlocksProgressEvents =\n  ProgressEvent<'blocks:get-many:blockstore:get-many'> |\n  ProgressEvent<'blocks:get-many:providers:want', CID> |\n  ProgressEvent<'blocks:get-many:blockstore:put', CID>\n\nexport type GetAllBlocksProgressEvents =\n  ProgressEvent<'blocks:get-all:blockstore:get-many'>\n\nexport type DeleteBlockProgressEvents =\n  ProgressEvent<'blocks:delete:blockstore:delete', CID>\n\nexport type DeleteManyBlocksProgressEvents =\n  ProgressEvent<'blocks:delete-many:blockstore:delete-many'>\n\nexport interface GetOfflineOptions {\n  /**\n   * If true, do not attempt to fetch any missing blocks from the network\n   *\n   * @default false\n   */\n  offline?: boolean\n}\n\nexport interface Blocks extends Blockstore<ProgressOptions<HasBlockProgressEvents>,\nProgressOptions<PutBlockProgressEvents>, ProgressOptions<PutManyBlocksProgressEvents>,\nGetOfflineOptions & ProviderOptions & ProgressOptions<GetBlockProgressEvents>,\nGetOfflineOptions & ProviderOptions & ProgressOptions<GetManyBlocksProgressEvents>,\nProgressOptions<GetAllBlocksProgressEvents>,\nProgressOptions<DeleteBlockProgressEvents>, ProgressOptions<DeleteManyBlocksProgressEvents>\n> {\n  /**\n   * A blockstore session only fetches blocks from a subset of network peers to\n   * reduce network traffic and improve performance.\n   *\n   * The initial set of peers can be specified, alternatively a `findProviders`\n   * routing query will occur to populate the set instead.\n   */\n  createSession(root: CID, options?: CreateSessionOptions<GetOfflineOptions & ProviderOptions & GetBlockProgressEvents>): SessionBlockstore\n}\n\n/**\n * A session blockstore is a special blockstore that only pulls content from a\n * subset of network peers which respond as having the block for the initial\n * root CID.\n *\n * Any blocks written to the blockstore as part of the session will propagate\n * to the blockstore the session was created from.\n *\n */\nexport interface SessionBlockstore extends Blockstore<ProgressOptions<HasBlockProgressEvents>,\nProgressOptions<PutBlockProgressEvents>, ProgressOptions<PutManyBlocksProgressEvents>,\nGetOfflineOptions & ProgressOptions<GetBlockProgressEvents>, GetOfflineOptions & ProgressOptions<GetManyBlocksProgressEvents>, ProgressOptions<GetAllBlocksProgressEvents>,\nProgressOptions<DeleteBlockProgressEvents>, ProgressOptions<DeleteManyBlocksProgressEvents>\n> {\n  /**\n   * Any in-progress operations will be aborted.\n   */\n  close(): void\n}\n\nexport interface BlockRetrievalOptions <ProgressEvents extends ProgressEvent<any, any> = ProgressEvent<any, any>> extends AbortOptions, ProgressOptions<ProgressEvents>, ProviderOptions {\n  /**\n   * A function that blockBrokers should call prior to returning a block to ensure it can maintain control\n   * of the block request flow. e.g. TrustedGatewayBlockBroker will use this to ensure that the block\n   * is valid from one of the gateways before assuming its work is done. If the block is not valid, it should try another gateway\n   * and WILL consider the gateway that returned the invalid blocks completely unreliable.\n   */\n  validateFn?(block: Uint8Array): Promise<void>\n\n  /**\n   * The maximum size a block can be in bytes.\n   *\n   * Attempts to retrieve a block larger than this will cause an error to be thrown.\n   *\n   * @default 2_097_152\n   */\n  maxSize?: number\n}\n\nexport interface BlockAnnounceOptions <ProgressEvents extends ProgressEvent<any, any> = ProgressEvent<any, any>> extends AbortOptions, ProgressOptions<ProgressEvents> {\n\n}\n\nexport interface CreateSessionOptions <ProgressEvents extends ProgressEvent<any, any> = ProgressEvent<any, any>> extends AbortOptions, ProgressOptions<ProgressEvents>, ProviderOptions {\n  /**\n   * The minimum number of providers for the root CID that are required for\n   * successful session creation.\n   *\n   * The session will become usable once this many providers have been\n   * discovered, up to `maxProviders` providers will continue to be added.\n   *\n   * @default 1\n   */\n  minProviders?: number\n\n  /**\n   * The maximum number of providers for the root CID to be added to a session.\n   *\n   * @default 5\n   */\n  maxProviders?: number\n}\n\nexport interface BlockBroker<RetrieveProgressEvents extends ProgressEvent<any, any> = ProgressEvent<any, any>, AnnounceProgressEvents extends ProgressEvent<any, any> = ProgressEvent<any, any>> {\n  /**\n   * Retrieve a block from a source\n   */\n  retrieve?(cid: CID, options?: BlockRetrievalOptions<RetrieveProgressEvents>): Promise<Uint8Array>\n\n  /**\n   * Make a new block available to peers\n   */\n  announce?(cid: CID, block: Uint8Array, options?: BlockAnnounceOptions<AnnounceProgressEvents>): Promise<void>\n\n  /**\n   * Create a new session\n   */\n  createSession?(options?: CreateSessionOptions<RetrieveProgressEvents>): BlockBroker<RetrieveProgressEvents, AnnounceProgressEvents>\n}\n\nexport const DEFAULT_SESSION_MIN_PROVIDERS = 1\nexport const DEFAULT_SESSION_MAX_PROVIDERS = 5\n", "export class InsufficientProvidersError extends Error {\n  static name = 'InsufficientProvidersError'\n\n  constructor (message = 'Insufficient providers found') {\n    super(message)\n    this.name = 'InsufficientProvidersError'\n  }\n}\n\nexport class NoRoutersAvailableError extends Error {\n  static name = 'NoRoutersAvailableError'\n\n  constructor (message = 'No routers available') {\n    super(message)\n    this.name = 'NoRoutersAvailableError'\n  }\n}\n\nexport class UnknownHashAlgorithmError extends Error {\n  static name = 'UnknownHashAlgorithmError'\n\n  constructor (message = 'Unknown hash algorithm') {\n    super(message)\n    this.name = 'UnknownHashAlgorithmError'\n  }\n}\n\nexport class UnknownCodecError extends Error {\n  static name = 'UnknownCodecError'\n\n  constructor (message = 'Unknown codec') {\n    super(message)\n    this.name = 'UnknownCodecError'\n  }\n}\n"],
  "mappings": ";kcAAA,IAAAA,EAAA,GAAAC,EAAAD,EAAA,mCAAAE,EAAA,kCAAAC,EAAA,+BAAAC,EAAA,4BAAAC,EAAA,sBAAAC,EAAA,8BAAAC,ICoKO,IAAMC,EAAgC,EAChCC,EAAgC,ECrKvC,IAAOC,EAAP,cAA0C,KAAK,CACnD,OAAO,KAAO,6BAEd,YAAaC,EAAU,+BAA8B,CACnD,MAAMA,CAAO,EACb,KAAK,KAAO,4BACd,GAGWC,EAAP,cAAuC,KAAK,CAChD,OAAO,KAAO,0BAEd,YAAaD,EAAU,uBAAsB,CAC3C,MAAMA,CAAO,EACb,KAAK,KAAO,yBACd,GAGWE,EAAP,cAAyC,KAAK,CAClD,OAAO,KAAO,4BAEd,YAAaF,EAAU,yBAAwB,CAC7C,MAAMA,CAAO,EACb,KAAK,KAAO,2BACd,GAGWG,EAAP,cAAiC,KAAK,CAC1C,OAAO,KAAO,oBAEd,YAAaH,EAAU,gBAAe,CACpC,MAAMA,CAAO,EACb,KAAK,KAAO,mBACd",
  "names": ["index_exports", "__export", "DEFAULT_SESSION_MAX_PROVIDERS", "DEFAULT_SESSION_MIN_PROVIDERS", "InsufficientProvidersError", "NoRoutersAvailableError", "UnknownCodecError", "UnknownHashAlgorithmError", "DEFAULT_SESSION_MIN_PROVIDERS", "DEFAULT_SESSION_MAX_PROVIDERS", "InsufficientProvidersError", "message", "NoRoutersAvailableError", "UnknownHashAlgorithmError", "UnknownCodecError"]
}
