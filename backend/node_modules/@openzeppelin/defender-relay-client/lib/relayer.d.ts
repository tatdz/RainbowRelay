/// <reference types="node" />
import { Network } from '@openzeppelin/defender-base-client';
import https from 'https';
export type Address = string;
export type BigUInt = string | number;
export type Hex = string;
export type Speed = 'safeLow' | 'average' | 'fast' | 'fastest';
export type Status = 'pending' | 'sent' | 'submitted' | 'inmempool' | 'mined' | 'confirmed' | 'failed';
export interface SendBaseTransactionRequest {
    to?: Address;
    value?: BigUInt;
    data?: Hex;
    gasLimit: BigUInt;
    validUntil?: string;
    isPrivate?: boolean;
}
export interface SendSpeedTransactionRequest extends SendBaseTransactionRequest {
    speed: Speed;
}
export interface SendLegacyTransactionRequest extends SendBaseTransactionRequest {
    gasPrice: BigUInt;
}
export interface SendEIP1559TransactionRequest extends SendBaseTransactionRequest {
    maxFeePerGas: BigUInt;
    maxPriorityFeePerGas: BigUInt;
}
export type RelayerTransactionPayload = SendBaseTransactionRequest | SendSpeedTransactionRequest | SendLegacyTransactionRequest | SendEIP1559TransactionRequest;
export interface SignMessagePayload {
    message: Hex;
}
export interface SignTypedDataPayload {
    domainSeparator: Hex;
    hashStructMessage: Hex;
}
export interface SignedMessagePayload {
    sig: Hex;
    r: Hex;
    s: Hex;
    v: number;
}
export interface RelayerGetResponse {
    relayerId: string;
    name: string;
    address: string;
    network: Network;
    paused: boolean;
    createdAt: string;
    pendingTxCost: string;
    minBalance: BigUInt;
    policies: UpdateRelayerPoliciesRequest;
    stackResourceId?: string;
}
export interface RelayerModel extends RelayerGetResponse {
}
export interface RelayerListResponse {
    items: RelayerGetResponse[];
    txsQuotaUsage: number;
}
export interface CreateRelayerRequest {
    name: string;
    useAddressFromRelayerId?: string;
    network: Network;
    minBalance: BigUInt;
    policies?: UpdateRelayerPoliciesRequest;
    stackResourceId?: string;
}
export interface UpdateRelayerPoliciesRequest {
    gasPriceCap?: BigUInt;
    whitelistReceivers?: Address[];
    EIP1559Pricing?: boolean;
    privateTransactions?: boolean;
}
export interface UpdateRelayerRequest {
    name?: string;
    policies?: UpdateRelayerPoliciesRequest;
    minBalance?: BigUInt;
}
export interface RelayerApiKey {
    keyId: string;
    relayerId: string;
    secretKey?: string;
    apiKey: string;
    createdAt: string;
    stackResourceId?: string;
}
export interface DeleteRelayerApiKeyResponse {
    message: string;
}
interface RelayerTransactionBase {
    transactionId: string;
    hash: string;
    to: Address;
    from: Address;
    value?: string;
    data?: string;
    speed?: Speed;
    gasLimit: number;
    nonce: number;
    status: Status;
    chainId: number;
    validUntil: string;
    createdAt: string;
    sentAt?: string;
    pricedAt?: string;
    isPrivate?: boolean;
}
interface RelayerLegacyTransaction extends RelayerTransactionBase {
    gasPrice: number;
}
interface RelayerEIP1559Transaction extends RelayerTransactionBase {
    maxPriorityFeePerGas: number;
    maxFeePerGas: number;
}
export type RelayerTransaction = RelayerLegacyTransaction | RelayerEIP1559Transaction;
export type PaginatedTransactionListResponse = RelayerTransaction[] | {
    items: RelayerTransaction[];
    next?: string;
};
export type RelayerParams = ApiRelayerParams | AutotaskRelayerParams;
export type ApiRelayerParams = {
    apiKey: string;
    apiSecret: string;
    httpsAgent?: https.Agent;
    useCredentialsCaching?: boolean;
};
export type AutotaskRelayerParams = {
    credentials: string;
    relayerARN: string;
    httpsAgent?: https.Agent;
    useCredentialsCaching?: boolean;
};
export type JsonRpcResponse = {
    id: number | null;
    jsonrpc: '2.0';
    result: any;
    error?: {
        code: number;
        message: string;
        data?: string;
    };
};
export type JsonRpcRequest = {
    id: number;
    jsonrpc: '2.0';
    method: string;
    params: string[];
};
export declare function isLegacyTx<TransactionLikeType extends object>(tx: TransactionLikeType): tx is TransactionLikeType & {
    gasPrice: NonNullable<unknown>;
};
export declare function isEIP1559Tx<TransactionLikeType extends object>(tx: TransactionLikeType): tx is TransactionLikeType & {
    maxPriorityFeePerGas: NonNullable<unknown>;
    maxFeePerGas: NonNullable<unknown>;
};
export type ListTransactionsRequest = {
    status?: 'pending' | 'mined' | 'failed';
    since?: Date;
    limit?: number;
    next?: string;
    sort?: 'asc' | 'desc';
    usePagination?: boolean;
};
export interface RelayerStatus {
    relayerId: string;
    name: string;
    nonce: number;
    address: string;
    numberOfPendingTransactions: number;
    paused: boolean;
    pendingTxCost?: string;
    txsQuotaUsage: number;
    rpcQuotaUsage: number;
    lastConfirmedTransaction?: {
        hash: string;
        status: string;
        minedAt: string;
        sentAt: string;
        nonce: number;
    };
}
export interface IRelayer {
    getRelayer(): Promise<RelayerGetResponse>;
    getRelayerStatus(): Promise<RelayerStatus>;
    sendTransaction(payload: RelayerTransactionPayload): Promise<RelayerTransaction>;
    replaceTransactionById(id: string, payload: RelayerTransactionPayload): Promise<RelayerTransaction>;
    replaceTransactionByNonce(nonce: number, payload: RelayerTransactionPayload): Promise<RelayerTransaction>;
    query(id: string): Promise<RelayerTransaction>;
    list(criteria?: ListTransactionsRequest): Promise<RelayerTransaction[] | PaginatedTransactionListResponse>;
    sign(payload: SignMessagePayload): Promise<SignedMessagePayload>;
    signTypedData(payload: SignTypedDataPayload): Promise<SignedMessagePayload>;
    call(method: string, params: string[]): Promise<JsonRpcResponse>;
}
export declare function isRelayer(params: any): params is Relayer;
export declare class Relayer implements IRelayer {
    private relayer;
    constructor(credentials: RelayerParams);
    getRelayer(): Promise<RelayerGetResponse>;
    getRelayerStatus(): Promise<RelayerStatus>;
    sign(payload: SignMessagePayload): Promise<SignedMessagePayload>;
    signTypedData(payload: SignTypedDataPayload): Promise<SignedMessagePayload>;
    sendTransaction(payload: RelayerTransactionPayload): Promise<RelayerTransaction>;
    replaceTransactionById(id: string, payload: RelayerTransactionPayload): Promise<RelayerTransaction>;
    replaceTransactionByNonce(nonce: number, payload: RelayerTransactionPayload): Promise<RelayerTransaction>;
    query(id: string): Promise<RelayerTransaction>;
    list(criteria?: ListTransactionsRequest): Promise<RelayerTransaction[] | PaginatedTransactionListResponse>;
    call(method: string, params: string[]): Promise<JsonRpcResponse>;
}
export {};
//# sourceMappingURL=relayer.d.ts.map