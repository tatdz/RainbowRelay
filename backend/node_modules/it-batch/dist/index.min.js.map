{
  "version": 3,
  "sources": ["../src/index.ts"],
  "sourcesContent": ["/**\n * @packageDocumentation\n *\n * The final batch may be smaller than the max.\n *\n * @example\n *\n * ```javascript\n * import batch from 'it-batch'\n * import all from 'it-all'\n *\n * // This can also be an iterator, generator, etc\n * const values = [0, 1, 2, 3, 4]\n * const batchSize = 2\n *\n * const result = all(batch(values, batchSize))\n *\n * console.info(result) // [0, 1], [2, 3], [4]\n * ```\n *\n * Async sources must be awaited:\n *\n * ```javascript\n * import batch from 'it-batch'\n * import all from 'it-all'\n *\n * const values = async function * () {\n *   yield * [0, 1, 2, 3, 4]\n * }\n *\n * const batchSize = 2\n * const result = await all(batch(values(), batchSize))\n *\n * console.info(result) // [0, 1], [2, 3], [4]\n * ```\n */\n\nfunction isAsyncIterable <T> (thing: any): thing is AsyncIterable<T> {\n  return thing[Symbol.asyncIterator] != null\n}\n\n/**\n * Takes an (async) iterable that emits things and returns an async iterable that\n * emits those things in fixed-sized batches\n */\nfunction batch <T> (source: Iterable<T>, size?: number): Generator<T[], void, undefined>\nfunction batch <T> (source: Iterable<T> | AsyncIterable<T>, size?: number): AsyncGenerator<T[], void, undefined>\nfunction batch <T> (source: Iterable<T> | AsyncIterable<T>, size: number = 1): Generator<T[], void, undefined> | AsyncGenerator<T[], void, undefined> {\n  size = Number(size)\n\n  if (isAsyncIterable(source)) {\n    return (async function * () {\n      let things: T[] = []\n\n      if (size < 1) {\n        size = 1\n      }\n\n      if (size !== Math.round(size)) {\n        throw new Error('Batch size must be an integer')\n      }\n\n      for await (const thing of source) {\n        things.push(thing)\n\n        while (things.length >= size) {\n          yield things.slice(0, size)\n\n          things = things.slice(size)\n        }\n      }\n\n      while (things.length > 0) {\n        yield things.slice(0, size)\n\n        things = things.slice(size)\n      }\n    }())\n  }\n\n  return (function * () {\n    let things: T[] = []\n\n    if (size < 1) {\n      size = 1\n    }\n\n    if (size !== Math.round(size)) {\n      throw new Error('Batch size must be an integer')\n    }\n\n    for (const thing of source) {\n      things.push(thing)\n\n      while (things.length >= size) {\n        yield things.slice(0, size)\n\n        things = things.slice(size)\n      }\n    }\n\n    while (things.length > 0) {\n      yield things.slice(0, size)\n\n      things = things.slice(size)\n    }\n  }())\n}\n\nexport default batch\n"],
  "mappings": ";2bAAA,IAAAA,EAAA,GAAAC,EAAAD,EAAA,aAAAE,IAqCA,SAASC,EAAqBC,EAAU,CACtC,OAAOA,EAAM,OAAO,aAAa,GAAK,IACxC,CAQA,SAASC,EAAWC,EAAwCC,EAAe,EAAC,CAG1E,OAFAA,EAAO,OAAOA,CAAI,EAEdJ,EAAgBG,CAAM,EAChB,iBAAgB,CACtB,IAAIE,EAAc,CAAA,EAMlB,GAJID,EAAO,IACTA,EAAO,GAGLA,IAAS,KAAK,MAAMA,CAAI,EAC1B,MAAM,IAAI,MAAM,+BAA+B,EAGjD,cAAiBH,KAASE,EAGxB,IAFAE,EAAO,KAAKJ,CAAK,EAEVI,EAAO,QAAUD,GACtB,MAAMC,EAAO,MAAM,EAAGD,CAAI,EAE1BC,EAASA,EAAO,MAAMD,CAAI,EAI9B,KAAOC,EAAO,OAAS,GACrB,MAAMA,EAAO,MAAM,EAAGD,CAAI,EAE1BC,EAASA,EAAO,MAAMD,CAAI,CAE9B,EAAC,EAGK,WAAU,CAChB,IAAIC,EAAc,CAAA,EAMlB,GAJID,EAAO,IACTA,EAAO,GAGLA,IAAS,KAAK,MAAMA,CAAI,EAC1B,MAAM,IAAI,MAAM,+BAA+B,EAGjD,QAAWH,KAASE,EAGlB,IAFAE,EAAO,KAAKJ,CAAK,EAEVI,EAAO,QAAUD,GACtB,MAAMC,EAAO,MAAM,EAAGD,CAAI,EAE1BC,EAASA,EAAO,MAAMD,CAAI,EAI9B,KAAOC,EAAO,OAAS,GACrB,MAAMA,EAAO,MAAM,EAAGD,CAAI,EAE1BC,EAASA,EAAO,MAAMD,CAAI,CAE9B,EAAC,CACH,CAEA,IAAAL,EAAeG",
  "names": ["index_exports", "__export", "index_default", "isAsyncIterable", "thing", "batch", "source", "size", "things"]
}
