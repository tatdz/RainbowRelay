{
  "version": 3,
  "sources": ["../src/index.ts", "../../it-batch/src/index.ts"],
  "sourcesContent": ["/**\n * @packageDocumentation\n *\n * Takes an async iterator that emits promise-returning functions, invokes them in parallel and emits the results in the same order as the input.\n *\n * The final batch may be smaller than the batch size.\n *\n * @example\n *\n * ```javascript\n * import parallelBatch from 'it-parallel-batch'\n * import all from 'it-all'\n * import delay from 'delay'\n *\n * // This can also be an iterator, async iterator, generator, etc\n * const input = [\n *   async () => {\n *     await delay(500)\n *\n *     return 1\n *   },\n *   async () => {\n *     await delay(200)\n *\n *     return 2\n *   },\n *   async () => {\n *     await delay(100)\n *\n *     return 3\n *   }\n * ]\n *\n * const batchSize = 2\n *\n * const result = await all(parallelBatch(input, batchSize))\n *\n * console.info(result) // [1, 2, 3]\n * ```\n */\n\nimport batch from 'it-batch'\n\ninterface Success<T> {\n  ok: true\n  value: T\n}\n\ninterface Failure {\n  ok: false\n  err: Error\n}\n\n/**\n * Takes an (async) iterator that emits promise-returning functions,\n * invokes them in parallel and emits the results as they become available but\n * in the same order as the input\n */\nexport default async function * parallelBatch <T> (source: AsyncIterable<() => Promise<T>> | Iterable<() => Promise<T>>, size: number = 1): AsyncGenerator<T, void, undefined> {\n  for await (const tasks of batch(source, size)) {\n    const things: Array<Promise<Success<T> | Failure>> = tasks.map(\n      async (p: () => Promise<T>) => {\n        return p().then(value => ({ ok: true, value }), err => ({ ok: false, err }))\n      })\n\n    for (let i = 0; i < things.length; i++) {\n      const result = await things[i]\n\n      if (result.ok) {\n        yield result.value\n      } else {\n        throw result.err\n      }\n    }\n  }\n}\n", "/**\n * @packageDocumentation\n *\n * The final batch may be smaller than the max.\n *\n * @example\n *\n * ```javascript\n * import batch from 'it-batch'\n * import all from 'it-all'\n *\n * // This can also be an iterator, generator, etc\n * const values = [0, 1, 2, 3, 4]\n * const batchSize = 2\n *\n * const result = all(batch(values, batchSize))\n *\n * console.info(result) // [0, 1], [2, 3], [4]\n * ```\n *\n * Async sources must be awaited:\n *\n * ```javascript\n * import batch from 'it-batch'\n * import all from 'it-all'\n *\n * const values = async function * () {\n *   yield * [0, 1, 2, 3, 4]\n * }\n *\n * const batchSize = 2\n * const result = await all(batch(values(), batchSize))\n *\n * console.info(result) // [0, 1], [2, 3], [4]\n * ```\n */\n\nfunction isAsyncIterable <T> (thing: any): thing is AsyncIterable<T> {\n  return thing[Symbol.asyncIterator] != null\n}\n\n/**\n * Takes an (async) iterable that emits things and returns an async iterable that\n * emits those things in fixed-sized batches\n */\nfunction batch <T> (source: Iterable<T>, size?: number): Generator<T[], void, undefined>\nfunction batch <T> (source: Iterable<T> | AsyncIterable<T>, size?: number): AsyncGenerator<T[], void, undefined>\nfunction batch <T> (source: Iterable<T> | AsyncIterable<T>, size: number = 1): Generator<T[], void, undefined> | AsyncGenerator<T[], void, undefined> {\n  size = Number(size)\n\n  if (isAsyncIterable(source)) {\n    return (async function * () {\n      let things: T[] = []\n\n      if (size < 1) {\n        size = 1\n      }\n\n      if (size !== Math.round(size)) {\n        throw new Error('Batch size must be an integer')\n      }\n\n      for await (const thing of source) {\n        things.push(thing)\n\n        while (things.length >= size) {\n          yield things.slice(0, size)\n\n          things = things.slice(size)\n        }\n      }\n\n      while (things.length > 0) {\n        yield things.slice(0, size)\n\n        things = things.slice(size)\n      }\n    }())\n  }\n\n  return (function * () {\n    let things: T[] = []\n\n    if (size < 1) {\n      size = 1\n    }\n\n    if (size !== Math.round(size)) {\n      throw new Error('Batch size must be an integer')\n    }\n\n    for (const thing of source) {\n      things.push(thing)\n\n      while (things.length >= size) {\n        yield things.slice(0, size)\n\n        things = things.slice(size)\n      }\n    }\n\n    while (things.length > 0) {\n      yield things.slice(0, size)\n\n      things = things.slice(size)\n    }\n  }())\n}\n\nexport default batch\n"],
  "mappings": ";mcAAA,IAAAA,EAAA,GAAAC,EAAAD,EAAA,aAAAE,ICqCA,SAASC,EAAqBC,EAAU,CACtC,OAAOA,EAAM,OAAO,aAAa,GAAK,IACxC,CAQA,SAASC,EAAWC,EAAwCC,EAAe,EAAC,CAG1E,OAFAA,EAAO,OAAOA,CAAI,EAEdJ,EAAgBG,CAAM,EAChB,iBAAgB,CACtB,IAAIE,EAAc,CAAA,EAMlB,GAJID,EAAO,IACTA,EAAO,GAGLA,IAAS,KAAK,MAAMA,CAAI,EAC1B,MAAM,IAAI,MAAM,+BAA+B,EAGjD,cAAiBH,KAASE,EAGxB,IAFAE,EAAO,KAAKJ,CAAK,EAEVI,EAAO,QAAUD,GACtB,MAAMC,EAAO,MAAM,EAAGD,CAAI,EAE1BC,EAASA,EAAO,MAAMD,CAAI,EAI9B,KAAOC,EAAO,OAAS,GACrB,MAAMA,EAAO,MAAM,EAAGD,CAAI,EAE1BC,EAASA,EAAO,MAAMD,CAAI,CAE9B,EAAC,EAGK,WAAU,CAChB,IAAIC,EAAc,CAAA,EAMlB,GAJID,EAAO,IACTA,EAAO,GAGLA,IAAS,KAAK,MAAMA,CAAI,EAC1B,MAAM,IAAI,MAAM,+BAA+B,EAGjD,QAAWH,KAASE,EAGlB,IAFAE,EAAO,KAAKJ,CAAK,EAEVI,EAAO,QAAUD,GACtB,MAAMC,EAAO,MAAM,EAAGD,CAAI,EAE1BC,EAASA,EAAO,MAAMD,CAAI,EAI9B,KAAOC,EAAO,OAAS,GACrB,MAAMA,EAAO,MAAM,EAAGD,CAAI,EAE1BC,EAASA,EAAO,MAAMD,CAAI,CAE9B,EAAC,CACH,CAEA,IAAAE,EAAeJ,EDnDf,eAAOK,EAA4CC,EAAsEC,EAAe,EAAC,CACvI,cAAiBC,KAASC,EAAMH,EAAQC,CAAI,EAAG,CAC7C,IAAMG,EAA+CF,EAAM,IACzD,MAAOG,GACEA,EAAC,EAAG,KAAKC,IAAU,CAAE,GAAI,GAAM,MAAAA,CAAK,GAAKC,IAAQ,CAAE,GAAI,GAAO,IAAAA,CAAG,EAAG,CAC5E,EAEH,QAASC,EAAI,EAAGA,EAAIJ,EAAO,OAAQI,IAAK,CACtC,IAAMC,EAAS,MAAML,EAAOI,CAAC,EAE7B,GAAIC,EAAO,GACT,MAAMA,EAAO,UAEb,OAAMA,EAAO,GAEjB,CACF,CACF",
  "names": ["index_exports", "__export", "parallelBatch", "isAsyncIterable", "thing", "batch", "source", "size", "things", "src_default", "parallelBatch", "source", "size", "tasks", "src_default", "things", "p", "value", "err", "i", "result"]
}
