import { EventEmitter } from 'events';
import type { Gateway, MapPortOptions, GlobalMapPortOptions, PortMapping } from '../index.js';
import type { AbortOptions } from 'abort-error';
import type { RemoteInfo } from 'dgram';
import type { DeferredPromise } from 'p-defer';
declare const OP_EXTERNAL_IP = 0;
declare const OP_MAP_UDP = 1;
declare const OP_MAP_TCP = 2;
export interface PortMappingOptions {
    type?: 'tcp' | 'udp';
    ttl?: number;
    public?: number;
    private?: number;
    internal?: number;
    external?: number;
}
export declare class PMPGateway extends EventEmitter implements Gateway {
    id: string;
    private readonly socket;
    private queue;
    private connecting;
    private listening;
    private req;
    private reqActive;
    readonly host: string;
    readonly port: number;
    readonly family: 'IPv4' | 'IPv6';
    private readonly options;
    private readonly refreshIntervals;
    constructor(gateway: string, options?: GlobalMapPortOptions);
    connect(): void;
    mapAll(localPort: number, options?: MapPortOptions): AsyncGenerator<PortMapping, void, unknown>;
    map(localPort: number, localHost: string, opts?: MapPortOptions): Promise<PortMapping>;
    unmap(localPort: number, opts?: MapPortOptions): Promise<void>;
    externalIp(options?: AbortOptions): Promise<string>;
    stop(options?: AbortOptions): Promise<void>;
    /**
     * Queues a UDP request to be send to the gateway device.
     */
    request(op: typeof OP_EXTERNAL_IP, deferred: DeferredPromise<any>): void;
    request(op: typeof OP_MAP_TCP | typeof OP_MAP_UDP, deferred: DeferredPromise<any>, localPort: number, obj: MapPortOptions): void;
    /**
     * Processes the next request if the socket is listening.
     */
    _next(): void;
    onListening(): void;
    onMessage(msg: Buffer, rinfo: RemoteInfo): void;
    onClose(): void;
    onError(err: Error): void;
}
export {};
//# sourceMappingURL=gateway.d.ts.map