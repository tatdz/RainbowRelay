import { TypedEventEmitter } from 'main-event';
import { KBucket } from './k-bucket.js';
import type { GetClosestPeersOptions, Peer } from './k-bucket.js';
import type { Network } from '../network.js';
import type { AbortOptions, ComponentLogger, Metrics, PeerId, PeerStore, Startable } from '@libp2p/interface';
import type { Ping } from '@libp2p/ping';
import type { AdaptiveTimeoutInit } from '@libp2p/utils/adaptive-timeout';
export declare const KBUCKET_SIZE = 20;
export declare const PREFIX_LENGTH = 6;
export declare const PING_NEW_CONTACT_TIMEOUT = 2000;
export declare const PING_NEW_CONTACT_CONCURRENCY = 20;
export declare const PING_NEW_CONTACT_MAX_QUEUE_SIZE = 100;
export declare const PING_OLD_CONTACT_COUNT = 3;
export declare const PING_OLD_CONTACT_TIMEOUT = 2000;
export declare const PING_OLD_CONTACT_CONCURRENCY = 20;
export declare const PING_OLD_CONTACT_MAX_QUEUE_SIZE = 100;
export declare const KAD_PEER_TAG_NAME = "kad-peer";
export declare const KAD_PEER_TAG_VALUE = 1;
export declare const LAST_PING_THRESHOLD = 600000;
export declare const POPULATE_FROM_DATASTORE_ON_START = true;
export declare const POPULATE_FROM_DATASTORE_LIMIT = 1000;
export interface RoutingTableInit {
    logPrefix: string;
    metricsPrefix: string;
    protocol: string;
    prefixLength?: number;
    splitThreshold?: number;
    kBucketSize?: number;
    pingNewContactTimeout?: AdaptiveTimeoutInit;
    pingNewContactConcurrency?: number;
    pingNewContactMaxQueueSize?: number;
    pingOldContactTimeout?: AdaptiveTimeoutInit;
    pingOldContactConcurrency?: number;
    pingOldContactMaxQueueSize?: number;
    numberOfOldContactsToPing?: number;
    peerTagName?: string;
    peerTagValue?: number;
    closeTagName?: string;
    closeTagValue?: number;
    network: Network;
    populateFromDatastoreOnStart?: boolean;
    populateFromDatastoreLimit?: number;
    lastPingThreshold?: number;
    closestPeerSetSize?: number;
    closestPeerSetRefreshInterval?: number;
}
export interface RoutingTableComponents {
    peerId: PeerId;
    peerStore: PeerStore;
    metrics?: Metrics;
    logger: ComponentLogger;
    ping: Ping;
}
export interface RoutingTableEvents {
    'peer:add': CustomEvent<PeerId>;
    'peer:remove': CustomEvent<PeerId>;
    'peer:ping': CustomEvent<PeerId>;
}
/**
 * A wrapper around `k-bucket`, to provide easy store and retrieval for peers.
 */
export declare class RoutingTable extends TypedEventEmitter<RoutingTableEvents> implements Startable {
    kBucketSize: number;
    kb: KBucket;
    network: Network;
    private readonly closestPeerTagger;
    private readonly log;
    private readonly components;
    private running;
    private readonly pingNewContactTimeout;
    private readonly pingNewContactQueue;
    private readonly pingOldContactTimeout;
    private readonly pingOldContactQueue;
    private readonly populateFromDatastoreOnStart;
    private readonly populateFromDatastoreLimit;
    private readonly protocol;
    private readonly peerTagName;
    private readonly peerTagValue;
    private readonly metrics?;
    private shutdownController;
    constructor(components: RoutingTableComponents, init: RoutingTableInit);
    isStarted(): boolean;
    start(): Promise<void>;
    afterStart(): Promise<void>;
    stop(): Promise<void>;
    private peerAdded;
    private peerRemoved;
    /**
     * Called on the `ping` event from `k-bucket` when a bucket is full
     * and cannot split.
     *
     * `oldContacts.length` is defined by the `numberOfNodesToPing` param
     * passed to the `k-bucket` constructor.
     *
     * `oldContacts` will not be empty and is the list of contacts that
     * have not been contacted for the longest.
     */
    pingOldContacts(oldContacts: Peer[], options?: AbortOptions): AsyncGenerator<Peer>;
    verifyNewContact(contact: Peer, options?: AbortOptions): Promise<boolean>;
    pingContact(contact: Peer, options?: AbortOptions): Promise<boolean>;
    /**
     * Amount of currently stored peers
     */
    get size(): number;
    /**
     * Find a specific peer by id
     */
    find(peer: PeerId, options?: AbortOptions): Promise<PeerId | undefined>;
    /**
     * Retrieve the closest peers to the given kadId
     */
    closestPeer(kadId: Uint8Array): PeerId | undefined;
    /**
     * Retrieve the `count`-closest peers to the given kadId
     */
    closestPeers(kadId: Uint8Array, options?: GetClosestPeersOptions): PeerId[];
    /**
     * Add or update the routing table with the given peer
     */
    add(peerId: PeerId, options?: AbortOptions): Promise<void>;
    /**
     * Remove a given peer from the table
     */
    remove(peer: PeerId, options?: AbortOptions): Promise<void>;
    private updateMetrics;
}
//# sourceMappingURL=index.d.ts.map