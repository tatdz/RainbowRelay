import { PeerSet } from '@libp2p/peer-collections';
import { KEEP_ALIVE_TAG } from '../constants.js';
import { PeerDistanceList } from '../peer-distance-list.js';
import { convertPeerId } from '../utils.js';
export const PEER_SET_SIZE = 20;
export const REFRESH_INTERVAL = 5000;
export const KAD_CLOSE_TAG_NAME = 'kad-close';
export const KAD_CLOSE_TAG_VALUE = 50;
/**
 * Contains a list of the kad-closest peers encountered on the network.
 *
 * Once every few seconds, if the list has changed, it tags the closest peers.
 */
export class ClosestPeers {
    routingTable;
    components;
    closestPeers;
    newPeers;
    refreshInterval;
    peerSetSize;
    timeout;
    closeTagName;
    closeTagValue;
    log;
    running;
    constructor(components, init) {
        this.components = components;
        this.log = components.logger.forComponent(`${init.logPrefix}:routing-table`);
        this.routingTable = init.routingTable;
        this.refreshInterval = init.refreshInterval ?? REFRESH_INTERVAL;
        this.peerSetSize = init.peerSetSize ?? PEER_SET_SIZE;
        this.closeTagName = init.closeTagName ?? KAD_CLOSE_TAG_NAME;
        this.closeTagValue = init.closeTagValue ?? KAD_CLOSE_TAG_VALUE;
        this.closestPeers = new PeerSet();
        this.onPeerPing = this.onPeerPing.bind(this);
        this.running = false;
    }
    async start() {
        if (this.running) {
            return;
        }
        this.running = true;
        const targetKadId = await convertPeerId(this.components.peerId);
        this.newPeers = new PeerDistanceList(targetKadId, this.peerSetSize);
        this.routingTable.addEventListener('peer:ping', this.onPeerPing);
        this.timeout = setInterval(() => {
            this.updatePeerTags()
                .catch(err => {
                this.log.error('error updating peer tags - %e', err);
            });
        }, this.refreshInterval);
    }
    stop() {
        this.running = false;
        this.routingTable.removeEventListener('peer:ping', this.onPeerPing);
        clearTimeout(this.timeout);
    }
    onPeerPing(event) {
        this.newPeers?.add({ id: event.detail, multiaddrs: [] })
            .catch(err => {
            this.log.error('error adding peer to distance list - %e', err);
        });
    }
    async updatePeerTags() {
        const newClosest = new PeerSet(this.newPeers?.peers.map(({ peer }) => peer.id));
        const added = newClosest.difference(this.closestPeers);
        const removed = this.closestPeers.difference(newClosest);
        this.closestPeers = newClosest;
        await Promise.all([
            ...[...added].map(async (peerId) => {
                await this.components.peerStore.merge(peerId, {
                    tags: {
                        [this.closeTagName]: {
                            value: this.closeTagValue
                        },
                        [KEEP_ALIVE_TAG]: {
                            value: 1
                        }
                    }
                });
            }),
            ...[...removed].map(async (peerId) => {
                await this.components.peerStore.merge(peerId, {
                    tags: {
                        [this.closeTagName]: undefined,
                        [KEEP_ALIVE_TAG]: undefined
                    }
                });
            })
        ]);
    }
}
//# sourceMappingURL=closest-peers.js.map