import { PeerMap, trackedPeerMap } from '@libp2p/peer-collections';
import map from 'it-map';
import { equals as uint8ArrayEquals } from 'uint8arrays/equals';
import { toString as uint8ArrayToString } from 'uint8arrays/to-string';
import { xor as uint8ArrayXor } from 'uint8arrays/xor';
import { PeerDistanceList } from '../peer-distance-list.js';
import { convertPeerId } from '../utils.js';
import { KBUCKET_SIZE, LAST_PING_THRESHOLD, PING_OLD_CONTACT_COUNT, PREFIX_LENGTH } from './index.js';
export function isLeafBucket(obj) {
    return Array.isArray(obj?.peers);
}
/**
 * Implementation of a Kademlia DHT routing table as a prefix binary trie with
 * configurable prefix length, bucket split threshold and size.
 */
export class KBucket {
    peerId;
    root;
    localPeer;
    prefixLength;
    splitThreshold;
    kBucketSize;
    numberOfNodesToPing;
    lastPingThreshold;
    ping;
    verify;
    onAdd;
    onRemove;
    onMove;
    addingPeerMap;
    constructor(components, options) {
        this.peerId = components.peerId;
        this.prefixLength = options.prefixLength ?? PREFIX_LENGTH;
        this.kBucketSize = options.kBucketSize ?? KBUCKET_SIZE;
        this.splitThreshold = options.splitThreshold ?? this.kBucketSize;
        this.numberOfNodesToPing = options.numberOfOldContactsToPing ?? PING_OLD_CONTACT_COUNT;
        this.lastPingThreshold = options.lastPingThreshold ?? LAST_PING_THRESHOLD;
        this.ping = options.ping;
        this.verify = options.verify;
        this.onAdd = options.onAdd;
        this.onRemove = options.onRemove;
        this.addingPeerMap = trackedPeerMap({
            name: `${options.metricsPrefix}_adding_peer_map`,
            metrics: components.metrics
        });
        this.root = {
            prefix: '',
            depth: 0,
            peers: []
        };
    }
    async start() {
        await this.addSelfPeer(this.peerId);
    }
    stop() {
        this.addingPeerMap.clear();
        this.root = {
            prefix: '',
            depth: 0,
            peers: []
        };
    }
    async addSelfPeer(peerId, options) {
        this.localPeer = {
            peerId,
            kadId: await convertPeerId(peerId, options),
            lastPing: Date.now()
        };
    }
    /**
     * Adds a contact to the trie
     */
    async add(peerId, options) {
        const peer = {
            peerId,
            kadId: await convertPeerId(peerId, options),
            lastPing: 0
        };
        const existingPromise = this.addingPeerMap.get(peerId);
        if (existingPromise != null) {
            return existingPromise;
        }
        try {
            const p = this._add(peer, options);
            this.addingPeerMap.set(peerId, p);
            await p;
        }
        finally {
            this.addingPeerMap.delete(peerId);
        }
    }
    async _add(peer, options) {
        const bucket = this._determineBucket(peer.kadId);
        // check if the contact already exists
        if (this._indexOf(bucket, peer.kadId) > -1) {
            return;
        }
        // are there too many peers in the bucket and can we make the trie deeper?
        if (bucket.peers.length === this.splitThreshold && bucket.depth < this.prefixLength) {
            // split the bucket
            await this._split(bucket, options);
            // try again
            await this._add(peer, options);
            return;
        }
        // is there space in the bucket?
        if (bucket.peers.length < this.kBucketSize) {
            // we've ping this peer previously, just add them to the bucket
            if (!needsPing(peer, this.lastPingThreshold)) {
                bucket.peers.push(peer);
                await this.onAdd?.(peer, bucket, options);
                return;
            }
            const result = await this.verify(peer, options);
            // only add if peer is online and functioning correctly
            if (result) {
                peer.lastPing = Date.now();
                // try again - buckets may have changed during ping
                await this._add(peer, options);
            }
            return;
        }
        // we are at the bottom of the trie and the bucket is full so we can't add
        // any more peers.
        //
        // instead ping the first `this.numberOfNodesToPing` in order to determine
        // if they are still online.
        //
        // only add the new peer if one of the pinged nodes does not respond, this
        // prevents DoS flooding with new invalid contacts.
        const toPing = bucket.peers
            .filter(peer => {
            if (peer.peerId.equals(this.localPeer?.peerId)) {
                return false;
            }
            if (peer.lastPing > (Date.now() - this.lastPingThreshold)) {
                return false;
            }
            return true;
        })
            .sort((a, b) => {
            // sort oldest ping -> newest
            if (a.lastPing < b.lastPing) {
                return -1;
            }
            if (a.lastPing > b.lastPing) {
                return 1;
            }
            return 0;
        })
            .slice(0, this.numberOfNodesToPing);
        let evicted = false;
        for await (const toEvict of this.ping(toPing, options)) {
            evicted = true;
            await this.remove(toEvict.kadId, options);
        }
        // did not evict any peers, cannot add new contact
        if (!evicted) {
            return;
        }
        // try again - buckets may have changed during ping
        await this._add(peer, options);
    }
    /**
     * Get 0-n closest contacts to the provided node id. "Closest" here means:
     * closest according to the XOR metric of the contact node id.
     *
     * @param {Uint8Array} id - Contact node id
     * @returns {Generator<Peer, void, undefined>} Array Maximum of n closest contacts to the node id
     */
    *closest(id, options) {
        const list = new PeerDistanceList(id, options?.count ?? this.kBucketSize);
        for (const peer of this.toIterable()) {
            if (options?.exclude?.some(p => p.equals(peer.peerId)) === true) {
                continue;
            }
            list.addWithKadId({ id: peer.peerId, multiaddrs: [] }, peer.kadId);
        }
        yield* map(list.peers, ({ peer }) => peer.id);
    }
    /**
     * Counts the total number of contacts in the tree.
     *
     * @returns {number} The number of contacts held in the tree
     */
    count() {
        function countBucket(bucket) {
            if (isLeafBucket(bucket)) {
                return bucket.peers.length;
            }
            let count = 0;
            if (bucket.left != null) {
                count += countBucket(bucket.left);
            }
            if (bucket.right != null) {
                count += countBucket(bucket.right);
            }
            return count;
        }
        return countBucket(this.root);
    }
    /**
     * Get a contact by its exact ID.
     * If this is a leaf, loop through the bucket contents and return the correct
     * contact if we have it or null if not. If this is an inner node, determine
     * which branch of the tree to traverse and repeat.
     *
     * @param {Uint8Array} kadId - The ID of the contact to fetch.
     * @returns {Peer | undefined} The contact if available, otherwise null
     */
    get(kadId) {
        const bucket = this._determineBucket(kadId);
        const index = this._indexOf(bucket, kadId);
        return bucket.peers[index];
    }
    /**
     * Removes contact with the provided id.
     *
     * @param {Uint8Array} kadId - The ID of the contact to remove
     */
    async remove(kadId, options) {
        const bucket = this._determineBucket(kadId);
        const index = this._indexOf(bucket, kadId);
        if (index > -1) {
            const peer = bucket.peers.splice(index, 1)[0];
            await this.onRemove?.(peer, bucket, options);
        }
    }
    /**
     * Similar to `toArray()` but instead of buffering everything up into an
     * array before returning it, yields contacts as they are encountered while
     * walking the tree.
     *
     * @returns {Iterable} All of the contacts in the tree, as an iterable
     */
    *toIterable() {
        function* iterate(bucket) {
            if (isLeafBucket(bucket)) {
                yield* bucket.peers;
                return;
            }
            yield* iterate(bucket.left);
            yield* iterate(bucket.right);
        }
        yield* iterate(this.root);
    }
    /**
     * Default distance function. Finds the XOR distance between firstId and
     * secondId.
     *
     * @param  {Uint8Array} firstId - Uint8Array containing first id.
     * @param  {Uint8Array} secondId - Uint8Array containing second id.
     * @returns {number} Integer The XOR distance between firstId and secondId.
     */
    distance(firstId, secondId) {
        return BigInt('0x' + uint8ArrayToString(uint8ArrayXor(firstId, secondId), 'base16'));
    }
    /**
     * Determines whether the id at the bitIndex is 0 or 1
     * Return left leaf if `id` at `bitIndex` is 0, right leaf otherwise
     *
     * @param {Uint8Array} kadId - Id to compare localNodeId with
     * @returns {LeafBucket} left leaf if id at bitIndex is 0, right leaf otherwise.
     */
    _determineBucket(kadId) {
        const bitString = uint8ArrayToString(kadId, 'base2');
        function findBucket(bucket, bitIndex = 0) {
            if (isLeafBucket(bucket)) {
                return bucket;
            }
            const bit = bitString[bitIndex];
            if (bit === '0') {
                return findBucket(bucket.left, bitIndex + 1);
            }
            return findBucket(bucket.right, bitIndex + 1);
        }
        return findBucket(this.root);
    }
    /**
     * Returns the index of the contact with provided
     * id if it exists, returns -1 otherwise.
     *
     * @param {object} bucket - internal object that has 2 leafs: left and right
     * @param {Uint8Array} kadId - KadId of peer
     * @returns {number} Integer Index of contact with provided id if it exists, -1 otherwise.
     */
    _indexOf(bucket, kadId) {
        return bucket.peers.findIndex(peer => uint8ArrayEquals(peer.kadId, kadId));
    }
    /**
     * Modify the bucket, turn it from a leaf bucket to an internal bucket
     *
     * @param {any} bucket - bucket for splitting
     */
    async _split(bucket, options) {
        // create child buckets
        const left = {
            prefix: '0',
            depth: bucket.depth + 1,
            peers: []
        };
        const right = {
            prefix: '1',
            depth: bucket.depth + 1,
            peers: []
        };
        // redistribute peers
        for (const peer of bucket.peers) {
            const bitString = uint8ArrayToString(peer.kadId, 'base2');
            if (bitString[bucket.depth] === '0') {
                left.peers.push(peer);
                await this.onMove?.(peer, bucket, left, options);
            }
            else {
                right.peers.push(peer);
                await this.onMove?.(peer, bucket, right, options);
            }
        }
        // convert old leaf bucket to internal bucket
        convertToInternalBucket(bucket, left, right);
    }
}
function convertToInternalBucket(bucket, left, right) {
    delete bucket.peers;
    bucket.left = left;
    bucket.right = right;
    if (bucket.prefix === '') {
        delete bucket.depth;
        delete bucket.prefix;
    }
    return true;
}
function needsPing(peer, threshold) {
    return peer.lastPing < (Date.now() - threshold);
}
//# sourceMappingURL=k-bucket.js.map