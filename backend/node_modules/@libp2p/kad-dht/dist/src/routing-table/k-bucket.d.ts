import type { PeerId, AbortOptions, Metrics } from '@libp2p/interface';
export interface PingFunction {
    /**
     * Return either none or at least one contact that does not respond to a ping
     * message
     */
    (oldContacts: Peer[], options?: AbortOptions): AsyncGenerator<Peer>;
}
/**
 * Before a peer can be added to the table, verify that it is online and working
 * correctly
 */
export interface VerifyFunction {
    (contact: Peer, options?: AbortOptions): Promise<boolean>;
}
export interface OnAddCallback {
    /**
     * Invoked when a new peer is added to the routing tables
     */
    (peer: Peer, bucket: LeafBucket, options?: AbortOptions): Promise<void>;
}
export interface OnRemoveCallback {
    /**
     * Invoked when a peer is evicted from the routing tables
     */
    (peer: Peer, bucket: LeafBucket, options?: AbortOptions): Promise<void>;
}
export interface OnMoveCallback {
    /**
     * Invoked when a peer is moved between buckets in the routing tables
     */
    (peer: Peer, oldBucket: LeafBucket, newBucket: LeafBucket, options?: AbortOptions): Promise<void>;
}
export interface KBucketComponents {
    peerId: PeerId;
    metrics?: Metrics;
}
export interface KBucketOptions {
    /**
     * The current peer. All subsequently added peers must have a KadID that is
     * the same length as this peer.
     */
    /**
     * How many bits of the key to use when forming the bucket trie. The larger
     * this value, the deeper the tree will grow and the slower the lookups will
     * be but the peers returned will be more specific to the key.
     *
     * @default 8
     */
    prefixLength?: number;
    /**
     * The number of nodes that a max-depth k-bucket can contain before being
     * full.
     *
     * @default 20
     */
    kBucketSize?: number;
    /**
     * The number of nodes that an intermediate k-bucket can contain before being
     * split.
     *
     * @default kBucketSize
     */
    splitThreshold?: number;
    /**
     * The number of nodes to ping when a bucket that should not be split becomes
     * full. KBucket will emit a `ping` event that contains
     * `numberOfOldContactsToPing` nodes that have not been contacted the longest.
     *
     * @default 3
     */
    numberOfOldContactsToPing?: number;
    /**
     * Do not re-ping a peer during this time window in ms
     *
     * @default 600000
     */
    lastPingThreshold?: number;
    ping: PingFunction;
    verify: VerifyFunction;
    onAdd?: OnAddCallback;
    onRemove?: OnRemoveCallback;
    metricsPrefix?: string;
}
export interface Peer {
    kadId: Uint8Array;
    peerId: PeerId;
    lastPing: number;
}
export interface LeafBucket {
    prefix: string;
    depth: number;
    peers: Peer[];
}
export interface InternalBucket {
    prefix: string;
    depth: number;
    left: Bucket;
    right: Bucket;
}
export type Bucket = LeafBucket | InternalBucket;
export declare function isLeafBucket(obj: any): obj is LeafBucket;
export interface GetClosestPeersOptions extends AbortOptions {
    count?: number;
    exclude?: PeerId[];
}
/**
 * Implementation of a Kademlia DHT routing table as a prefix binary trie with
 * configurable prefix length, bucket split threshold and size.
 */
export declare class KBucket {
    private readonly peerId;
    root: Bucket;
    localPeer?: Peer;
    private readonly prefixLength;
    private readonly splitThreshold;
    private readonly kBucketSize;
    private readonly numberOfNodesToPing;
    private readonly lastPingThreshold;
    ping: PingFunction;
    verify: VerifyFunction;
    private readonly onAdd?;
    private readonly onRemove?;
    private readonly onMove?;
    private readonly addingPeerMap;
    constructor(components: KBucketComponents, options: KBucketOptions);
    start(): Promise<void>;
    stop(): void;
    addSelfPeer(peerId: PeerId, options?: AbortOptions): Promise<void>;
    /**
     * Adds a contact to the trie
     */
    add(peerId: PeerId, options?: AbortOptions): Promise<void>;
    private _add;
    /**
     * Get 0-n closest contacts to the provided node id. "Closest" here means:
     * closest according to the XOR metric of the contact node id.
     *
     * @param {Uint8Array} id - Contact node id
     * @returns {Generator<Peer, void, undefined>} Array Maximum of n closest contacts to the node id
     */
    closest(id: Uint8Array, options?: GetClosestPeersOptions): Generator<PeerId, void, undefined>;
    /**
     * Counts the total number of contacts in the tree.
     *
     * @returns {number} The number of contacts held in the tree
     */
    count(): number;
    /**
     * Get a contact by its exact ID.
     * If this is a leaf, loop through the bucket contents and return the correct
     * contact if we have it or null if not. If this is an inner node, determine
     * which branch of the tree to traverse and repeat.
     *
     * @param {Uint8Array} kadId - The ID of the contact to fetch.
     * @returns {Peer | undefined} The contact if available, otherwise null
     */
    get(kadId: Uint8Array): Peer | undefined;
    /**
     * Removes contact with the provided id.
     *
     * @param {Uint8Array} kadId - The ID of the contact to remove
     */
    remove(kadId: Uint8Array, options?: AbortOptions): Promise<void>;
    /**
     * Similar to `toArray()` but instead of buffering everything up into an
     * array before returning it, yields contacts as they are encountered while
     * walking the tree.
     *
     * @returns {Iterable} All of the contacts in the tree, as an iterable
     */
    toIterable(): Generator<Peer, void, undefined>;
    /**
     * Default distance function. Finds the XOR distance between firstId and
     * secondId.
     *
     * @param  {Uint8Array} firstId - Uint8Array containing first id.
     * @param  {Uint8Array} secondId - Uint8Array containing second id.
     * @returns {number} Integer The XOR distance between firstId and secondId.
     */
    distance(firstId: Uint8Array, secondId: Uint8Array): bigint;
    /**
     * Determines whether the id at the bitIndex is 0 or 1
     * Return left leaf if `id` at `bitIndex` is 0, right leaf otherwise
     *
     * @param {Uint8Array} kadId - Id to compare localNodeId with
     * @returns {LeafBucket} left leaf if id at bitIndex is 0, right leaf otherwise.
     */
    private _determineBucket;
    /**
     * Returns the index of the contact with provided
     * id if it exists, returns -1 otherwise.
     *
     * @param {object} bucket - internal object that has 2 leafs: left and right
     * @param {Uint8Array} kadId - KadId of peer
     * @returns {number} Integer Index of contact with provided id if it exists, -1 otherwise.
     */
    private _indexOf;
    /**
     * Modify the bucket, turn it from a leaf bucket to an internal bucket
     *
     * @param {any} bucket - bucket for splitting
     */
    private _split;
}
//# sourceMappingURL=k-bucket.d.ts.map