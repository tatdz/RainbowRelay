import { InvalidMessageError } from '@libp2p/interface';
import { protocols } from '@multiformats/multiaddr';
import { equals as uint8ArrayEquals } from 'uint8arrays';
import { MessageType } from '../../message/dht.js';
export class FindNodeHandler {
    peerRouting;
    peerInfoMapper;
    peerId;
    addressManager;
    log;
    constructor(components, init) {
        const { peerRouting, logPrefix } = init;
        this.log = components.logger.forComponent(`${logPrefix}:rpc:handlers:find-node`);
        this.peerId = components.peerId;
        this.addressManager = components.addressManager;
        this.peerRouting = peerRouting;
        this.peerInfoMapper = init.peerInfoMapper;
    }
    /**
     * Process `FindNode` DHT messages
     */
    async handle(peerId, msg) {
        this.log('incoming request from %p for peers close to %b', peerId, msg.key);
        try {
            if (msg.key == null) {
                throw new InvalidMessageError('Invalid FIND_NODE message received - key was missing');
            }
            const closer = await this.peerRouting.getClosestPeersOffline(msg.key, {
                exclude: [
                    // never tell a peer about itself
                    peerId,
                    // do not include the server in the results
                    this.peerId
                ]
            });
            if (uint8ArrayEquals(this.peerId.toMultihash().bytes, msg.key)) {
                closer.push({
                    id: this.peerId,
                    multiaddrs: this.addressManager.getAddresses().map(ma => ma.decapsulateCode(protocols('p2p').code))
                });
            }
            const response = {
                type: MessageType.FIND_NODE,
                clusterLevel: msg.clusterLevel,
                closer: closer
                    .map(this.peerInfoMapper)
                    .filter(({ multiaddrs }) => multiaddrs.length)
                    .map(peerInfo => ({
                    id: peerInfo.id.toMultihash().bytes,
                    multiaddrs: peerInfo.multiaddrs.map(ma => ma.bytes)
                })),
                providers: []
            };
            if (response.closer.length === 0) {
                this.log('could not find any peers closer to %b for %p', msg.key, peerId);
            }
            else {
                this.log('found %d peers close to %b for %p', response.closer.length, msg.key, peerId);
            }
            return response;
        }
        catch (err) {
            this.log('error during finding peers closer to %b for %p - %e', msg.key, peerId, err);
            throw err;
        }
    }
}
//# sourceMappingURL=find-node.js.map