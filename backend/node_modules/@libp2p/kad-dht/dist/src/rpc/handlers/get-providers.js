import { InvalidMessageError } from '@libp2p/interface';
import all from 'it-all';
import map from 'it-map';
import { CID } from 'multiformats/cid';
import { MessageType } from '../../message/dht.js';
export class GetProvidersHandler {
    peerId;
    peerRouting;
    providers;
    peerStore;
    peerInfoMapper;
    log;
    constructor(components, init) {
        const { peerRouting, providers, logPrefix } = init;
        this.log = components.logger.forComponent(`${logPrefix}:rpc:handlers:get-providers`);
        this.peerId = components.peerId;
        this.peerStore = components.peerStore;
        this.peerRouting = peerRouting;
        this.providers = providers;
        this.peerInfoMapper = init.peerInfoMapper;
    }
    async handle(peerId, msg) {
        if (msg.key == null) {
            throw new InvalidMessageError('Invalid GET_PROVIDERS message received - key was missing');
        }
        let cid;
        try {
            cid = CID.decode(msg.key);
        }
        catch (err) {
            throw new InvalidMessageError('Invalid CID');
        }
        this.log('%p asking for providers for %s', peerId, cid);
        const [providerPeers, closerPeers] = await Promise.all([
            all(map(await this.providers.getProviders(cid), async (peerId) => {
                const peer = await this.peerStore.get(peerId);
                const info = {
                    id: peer.id,
                    multiaddrs: peer.addresses.map(({ multiaddr }) => multiaddr)
                };
                return info;
            })),
            this.peerRouting.getClosestPeersOffline(msg.key)
        ]);
        const response = {
            type: MessageType.GET_PROVIDERS,
            key: msg.key,
            clusterLevel: msg.clusterLevel,
            closer: closerPeers
                .map(this.peerInfoMapper)
                .filter(({ id, multiaddrs }) => multiaddrs.length > 0)
                .map(peerInfo => ({
                id: peerInfo.id.toMultihash().bytes,
                multiaddrs: peerInfo.multiaddrs.map(ma => ma.bytes)
            })),
            providers: providerPeers
                .map(this.peerInfoMapper)
                .filter(({ id, multiaddrs }) => multiaddrs.length > 0)
                .map(peerInfo => ({
                id: peerInfo.id.toMultihash().bytes,
                multiaddrs: peerInfo.multiaddrs.map(ma => ma.bytes)
            }))
        };
        this.log('got %s providers %s closerPeers', response.providers.length, response.closer.length);
        return response;
    }
    async _getAddresses(peerId) {
        return [];
    }
}
//# sourceMappingURL=get-providers.js.map