import { TypedEventEmitter } from 'main-event';
import { Message } from './message/dht.js';
import type { DisjointPath, KadDHTComponents, QueryEvent } from './index.js';
import type { AbortOptions, Stream, PeerId, PeerInfo, Startable, RoutingOptions } from '@libp2p/interface';
import type { AdaptiveTimeoutInit } from '@libp2p/utils/adaptive-timeout';
export interface NetworkInit {
    protocol: string;
    logPrefix: string;
    metricsPrefix: string;
    timeout?: Omit<AdaptiveTimeoutInit, 'metricsName' | 'metrics'>;
}
interface NetworkEvents {
    peer: CustomEvent<PeerInfo>;
}
export interface SendMessageOptions extends RoutingOptions {
    /**
     * Queries involve following up to `k` disjoint paths through the network -
     * this option is which index within `k` this message is for, and it
     * allows observers to collate events together on a per-path basis
     */
    path: DisjointPath;
}
/**
 * Handle network operations for the dht
 */
export declare class Network extends TypedEventEmitter<NetworkEvents> implements Startable {
    private readonly log;
    private readonly protocol;
    private running;
    private readonly components;
    private readonly timeout;
    private readonly metrics;
    /**
     * Create a new network
     */
    constructor(components: KadDHTComponents, init: NetworkInit);
    /**
     * Start the network
     */
    start(): Promise<void>;
    /**
     * Stop all network activity
     */
    stop(): Promise<void>;
    /**
     * Is the network online?
     */
    isStarted(): boolean;
    /**
     * Send a request and read a response
     */
    sendRequest(to: PeerId, msg: Partial<Message>, options: SendMessageOptions): AsyncGenerator<QueryEvent>;
    /**
     * Sends a message without expecting an answer
     */
    sendMessage(to: PeerId, msg: Partial<Message>, options: SendMessageOptions): AsyncGenerator<QueryEvent>;
    /**
     * Write a message to the given stream
     */
    _writeMessage(stream: Stream, msg: Partial<Message>, options: AbortOptions): Promise<void>;
    /**
     * Write a message and read a response
     */
    _writeReadMessage(stream: Stream, msg: Partial<Message>, options: AbortOptions): Promise<Message>;
}
export {};
//# sourceMappingURL=network.d.ts.map