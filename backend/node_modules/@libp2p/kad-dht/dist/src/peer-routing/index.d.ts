import type { DHTRecord, FinalPeerEvent, QueryEvent, Validators } from '../index.js';
import type { Network, SendMessageOptions } from '../network.js';
import type { QueryManager, QueryOptions } from '../query/manager.js';
import type { RoutingTable } from '../routing-table/index.js';
import type { GetClosestPeersOptions } from '../routing-table/k-bucket.ts';
import type { ComponentLogger, Metrics, PeerId, PeerInfo, PeerStore, RoutingOptions } from '@libp2p/interface';
import type { ConnectionManager } from '@libp2p/interface-internal';
import type { AbortOptions } from 'it-pushable';
export interface PeerRoutingComponents {
    peerId: PeerId;
    peerStore: PeerStore;
    logger: ComponentLogger;
    metrics?: Metrics;
    connectionManager: ConnectionManager;
}
export interface PeerRoutingInit {
    routingTable: RoutingTable;
    network: Network;
    validators: Validators;
    queryManager: QueryManager;
    logPrefix: string;
}
export declare class PeerRouting {
    private readonly log;
    private readonly routingTable;
    private readonly network;
    private readonly validators;
    private readonly queryManager;
    private readonly components;
    constructor(components: PeerRoutingComponents, init: PeerRoutingInit);
    /**
     * Look if we are connected to a peer with the given id.
     * Returns its id and addresses, if found, otherwise `undefined`.
     */
    findPeerLocal(peer: PeerId, options?: AbortOptions): Promise<PeerInfo | undefined>;
    /**
     * Get a value via rpc call for the given parameters
     */
    _getValueSingle(peer: PeerId, key: Uint8Array, options: SendMessageOptions): AsyncGenerator<QueryEvent>;
    /**
     * Get the public key directly from a node
     */
    getPublicKeyFromNode(peer: PeerId, options?: RoutingOptions): AsyncGenerator<QueryEvent>;
    /**
     * Search for a peer with the given ID
     */
    findPeer(id: PeerId, options?: RoutingOptions): AsyncGenerator<FinalPeerEvent | QueryEvent>;
    /**
     * Kademlia 'FIND_NODE' operation on a key, which could be the bytes from a
     * multihash or a peer ID
     */
    getClosestPeers(key: Uint8Array, options?: QueryOptions): AsyncGenerator<QueryEvent>;
    /**
     * Query a particular peer for the value for the given key.
     * It will either return the value or a list of closer peers.
     *
     * Note: The peerStore is updated with new addresses found for the given peer.
     */
    getValueOrPeers(peer: PeerId, key: Uint8Array, options: SendMessageOptions): AsyncGenerator<QueryEvent>;
    /**
     * Verify a record, fetching missing public keys from the network.
     * Throws an error if the record is invalid.
     */
    _verifyRecordOnline(record: DHTRecord, options?: AbortOptions): Promise<void>;
    /**
     * Get the peers in our routing table that are closest to the passed key
     */
    getClosestPeersOffline(key: Uint8Array, options?: GetClosestPeersOptions): Promise<PeerInfo[]>;
}
//# sourceMappingURL=index.d.ts.map