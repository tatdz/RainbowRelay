import { Libp2pRecord } from '@libp2p/record';
import type { KadDHTComponents, Validators, Selectors, ValueEvent, QueryEvent } from '../index.js';
import type { Network, SendMessageOptions } from '../network.js';
import type { PeerRouting } from '../peer-routing/index.js';
import type { QueryManager } from '../query/manager.js';
import type { AbortOptions, RoutingOptions } from '@libp2p/interface';
export interface ContentFetchingInit {
    validators: Validators;
    selectors: Selectors;
    peerRouting: PeerRouting;
    queryManager: QueryManager;
    network: Network;
    logPrefix: string;
    datastorePrefix: string;
}
export declare class ContentFetching {
    private readonly log;
    private readonly components;
    private readonly validators;
    private readonly selectors;
    private readonly peerRouting;
    private readonly queryManager;
    private readonly network;
    private readonly datastorePrefix;
    constructor(components: KadDHTComponents, init: ContentFetchingInit);
    /**
     * Attempt to retrieve the value for the given key from
     * the local datastore
     */
    getLocal(key: Uint8Array, options?: AbortOptions): Promise<Libp2pRecord>;
    /**
     * Send the best record found to any peers that have an out of date record
     */
    sendCorrectionRecord(key: Uint8Array, vals: ValueEvent[], best: Uint8Array, options: SendMessageOptions): AsyncGenerator<QueryEvent>;
    /**
     * Store the given key/value pair in the DHT
     */
    put(key: Uint8Array, value: Uint8Array, options: RoutingOptions): AsyncGenerator<unknown, void, undefined>;
    /**
     * Get the value to the given key
     */
    get(key: Uint8Array, options: RoutingOptions): AsyncGenerator<QueryEvent | ValueEvent>;
    /**
     * Get the `n` values to the given key without sorting
     */
    getMany(key: Uint8Array, options?: RoutingOptions): AsyncGenerator<QueryEvent>;
}
//# sourceMappingURL=index.d.ts.map