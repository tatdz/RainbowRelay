import { Status } from '../pb/index.js';
import type { RelayReservation } from '../index.js';
import type { Limit } from '../pb/index.js';
import type { ComponentLogger, Metrics, PeerId } from '@libp2p/interface';
import type { PeerMap } from '@libp2p/peer-collections';
import type { Multiaddr } from '@multiformats/multiaddr';
export type ReservationStatus = Status.OK | Status.PERMISSION_DENIED | Status.RESERVATION_REFUSED;
export interface ReservationStoreComponents {
    logger: ComponentLogger;
    metrics?: Metrics;
}
export interface ReservationStoreInit {
    /**
     * maximum number of reservations allowed
     *
     * @default 15
     */
    maxReservations?: number;
    /**
     * interval after which stale reservations are cleared
     *
     * @default 300000
     */
    reservationClearInterval?: number;
    /**
     * apply default relay limits to a new reservation
     *
     * @default true
     */
    applyDefaultLimit?: boolean;
    /**
     * reservation ttl
     *
     * @default 7200000
     */
    reservationTtl?: number;
    /**
     * The maximum time a relayed connection can be open for
     */
    defaultDurationLimit?: number;
    /**
     * The maximum amount of data allowed to be transferred over a relayed connection
     */
    defaultDataLimit?: bigint;
}
export declare class ReservationStore {
    readonly reservations: PeerMap<RelayReservation>;
    private readonly maxReservations;
    private readonly applyDefaultLimit;
    private readonly reservationTtl;
    private readonly defaultDurationLimit;
    private readonly defaultDataLimit;
    private readonly log;
    constructor(components: ReservationStoreComponents, init?: ReservationStoreInit);
    reserve(peer: PeerId, addr: Multiaddr, limit?: Limit): {
        status: ReservationStatus;
        expire?: number;
    };
    removeReservation(peer: PeerId): void;
    get(peer: PeerId): RelayReservation | undefined;
    clear(): void;
}
//# sourceMappingURL=reservation-store.d.ts.map