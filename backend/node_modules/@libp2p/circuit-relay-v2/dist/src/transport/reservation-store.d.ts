import { TypedEventEmitter } from 'main-event';
import type { Reservation } from '../pb/index.js';
import type { Libp2pEvents, ComponentLogger, PeerId, PeerStore, Startable, Metrics } from '@libp2p/interface';
import type { ConnectionManager } from '@libp2p/interface-internal';
import type { TypedEventTarget } from 'main-event';
export interface ReservationStoreComponents {
    peerId: PeerId;
    connectionManager: ConnectionManager;
    peerStore: PeerStore;
    events: TypedEventTarget<Libp2pEvents>;
    logger: ComponentLogger;
    metrics?: Metrics;
}
export interface ReservationStoreInit {
    /**
     * Multiple relays may be discovered simultaneously - to prevent listening
     * on too many relays, this value controls how many to attempt to reserve a
     * slot on at once. If set to more than one, we may end up listening on
     * more relays than the `maxReservations` value, but on networks with poor
     * connectivity the user may wish to attempt to reserve on multiple relays
     * simultaneously.
     *
     * @default 1
     */
    reservationConcurrency?: number;
    /**
     * Limit the number of potential relays we will dial
     *
     * @default 100
     */
    maxReservationQueueLength?: number;
    /**
     * When creating a reservation it must complete within this number of ms
     *
     * @default 5000
     */
    reservationCompletionTimeout?: number;
}
export type RelayType = 'discovered' | 'configured';
export interface DiscoveredRelayEntry {
    timeout: ReturnType<typeof setTimeout>;
    type: 'discovered';
    reservation: Reservation;
    /**
     * Stores the id of the connection we have to the relay
     */
    connection: string;
    /**
     * Stores the identifier returned when the reservation was requested
     */
    id: string;
}
export interface ConfiguredRelayEntry {
    timeout: ReturnType<typeof setTimeout>;
    type: 'configured';
    reservation: Reservation;
    /**
     * Stores the id of the connection we have to the relay
     */
    connection: string;
}
export type RelayEntry = DiscoveredRelayEntry | ConfiguredRelayEntry;
export interface RelayReservation {
    relay: PeerId;
    details: RelayEntry;
}
export interface ReservationStoreEvents {
    'relay:not-enough-relays': CustomEvent;
    'relay:found-enough-relays': CustomEvent;
    'relay:removed': CustomEvent<RelayReservation>;
    'relay:created-reservation': CustomEvent<RelayReservation>;
}
export declare class ReservationStore extends TypedEventEmitter<ReservationStoreEvents> implements Startable {
    #private;
    private readonly peerId;
    private readonly connectionManager;
    private readonly peerStore;
    private readonly events;
    private readonly reserveQueue;
    private readonly reservations;
    private readonly pendingReservations;
    private readonly maxReservationQueueLength;
    private readonly reservationCompletionTimeout;
    private started;
    private readonly log;
    private relayFilter;
    constructor(components: ReservationStoreComponents, init?: ReservationStoreInit);
    isStarted(): boolean;
    start(): void;
    afterStart(): void;
    stop(): void;
    reserveRelay(): string;
    /**
     * If the number of current relays is beneath the configured `maxReservations`
     * value, and the passed peer id is not our own, and we have a non-relayed
     * connection to the remote, and the remote peer speaks the hop protocol, try
     * to reserve a slot on the remote peer
     */
    addRelay(peerId: PeerId, type: RelayType): Promise<RelayReservation>;
    hasReservation(peerId: PeerId): boolean;
    getReservation(peerId: PeerId): Reservation | undefined;
    reservationCount(type?: RelayType): number;
    cancelReservations(): void;
}
//# sourceMappingURL=reservation-store.d.ts.map