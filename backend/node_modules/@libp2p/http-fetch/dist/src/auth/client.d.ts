import type { PeerId, PrivateKey } from '@libp2p/interface';
import type { AbortOptions } from '@multiformats/multiaddr';
import type { CookieAgent } from 'http-cookie-agent/undici';
import type { CookieJar } from 'tough-cookie';
export interface TokenInfo {
    creationTime: Date;
    bearer: string;
    peer: PeerId;
    agent: CookieAgent;
    jar: CookieJar;
}
export interface AuthenticatedFetchOptions extends RequestInit {
    /**
     * The Fetch implementation to use
     *
     * @default globalThis.fetch
     */
    fetch?: typeof globalThis.fetch;
    /**
     * The hostname to use - by default this will be extracted from the `.host`
     * property of `authEndpointURI`
     */
    hostname?: string;
    /**
     * A function to verify the peer ID of the server. This function
     * will be called after the server has authenticated itself.
     * If the function returns false, the request will be aborted.
     */
    verifyPeer?(peerId: PeerId, options: AbortOptions): boolean | Promise<boolean>;
}
export interface AuthenticateServerOptions extends AbortOptions {
    /**
     * The Fetch implementation to use
     *
     * @default globalThis.fetch
     */
    fetch?: AuthenticatedFetchOptions['fetch'];
    /**
     * The hostname to use - by default this will be extracted from the `.host`
     * property of `authEndpointURI`
     */
    hostname?: AuthenticatedFetchOptions['hostname'];
}
export declare class ClientAuth {
    key: PrivateKey;
    tokens: Map<string, TokenInfo>;
    tokenTTL: number;
    constructor(key: PrivateKey, opts?: {
        tokenTTL?: number;
    });
    private generateChallenge;
    private encodeAuthParams;
    bearerAuthHeaderWithPeer(hostname: string): {
        'authorization': string;
        peer: PeerId;
        agent: CookieAgent;
        jar: CookieJar;
    } | undefined;
    bearerAuthHeader(hostname: string): string | undefined;
    /**
     * authenticatedFetch is like `fetch`, but it also handles HTTP Peer ID
     * authentication with the server.
     *
     * If we have not seen the server before, verifyPeer will be called to check
     * if we want to make the request to the server with the given peer id. This
     * happens after we've authenticated the server.
     */
    authenticatedFetch(request: string | URL | Request, options?: AuthenticatedFetchOptions): Promise<Response & {
        peer: PeerId;
    }>;
    private doAuthenticatedFetch;
    authenticateServer(authEndpointURI: string | URL, options?: AuthenticateServerOptions): Promise<PeerId>;
}
//# sourceMappingURL=client.d.ts.map