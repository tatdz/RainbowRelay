import { type Uint8ArrayList } from 'uint8arraylist';
interface Fetch {
    (req: Request): Promise<Response>;
}
interface Duplex<TSource, TSink = TSource, RSink = Promise<void>> {
    source: AsyncIterable<TSource> | Iterable<TSource>;
    sink(source: AsyncIterable<TSink> | Iterable<TSink>): RSink;
}
/**
 * Create a fetch function that can be used to fetch requests via a duplex stream
 *
 * @returns a function that can be used to fetch requests via a duplex stream
 */
export declare function fetchViaDuplex(s: Duplex<Uint8Array | Uint8ArrayList>): Fetch;
/**
 * A function that can be used to handle HTTP requests
 */
export interface HTTPHandler {
    (req: Request): Promise<Response>;
}
/**
 *
 * @param s - Duplex where the request will be read from and the response will be written to
 * @param h - HTTP handler that will be called with the request
 */
export declare function handleRequestViaDuplex(s: Duplex<Uint8Array | Uint8ArrayList>, h: HTTPHandler): Promise<void>;
/**
 * Exported for testing.
 *
 * @param expectRequest - is this a Request or a Response
 * @param r - where to read from
 * @returns two promises. The first is the parsed Request or Response. The second is a promise that resolves when the parsing is done.
 */
export declare function readHTTPMsg(expectRequest: boolean, r: Duplex<Uint8Array | Uint8ArrayList>): [Promise<Request | Response>, Promise<void>];
export {};
//# sourceMappingURL=index.d.ts.map