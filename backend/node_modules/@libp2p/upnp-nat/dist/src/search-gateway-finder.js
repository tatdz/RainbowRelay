import { start, stop } from '@libp2p/interface';
import { repeatingTask } from '@libp2p/utils/repeating-task';
import { TypedEventEmitter } from 'main-event';
import { DEFAULT_GATEWAY_SEARCH_INTERVAL, DEFAULT_GATEWAY_SEARCH_MESSAGE_INTERVAL, DEFAULT_GATEWAY_SEARCH_TIMEOUT, DEFAULT_INITIAL_GATEWAY_SEARCH_INTERVAL, DEFAULT_INITIAL_GATEWAY_SEARCH_MESSAGE_INTERVAL, DEFAULT_INITIAL_GATEWAY_SEARCH_TIMEOUT } from './constants.js';
export class SearchGatewayFinder extends TypedEventEmitter {
    log;
    gateways;
    findGateways;
    portMappingClient;
    started;
    constructor(components, init) {
        super();
        this.log = components.logger.forComponent('libp2p:upnp-nat');
        this.portMappingClient = init.portMappingClient;
        this.started = false;
        this.gateways = [];
        // every five minutes, search for network gateways for one minute
        this.findGateways = repeatingTask(async (options) => {
            try {
                const searchMessageInterval = this.gateways.length > 0
                    ? init.searchMessageInterval ?? DEFAULT_GATEWAY_SEARCH_MESSAGE_INTERVAL
                    : init.initialSearchMessageInterval ?? DEFAULT_INITIAL_GATEWAY_SEARCH_MESSAGE_INTERVAL;
                this.log('begin gateway search, sending M-SEARCH every %dms', searchMessageInterval);
                for await (const gateway of this.portMappingClient.findGateways({
                    ...options,
                    searchInterval: searchMessageInterval
                })) {
                    if (this.gateways.some(g => {
                        return g.id === gateway.id && g.family === gateway.family;
                    })) {
                        // already seen this gateway
                        continue;
                    }
                    this.gateways.push(gateway);
                    this.safeDispatchEvent('gateway', {
                        detail: gateway
                    });
                    // we've found a gateway, wait for longer before searching again
                    const searchInterval = init.searchTimeout ?? DEFAULT_GATEWAY_SEARCH_INTERVAL;
                    const searchTimeout = init.searchTimeout ?? DEFAULT_GATEWAY_SEARCH_TIMEOUT;
                    this.log('switching gateway search to every %dms, timing out after %dms', searchInterval, searchTimeout);
                    this.findGateways.setInterval(searchInterval);
                    this.findGateways.setTimeout(searchTimeout);
                }
                this.log('gateway search finished, found %d gateways', this.gateways.length);
            }
            catch (err) {
                this.log.error('gateway search errored - %e', err);
            }
        }, init.initialSearchInterval ?? DEFAULT_INITIAL_GATEWAY_SEARCH_INTERVAL, {
            runImmediately: true,
            timeout: init.initialSearchTimeout ?? DEFAULT_INITIAL_GATEWAY_SEARCH_TIMEOUT
        });
    }
    async start() {
        if (this.started) {
            return;
        }
        this.started = true;
        await start(this.findGateways);
    }
    async stop() {
        await stop(this.findGateways);
        this.started = false;
    }
}
//# sourceMappingURL=search-gateway-finder.js.map