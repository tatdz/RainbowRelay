/**
 * @packageDocumentation
 *
 * A connection encrypter that does no connection encryption and trusts the
 * remote peer to provide the correct PeerId.
 *
 * This should not be used in production and is for research purposes only.
 *
 * @example
 *
 * ```typescript
 * import { createLibp2p } from 'libp2p'
 * import { plaintext } from '@libp2p/plaintext'
 *
 * const node = await createLibp2p({
 *   // ...other options
 *   connectionEncrypters: [
 *     plaintext()
 *   ]
 * })
 * ```
 */
import { publicKeyFromRaw } from '@libp2p/crypto/keys';
import { UnexpectedPeerError, InvalidCryptoExchangeError, serviceCapabilities, ProtocolError } from '@libp2p/interface';
import { peerIdFromPublicKey } from '@libp2p/peer-id';
import { pbStream } from 'it-protobuf-stream';
import { equals as uint8ArrayEquals } from 'uint8arrays/equals';
import { Exchange, KeyType } from './pb/proto.js';
const PROTOCOL = '/plaintext/2.0.0';
class Plaintext {
    protocol = PROTOCOL;
    privateKey;
    log;
    constructor(components) {
        this.privateKey = components.privateKey;
        this.log = components.logger.forComponent('libp2p:plaintext');
    }
    [Symbol.toStringTag] = '@libp2p/plaintext';
    [serviceCapabilities] = [
        '@libp2p/connection-encryption'
    ];
    async secureInbound(conn, options) {
        return this._encrypt(conn, options);
    }
    async secureOutbound(conn, options) {
        return this._encrypt(conn, options);
    }
    /**
     * Encrypt connection
     */
    async _encrypt(conn, options) {
        const pb = pbStream(conn).pb(Exchange);
        this.log('write pubkey exchange to peer %p', options?.remotePeer);
        const publicKey = this.privateKey.publicKey;
        const [, response] = await Promise.all([
            // Encode the public key and write it to the remote peer
            pb.write({
                id: publicKey.toMultihash().bytes,
                pubkey: {
                    Type: KeyType[publicKey.type],
                    Data: publicKey.raw
                }
            }, options),
            // Get the Exchange message
            pb.read(options)
        ]);
        let peerId;
        try {
            if (response.pubkey == null) {
                throw new ProtocolError('Public key missing');
            }
            if (response.pubkey.Data.byteLength === 0) {
                throw new ProtocolError('Public key data too short');
            }
            if (response.id == null) {
                throw new ProtocolError('Remote id missing');
            }
            const pubKey = publicKeyFromRaw(response.pubkey.Data);
            peerId = peerIdFromPublicKey(pubKey);
            if (!uint8ArrayEquals(peerId.toMultihash().bytes, response.id)) {
                throw new InvalidCryptoExchangeError('Public key did not match id');
            }
        }
        catch (err) {
            this.log.error(err);
            throw new InvalidCryptoExchangeError('Invalid public key - ' + err.message);
        }
        if (options?.remotePeer != null && !peerId.equals(options?.remotePeer)) {
            throw new UnexpectedPeerError();
        }
        this.log('plaintext key exchange completed successfully with peer %p', peerId);
        return {
            conn: pb.unwrap().unwrap(),
            remotePeer: peerId
        };
    }
}
export function plaintext() {
    return (components) => new Plaintext(components);
}
//# sourceMappingURL=index.js.map